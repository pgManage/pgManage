//jslint white:true
/**
    
    ######## BEFORE UPDATING DATA-HANDLING CODE OR USING THE COALESCE OPERATOR: ######## ~michael
    don't use the pipe-pipe "||" coalesce operator when handling data because if a zero comes to the coalesce (and it is a number 0 and not a string "0") it will be evaluated as false and thus coalesce to the next operand. Whenever you use this operator: be careful of what will be evaluated.
    
    To see this in action run this in your console:
    
    console.log( true      || 'test' );  // logs:  true  (expected)
    console.log( false     || 'test' );  // logs: 'test' (expected)

    console.log( null      || 'test' );  // logs: 'test' (expected)
    console.log( undefined || 'test' );  // logs: 'test' (expected)

    console.log( '1'       || 'test' );  // logs: '1'    (expected)
    console.log(  1        || 'test' );  // logs:  1     (expected)
    console.log( '0'       || 'test' );  // logs: '0'    (expected)
    console.log(  0        || 'test' );  // logs: 'test' (OH NO!!)
    
    here is another demonstration:
    
    console.log( Boolean(true)      );
    console.log( Boolean(false)     );
    console.log( Boolean(null)      );
    console.log( Boolean(undefined) );
    console.log( Boolean('1')       );
    console.log( Boolean( 1)        );
    console.log( Boolean('0')       );
    console.log( Boolean( 0)        ); // zero evaluates to false
    
    
    ######## BEFORE UPDATING FASTCLICK: ######## ~michael
    fastclick (around line 254) has some code added (by michael) to add a feature to fastclick, bring this code to any new version
    
    it also has (around line 123) some code added to an if statement added by joseph:
        if (deviceIsAndroid || deviceIsIOS) {
    as opposed to:
        if (deviceIsAndroid) {
    
    
    ######## BEFORE UPDATING X-TAGS: ######## ~michael and nunzio
    nunzio: you have to delete '"function"==typeof define&&define.amd?define(X):"undefined"!=typeof module&&module.exports?module.exports=X:' from xtags for electron
    nunzio: the below warning now seems to be outdated
    make sure you include the polyfills and make sure that there isn't still a duplicated block of code in the source, if there is remove it, here is how to find out:
    
    do a find in textedit for: "scope.upgradeDocumentTree = nop;" (excluding the quotes of course)
    AND var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE
    
    remove the whole block of code surrounding the second match (it might be the first match but I think it is the second match)
    
    
    ######## ELEMENT REGISTRATION: ######## ~michael
    When registering a custom element:
        1) register it after the "DOMContentLoaded" event has fired. Doing this prevents an issue that we ran into where in some cases (I believe when greyspots.js is cached and you are on yosemite is one case) some elements would be cut off and would disappear.
        2) Use the "methods" for public functions only, private functions should be kept in the "DOMContentLoaded" function. By keeping the functions in there it makes it so that the code for that element is the only code that can run those functions and it prevents these functions for cluttering public namespaces.
        3) Use "'use strict';" from the beginning. If you don't start out with it you might introduce strict mode errors that you don't even know about. Then one day you might decide to put "'use strict';" in there and errors you didn't know about will appear. Some errors might appear when you first move it over and some errors might be disvovered by your users because you didn't test every little feature of the element.
    
    An example:
    
    document.addEventListener('DOMContentLoaded', function () {
        'use strict';
        
        // ### private functions go here ###
        function foobar() {
            // do stuff to "element" here (gs-new-element is the only element that can run this function)
        }
        
        xtag.register('gs-new-element', {
            lifecycle: {
                'created': function () {
                    
                }
            },
            events: {},
            accessors: {},
            methods: {
                // ### public functions go here ###
            }
        });
    });
    
    ######## PSEUDO ELEMENT WARNING: ######## ~michael
    In firefox I ran into an issue where the undo history of controls in a gs-form (with the attribute "save-while-typing") was being erased. Turns out the issue was caused by a CSS pseudo-element. I was using a pseudo-element for a little box attached to the form to tell the user if the form was waiting to save or saving. By changing the pseudo-element to a real element that I add and remove with Javascript the issue was fixed.
    
    If you want to use a pseudo-element: make sure it doesn't affect the undo history of elements that are children of the element that the pseudo-element is attached to. This issue could have been fixed by now.
    
    
    
    ######## TEMPLATE SHIM: ######## ~michael
    The template polyfill has been changed, DO NOT UPDATE. It is for old browsers, and old browsers don't change so there is should be no need for the polyfill to change.
    
*//**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// minimal template polyfill
if (typeof HTMLTemplateElement === 'undefined') {
    (function() {
  
      var TEMPLATE_TAG = 'template';
  
      var contentDoc = document.implementation.createHTMLDocument('template');
  
      /**
        Provides a minimal shim for the <template> element.
      */
      HTMLTemplateElement = function() {};
      HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);
  
      /**
        The `decorate` method moves element children to the template's `content`.
        NOTE: there is no support for dynamically adding elements to templates.
      */
      HTMLTemplateElement.decorate = function(template) {
          if (!template.content) {
              template.content = template.ownerDocument.createDocumentFragment();
          }
          var child;
          while (child = template.firstChild) {
              template.content.appendChild(child);
          }
          
          if (!template.content.children) {
              Object.defineProperty(template.content, 'children', {
                  get: function() {
                      'use strict';
                      var arrChildren = [], i, len, childNodes = this.childNodes;
                      
                      for (i = 0, len = childNodes.length; i < len; i += 1) {
                          if (childNodes[i].nodeType !== 3) {
                              arrChildren.push(childNodes[i]);
                          }
                      }
                      
                      return arrChildren;
                  },
                  configurable: true
              });
          }
          
          //HTMLTemplateElement.bootstrap(template.content);
          
          //console.log(template.content);
          
          // add innerHTML to template
          Object.defineProperty(template, 'innerHTML', {
              get: function() {
                  var o = '', fragment = this.content.cloneNode(true);//,
                      //templates = xtag.toArray(fragment.querySelectorAll(TEMPLATE_TAG)), i, l;
                  
                  //for (i = 0, l = templates.length; i < l; i += 1) {
                  //    templates[i].outerHTML = templates[i].outerHTML;
                  //    console.log(templates[i].outerHTML);
                  //}
                  
                  for (var e = fragment.firstChild; e; e = e.nextSibling) {
                      o += e.outerHTML || escapeData(e.data);
                  }
                  
                  //console.log(o);
                  
                  return o;
              },
              set: function(text) {
                  contentDoc.body.innerHTML = text;
                  
                  while (this.content.firstChild) {
                      this.content.removeChild(this.content.firstChild);
                  }
                  while (contentDoc.body.firstChild) {
                      this.content.appendChild(contentDoc.body.firstChild);
                  }
                  //HTMLTemplateElement.bootstrap(this.content);
              },
              configurable: true
              //writable: true
          });
        
          // add outerHTML to template
          Object.defineProperty(template, 'outerHTML', {
              get: function () {
                  var openTagText, arrAttr, i, len, innerHTML = this.innerHTML;
                  
                  arrAttr = this.attributes;
                  
                  for (i = 0, len = arrAttr.length, openTagText = '<template'; i < len; i += 1) { // >
                      openTagText += ' ' + arrAttr[i].nodeName + '="' + encodeHTML(arrAttr[i].value) + '"';
                  }
                  
                  return openTagText + '>' + innerHTML + '</template>';
              },
              configurable: true
              //writable: true
          });
      };
  
      /**
        The `bootstrap` method is called automatically and "fixes" all
        <template> elements in the document referenced by the `doc` argument.
      */
      HTMLTemplateElement.bootstrap = function(doc) {
          var templates = doc.querySelectorAll(TEMPLATE_TAG), i, l, t;
          
          for (i = 0, l = templates.length, t; (i < l) && (t = templates[i]); i += 1) {
              if (!GS.findParentTag(t, 'template') && GS.findParentTag(t, 'html')) {
                  HTMLTemplateElement.decorate(t);
              }
          }
      };
  
      // auto-bootstrapping for main document
      window.addEventListener('DOMContentLoaded', function() {
        HTMLTemplateElement.bootstrap(document);
      });
  
      // Patch document.createElement to ensure newly created templates have content
      var createElement = document.createElement;
      document.createElement = function() {
        'use strict';
        var el = createElement.apply(document, arguments);
        if (el.localName == 'template') {
          HTMLTemplateElement.decorate(el);
        }
        return el;
      };
  
      var escapeDataRegExp = /[&\u00A0<>]/g;
  
      function escapeReplace(c) {
        switch (c) {
          case '&':
            return '&amp;';
          case '<':
            return '&lt;';
          case '>':
            return '&gt;';
          case '\u00A0':
            return '&nbsp;';
        }
      }
  
      function escapeData(s) {
        return s.replace(escapeDataRegExp, escapeReplace);
      }
    })();
  }(function(){function e(e){if(this._element=e,e.className!=this._classCache){if(this._classCache=e.className,!this._classCache)return;var t,n=this._classCache.replace(/^\s+|\s+$/g,"").split(/\s+/);for(t=0;n.length>t;t++)a.call(this,n[t])}}function t(e,t){e.className=t.join(" ")}function n(e,t,n){Object.defineProperty?Object.defineProperty(e,t,{get:n}):e.__defineGetter__(t,n)}if(!(window.Element===void 0||"classList"in document.documentElement)){var r=Array.prototype,o=r.indexOf,i=r.slice,a=r.push,s=r.splice,c=r.join;e.prototype={add:function(e){this.contains(e)||(a.call(this,e),t(this._element,i.call(this,0)))},contains:function(e){return-1!==o.call(this,e)},item:function(e){return this[e]||null},remove:function(e){var n=o.call(this,e);-1!==n&&(s.call(this,n,1),t(this._element,i.call(this,0)))},toString:function(){return c.call(this," ")},toggle:function(e){-1===o.call(this,e)?this.add(e):this.remove(e)}},window.DOMTokenList=e,n(Element.prototype,"classList",function(){return new e(this)})}})(),function(){window.WebComponents=window.WebComponents||{flags:{}};var e="webcomponents-lite.js",t=document.querySelector('script[src*="'+e+'"]'),n={};if(!n.noOpts){if(location.search.slice(1).split("&").forEach(function(e){var t,r=e.split("=");r[0]&&(t=r[0].match(/wc-(.+)/))&&(n[t[1]]=r[1]||!0)}),t)for(var r,o=0;r=t.attributes[o];o++)"src"!==r.name&&(n[r.name]=r.value||!0);if(n.log&&n.log.split){var i=n.log.split(",");n.log={},i.forEach(function(e){n.log[e]=!0})}else n.log={}}n.register&&(window.CustomElements=window.CustomElements||{flags:{}},window.CustomElements.flags.register=n.register),WebComponents.flags=n}(),function(e){"use strict";function t(e){return void 0!==h[e]}function n(){s.call(this),this._isInvalid=!0}function r(e){return""==e&&n.call(this),e.toLowerCase()}function o(e){var t=e.charCodeAt(0);return t>32&&127>t&&-1==[34,35,60,62,63,96].indexOf(t)?e:encodeURIComponent(e)}function i(e){var t=e.charCodeAt(0);return t>32&&127>t&&-1==[34,35,60,62,96].indexOf(t)?e:encodeURIComponent(e)}function a(e,a,s){function c(e){y.push(e)}var u=a||"scheme start",l=0,d="",b=!1,g=!1,y=[];e:for(;(e[l-1]!=f||0==l)&&!this._isInvalid;){var w=e[l];switch(u){case"scheme start":if(!w||!m.test(w)){if(a){c("Invalid scheme.");break e}d="",u="no scheme";continue}d+=w.toLowerCase(),u="scheme";break;case"scheme":if(w&&v.test(w))d+=w.toLowerCase();else{if(":"!=w){if(a){if(f==w)break e;c("Code point not allowed in scheme: "+w);break e}d="",l=0,u="no scheme";continue}if(this._scheme=d,d="",a)break e;t(this._scheme)&&(this._isRelative=!0),u="file"==this._scheme?"relative":this._isRelative&&s&&s._scheme==this._scheme?"relative or authority":this._isRelative?"authority first slash":"scheme data"}break;case"scheme data":"?"==w?(this._query="?",u="query"):"#"==w?(this._fragment="#",u="fragment"):f!=w&&"	"!=w&&"\n"!=w&&"\r"!=w&&(this._schemeData+=o(w));break;case"no scheme":if(s&&t(s._scheme)){u="relative";continue}c("Missing scheme."),n.call(this);break;case"relative or authority":if("/"!=w||"/"!=e[l+1]){c("Expected /, got: "+w),u="relative";continue}u="authority ignore slashes";break;case"relative":if(this._isRelative=!0,"file"!=this._scheme&&(this._scheme=s._scheme),f==w){this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query=s._query,this._username=s._username,this._password=s._password;break e}if("/"==w||"\\"==w)"\\"==w&&c("\\ is an invalid code point."),u="relative slash";else if("?"==w)this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query="?",this._username=s._username,this._password=s._password,u="query";else{if("#"!=w){var _=e[l+1],E=e[l+2];("file"!=this._scheme||!m.test(w)||":"!=_&&"|"!=_||f!=E&&"/"!=E&&"\\"!=E&&"?"!=E&&"#"!=E)&&(this._host=s._host,this._port=s._port,this._username=s._username,this._password=s._password,this._path=s._path.slice(),this._path.pop()),u="relative path";continue}this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query=s._query,this._fragment="#",this._username=s._username,this._password=s._password,u="fragment"}break;case"relative slash":if("/"!=w&&"\\"!=w){"file"!=this._scheme&&(this._host=s._host,this._port=s._port,this._username=s._username,this._password=s._password),u="relative path";continue}"\\"==w&&c("\\ is an invalid code point."),u="file"==this._scheme?"file host":"authority ignore slashes";break;case"authority first slash":if("/"!=w){c("Expected '/', got: "+w),u="authority ignore slashes";continue}u="authority second slash";break;case"authority second slash":if(u="authority ignore slashes","/"!=w){c("Expected '/', got: "+w);continue}break;case"authority ignore slashes":if("/"!=w&&"\\"!=w){u="authority";continue}c("Expected authority, got: "+w);break;case"authority":if("@"==w){b&&(c("@ already seen."),d+="%40"),b=!0;for(var T=0;d.length>T;T++){var C=d[T];if("	"!=C&&"\n"!=C&&"\r"!=C)if(":"!=C||null!==this._password){var M=o(C);null!==this._password?this._password+=M:this._username+=M}else this._password="";else c("Invalid whitespace in authority.")}d=""}else{if(f==w||"/"==w||"\\"==w||"?"==w||"#"==w){l-=d.length,d="",u="host";continue}d+=w}break;case"file host":if(f==w||"/"==w||"\\"==w||"?"==w||"#"==w){2!=d.length||!m.test(d[0])||":"!=d[1]&&"|"!=d[1]?0==d.length?u="relative path start":(this._host=r.call(this,d),d="",u="relative path start"):u="relative path";continue}"	"==w||"\n"==w||"\r"==w?c("Invalid whitespace in file host."):d+=w;break;case"host":case"hostname":if(":"!=w||g){if(f==w||"/"==w||"\\"==w||"?"==w||"#"==w){if(this._host=r.call(this,d),d="",u="relative path start",a)break e;continue}"	"!=w&&"\n"!=w&&"\r"!=w?("["==w?g=!0:"]"==w&&(g=!1),d+=w):c("Invalid code point in host/hostname: "+w)}else if(this._host=r.call(this,d),d="",u="port","hostname"==a)break e;break;case"port":if(/[0-9]/.test(w))d+=w;else{if(f==w||"/"==w||"\\"==w||"?"==w||"#"==w||a){if(""!=d){var L=parseInt(d,10);L!=h[this._scheme]&&(this._port=L+""),d=""}if(a)break e;u="relative path start";continue}"	"==w||"\n"==w||"\r"==w?c("Invalid code point in port: "+w):n.call(this)}break;case"relative path start":if("\\"==w&&c("'\\' not allowed in path."),u="relative path","/"!=w&&"\\"!=w)continue;break;case"relative path":if(f!=w&&"/"!=w&&"\\"!=w&&(a||"?"!=w&&"#"!=w))"	"!=w&&"\n"!=w&&"\r"!=w&&(d+=o(w));else{"\\"==w&&c("\\ not allowed in relative path.");var O;(O=p[d.toLowerCase()])&&(d=O),".."==d?(this._path.pop(),"/"!=w&&"\\"!=w&&this._path.push("")):"."==d&&"/"!=w&&"\\"!=w?this._path.push(""):"."!=d&&("file"==this._scheme&&0==this._path.length&&2==d.length&&m.test(d[0])&&"|"==d[1]&&(d=d[0]+":"),this._path.push(d)),d="","?"==w?(this._query="?",u="query"):"#"==w&&(this._fragment="#",u="fragment")}break;case"query":a||"#"!=w?f!=w&&"	"!=w&&"\n"!=w&&"\r"!=w&&(this._query+=i(w)):(this._fragment="#",u="fragment");break;case"fragment":f!=w&&"	"!=w&&"\n"!=w&&"\r"!=w&&(this._fragment+=w)}l++}}function s(){this._scheme="",this._schemeData="",this._username="",this._password=null,this._host="",this._port="",this._path=[],this._query="",this._fragment="",this._isInvalid=!1,this._isRelative=!1}function c(e,t){void 0===t||t instanceof c||(t=new c(t+"")),this._url=e,s.call(this);var n=e.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g,"");a.call(this,n,null,t)}var u=!1;if(!e.forceJURL)try{var l=new URL("b","http://a");l.pathname="c%20d",u="http://a/c%20d"===l.href}catch(d){}if(!u){var h=Object.create(null);h.ftp=21,h.file=0,h.gopher=70,h.http=80,h.https=443,h.ws=80,h.wss=443;var p=Object.create(null);p["%2e"]=".",p[".%2e"]="..",p["%2e."]="..",p["%2e%2e"]="..";var f=void 0,m=/[a-zA-Z]/,v=/[a-zA-Z0-9\+\-\.]/;c.prototype={toString:function(){return this.href},get href(){if(this._isInvalid)return this._url;var e="";return(""!=this._username||null!=this._password)&&(e=this._username+(null!=this._password?":"+this._password:"")+"@"),this.protocol+(this._isRelative?"//"+e+this.host:"")+this.pathname+this._query+this._fragment},set href(e){s.call(this),a.call(this,e)},get protocol(){return this._scheme+":"},set protocol(e){this._isInvalid||a.call(this,e+":","scheme start")},get host(){return this._isInvalid?"":this._port?this._host+":"+this._port:this._host},set host(e){!this._isInvalid&&this._isRelative&&a.call(this,e,"host")},get hostname(){return this._host},set hostname(e){!this._isInvalid&&this._isRelative&&a.call(this,e,"hostname")},get port(){return this._port},set port(e){!this._isInvalid&&this._isRelative&&a.call(this,e,"port")},get pathname(){return this._isInvalid?"":this._isRelative?"/"+this._path.join("/"):this._schemeData},set pathname(e){!this._isInvalid&&this._isRelative&&(this._path=[],a.call(this,e,"relative path start"))},get search(){return this._isInvalid||!this._query||"?"==this._query?"":this._query},set search(e){!this._isInvalid&&this._isRelative&&(this._query="?","?"==e[0]&&(e=e.slice(1)),a.call(this,e,"query"))},get hash(){return this._isInvalid||!this._fragment||"#"==this._fragment?"":this._fragment},set hash(e){this._isInvalid||(this._fragment="#","#"==e[0]&&(e=e.slice(1)),a.call(this,e,"fragment"))},get origin(){var e;if(this._isInvalid||!this._scheme)return"";switch(this._scheme){case"data":case"file":case"javascript":case"mailto":return"null"}return e=this.host,e?this._scheme+"://"+e:""}};var b=e.URL;b&&(c.createObjectURL=function(){return b.createObjectURL.apply(b,arguments)},c.revokeObjectURL=function(e){b.revokeObjectURL(e)}),e.URL=c}}(self),"undefined"==typeof WeakMap&&function(){var e=Object.defineProperty,t=Date.now()%1e9,n=function(){this.name="__st"+(1e9*Math.random()>>>0)+(t++ +"__")};n.prototype={set:function(t,n){var r=t[this.name];return r&&r[0]===t?r[1]=n:e(t,this.name,{value:[t,n],writable:!0}),this},get:function(e){var t;return(t=e[this.name])&&t[0]===e?t[1]:void 0},"delete":function(e){var t=e[this.name];return t&&t[0]===e?(t[0]=t[1]=void 0,!0):!1},has:function(e){var t=e[this.name];return t?t[0]===e:!1}},window.WeakMap=n}(),function(e){function t(e){w.push(e),y||(y=!0,m(r))}function n(e){return window.ShadowDOMPolyfill&&window.ShadowDOMPolyfill.wrapIfNeeded(e)||e}function r(){y=!1;var e=w;w=[],e.sort(function(e,t){return e.uid_-t.uid_});var t=!1;e.forEach(function(e){var n=e.takeRecords();o(e),n.length&&(e.callback_(n,e),t=!0)}),t&&r()}function o(e){e.nodes_.forEach(function(t){var n=v.get(t);n&&n.forEach(function(t){t.observer===e&&t.removeTransientObservers()})})}function i(e,t){for(var n=e;n;n=n.parentNode){var r=v.get(n);if(r)for(var o=0;r.length>o;o++){var i=r[o],a=i.options;if(n===e||a.subtree){var s=t(a);s&&i.enqueue(s)}}}}function a(e){this.callback_=e,this.nodes_=[],this.records_=[],this.uid_=++_}function s(e,t){this.type=e,this.target=t,this.addedNodes=[],this.removedNodes=[],this.previousSibling=null,this.nextSibling=null,this.attributeName=null,this.attributeNamespace=null,this.oldValue=null}function c(e){var t=new s(e.type,e.target);return t.addedNodes=e.addedNodes.slice(),t.removedNodes=e.removedNodes.slice(),t.previousSibling=e.previousSibling,t.nextSibling=e.nextSibling,t.attributeName=e.attributeName,t.attributeNamespace=e.attributeNamespace,t.oldValue=e.oldValue,t}function u(e,t){return E=new s(e,t)}function l(e){return T?T:(T=c(E),T.oldValue=e,T)}function d(){E=T=void 0}function h(e){return e===T||e===E}function p(e,t){return e===t?e:T&&h(e)?T:null}function f(e,t,n){this.observer=e,this.target=t,this.options=n,this.transientObservedNodes=[]}if(!e.JsMutationObserver){var m,v=new WeakMap;if(/Trident|Edge/.test(navigator.userAgent))m=setTimeout;else if(window.setImmediate)m=window.setImmediate;else{var b=[],g=Math.random()+"";window.addEventListener("message",function(e){if(e.data===g){var t=b;b=[],t.forEach(function(e){e()})}}),m=function(e){b.push(e),window.postMessage(g,"*")}}var y=!1,w=[],_=0;a.prototype={observe:function(e,t){if(e=n(e),!t.childList&&!t.attributes&&!t.characterData||t.attributeOldValue&&!t.attributes||t.attributeFilter&&t.attributeFilter.length&&!t.attributes||t.characterDataOldValue&&!t.characterData)throw new SyntaxError;var r=v.get(e);r||v.set(e,r=[]);for(var o,i=0;r.length>i;i++)if(r[i].observer===this){o=r[i],o.removeListeners(),o.options=t;break}o||(o=new f(this,e,t),r.push(o),this.nodes_.push(e)),o.addListeners()},disconnect:function(){this.nodes_.forEach(function(e){for(var t=v.get(e),n=0;t.length>n;n++){var r=t[n];if(r.observer===this){r.removeListeners(),t.splice(n,1);break}}},this),this.records_=[]},takeRecords:function(){var e=this.records_;return this.records_=[],e}};var E,T;f.prototype={enqueue:function(e){var n=this.observer.records_,r=n.length;if(n.length>0){var o=n[r-1],i=p(o,e);if(i)return n[r-1]=i,void 0}else t(this.observer);n[r]=e},addListeners:function(){this.addListeners_(this.target)},addListeners_:function(e){var t=this.options;t.attributes&&e.addEventListener("DOMAttrModified",this,!0),t.characterData&&e.addEventListener("DOMCharacterDataModified",this,!0),t.childList&&e.addEventListener("DOMNodeInserted",this,!0),(t.childList||t.subtree)&&e.addEventListener("DOMNodeRemoved",this,!0)},removeListeners:function(){this.removeListeners_(this.target)},removeListeners_:function(e){var t=this.options;t.attributes&&e.removeEventListener("DOMAttrModified",this,!0),t.characterData&&e.removeEventListener("DOMCharacterDataModified",this,!0),t.childList&&e.removeEventListener("DOMNodeInserted",this,!0),(t.childList||t.subtree)&&e.removeEventListener("DOMNodeRemoved",this,!0)},addTransientObserver:function(e){if(e!==this.target){this.addListeners_(e),this.transientObservedNodes.push(e);var t=v.get(e);t||v.set(e,t=[]),t.push(this)}},removeTransientObservers:function(){var e=this.transientObservedNodes;this.transientObservedNodes=[],e.forEach(function(e){this.removeListeners_(e);for(var t=v.get(e),n=0;t.length>n;n++)if(t[n]===this){t.splice(n,1);break}},this)},handleEvent:function(e){switch(e.stopImmediatePropagation(),e.type){case"DOMAttrModified":var t=e.attrName,n=e.relatedNode.namespaceURI,r=e.target,o=new u("attributes",r);o.attributeName=t,o.attributeNamespace=n;var a=e.attrChange===MutationEvent.ADDITION?null:e.prevValue;i(r,function(e){return!e.attributes||e.attributeFilter&&e.attributeFilter.length&&-1===e.attributeFilter.indexOf(t)&&-1===e.attributeFilter.indexOf(n)?void 0:e.attributeOldValue?l(a):o});break;case"DOMCharacterDataModified":var r=e.target,o=u("characterData",r),a=e.prevValue;i(r,function(e){return e.characterData?e.characterDataOldValue?l(a):o:void 0});break;case"DOMNodeRemoved":this.addTransientObserver(e.target);case"DOMNodeInserted":var s,c,h=e.target;"DOMNodeInserted"===e.type?(s=[h],c=[]):(s=[],c=[h]);var p=h.previousSibling,f=h.nextSibling,o=u("childList",e.target.parentNode);o.addedNodes=s,o.removedNodes=c,o.previousSibling=p,o.nextSibling=f,i(e.relatedNode,function(e){return e.childList?o:void 0})}d()}},e.JsMutationObserver=a,e.MutationObserver||(e.MutationObserver=a,a._isPolyfilled=!0)}}(self),"undefined"==typeof HTMLTemplateElement&&function(){function e(e){switch(e){case"&":return"&amp;";case"<":return"&lt;";case">":return"&gt;";case"Â ":return"&nbsp;"}}function t(t){return t.replace(a,e)}var n="template",r=document.implementation.createHTMLDocument("template"),o=!0;HTMLTemplateElement=function(){},HTMLTemplateElement.prototype=Object.create(HTMLElement.prototype),HTMLTemplateElement.decorate=function(e){if(!e.content){e.content=r.createDocumentFragment();for(var n;n=e.firstChild;)e.content.appendChild(n);if(o)try{Object.defineProperty(e,"innerHTML",{get:function(){for(var e="",n=this.content.firstChild;n;n=n.nextSibling)e+=n.outerHTML||t(n.data);return e},set:function(e){for(r.body.innerHTML=e,HTMLTemplateElement.bootstrap(r);this.content.firstChild;)this.content.removeChild(this.content.firstChild);for(;r.body.firstChild;)this.content.appendChild(r.body.firstChild)},configurable:!0})}catch(i){o=!1}HTMLTemplateElement.bootstrap(e.content)}},HTMLTemplateElement.bootstrap=function(e){for(var t,r=e.querySelectorAll(n),o=0,i=r.length;i>o&&(t=r[o]);o++)HTMLTemplateElement.decorate(t)},document.addEventListener("DOMContentLoaded",function(){HTMLTemplateElement.bootstrap(document)});var i=document.createElement;document.createElement=function(){"use strict";var e=i.apply(document,arguments);return"template"==e.localName&&HTMLTemplateElement.decorate(e),e};var a=/[&\u00A0<>]/g}(),function(){"use strict";if(!window.performance){var e=Date.now();window.performance={now:function(){return Date.now()-e}}}window.requestAnimationFrame||(window.requestAnimationFrame=function(){var e=window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame;return e?function(t){return e(function(){t(performance.now())})}:function(e){return window.setTimeout(e,1e3/60)}}()),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(){return window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||function(e){clearTimeout(e)}}());var t=function(){var e=document.createEvent("Event");return e.initEvent("foo",!0,!0),e.preventDefault(),e.defaultPrevented}();if(!t){var n=Event.prototype.preventDefault;Event.prototype.preventDefault=function(){this.cancelable&&(n.call(this),Object.defineProperty(this,"defaultPrevented",{get:function(){return!0},configurable:!0}))}}var r=/Trident/.test(navigator.userAgent);if((!window.CustomEvent||r&&"function"!=typeof window.CustomEvent)&&(window.CustomEvent=function(e,t){t=t||{};var n=document.createEvent("CustomEvent");return n.initCustomEvent(e,Boolean(t.bubbles),Boolean(t.cancelable),t.detail),n},window.CustomEvent.prototype=window.Event.prototype),!window.Event||r&&"function"!=typeof window.Event){var o=window.Event;window.Event=function(e,t){t=t||{};var n=document.createEvent("Event");return n.initEvent(e,Boolean(t.bubbles),Boolean(t.cancelable)),n},window.Event.prototype=o.prototype}}(window.WebComponents),window.HTMLImports=window.HTMLImports||{flags:{}},function(e){function t(e,t){t=t||f,r(function(){i(e,t)},t)}function n(e){return"complete"===e.readyState||e.readyState===b}function r(e,t){if(n(t))e&&e();else{var o=function(){("complete"===t.readyState||t.readyState===b)&&(t.removeEventListener(g,o),r(e,t))};t.addEventListener(g,o)}}function o(e){e.target.__loaded=!0}function i(e,t){function n(){c==u&&e&&e({allImports:s,loadedImports:l,errorImports:d})}function r(e){o(e),l.push(this),c++,n()}function i(){d.push(this),c++,n()}var s=t.querySelectorAll("link[rel=import]"),c=0,u=s.length,l=[],d=[];if(u)for(var h,p=0;u>p&&(h=s[p]);p++)a(h)?(l.push(this),c++,n()):(h.addEventListener("load",r),h.addEventListener("error",i));else n()}function a(e){return d?e.__loaded||e.import&&"loading"!==e.import.readyState:e.__importParsed}function s(e){for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)c(t)&&u(t)}function c(e){return"link"===e.localName&&"import"===e.rel}function u(e){var t=e.import;t?o({target:e}):(e.addEventListener("load",o),e.addEventListener("error",o))}var l="import",d=Boolean(l in document.createElement("link")),h=Boolean(window.ShadowDOMPolyfill),p=function(e){return h?window.ShadowDOMPolyfill.wrapIfNeeded(e):e},f=p(document),m={get:function(){var e=window.HTMLImports.currentScript||document.currentScript||("complete"!==document.readyState?document.scripts[document.scripts.length-1]:null);return p(e)},configurable:!0};Object.defineProperty(document,"_currentScript",m),Object.defineProperty(f,"_currentScript",m);var v=/Trident/.test(navigator.userAgent),b=v?"complete":"interactive",g="readystatechange";d&&(new MutationObserver(function(e){for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)t.addedNodes&&s(t.addedNodes)}).observe(document.head,{childList:!0}),function(){if("loading"===document.readyState)for(var e,t=document.querySelectorAll("link[rel=import]"),n=0,r=t.length;r>n&&(e=t[n]);n++)u(e)}()),t(function(e){window.HTMLImports.ready=!0,window.HTMLImports.readyTime=(new Date).getTime();var t=f.createEvent("CustomEvent");t.initCustomEvent("HTMLImportsLoaded",!0,!0,e),f.dispatchEvent(t)}),e.IMPORT_LINK_TYPE=l,e.useNative=d,e.rootDocument=f,e.whenReady=t,e.isIE=v}(window.HTMLImports),function(e){var t=[],n=function(e){t.push(e)},r=function(){t.forEach(function(t){t(e)})};e.addModule=n,e.initializeModules=r}(window.HTMLImports),window.HTMLImports.addModule(function(e){var t=/(url\()([^)]*)(\))/g,n=/(@import[\s]+(?!url\())([^;]*)(;)/g,r={resolveUrlsInStyle:function(e,t){var n=e.ownerDocument,r=n.createElement("a");return e.textContent=this.resolveUrlsInCssText(e.textContent,t,r),e},resolveUrlsInCssText:function(e,r,o){var i=this.replaceUrls(e,o,r,t);return i=this.replaceUrls(i,o,r,n)},replaceUrls:function(e,t,n,r){return e.replace(r,function(e,r,o,i){var a=o.replace(/["']/g,"");return n&&(a=new URL(a,n).href),t.href=a,a=t.href,r+"'"+a+"'"+i})}};e.path=r}),window.HTMLImports.addModule(function(e){var t={async:!0,ok:function(e){return e.status>=200&&300>e.status||304===e.status||0===e.status},load:function(n,r,o){var i=new XMLHttpRequest;return(e.flags.debug||e.flags.bust)&&(n+="?"+Math.random()),i.open("GET",n,t.async),i.addEventListener("readystatechange",function(e){if(4===i.readyState){var n=null;try{var a=i.getResponseHeader("Location");a&&(n="/"===a.substr(0,1)?location.origin+a:a)}catch(e){console.error(e.message)}r.call(o,!t.ok(i)&&i,i.response||i.responseText,n)}}),i.send(),i},loadDocument:function(e,t,n){this.load(e,t,n).responseType="document"}};e.xhr=t}),window.HTMLImports.addModule(function(e){var t=e.xhr,n=e.flags,r=function(e,t){this.cache={},this.onload=e,this.oncomplete=t,this.inflight=0,this.pending={}};r.prototype={addNodes:function(e){this.inflight+=e.length;for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)this.require(t);this.checkDone()},addNode:function(e){this.inflight++,this.require(e),this.checkDone()},require:function(e){var t=e.src||e.href;e.__nodeUrl=t,this.dedupe(t,e)||this.fetch(t,e)},dedupe:function(e,t){return this.pending[e]?(this.pending[e].push(t),!0):this.cache[e]?(this.onload(e,t,this.cache[e]),this.tail(),!0):(this.pending[e]=[t],!1)},fetch:function(e,r){if(n.load&&console.log("fetch",e,r),e)if(e.match(/^data:/)){var o=e.split(","),i=o[0],a=o[1];a=i.indexOf(";base64")>-1?atob(a):decodeURIComponent(a),setTimeout(function(){this.receive(e,r,null,a)}.bind(this),0)}else{var s=function(t,n,o){this.receive(e,r,t,n,o)}.bind(this);t.load(e,s)}else setTimeout(function(){this.receive(e,r,{error:"href must be specified"},null)}.bind(this),0)},receive:function(e,t,n,r,o){this.cache[e]=r;for(var i,a=this.pending[e],s=0,c=a.length;c>s&&(i=a[s]);s++)this.onload(e,i,r,n,o),this.tail();this.pending[e]=null},tail:function(){--this.inflight,this.checkDone()},checkDone:function(){this.inflight||this.oncomplete()}},e.Loader=r}),window.HTMLImports.addModule(function(e){var t=function(e){this.addCallback=e,this.mo=new MutationObserver(this.handler.bind(this))};t.prototype={handler:function(e){for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)"childList"===t.type&&t.addedNodes.length&&this.addedNodes(t.addedNodes)},addedNodes:function(e){this.addCallback&&this.addCallback(e);for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)t.children&&t.children.length&&this.addedNodes(t.children)},observe:function(e){this.mo.observe(e,{childList:!0,subtree:!0})}},e.Observer=t}),window.HTMLImports.addModule(function(e){function t(e){return"link"===e.localName&&e.rel===l}function n(e){var t=r(e);return"data:text/javascript;charset=utf-8,"+encodeURIComponent(t)}function r(e){return e.textContent+o(e)}function o(e){var t=e.ownerDocument;t.__importedScripts=t.__importedScripts||0;var n=e.ownerDocument.baseURI,r=t.__importedScripts?"-"+t.__importedScripts:"";return t.__importedScripts++,"\n//# sourceURL="+n+r+".js\n"}function i(e){var t=e.ownerDocument.createElement("style");return t.textContent=e.textContent,a.resolveUrlsInStyle(t),t}var a=e.path,s=e.rootDocument,c=e.flags,u=e.isIE,l=e.IMPORT_LINK_TYPE,d="link[rel="+l+"]",h={documentSelectors:d,importsSelectors:[d,"link[rel=stylesheet]:not([type])","style:not([type])","script:not([type])",'script[type="application/javascript"]','script[type="text/javascript"]'].join(","),map:{link:"parseLink",script:"parseScript",style:"parseStyle"},dynamicElements:[],parseNext:function(){var e=this.nextToParse();e&&this.parse(e)},parse:function(e){if(this.isParsed(e))return c.parse&&console.log("[%s] is already parsed",e.localName),void 0;var t=this[this.map[e.localName]];t&&(this.markParsing(e),t.call(this,e))},parseDynamic:function(e,t){this.dynamicElements.push(e),t||this.parseNext()},markParsing:function(e){c.parse&&console.log("parsing",e),this.parsingElement=e},markParsingComplete:function(e){e.__importParsed=!0,this.markDynamicParsingComplete(e),e.__importElement&&(e.__importElement.__importParsed=!0,this.markDynamicParsingComplete(e.__importElement)),this.parsingElement=null,c.parse&&console.log("completed",e)},markDynamicParsingComplete:function(e){var t=this.dynamicElements.indexOf(e);t>=0&&this.dynamicElements.splice(t,1)},parseImport:function(e){if(e.import=e.__doc,window.HTMLImports.__importsParsingHook&&window.HTMLImports.__importsParsingHook(e),e.import&&(e.import.__importParsed=!0),this.markParsingComplete(e),e.__resource&&!e.__error?e.dispatchEvent(new CustomEvent("load",{bubbles:!1})):e.dispatchEvent(new CustomEvent("error",{bubbles:!1})),e.__pending)for(var t;e.__pending.length;)t=e.__pending.shift(),t&&t({target:e});this.parseNext()},parseLink:function(e){t(e)?this.parseImport(e):(e.href=e.href,this.parseGeneric(e))},parseStyle:function(e){var t=e;e=i(e),t.__appliedElement=e,e.__importElement=t,this.parseGeneric(e)},parseGeneric:function(e){this.trackElement(e),this.addElementToDocument(e)},rootImportForElement:function(e){for(var t=e;t.ownerDocument.__importLink;)t=t.ownerDocument.__importLink;return t},addElementToDocument:function(e){var t=this.rootImportForElement(e.__importElement||e);t.parentNode.insertBefore(e,t)},trackElement:function(e,t){var n=this,r=function(o){e.removeEventListener("load",r),e.removeEventListener("error",r),t&&t(o),n.markParsingComplete(e),n.parseNext()};if(e.addEventListener("load",r),e.addEventListener("error",r),u&&"style"===e.localName){var o=!1;if(-1==e.textContent.indexOf("@import"))o=!0;else if(e.sheet){o=!0;for(var i,a=e.sheet.cssRules,s=a?a.length:0,c=0;s>c&&(i=a[c]);c++)i.type===CSSRule.IMPORT_RULE&&(o=o&&Boolean(i.styleSheet))}o&&setTimeout(function(){e.dispatchEvent(new CustomEvent("load",{bubbles:!1}))})}},parseScript:function(t){var r=document.createElement("script");r.__importElement=t,r.src=t.src?t.src:n(t),e.currentScript=t,this.trackElement(r,function(){r.parentNode&&r.parentNode.removeChild(r),e.currentScript=null}),this.addElementToDocument(r)},nextToParse:function(){return this._mayParse=[],!this.parsingElement&&(this.nextToParseInDoc(s)||this.nextToParseDynamic())},nextToParseInDoc:function(e,n){if(e&&0>this._mayParse.indexOf(e)){this._mayParse.push(e);for(var r,o=e.querySelectorAll(this.parseSelectorsForNode(e)),i=0,a=o.length;a>i&&(r=o[i]);i++)if(!this.isParsed(r))return this.hasResource(r)?t(r)?this.nextToParseInDoc(r.__doc,r):r:void 0}return n},nextToParseDynamic:function(){return this.dynamicElements[0]},parseSelectorsForNode:function(e){var t=e.ownerDocument||e;return t===s?this.documentSelectors:this.importsSelectors},isParsed:function(e){return e.__importParsed},needsDynamicParsing:function(e){return this.dynamicElements.indexOf(e)>=0},hasResource:function(e){return t(e)&&void 0===e.__doc?!1:!0}};e.parser=h,e.IMPORT_SELECTOR=d}),window.HTMLImports.addModule(function(e){function t(e){return n(e,a)}function n(e,t){return"link"===e.localName&&e.getAttribute("rel")===t}function r(e){return!!Object.getOwnPropertyDescriptor(e,"baseURI")}function o(e,t){var n=document.implementation.createHTMLDocument(a);n._URL=t;var o=n.createElement("base");o.setAttribute("href",t),n.baseURI||r(n)||Object.defineProperty(n,"baseURI",{value:t});var i=n.createElement("meta");return i.setAttribute("charset","utf-8"),n.head.appendChild(i),n.head.appendChild(o),n.body.innerHTML=e,window.HTMLTemplateElement&&HTMLTemplateElement.bootstrap&&HTMLTemplateElement.bootstrap(n),n}var i=e.flags,a=e.IMPORT_LINK_TYPE,s=e.IMPORT_SELECTOR,c=e.rootDocument,u=e.Loader,l=e.Observer,d=e.parser,h={documents:{},documentPreloadSelectors:s,importsPreloadSelectors:[s].join(","),loadNode:function(e){p.addNode(e)},loadSubtree:function(e){var t=this.marshalNodes(e);p.addNodes(t)},marshalNodes:function(e){return e.querySelectorAll(this.loadSelectorsForNode(e))},loadSelectorsForNode:function(e){var t=e.ownerDocument||e;return t===c?this.documentPreloadSelectors:this.importsPreloadSelectors},loaded:function(e,n,r,a,s){if(i.load&&console.log("loaded",e,n),n.__resource=r,n.__error=a,t(n)){var c=this.documents[e];void 0===c&&(c=a?null:o(r,s||e),c&&(c.__importLink=n,this.bootDocument(c)),this.documents[e]=c),n.__doc=c}d.parseNext()},bootDocument:function(e){this.loadSubtree(e),this.observer.observe(e),d.parseNext()},loadedAll:function(){d.parseNext()}},p=new u(h.loaded.bind(h),h.loadedAll.bind(h));if(h.observer=new l,!document.baseURI){var f={get:function(){var e=document.querySelector("base");return e?e.href:window.location.href},configurable:!0};Object.defineProperty(document,"baseURI",f),Object.defineProperty(c,"baseURI",f)}e.importer=h,e.importLoader=p}),window.HTMLImports.addModule(function(e){var t=e.parser,n=e.importer,r={added:function(e){for(var r,o,i,a,s=0,c=e.length;c>s&&(a=e[s]);s++)r||(r=a.ownerDocument,o=t.isParsed(r)),i=this.shouldLoadNode(a),i&&n.loadNode(a),this.shouldParseNode(a)&&o&&t.parseDynamic(a,i)},shouldLoadNode:function(e){return 1===e.nodeType&&o.call(e,n.loadSelectorsForNode(e))},shouldParseNode:function(e){return 1===e.nodeType&&o.call(e,t.parseSelectorsForNode(e))}};n.observer.addCallback=r.added.bind(r);var o=HTMLElement.prototype.matches||HTMLElement.prototype.matchesSelector||HTMLElement.prototype.webkitMatchesSelector||HTMLElement.prototype.mozMatchesSelector||HTMLElement.prototype.msMatchesSelector}),function(e){function t(){window.HTMLImports.importer.bootDocument(r)}var n=e.initializeModules;if(e.isIE,!e.useNative){n();var r=e.rootDocument;"complete"===document.readyState||"interactive"===document.readyState&&!window.attachEvent?t():document.addEventListener("DOMContentLoaded",t)}}(window.HTMLImports),window.CustomElements=window.CustomElements||{flags:{}},function(e){var t=e.flags,n=[],r=function(e){n.push(e)},o=function(){n.forEach(function(t){t(e)})};e.addModule=r,e.initializeModules=o,e.hasNative=Boolean(document.registerElement),e.isIE=/Trident/.test(navigator.userAgent),e.useNative=!t.register&&e.hasNative&&!window.ShadowDOMPolyfill&&(!window.HTMLImports||window.HTMLImports.useNative)}(window.CustomElements),window.CustomElements.addModule(function(e){function t(e,t){n(e,function(e){return t(e)?!0:(r(e,t),void 0)}),r(e,t)}function n(e,t,r){var o=e.firstElementChild;if(!o)for(o=e.firstChild;o&&o.nodeType!==Node.ELEMENT_NODE;)o=o.nextSibling;for(;o;)t(o,r)!==!0&&n(o,t,r),o=o.nextElementSibling;return null}function r(e,n){for(var r=e.shadowRoot;r;)t(r,n),r=r.olderShadowRoot}function o(e,t){i(e,t,[])}function i(e,t,n){if(e=window.wrap(e),!(n.indexOf(e)>=0)){n.push(e);for(var r,o=e.querySelectorAll("link[rel="+a+"]"),s=0,c=o.length;c>s&&(r=o[s]);s++)r.import&&i(r.import,t,n);t(e)}}var a=window.HTMLImports?window.HTMLImports.IMPORT_LINK_TYPE:"none";e.forDocumentTree=o,e.forSubtree=t}),window.CustomElements.addModule(function(e){function t(e,t){return n(e,t)||r(e,t)}function n(t,n){return e.upgrade(t,n)?!0:(n&&a(t),void 0)}function r(e,t){y(e,function(e){return n(e,t)?!0:void 0})}function o(e){T.push(e),E||(E=!0,setTimeout(i))}function i(){E=!1;for(var e,t=T,n=0,r=t.length;r>n&&(e=t[n]);n++)e();T=[]}function a(e){_?o(function(){s(e)}):s(e)}function s(e){e.__upgraded__&&!e.__attached&&(e.__attached=!0,e.attachedCallback&&e.attachedCallback())}function c(e){u(e),y(e,function(e){u(e)})}function u(e){_?o(function(){l(e)}):l(e)}function l(e){e.__upgraded__&&e.__attached&&(e.__attached=!1,e.detachedCallback&&e.detachedCallback())}function d(e){for(var t=e,n=window.wrap(document);t;){if(t==n)return!0;t=t.parentNode||t.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&t.host}}function h(e){if(e.shadowRoot&&!e.shadowRoot.__watched){g.dom&&console.log("watching shadow-root for: ",e.localName);
  for(var t=e.shadowRoot;t;)m(t),t=t.olderShadowRoot}}function p(e,n){if(g.dom){var r=n[0];if(r&&"childList"===r.type&&r.addedNodes&&r.addedNodes){for(var o=r.addedNodes[0];o&&o!==document&&!o.host;)o=o.parentNode;var i=o&&(o.URL||o._URL||o.host&&o.host.localName)||"";i=i.split("/?").shift().split("/").pop()}console.group("mutations (%d) [%s]",n.length,i||"")}var a=d(e);n.forEach(function(e){"childList"===e.type&&(C(e.addedNodes,function(e){e.localName&&t(e,a)}),C(e.removedNodes,function(e){e.localName&&c(e)}))}),g.dom&&console.groupEnd()}function f(e){for(e=window.wrap(e),e||(e=window.wrap(document));e.parentNode;)e=e.parentNode;var t=e.__observer;t&&(p(e,t.takeRecords()),i())}function m(e){if(!e.__observer){var t=new MutationObserver(p.bind(this,e));t.observe(e,{childList:!0,subtree:!0}),e.__observer=t}}function v(e){e=window.wrap(e),g.dom&&console.group("upgradeDocument: ",e.baseURI.split("/").pop());var n=e===window.wrap(document);t(e,n),m(e),g.dom&&console.groupEnd()}function b(e){w(e,v)}var g=e.flags,y=e.forSubtree,w=e.forDocumentTree,_=window.MutationObserver._isPolyfilled&&g["throttle-attached"];e.hasPolyfillMutations=_,e.hasThrottledAttached=_;var E=!1,T=[],C=Array.prototype.forEach.call.bind(Array.prototype.forEach),M=Element.prototype.createShadowRoot;M&&(Element.prototype.createShadowRoot=function(){var e=M.call(this);return window.CustomElements.watchShadow(this),e}),e.watchShadow=h,e.upgradeDocumentTree=b,e.upgradeDocument=v,e.upgradeSubtree=r,e.upgradeAll=t,e.attached=a,e.takeRecords=f}),window.CustomElements.addModule(function(e){function t(t,r){if("template"===t.localName&&window.HTMLTemplateElement&&HTMLTemplateElement.decorate&&HTMLTemplateElement.decorate(t),!t.__upgraded__&&t.nodeType===Node.ELEMENT_NODE){var o=t.getAttribute("is"),i=e.getRegisteredDefinition(t.localName)||e.getRegisteredDefinition(o);if(i&&(o&&i.tag==t.localName||!o&&!i.extends))return n(t,i,r)}}function n(t,n,o){return a.upgrade&&console.group("upgrade:",t.localName),n.is&&t.setAttribute("is",n.is),r(t,n),t.__upgraded__=!0,i(t),o&&e.attached(t),e.upgradeSubtree(t,o),a.upgrade&&console.groupEnd(),t}function r(e,t){Object.__proto__?e.__proto__=t.prototype:(o(e,t.prototype,t.native),e.__proto__=t.prototype)}function o(e,t,n){for(var r={},o=t;o!==n&&o!==HTMLElement.prototype;){for(var i,a=Object.getOwnPropertyNames(o),s=0;i=a[s];s++)r[i]||(Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(o,i)),r[i]=1);o=Object.getPrototypeOf(o)}}function i(e){e.createdCallback&&e.createdCallback()}var a=e.flags;e.upgrade=t,e.upgradeWithDefinition=n,e.implementPrototype=r}),window.CustomElements.addModule(function(e){function t(t,r){var c=r||{};if(!t)throw Error("document.registerElement: first argument `name` must not be empty");if(0>t.indexOf("-"))throw Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '"+(t+"")+"'.");if(o(t))throw Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '"+(t+"")+"'. The type name is invalid.");if(u(t))throw Error("DuplicateDefinitionError: a type with name '"+(t+"")+"' is already registered");return c.prototype||(c.prototype=Object.create(HTMLElement.prototype)),c.__name=t.toLowerCase(),c.lifecycle=c.lifecycle||{},c.ancestry=i(c.extends),a(c),s(c),n(c.prototype),l(c.__name,c),c.ctor=d(c),c.ctor.prototype=c.prototype,c.prototype.constructor=c.ctor,e.ready&&b(document),c.ctor}function n(e){if(!e.setAttribute._polyfilled){var t=e.setAttribute;e.setAttribute=function(e,n){r.call(this,e,n,t)};var n=e.removeAttribute;e.removeAttribute=function(e){r.call(this,e,null,n)},e.setAttribute._polyfilled=!0}}function r(e,t,n){e=e.toLowerCase();var r=this.getAttribute(e);n.apply(this,arguments);var o=this.getAttribute(e);this.attributeChangedCallback&&o!==r&&this.attributeChangedCallback(e,r,o)}function o(e){for(var t=0;E.length>t;t++)if(e===E[t])return!0}function i(e){var t=u(e);return t?i(t.extends).concat([t]):[]}function a(e){for(var t,n=e.extends,r=0;t=e.ancestry[r];r++)n=t.is&&t.tag;e.tag=n||e.__name,n&&(e.is=e.__name)}function s(e){if(!Object.__proto__){var t=HTMLElement.prototype;if(e.is){var n=document.createElement(e.tag);t=Object.getPrototypeOf(n)}for(var r,o=e.prototype,i=!1;o;)o==t&&(i=!0),r=Object.getPrototypeOf(o),r&&(o.__proto__=r),o=r;i||console.warn(e.tag+" prototype not found in prototype chain for "+e.is),e.native=t}}function c(e){return y(M(e.tag),e)}function u(e){return e?T[e.toLowerCase()]:void 0}function l(e,t){T[e]=t}function d(e){return function(){return c(e)}}function h(e,t,n){return e===C?p(t,n):L(e,t)}function p(e,t){e&&(e=e.toLowerCase()),t&&(t=t.toLowerCase());var n=u(t||e);if(n){if(e==n.tag&&t==n.is)return new n.ctor;if(!t&&!n.is)return new n.ctor}var r;return t?(r=p(e),r.setAttribute("is",t),r):(r=M(e),e.indexOf("-")>=0&&w(r,HTMLElement),r)}function f(e,t){var n=e[t];e[t]=function(){var e=n.apply(this,arguments);return g(e),e}}var m,v=e.isIE,b=e.upgradeDocumentTree,g=e.upgradeAll,y=e.upgradeWithDefinition,w=e.implementPrototype,_=e.useNative,E=["annotation-xml","color-profile","font-face","font-face-src","font-face-uri","font-face-format","font-face-name","missing-glyph"],T={},C="http://www.w3.org/1999/xhtml",M=document.createElement.bind(document),L=document.createElementNS.bind(document);m=Object.__proto__||_?function(e,t){return e instanceof t}:function(e,t){if(e instanceof t)return!0;for(var n=e;n;){if(n===t.prototype)return!0;n=n.__proto__}return!1},f(Node.prototype,"cloneNode"),f(document,"importNode"),v&&function(){var e=document.importNode;document.importNode=function(){var t=e.apply(document,arguments);if(t.nodeType==t.DOCUMENT_FRAGMENT_NODE){var n=document.createDocumentFragment();return n.appendChild(t),n}return t}}(),document.registerElement=t,document.createElement=p,document.createElementNS=h,e.registry=T,e.instanceof=m,e.reservedTagList=E,e.getRegisteredDefinition=u,document.register=document.registerElement}),function(e){function t(){i(window.wrap(document)),window.CustomElements.ready=!0;var e=window.requestAnimationFrame||function(e){setTimeout(e,16)};e(function(){setTimeout(function(){window.CustomElements.readyTime=Date.now(),window.HTMLImports&&(window.CustomElements.elapsed=window.CustomElements.readyTime-window.HTMLImports.readyTime),document.dispatchEvent(new CustomEvent("WebComponentsReady",{bubbles:!0}))})})}var n=e.useNative,r=e.initializeModules;if(e.isIE,n){var o=function(){};e.watchShadow=o,e.upgrade=o,e.upgradeAll=o,e.upgradeDocumentTree=o,e.upgradeSubtree=o,e.takeRecords=o,e.instanceof=function(e,t){return e instanceof t}}else r();var i=e.upgradeDocumentTree,a=e.upgradeDocument;if(window.wrap||(window.ShadowDOMPolyfill?(window.wrap=window.ShadowDOMPolyfill.wrapIfNeeded,window.unwrap=window.ShadowDOMPolyfill.unwrapIfNeeded):window.wrap=window.unwrap=function(e){return e}),window.HTMLImports&&(window.HTMLImports.__importsParsingHook=function(e){e.import&&a(wrap(e.import))}),"complete"===document.readyState||e.flags.eager)t();else if("interactive"!==document.readyState||window.attachEvent||window.HTMLImports&&!window.HTMLImports.ready){var s=window.HTMLImports&&!window.HTMLImports.ready?"HTMLImportsLoaded":"DOMContentLoaded";window.addEventListener(s,t)}else t()}(window.CustomElements),function(){var e=document.createElement("style");e.textContent="body {transition: opacity ease-in 0.2s; } \nbody[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } \n";var t=document.querySelector("head");t.insertBefore(e,t.firstChild)}(window.WebComponents),function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.PointerEventsPolyfill=t()}(this,function(){"use strict";function e(e,t){t=t||Object.create(null);var n=document.createEvent("Event");n.initEvent(e,t.bubbles||!1,t.cancelable||!1);for(var r,o=2;l.length>o;o++)r=l[o],n[r]=t[r]||d[o];n.buttons=t.buttons||0;var i=0;return i=t.pressure?t.pressure:n.buttons?.5:0,n.x=n.clientX,n.y=n.clientY,n.pointerId=t.pointerId||0,n.width=t.width||0,n.height=t.height||0,n.pressure=i,n.tiltX=t.tiltX||0,n.tiltY=t.tiltY||0,n.pointerType=t.pointerType||"",n.hwTimestamp=t.hwTimestamp||0,n.isPrimary=t.isPrimary||!1,n}function t(){this.array=[],this.size=0}function n(e,t,n,r){this.addCallback=e.bind(r),this.removeCallback=t.bind(r),this.changedCallback=n.bind(r),O&&(this.observer=new O(this.mutationWatcher.bind(this)))}function r(e){return"body /shadow-deep/ "+o(e)}function o(e){return'[touch-action="'+e+'"]'}function i(e){return"{ -ms-touch-action: "+e+"; touch-action: "+e+"; touch-action-delay: none; }"}function a(){if(A){I.forEach(function(e){e+""===e?(k+=o(e)+i(e)+"\n",x&&(k+=r(e)+i(e)+"\n")):(k+=e.selectors.map(o)+i(e.rule)+"\n",x&&(k+=e.selectors.map(r)+i(e.rule)+"\n"))});var e=document.createElement("style");e.textContent=k,document.head.appendChild(e)}}function s(){if(!window.PointerEvent){if(window.PointerEvent=h,window.navigator.msPointerEnabled){var e=window.navigator.msMaxTouchPoints;Object.defineProperty(window.navigator,"maxTouchPoints",{value:e,enumerable:!0}),_.registerSource("ms",ot)}else _.registerSource("mouse",U),void 0!==window.ontouchstart&&_.registerSource("touch",et);_.register(document)}}function c(e){if(!_.pointermap.has(e))throw Error("InvalidPointerId")}function u(){window.Element&&!Element.prototype.setPointerCapture&&Object.defineProperties(Element.prototype,{setPointerCapture:{value:J},releasePointerCapture:{value:Q}})}var l=["bubbles","cancelable","view","detail","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","pageX","pageY"],d=[!1,!1,null,null,0,0,0,0,!1,!1,!1,!1,0,null,0,0],h=e,p=window.Map&&window.Map.prototype.forEach,f=p?Map:t;t.prototype={set:function(e,t){return void 0===t?this.delete(e):(this.has(e)||this.size++,this.array[e]=t,void 0)},has:function(e){return void 0!==this.array[e]},"delete":function(e){this.has(e)&&(delete this.array[e],this.size--)},get:function(e){return this.array[e]},clear:function(){this.array.length=0,this.size=0},forEach:function(e,t){return this.array.forEach(function(n,r){e.call(t,n,r,this)},this)}};var m=f,v=["bubbles","cancelable","view","detail","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","buttons","pointerId","width","height","pressure","tiltX","tiltY","pointerType","hwTimestamp","isPrimary","type","target","currentTarget","which","pageX","pageY","timeStamp"],b=[!1,!1,null,null,0,0,0,0,!1,!1,!1,!1,0,null,0,0,0,0,0,0,0,"",0,!1,"",null,null,0,0,0,0],g={pointerover:1,pointerout:1,pointerenter:1,pointerleave:1},y="undefined"!=typeof SVGElementInstance,w={pointermap:new m,eventMap:Object.create(null),captureInfo:Object.create(null),eventSources:Object.create(null),eventSourceList:[],registerSource:function(e,t){var n=t,r=n.events;r&&(r.forEach(function(e){n[e]&&(this.eventMap[e]=n[e].bind(n))},this),this.eventSources[e]=n,this.eventSourceList.push(n))},register:function(e){for(var t,n=this.eventSourceList.length,r=0;n>r&&(t=this.eventSourceList[r]);r++)t.register.call(t,e)},unregister:function(e){for(var t,n=this.eventSourceList.length,r=0;n>r&&(t=this.eventSourceList[r]);r++)t.unregister.call(t,e)},contains:function(e,t){try{return e.contains(t)}catch(n){return!1}},down:function(e){e.bubbles=!0,this.fireEvent("pointerdown",e)},move:function(e){e.bubbles=!0,this.fireEvent("pointermove",e)},up:function(e){e.bubbles=!0,this.fireEvent("pointerup",e)},enter:function(e){e.bubbles=!1,this.fireEvent("pointerenter",e)},leave:function(e){e.bubbles=!1,this.fireEvent("pointerleave",e)},over:function(e){e.bubbles=!0,this.fireEvent("pointerover",e)},out:function(e){e.bubbles=!0,this.fireEvent("pointerout",e)},cancel:function(e){e.bubbles=!0,this.fireEvent("pointercancel",e)},leaveOut:function(e){this.out(e),this.contains(e.target,e.relatedTarget)||this.leave(e)},enterOver:function(e){this.over(e),this.contains(e.target,e.relatedTarget)||this.enter(e)},eventHandler:function(e){if(!e._handledByPE){var t=e.type,n=this.eventMap&&this.eventMap[t];n&&n(e),e._handledByPE=!0}},listen:function(e,t){t.forEach(function(t){this.addEvent(e,t)},this)},unlisten:function(e,t){t.forEach(function(t){this.removeEvent(e,t)},this)},addEvent:function(e,t){e.addEventListener(t,this.boundHandler)},removeEvent:function(e,t){e.removeEventListener(t,this.boundHandler)},makeEvent:function(e,t){this.captureInfo[t.pointerId]&&(t.relatedTarget=null);var n=new h(e,t);return t.preventDefault&&(n.preventDefault=t.preventDefault),n._target=n._target||t.target,n},fireEvent:function(e,t){var n=this.makeEvent(e,t);return this.dispatchEvent(n)},cloneEvent:function(e){for(var t,n=Object.create(null),r=0;v.length>r;r++)t=v[r],n[t]=e[t]||b[r],!y||"target"!==t&&"relatedTarget"!==t||n[t]instanceof SVGElementInstance&&(n[t]=n[t].correspondingUseElement);return e.preventDefault&&(n.preventDefault=function(){e.preventDefault()}),n},getTarget:function(e){var t=this.captureInfo[e.pointerId];return t?e._target!==t&&e.type in g?void 0:t:e._target},setCapture:function(e,t){this.captureInfo[e]&&this.releaseCapture(e),this.captureInfo[e]=t;var n=document.createEvent("Event");n.initEvent("gotpointercapture",!0,!1),n.pointerId=e,this.implicitRelease=this.releaseCapture.bind(this,e),document.addEventListener("pointerup",this.implicitRelease),document.addEventListener("pointercancel",this.implicitRelease),n._target=t,this.asyncDispatchEvent(n)},releaseCapture:function(e){var t=this.captureInfo[e];if(t){var n=document.createEvent("Event");n.initEvent("lostpointercapture",!0,!1),n.pointerId=e,this.captureInfo[e]=void 0,document.removeEventListener("pointerup",this.implicitRelease),document.removeEventListener("pointercancel",this.implicitRelease),n._target=t,this.asyncDispatchEvent(n)}},dispatchEvent:function(e){var t=this.getTarget(e);return t?t.dispatchEvent(e):void 0},asyncDispatchEvent:function(e){requestAnimationFrame(this.dispatchEvent.bind(this,e))}};w.boundHandler=w.eventHandler.bind(w);var _=w,E={shadow:function(e){return e?e.shadowRoot||e.webkitShadowRoot:void 0},canTarget:function(e){return e&&Boolean(e.elementFromPoint)},targetingShadow:function(e){var t=this.shadow(e);return this.canTarget(t)?t:void 0},olderShadow:function(e){var t=e.olderShadowRoot;if(!t){var n=e.querySelector("shadow");n&&(t=n.olderShadowRoot)}return t},allShadows:function(e){for(var t=[],n=this.shadow(e);n;)t.push(n),n=this.olderShadow(n);return t},searchRoot:function(e,t,n){if(e){var r,o,i=e.elementFromPoint(t,n);for(o=this.targetingShadow(i);o;){if(r=o.elementFromPoint(t,n)){var a=this.targetingShadow(r);return this.searchRoot(a,t,n)||r}o=this.olderShadow(o)}return i}},owner:function(e){for(var t=e;t.parentNode;)t=t.parentNode;return t.nodeType!==Node.DOCUMENT_NODE&&t.nodeType!==Node.DOCUMENT_FRAGMENT_NODE&&(t=document),t},findTarget:function(e){var t=e.clientX,n=e.clientY,r=this.owner(e.target);return r.elementFromPoint(t,n)||(r=document),this.searchRoot(r,t,n)}},T=Array.prototype.forEach.call.bind(Array.prototype.forEach),C=Array.prototype.map.call.bind(Array.prototype.map),M=Array.prototype.slice.call.bind(Array.prototype.slice),L=Array.prototype.filter.call.bind(Array.prototype.filter),O=window.MutationObserver||window.WebKitMutationObserver,S="[touch-action]",N={subtree:!0,childList:!0,attributes:!0,attributeOldValue:!0,attributeFilter:["touch-action"]};n.prototype={watchSubtree:function(e){this.observer&&E.canTarget(e)&&this.observer.observe(e,N)},enableOnSubtree:function(e){this.watchSubtree(e),e===document&&"complete"!==document.readyState?this.installOnLoad():this.installNewSubtree(e)},installNewSubtree:function(e){T(this.findElements(e),this.addElement,this)},findElements:function(e){return e.querySelectorAll?e.querySelectorAll(S):[]},removeElement:function(e){this.removeCallback(e)},addElement:function(e){this.addCallback(e)},elementChanged:function(e,t){this.changedCallback(e,t)},concatLists:function(e,t){return e.concat(M(t))},installOnLoad:function(){document.addEventListener("readystatechange",function(){"complete"===document.readyState&&this.installNewSubtree(document)}.bind(this))},isElement:function(e){return e.nodeType===Node.ELEMENT_NODE},flattenMutationTree:function(e){var t=C(e,this.findElements,this);return t.push(L(e,this.isElement)),t.reduce(this.concatLists,[])},mutationWatcher:function(e){e.forEach(this.mutationHandler,this)},mutationHandler:function(e){if("childList"===e.type){var t=this.flattenMutationTree(e.addedNodes);t.forEach(this.addElement,this);var n=this.flattenMutationTree(e.removedNodes);n.forEach(this.removeElement,this)}else"attributes"===e.type&&this.elementChanged(e.target,e.oldValue)}};var P=n,I=["none","auto","pan-x","pan-y",{rule:"pan-x pan-y",selectors:["pan-x pan-y","pan-y pan-x"]}],k="",A=window.PointerEvent||window.MSPointerEvent,x=!window.ShadowDOMPolyfill&&document.head.createShadowRoot,D=_.pointermap,R=25,H=[1,4,2,8,16],j=!1;try{j=1===new MouseEvent("test",{buttons:1}).buttons}catch(F){}var q,Y={POINTER_ID:1,POINTER_TYPE:"mouse",events:["mousedown","mousemove","mouseup","mouseover","mouseout"],register:function(e){_.listen(e,this.events)},unregister:function(e){_.unlisten(e,this.events)},lastTouches:[],isEventSimulatedFromTouch:function(e){for(var t,n=this.lastTouches,r=e.clientX,o=e.clientY,i=0,a=n.length;a>i&&(t=n[i]);i++){var s=Math.abs(r-t.x),c=Math.abs(o-t.y);if(R>=s&&R>=c)return!0}},prepareEvent:function(e){var t=_.cloneEvent(e),n=t.preventDefault;return t.preventDefault=function(){e.preventDefault(),n()},t.pointerId=this.POINTER_ID,t.isPrimary=!0,t.pointerType=this.POINTER_TYPE,t},prepareButtonsForMove:function(e,t){var n=D.get(this.POINTER_ID);e.buttons=n?n.buttons:0,t.buttons=e.buttons},mousedown:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=D.get(this.POINTER_ID),n=this.prepareEvent(e);j||(n.buttons=H[n.button],t&&(n.buttons|=t.buttons),e.buttons=n.buttons),D.set(this.POINTER_ID,e),t?_.move(n):_.down(n)}},mousemove:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=this.prepareEvent(e);j||this.prepareButtonsForMove(t,e),_.move(t)}},mouseup:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=D.get(this.POINTER_ID),n=this.prepareEvent(e);if(!j){var r=H[n.button];n.buttons=t?t.buttons&~r:0,e.buttons=n.buttons}D.set(this.POINTER_ID,e),0===n.buttons||n.buttons===H[n.button]?(this.cleanupMouse(),_.up(n)):_.move(n)}},mouseover:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=this.prepareEvent(e);j||this.prepareButtonsForMove(t,e),_.enterOver(t)}},mouseout:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=this.prepareEvent(e);j||this.prepareButtonsForMove(t,e),_.leaveOut(t)}},cancel:function(e){var t=this.prepareEvent(e);_.cancel(t),this.cleanupMouse()},cleanupMouse:function(){D.delete(this.POINTER_ID)}},U=Y,X=_.captureInfo,B=E.findTarget.bind(E),z=E.allShadows.bind(E),W=_.pointermap,V=2500,K=200,G="touch-action",$=!1,Z={events:["touchstart","touchmove","touchend","touchcancel"],register:function(e){$?_.listen(e,this.events):q.enableOnSubtree(e)},unregister:function(e){$&&_.unlisten(e,this.events)},elementAdded:function(e){var t=e.getAttribute(G),n=this.touchActionToScrollType(t);n&&(e._scrollType=n,_.listen(e,this.events),z(e).forEach(function(e){e._scrollType=n,_.listen(e,this.events)},this))},elementRemoved:function(e){e._scrollType=void 0,_.unlisten(e,this.events),z(e).forEach(function(e){e._scrollType=void 0,_.unlisten(e,this.events)},this)},elementChanged:function(e,t){var n=e.getAttribute(G),r=this.touchActionToScrollType(n),o=this.touchActionToScrollType(t);r&&o?(e._scrollType=r,z(e).forEach(function(e){e._scrollType=r},this)):o?this.elementRemoved(e):r&&this.elementAdded(e)},scrollTypes:{EMITTER:"none",XSCROLLER:"pan-x",YSCROLLER:"pan-y",SCROLLER:/^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/},touchActionToScrollType:function(e){var t=e,n=this.scrollTypes;return"none"===t?"none":t===n.XSCROLLER?"X":t===n.YSCROLLER?"Y":n.SCROLLER.exec(t)?"XY":void 0},POINTER_TYPE:"touch",firstTouch:null,isPrimaryTouch:function(e){return this.firstTouch===e.identifier},setPrimaryTouch:function(e){(0===W.size||1===W.size&&W.has(1))&&(this.firstTouch=e.identifier,this.firstXY={X:e.clientX,Y:e.clientY},this.scrolling=!1,this.cancelResetClickCount())},removePrimaryPointer:function(e){e.isPrimary&&(this.firstTouch=null,this.firstXY=null,this.resetClickCount())},clickCount:0,resetId:null,resetClickCount:function(){var e=function(){this.clickCount=0,this.resetId=null}.bind(this);this.resetId=setTimeout(e,K)},cancelResetClickCount:function(){this.resetId&&clearTimeout(this.resetId)},typeToButtons:function(e){var t=0;return("touchstart"===e||"touchmove"===e)&&(t=1),t},touchToPointer:function(e){var t=this.currentTouchEvent,n=_.cloneEvent(e),r=n.pointerId=e.identifier+2;n.target=X[r]||B(n),n.bubbles=!0,n.cancelable=!0,n.detail=this.clickCount,n.button=0,n.buttons=this.typeToButtons(t.type),n.width=e.radiusX||e.webkitRadiusX||0,n.height=e.radiusY||e.webkitRadiusY||0,n.pressure=e.force||e.webkitForce||.5,n.isPrimary=this.isPrimaryTouch(e),n.pointerType=this.POINTER_TYPE;var o=this;return n.preventDefault=function(){o.scrolling=!1,o.firstXY=null,t.preventDefault()},n},processTouches:function(e,t){var n=e.changedTouches;this.currentTouchEvent=e;for(var r,o=0;n.length>o;o++)r=n[o],t.call(this,this.touchToPointer(r))},shouldScroll:function(e){if(this.firstXY){var t,n=e.currentTarget._scrollType;if("none"===n)t=!1;else if("XY"===n)t=!0;else{var r=e.changedTouches[0],o=n,i="Y"===n?"X":"Y",a=Math.abs(r["client"+o]-this.firstXY[o]),s=Math.abs(r["client"+i]-this.firstXY[i]);t=a>=s}return this.firstXY=null,t}},findTouch:function(e,t){for(var n,r=0,o=e.length;o>r&&(n=e[r]);r++)if(n.identifier===t)return!0},vacuumTouches:function(e){var t=e.touches;if(W.size>=t.length){var n=[];W.forEach(function(e,r){if(1!==r&&!this.findTouch(t,r-2)){var o=e.out;n.push(o)}},this),n.forEach(this.cancelOut,this)}},touchstart:function(e){this.vacuumTouches(e),this.setPrimaryTouch(e.changedTouches[0]),this.dedupSynthMouse(e),this.scrolling||(this.clickCount++,this.processTouches(e,this.overDown))},overDown:function(e){W.set(e.pointerId,{target:e.target,out:e,outTarget:e.target}),_.over(e),_.enter(e),_.down(e)},touchmove:function(e){this.scrolling||(this.shouldScroll(e)?(this.scrolling=!0,this.touchcancel(e)):(e.preventDefault(),this.processTouches(e,this.moveOverOut)))},moveOverOut:function(e){var t=e,n=W.get(t.pointerId);if(n){var r=n.out,o=n.outTarget;_.move(t),r&&o!==t.target&&(r.relatedTarget=t.target,t.relatedTarget=o,r.target=o,t.target?(_.leaveOut(r),_.enterOver(t)):(t.target=o,t.relatedTarget=null,this.cancelOut(t))),n.out=t,n.outTarget=t.target}},touchend:function(e){this.dedupSynthMouse(e),this.processTouches(e,this.upOut)},upOut:function(e){this.scrolling||(_.up(e),_.out(e),_.leave(e)),this.cleanUpPointer(e)},touchcancel:function(e){this.processTouches(e,this.cancelOut)},cancelOut:function(e){_.cancel(e),_.out(e),_.leave(e),this.cleanUpPointer(e)},cleanUpPointer:function(e){W.delete(e.pointerId),this.removePrimaryPointer(e)},dedupSynthMouse:function(e){var t=U.lastTouches,n=e.changedTouches[0];if(this.isPrimaryTouch(n)){var r={x:n.clientX,y:n.clientY};t.push(r);var o=function(e,t){var n=e.indexOf(t);n>-1&&e.splice(n,1)}.bind(null,t,r);setTimeout(o,V)}}};$||(q=new P(Z.elementAdded,Z.elementRemoved,Z.elementChanged,Z));var J,Q,et=Z,tt=_.pointermap,nt=window.MSPointerEvent&&"number"==typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE,rt={events:["MSPointerDown","MSPointerMove","MSPointerUp","MSPointerOut","MSPointerOver","MSPointerCancel","MSGotPointerCapture","MSLostPointerCapture"],register:function(e){_.listen(e,this.events)},unregister:function(e){_.unlisten(e,this.events)},POINTER_TYPES:["","unavailable","touch","pen","mouse"],prepareEvent:function(e){var t=e;return nt&&(t=_.cloneEvent(e),t.pointerType=this.POINTER_TYPES[e.pointerType]),t},cleanup:function(e){tt.delete(e)},MSPointerDown:function(e){tt.set(e.pointerId,e);var t=this.prepareEvent(e);_.down(t)},MSPointerMove:function(e){var t=this.prepareEvent(e);_.move(t)},MSPointerUp:function(e){var t=this.prepareEvent(e);_.up(t),this.cleanup(e.pointerId)},MSPointerOut:function(e){var t=this.prepareEvent(e);_.leaveOut(t)},MSPointerOver:function(e){var t=this.prepareEvent(e);_.enterOver(t)},MSPointerCancel:function(e){var t=this.prepareEvent(e);_.cancel(t),this.cleanup(e.pointerId)},MSLostPointerCapture:function(e){var t=_.makeEvent("lostpointercapture",e);_.dispatchEvent(t)},MSGotPointerCapture:function(e){var t=_.makeEvent("gotpointercapture",e);_.dispatchEvent(t)}},ot=rt,it=window.navigator;it.msPointerEnabled?(J=function(e){c(e),this.msSetPointerCapture(e)},Q=function(e){c(e),this.msReleasePointerCapture(e)}):(J=function(e){c(e),_.setCapture(e,this)},Q=function(e){c(e),_.releaseCapture(e,this)}),a(),s(),u();var at={dispatcher:_,Installer:P,PointerEvent:h,PointerMap:m,targetFinding:E};return at}),function(){function e(e){var t=D.call(e);return x[t]||(x[t]=t.match(R)[1].toLowerCase())}function t(n,r){var o=t[r||e(n)];return o?o(n):n}function n(t){return H[e(t)]?[t]:Array.prototype.slice.call(t,0)}function r(e,t){return(t||j).length?n(e.querySelectorAll(t)):[]}function o(e){e()}function i(n,r,o){var i=e(o);return"object"==i&&"object"==e(n[r])?X.merge(n[r],o):n[r]=t(o,i),n}function a(e,t,n){var r,o={};for(var i in t)o[i.split(":")[0]]=i;for(i in n)r=o[i.split(":")[0]],"function"==typeof t[r]?(r.match(":mixins")||(t[r+":mixins"]=t[r],delete t[r],r+=":mixins"),t[r].__mixin__=X.applyPseudos(i+(i.match(":mixins")?"":":mixins"),n[i],e.pseudos,t[r].__mixin__)):(t[i]=n[i],delete t[r])}function s(e,t,n){for(var r in n)t[r+":__mixin__("+F++ +")"]=X.applyPseudos(r,n[r],e.pseudos)}function c(e,t){for(var n=e.length;n--;)t.unshift(e[n]),X.mixins[e[n]].mixins&&c(X.mixins[e[n]].mixins,t);return t}function u(e){return c(e.mixins,[]).forEach(function(t){var n=X.mixins[t];for(var r in n){var o=n[r],i=e[r];if(i)switch(r){case"mixins":break;case"events":s(e,i,o);break;case"accessors":case"prototype":for(var c in o)i[c]?a(e,i[c],o[c],t):i[c]=o[c];break;default:a(e,i,o,t)}else e[r]=o}}),e}function l(e,t){for(var n,r=t.target,o=t.currentTarget;!n&&r&&r!=o;)r.tagName&&A.call(r,e.value)&&(n=r),r=r.parentNode;return!n&&o.tagName&&A.call(o,e.value)&&(n=o),n?e.listener=e.listener.bind(n):null}function d(e){return 0===e.button}function h(e,t,n,r){r?t[e]=n[e]:Object.defineProperty(t,e,{writable:!0,enumerable:!0,value:n[e]})}function p(e,t){var n=Object.getOwnPropertyDescriptor(e,"target");for(var r in t)q[r]||h(r,e,t,n);e.baseEvent=t}function f(e,t,n,r,o){_[o].call(e,n,t&&t.boolean?"":r)}function m(e,t,n,r,o){if(t&&(t.property||t.selector))for(var i=t.property?[e.xtag[t.property]]:t.selector?X.query(e,t.selector):[],a=i.length;a--;)i[a][o](n,r)}function v(e,t,n,r,o,i){var a=n.split(":"),s=a[0];"get"==s?(a[0]=t,e.prototype[t].get=X.applyPseudos(a.join(":"),r[n],e.pseudos,r[n])):"set"==s?(a[0]=t,e.prototype[t].set=X.applyPseudos(a.join(":"),o?function(e){var t,a="setAttribute";o.boolean?(e=!!e,t=this.hasAttribute(i),e||(a="removeAttribute")):(e=o.validate?o.validate.call(this,e):e,t=this.getAttribute(i)),f(this,o,i,e,a),r[n].call(this,e,t),m(this,o,i,e,a)}:r[n]?function(e){r[n].call(this,e)}:null,e.pseudos,r[n]),o&&(o.setter=r[n])):e.prototype[t][n]=r[n]}function b(e,t){e.prototype[t]={};var n,r=e.accessors[t],o=r.attribute;o&&(n=o.name=(o?o.name||t.replace(O,"$1-$2"):t).toLowerCase(),o.key=t,e.attributes[n]=o);for(var i in r)v(e,t,i,r,o,n);if(o){if(!e.prototype[t].get){var a=(o.boolean?"has":"get")+"Attribute";e.prototype[t].get=function(){return this[a](n)}}e.prototype[t].set||(e.prototype[t].set=function(e){e=o.boolean?!!e:o.validate?o.validate.call(this,e):e;var t=o.boolean?e?"setAttribute":"removeAttribute":"setAttribute";f(this,o,n,e,t),m(this,o,n,e,t)})}}function g(e){return"function"==typeof e?U.exec(""+e)[1]:e}var y=window,w=document,_={setAttribute:Element.prototype.setAttribute,removeAttribute:Element.prototype.removeAttribute},E=Element.prototype.createShadowRoot,T=w.createElement("div"),C=function(){},M=function(){return!0},L=/,/g,O=/([a-z])([A-Z])/g,S=/\(|\)/g,N=/:(\w+)\u276A(.+?(?=\u276B))|:(\w+)/g,P=/(\d+)/g,I={action:function(e,t){return e.value.match(P).indexOf(t.keyCode+"")>-1==("keypass"==e.name)||null}},k=function(){var e=Object.keys(window).join(),t=(e.match(/,(ms)/)||e.match(/,(moz)/)||e.match(/,(O)/)||[null,"webkit"])[1].toLowerCase();return{dom:"ms"==t?"MS":t,lowercase:t,css:"-"+t+"-",js:"ms"==t?t:t.charAt(0).toUpperCase()+t.substring(1)}}(),A=Element.prototype.matches||Element.prototype.matchesSelector||Element.prototype[k.lowercase+"MatchesSelector"],x={},D=x.toString,R=/\s([a-zA-Z]+)/;t.object=function(e){var n={};for(var r in e)n[r]=t(e[r]);return n},t.array=function(e){for(var n=e.length,r=Array(n);n--;)r[n]=t(e[n]);return r};var H={undefined:1,"null":1,number:1,"boolean":1,string:1,"function":1},j="",F=0,q={};for(var Y in w.createEvent("CustomEvent"))q[Y]=1;var U=/\/\*!?(?:\@preserve)?[ \t]*(?:\r\n|\n)([\s\S]*?)(?:\r\n|\n)\s*\*\//,X={tags:{},defaultOptions:{pseudos:[],mixins:[],events:{},methods:{},accessors:{},lifecycle:{},attributes:{},prototype:{xtag:{get:function(){return this.__xtag__?this.__xtag__:this.__xtag__={data:{}}}}}},register:function(e,t){var r;if("string"!=typeof e)throw"First argument must be a Custom Element string name";r=e.toLowerCase(),X.tags[r]=t||{};var o=t.prototype;delete t.prototype;var i=X.tags[r].compiled=u(X.merge({},X.defaultOptions,t)),a=i.prototype,s=i.lifecycle;for(var c in i.events)i.events[c]=X.parseEvent(c,i.events[c]);for(c in s)s[c.split(":")[0]]=X.applyPseudos(c,s[c],i.pseudos,s[c]);for(c in i.methods)a[c.split(":")[0]]={value:X.applyPseudos(c,i.methods[c],i.pseudos,i.methods[c]),enumerable:!0};for(c in i.accessors)b(i,c);i.shadow&&(i.shadow=i.shadow.nodeName?i.shadow:X.createFragment(i.shadow)),i.content&&(i.content=i.content.nodeName?i.content.innerHTML:g(i.content));var l=s.created,d=s.finalized;a.createdCallback={enumerable:!0,value:function(){var e=this;i.shadow&&E&&this.createShadowRoot().appendChild(i.shadow.cloneNode(!0)),i.content&&(this.appendChild(document.createElement("div")).outerHTML=i.content);var t=l?l.apply(this,arguments):null;X.addEvents(this,i.events);for(var n in i.attributes){var r=i.attributes[n],o=this.hasAttribute(n),a=void 0!==r.def;(o||r.boolean||a)&&(this[r.key]=r.boolean?o:!o&&a?r.def:this.getAttribute(n))}return i.pseudos.forEach(function(t){t.onAdd.call(e,t)}),this.xtagComponentReady=!0,d&&d.apply(this,arguments),t}};var h=s.inserted,p=s.removed;(h||p)&&(a.attachedCallback={value:function(){return p&&(this.xtag.__parentNode__=this.parentNode),h?h.apply(this,arguments):void 0},enumerable:!0}),p&&(a.detachedCallback={value:function(){var e=n(arguments);e.unshift(this.xtag.__parentNode__);var t=p.apply(this,e);return delete this.xtag.__parentNode__,t},enumerable:!0}),s.attributeChanged&&(a.attributeChangedCallback={value:s.attributeChanged,enumerable:!0}),a.setAttribute={writable:!0,enumerable:!0,value:function(e,t){var n,r=e.toLowerCase(),o=i.attributes[r];o&&(n=this.getAttribute(r),t=o.boolean?"":o.validate?o.validate.call(this,t):t),f(this,o,r,t,"setAttribute"),o&&(o.setter&&o.setter.call(this,o.boolean?!0:t,n),m(this,o,r,t,"setAttribute"))}},a.removeAttribute={writable:!0,enumerable:!0,value:function(e){var t=e.toLowerCase(),n=i.attributes[t],r=this.hasAttribute(t);f(this,n,t,"","removeAttribute"),n&&(n.setter&&n.setter.call(this,n.boolean?!1:void 0,r),m(this,n,t,"","removeAttribute"))}};var v={},_=o instanceof y.HTMLElement,T=i["extends"]&&(v["extends"]=i["extends"]);return o&&Object.getOwnPropertyNames(o).forEach(function(e){var t=a[e],n=_?Object.getOwnPropertyDescriptor(o,e):o[e];if(t)for(var r in n)t[r]="function"==typeof n[r]&&t[r]?X.wrap(n[r],t[r]):n[r];a[e]=t||n}),v.prototype=Object.create(T?Object.create(w.createElement(T).constructor).prototype:y.HTMLElement.prototype,a),w.registerElement(r,v)},mixins:{},prefix:k,captureEvents:{focus:1,blur:1,scroll:1,DOMMouseScroll:1},customEvents:{animationstart:{attach:[k.dom+"AnimationStart"]},animationend:{attach:[k.dom+"AnimationEnd"]},transitionend:{attach:[k.dom+"TransitionEnd"]},move:{attach:["pointermove"]},enter:{attach:["pointerenter"]},leave:{attach:["pointerleave"]},scrollwheel:{attach:["DOMMouseScroll","mousewheel"],condition:function(e){return e.delta=e.wheelDelta?e.wheelDelta/40:Math.round(-1*(e.detail/3.5)),!0
  }},tap:{attach:["pointerdown","pointerup"],condition:function(e,t){if("pointerdown"==e.type)t.startX=e.clientX,t.startY=e.clientY;else if(0===e.button&&10>Math.abs(t.startX-e.clientX)&&10>Math.abs(t.startY-e.clientY))return!0}},tapstart:{attach:["pointerdown"],condition:d},tapend:{attach:["pointerup"],condition:d},tapmove:{attach:["pointerdown"],condition:function(e,t){if("pointerdown"==e.type){var n=t.listener.bind(this);t.tapmoveListeners||(t.tapmoveListeners=X.addEvents(document,{pointermove:n,pointerup:n,pointercancel:n}))}else("pointerup"==e.type||"pointercancel"==e.type)&&(X.removeEvents(document,t.tapmoveListeners),t.tapmoveListeners=null);return!0}},taphold:{attach:["pointerdown","pointerup"],condition:function(e,t){if("pointerdown"==e.type)(t.pointers=t.pointers||{})[e.pointerId]=setTimeout(X.fireEvent.bind(null,this,"taphold"),t.duration||1e3);else{if("pointerup"!=e.type)return!0;t.pointers&&(clearTimeout(t.pointers[e.pointerId]),delete t.pointers[e.pointerId])}}}},pseudos:{__mixin__:{},mixins:{onCompiled:function(e,t){var n=t.source&&t.source.__mixin__||t.source;if(!n)return e;switch(t.value){case null:case"":case"before":return function(){return n.apply(this,arguments),e.apply(this,arguments)};case"after":return function(){var t=e.apply(this,arguments);return n.apply(this,arguments),t};case"none":return e}}},keypass:I,keyfail:I,delegate:{action:l},preventable:{action:function(e,t){return!t.defaultPrevented}},duration:{onAdd:function(e){e.source.duration=Number(e.value)}},capture:{onCompiled:function(e,t){t.source&&(t.source.capture=!0)}}},clone:t,typeOf:e,toArray:n,wrap:function(e,t){return function(){var n=e.apply(this,arguments);return t.apply(this,arguments),n}},merge:function(t,n,r){if("string"==e(n))return i(t,n,r);for(var o=1,a=arguments.length;a>o;o++){var s=arguments[o];for(var c in s)i(t,c,s[c])}return t},uid:function(){return Math.random().toString(36).substr(2,10)},query:r,skipTransition:function(e,t,n){var r=k.js+"TransitionProperty";e.style[r]=e.style.transitionProperty="none";var o=t?t.call(n||e):null;return X.skipFrame(function(){e.style[r]=e.style.transitionProperty="",o&&o.call(n||e)})},requestFrame:function(){var e=y.requestAnimationFrame||y[k.lowercase+"RequestAnimationFrame"]||function(e){return y.setTimeout(e,20)};return function(t){return e(t)}}(),cancelFrame:function(){var e=y.cancelAnimationFrame||y[k.lowercase+"CancelAnimationFrame"]||y.clearTimeout;return function(t){return e(t)}}(),skipFrame:function(e){var t=X.requestFrame(function(){t=X.requestFrame(e)});return t},matchSelector:function(e,t){return A.call(e,t)},set:function(e,t,n){e[t]=n,window.CustomElements&&CustomElements.upgradeAll(e)},innerHTML:function(e,t){X.set(e,"innerHTML",t)},hasClass:function(e,t){return e.className.split(" ").indexOf(t.trim())>-1},addClass:function(e,t){var n=e.className.trim().split(" ");return t.trim().split(" ").forEach(function(e){~n.indexOf(e)||n.push(e)}),e.className=n.join(" ").trim(),e},removeClass:function(e,t){var n=t.trim().split(" ");return e.className=e.className.trim().split(" ").filter(function(e){return e&&!~n.indexOf(e)}).join(" "),e},toggleClass:function(e,t){return X[X.hasClass(e,t)?"removeClass":"addClass"].call(null,e,t)},queryChildren:function(e,t){var r=e.id,o="#"+(e.id=r||"x_"+X.uid())+" > ",i=e.parentNode||!T.appendChild(e);t=o+(t+"").replace(L,","+o);var a=e.parentNode.querySelectorAll(t);return r||e.removeAttribute("id"),i||T.removeChild(e),n(a)},createFragment:function(e){var t=document.createElement("template");return e&&(e.nodeName?n(arguments).forEach(function(e){t.content.appendChild(e)}):t.innerHTML=g(e)),document.importNode(t.content,!0)},manipulate:function(e,t){var n=e.nextSibling,r=e.parentNode,o=t.call(e)||e;n?r.insertBefore(o,n):r.appendChild(o)},applyPseudos:function(e,t,r,i){var a=t,s={};if(e.match(":")){var c=[],u=0;e.replace(S,function(e){return"("==e?1==++u?"âª":"(":--u?")":"â«"}).replace(N,function(e,t,n,r){c.push([t||r,n])});for(var l=c.length;l--;)o(function(){var o=c[l][0],u=c[l][1];if(!X.pseudos[o])throw"pseudo not found: "+o+" "+u;u=""===u||u===void 0?null:u;var d=s[l]=Object.create(X.pseudos[o]);d.key=e,d.name=o,d.value=u,d.arguments=(u||"").split(","),d.action=d.action||M,d.source=i,d.onAdd=d.onAdd||C,d.onRemove=d.onRemove||C;var h=d.listener=a;a=function(){var e=d.action.apply(this,[d].concat(n(arguments)));return null===e||e===!1?e:(e=d.listener.apply(this,arguments),d.listener=h,e)},r?r.push(d):d.onAdd.call(t,d)})}for(var d in s)s[d].onCompiled&&(a=s[d].onCompiled(a,s[d])||a);return a},removePseudos:function(e,t){t.forEach(function(t){t.onRemove.call(e,t)})},parseEvent:function(e,t){var r=e.split(":"),o=r.shift(),i=X.customEvents[o],a=X.merge({type:o,stack:C,condition:M,capture:X.captureEvents[o],attach:[],_attach:[],pseudos:"",_pseudos:[],onAdd:C,onRemove:C},i||{});a.attach=n(a.base||a.attach),a.chain=o+(a.pseudos.length?":"+a.pseudos:"")+(r.length?":"+r.join(":"):"");var s=X.applyPseudos(a.chain,t,a._pseudos,a);return a.stack=function(e){e.currentTarget=e.currentTarget||this;var t=e.detail||{};return t.__stack__?t.__stack__==s?(e.stopPropagation(),e.cancelBubble=!0,s.apply(this,arguments)):void 0:s.apply(this,arguments)},a.listener=function(e){var t=n(arguments),r=a.condition.apply(this,t.concat([a]));return r?e.type!=o&&e.baseEvent&&e.type!=e.baseEvent.type?(X.fireEvent(e.target,o,{baseEvent:e,detail:r!==!0&&(r.__stack__=s)?r:{__stack__:s}}),void 0):a.stack.apply(this,t):r},a.attach.forEach(function(e){a._attach.push(X.parseEvent(e,a.listener))}),a},addEvent:function(e,t,n,r){var o="function"==typeof n?X.parseEvent(t,n):n;return o._pseudos.forEach(function(t){t.onAdd.call(e,t)}),o._attach.forEach(function(t){X.addEvent(e,t.type,t)}),o.onAdd.call(e,o,o.listener),e.addEventListener(o.type,o.stack,r||o.capture),o},addEvents:function(e,t){var n={};for(var r in t)n[r]=X.addEvent(e,r,t[r]);return n},removeEvent:function(e,t,n){n=n||t,n.onRemove.call(e,n,n.listener),X.removePseudos(e,n._pseudos),n._attach.forEach(function(t){X.removeEvent(e,t)}),e.removeEventListener(n.type,n.stack)},removeEvents:function(e,t){for(var n in t)X.removeEvent(e,t[n])},fireEvent:function(e,t,n){var r=w.createEvent("CustomEvent");n=n||{},r.initCustomEvent(t,n.bubbles!==!1,n.cancelable!==!1,n.detail),n.baseEvent&&p(r,n.baseEvent),e.dispatchEvent(r)}};y.xtag=X,w.addEventListener("WebComponentsReady",function(){X.fireEvent(w.body,"DOMComponentsLoaded")})}();
  
  
  
  ;(function () {
      'use strict';
  
      /**
       * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
       *
       * @codingstandard ftlabs-jsv2
       * @copyright The Financial Times Limited [All Rights Reserved]
       * @license MIT License (see LICENSE.txt)
       */
  
      /*jslint browser:true, node:true*/
      /*global define, Event, Node*/
  
  
      /**
       * Instantiate fast-clicking listeners on the specified layer.
       *
       * @constructor
       * @param {Element} layer The layer to listen on
       * @param {Object} [options={}] The options to override the defaults
       */
      function FastClick(layer, options) {
          var oldOnClick;
  
          options = options || {};
  
          /**
           * Whether a click is currently being tracked.
           *
           * @type boolean
           */
          this.trackingClick = false;
  
  
          /**
           * Timestamp for when click tracking started.
           *
           * @type number
           */
          this.trackingClickStart = 0;
  
  
          /**
           * The element being tracked for a click.
           *
           * @type EventTarget
           */
          this.targetElement = null;
  
  
          /**
           * X-coordinate of touch start event.
           *
           * @type number
           */
          this.touchStartX = 0;
  
  
          /**
           * Y-coordinate of touch start event.
           *
           * @type number
           */
          this.touchStartY = 0;
  
  
          /**
           * ID of the last touch, retrieved from Touch.identifier.
           *
           * @type number
           */
          this.lastTouchIdentifier = 0;
  
  
          /**
           * Touchmove boundary, beyond which a click will be cancelled.
           *
           * @type number
           */
          this.touchBoundary = options.touchBoundary || 10;
  
  
          /**
           * The FastClick layer.
           *
           * @type Element
           */
          this.layer = layer;
  
          /**
           * The minimum time between tap(touchstart and touchend) events
           *
           * @type number
           */
          this.tapDelay = options.tapDelay || 200;
  
          /**
           * The maximum time for a tap
           *
           * @type number
           */
          this.tapTimeout = options.tapTimeout || 700;
  
          if (FastClick.notNeeded(layer)) {
              return;
          }
  
          // Some old versions of Android don't have Function.prototype.bind
          function bind(method, context) {
              return function() { return method.apply(context, arguments); };
          }
  
  
          var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
          var context = this;
          for (var i = 0, l = methods.length; i < l; i++) {
              context[methods[i]] = bind(context[methods[i]], context);
          }
  
          // Set up event handlers as required
          //deviceIsIOS was added by Mojo
          if (deviceIsAndroid || deviceIsIOS) {
              layer.addEventListener('mouseover', this.onMouse, true);
              layer.addEventListener('mousedown', this.onMouse, true);
              layer.addEventListener('mouseup', this.onMouse, true);
          }
  
          layer.addEventListener('click', this.onClick, true);
          layer.addEventListener('touchstart', this.onTouchStart, false);
          layer.addEventListener('touchmove', this.onTouchMove, false);
          layer.addEventListener('touchend', this.onTouchEnd, false);
          layer.addEventListener('touchcancel', this.onTouchCancel, false);
  
          // Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
          // which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
          // layer when they are cancelled.
          if (!Event.prototype.stopImmediatePropagation) {
              layer.removeEventListener = function(type, callback, capture) {
                  var rmv = Node.prototype.removeEventListener;
                  if (type === 'click') {
                      rmv.call(layer, type, callback.hijacked || callback, capture);
                  } else {
                      rmv.call(layer, type, callback, capture);
                  }
              };
  
              layer.addEventListener = function(type, callback, capture) {
                  var adv = Node.prototype.addEventListener;
                  if (type === 'click') {
                      adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
                          if (!event.propagationStopped) {
                              callback(event);
                          }
                      }), capture);
                  } else {
                      adv.call(layer, type, callback, capture);
                  }
              };
          }
  
          // If a handler is already declared in the element's onclick attribute, it will be fired before
          // FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
          // adding it as listener.
          if (typeof layer.onclick === 'function') {
  
              // Android browser on at least 3.2 requires a new reference to the function in layer.onclick
              // - the old one won't work if passed to addEventListener directly.
              oldOnClick = layer.onclick;
              layer.addEventListener('click', function(event) {
                  oldOnClick(event);
              }, false);
              layer.onclick = null;
          }
      }
  
      /**
      * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
      *
      * @type boolean
      */
      var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;
  
      /**
       * Android requires exceptions.
       *
       * @type boolean
       */
      var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;
  
  
      /**
       * iOS requires exceptions.
       *
       * @type boolean
       */
      var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;
  
  
      /**
       * iOS 4 requires an exception for select elements.
       *
       * @type boolean
       */
      var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);
  
  
      /**
       * iOS 6.0-7.* requires the target element to be manually derived
       *
       * @type boolean
       */
      var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);
  
      /**
       * BlackBerry requires exceptions.
       *
       * @type boolean
       */
      var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;
  
      /**
       * Determine whether a given element requires a native click.
       *
       * @param {EventTarget|Element} target Target DOM element
       * @returns {boolean} Returns true if the element needs a native click
       */
      FastClick.prototype.needsClick = function(target) {
          switch (target.nodeName.toLowerCase()) {
  
          // Don't send a synthetic click to disabled inputs (issue #62)
          case 'button':
          case 'select':
          case 'textarea':
              if (target.disabled) {
                  return true;
              }
  
              break;
          case 'input':
  
              // File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
              if ((deviceIsIOS && target.type === 'file') || target.disabled) {
                  return true;
              }
  
              break;
          case 'label':
          case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
          case 'video':
              return true;
          }
          
          // CODE ADDED BY MICHAEL (added for case when we need to have click for html that we have no control over
          //                          (our example is the contents of an ACE editor need regular clicks but we cant add a "needsclick" to every element in an ACE editor)
          //                       )
          var currentElement = target.parentNode;
          
          // loop through parents and if any of the parents has the "childrenneedsclick" class than return true
          while (currentElement && currentElement.parentNode && currentElement.parentNode.nodeName !== 'HTML') {
              if (currentElement.classList.contains('childrenneedsclick')) {//alert('test');
                  return true;
              }
              
              currentElement = currentElement.parentNode;
          }
          
          return (/\bneedsclick\b/).test(target.className);
      };
  
  
      /**
       * Determine whether a given element requires a call to focus to simulate click into element.
       *
       * @param {EventTarget|Element} target Target DOM element
       * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
       */
      FastClick.prototype.needsFocus = function(target) {
          switch (target.nodeName.toLowerCase()) {
          case 'textarea':
              return true;
          case 'select':
              return !deviceIsAndroid;
          case 'input':
              switch (target.type) {
              case 'button':
              case 'checkbox':
              case 'file':
              case 'image':
              case 'radio':
              case 'submit':
                  return false;
              }
  
              // No point in attempting to focus disabled inputs
              return !target.disabled && !target.readOnly;
          default:
              return (/\bneedsfocus\b/).test(target.className);
          }
      };
  
  
      /**
       * Send a click event to the specified element.
       *
       * @param {EventTarget|Element} targetElement
       * @param {Event} event
       */
      FastClick.prototype.sendClick = function(targetElement, event) {
          var clickEvent, touch;
  
          // On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
          if (document.activeElement && document.activeElement !== targetElement) {
              document.activeElement.blur();
          }
  
          touch = event.changedTouches[0];
          //console.log('test click');
  
          // Synthesise a click event, with an extra attribute so it can be tracked
          clickEvent = document.createEvent('MouseEvents');
          clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
          clickEvent.forwardedTouchEvent = true;
          targetElement.dispatchEvent(clickEvent);
      };
  
      FastClick.prototype.determineEventType = function(targetElement) {
  
          //Issue #159: Android Chrome Select Box does not open with a synthetic click event
          if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
              return 'mousedown';
          }
  
          return 'click';
      };
  
  
      /**
       * @param {EventTarget|Element} targetElement
       */
      FastClick.prototype.focus = function(targetElement) {
          var length;
  
          // Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
          if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
              length = targetElement.value.length;
              targetElement.setSelectionRange(length, length);
          } else {
              targetElement.focus();
          }
      };
  
  
      /**
       * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
       *
       * @param {EventTarget|Element} targetElement
       */
      FastClick.prototype.updateScrollParent = function(targetElement) {
          var scrollParent, parentElement;
  
          scrollParent = targetElement.fastClickScrollParent;
  
          // Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
          // target element was moved to another parent.
          if (!scrollParent || !scrollParent.contains(targetElement)) {
              parentElement = targetElement;
              do {
                  if (parentElement.scrollHeight > parentElement.offsetHeight) {
                      scrollParent = parentElement;
                      targetElement.fastClickScrollParent = parentElement;
                      break;
                  }
  
                  parentElement = parentElement.parentElement;
              } while (parentElement);
          }
  
          // Always update the scroll top tracker if possible.
          if (scrollParent) {
              scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
          }
      };
  
  
      /**
       * @param {EventTarget} targetElement
       * @returns {Element|EventTarget}
       */
      FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
  
          // On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
          if (eventTarget.nodeType === Node.TEXT_NODE) {
              return eventTarget.parentNode;
          }
  
          return eventTarget;
      };
  
  
      /**
       * On touch start, record the position and scroll offset.
       *
       * @param {Event} event
       * @returns {boolean}
       */
      FastClick.prototype.onTouchStart = function(event) {
          var targetElement, touch, selection;
  
          // Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
          if (event.targetTouches.length > 1) {
              return true;
          }
  
          targetElement = this.getTargetElementFromEventTarget(event.target);
          touch = event.targetTouches[0];
  
          if (deviceIsIOS) {
  
              // Only trusted events will deselect text on iOS (issue #49)
              selection = window.getSelection();
              if (selection.rangeCount && !selection.isCollapsed) {
                  return true;
              }
  
              if (!deviceIsIOS4) {
  
                  // Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
                  // when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
                  // with the same identifier as the touch event that previously triggered the click that triggered the alert.
                  // Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
                  // immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
                  // Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
                  // which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
                  // random integers, it's safe to to continue if the identifier is 0 here.
                  if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
                      event.preventDefault();
                      return false;
                  }
  
                  this.lastTouchIdentifier = touch.identifier;
  
                  // If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
                  // 1) the user does a fling scroll on the scrollable layer
                  // 2) the user stops the fling scroll with another tap
                  // then the event.target of the last 'touchend' event will be the element that was under the user's finger
                  // when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
                  // is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
                  this.updateScrollParent(targetElement);
              }
          }
  
          this.trackingClick = true;
          this.trackingClickStart = event.timeStamp;
          this.targetElement = targetElement;
  
          this.touchStartX = touch.pageX;
          this.touchStartY = touch.pageY;
  
          // Prevent phantom clicks on fast double-tap (issue #36)
          if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
              event.preventDefault();
          }
  
          return true;
      };
  
  
      /**
       * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
       *
       * @param {Event} event
       * @returns {boolean}
       */
      FastClick.prototype.touchHasMoved = function(event) {
          var touch = event.changedTouches[0], boundary = this.touchBoundary;
  
          if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
              return true;
          }
  
          return false;
      };
  
  
      /**
       * Update the last position.
       *
       * @param {Event} event
       * @returns {boolean}
       */
      FastClick.prototype.onTouchMove = function(event) {
          if (!this.trackingClick) {
              return true;
          }
  
          // If the touch has moved, cancel the click tracking
          if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
              this.trackingClick = false;
              this.targetElement = null;
          }
  
          return true;
      };
  
  
      /**
       * Attempt to find the labelled control for the given label element.
       *
       * @param {EventTarget|HTMLLabelElement} labelElement
       * @returns {Element|null}
       */
      FastClick.prototype.findControl = function(labelElement) {
  
          // Fast path for newer browsers supporting the HTML5 control attribute
          if (labelElement.control !== undefined) {
              return labelElement.control;
          }
  
          // All browsers under test that support touch events also support the HTML5 htmlFor attribute
          if (labelElement.htmlFor) {
              return document.getElementById(labelElement.htmlFor);
          }
  
          // If no for attribute exists, attempt to retrieve the first labellable descendant element
          // the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
          return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
      };
  
  
      /**
       * On touch end, determine whether to send a click event at once.
       *
       * @param {Event} event
       * @returns {boolean}
       */
      FastClick.prototype.onTouchEnd = function(event) {
          var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;
  
          if (!this.trackingClick) {
              return true;
          }
  
          // Prevent phantom clicks on fast double-tap (issue #36)
          if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
              this.cancelNextClick = true;
              return true;
          }
  
          if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
              return true;
          }
  
          // Reset to prevent wrong click cancel on input (issue #156).
          this.cancelNextClick = false;
  
          this.lastClickTime = event.timeStamp;
  
          trackingClickStart = this.trackingClickStart;
          this.trackingClick = false;
          this.trackingClickStart = 0;
  
          // On some iOS devices, the targetElement supplied with the event is invalid if the layer
          // is performing a transition or scroll, and has to be re-detected manually. Note that
          // for this to function correctly, it must be called *after* the event target is checked!
          // See issue #57; also filed as rdar://13048589 .
          if (deviceIsIOSWithBadTarget) {
              touch = event.changedTouches[0];
  
              // In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
              targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
              targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
          }
  
          targetTagName = targetElement.tagName.toLowerCase();
          if (targetTagName === 'label') {
              forElement = this.findControl(targetElement);
              if (forElement) {
                  this.focus(targetElement);
                  if (deviceIsAndroid) {
                      return false;
                  }
  
                  targetElement = forElement;
              }
          } else if (this.needsFocus(targetElement)) {
  
              // Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
              // Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
              if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
                  this.targetElement = null;
                  return false;
              }
  
              this.focus(targetElement);
              this.sendClick(targetElement, event);
  
              // Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
              // Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
              if (!deviceIsIOS || targetTagName !== 'select') {
                  this.targetElement = null;
                  event.preventDefault();
              }
  
              return false;
          }
  
          if (deviceIsIOS && !deviceIsIOS4) {
  
              // Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
              // and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
              scrollParent = targetElement.fastClickScrollParent;
              if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
                  return true;
              }
          }
  
          // Prevent the actual click from going though - unless the target node is marked as requiring
          // real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
          if (!this.needsClick(targetElement)) {
              event.preventDefault();
              this.sendClick(targetElement, event);
          }
  
          return false;
      };
  
  
      /**
       * On touch cancel, stop tracking the click.
       *
       * @returns {void}
       */
      FastClick.prototype.onTouchCancel = function() {
          this.trackingClick = false;
          this.targetElement = null;
      };
  
  
      /**
       * Determine mouse events which should be permitted.
       *
       * @param {Event} event
       * @returns {boolean}
       */
      FastClick.prototype.onMouse = function(event) {
  
          // If a target element was never set (because a touch event was never fired) allow the event
          if (!this.targetElement) {
              return true;
          }
  
          if (event.forwardedTouchEvent) {
              return true;
          }
  
          // Programmatically generated events targeting a specific element should be permitted
          if (!event.cancelable) {
              return true;
          }
  
          // Derive and check the target element to see whether the mouse event needs to be permitted;
          // unless explicitly enabled, prevent non-touch click events from triggering actions,
          // to prevent ghost/doubleclicks.
          if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
  
              // Prevent any user-added listeners declared on FastClick element from being fired.
              if (event.stopImmediatePropagation) {
                  event.stopImmediatePropagation();
              } else {
  
                  // Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
                  event.propagationStopped = true;
              }
  
              // Cancel the event
              event.stopPropagation();
              event.preventDefault();
  
              return false;
          }
  
          // If the mouse event is permitted, return true for the action to go through.
          return true;
      };
  
  
      /**
       * On actual clicks, determine whether this is a touch-generated click, a click action occurring
       * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
       * an actual click which should be permitted.
       *
       * @param {Event} event
       * @returns {boolean}
       */
      FastClick.prototype.onClick = function(event) {
          var permitted;
  
          // It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
          if (this.trackingClick) {
              this.targetElement = null;
              this.trackingClick = false;
              return true;
          }
  
          // Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
          if (event.target.type === 'submit' && event.detail === 0) {
              return true;
          }
  
          permitted = this.onMouse(event);
  
          // Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
          if (!permitted) {
              this.targetElement = null;
          }
  
          // If clicks are permitted, return true for the action to go through.
          return permitted;
      };
  
  
      /**
       * Remove all FastClick's event listeners.
       *
       * @returns {void}
       */
      FastClick.prototype.destroy = function() {
          var layer = this.layer;
  
          if (deviceIsAndroid) {
              layer.removeEventListener('mouseover', this.onMouse, true);
              layer.removeEventListener('mousedown', this.onMouse, true);
              layer.removeEventListener('mouseup', this.onMouse, true);
          }
  
          layer.removeEventListener('click', this.onClick, true);
          layer.removeEventListener('touchstart', this.onTouchStart, false);
          layer.removeEventListener('touchmove', this.onTouchMove, false);
          layer.removeEventListener('touchend', this.onTouchEnd, false);
          layer.removeEventListener('touchcancel', this.onTouchCancel, false);
      };
  
  
      /**
       * Check whether FastClick is needed.
       *
       * @param {Element} layer The layer to listen on
       */
      FastClick.notNeeded = function(layer) {
          var metaViewport;
          var chromeVersion;
          var blackberryVersion;
  
          // Devices that don't support touch don't need FastClick
          if (typeof window.ontouchstart === 'undefined') {
              return true;
          }
  
          // Chrome version - zero for other browsers
          chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];
  
          if (chromeVersion) {
  
              if (deviceIsAndroid) {
                  metaViewport = document.querySelector('meta[name=viewport]');
  
                  if (metaViewport) {
                      // Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
                      if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
                          return true;
                      }
                      // Chrome 32 and above with width=device-width or less don't need FastClick
                      if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
                          return true;
                      }
                  }
  
              // Chrome desktop doesn't need FastClick (issue #15)
              } else {
                  return true;
              }
          }
  
          if (deviceIsBlackBerry10) {
              blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);
  
              // BlackBerry 10.3+ does not require Fastclick library.
              // https://github.com/ftlabs/fastclick/issues/251
              if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
                  metaViewport = document.querySelector('meta[name=viewport]');
  
                  if (metaViewport) {
                      // user-scalable=no eliminates click delay.
                      if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
                          return true;
                      }
                      // width=device-width (or less than device-width) eliminates click delay.
                      if (document.documentElement.scrollWidth <= window.outerWidth) {
                          return true;
                      }
                  }
              }
          }
  
          // IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
          if (layer.style.msTouchAction === 'none') {
              return true;
          }
  
          // IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
          // http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
          if (layer.style.touchAction === 'none') {
              return true;
          }
  
          return false;
      };
  
  
      /**
       * Factory method for creating a FastClick object
       *
       * @param {Element} layer The layer to listen on
       * @param {Object} [options={}] The options to override the defaults
       */
      FastClick.attach = function(layer, options) {
          return new FastClick(layer, options);
      };
  
  
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
  
          // AMD. Register as an anonymous module.
          define(function() {
              return FastClick;
          });
      } else if (typeof module !== 'undefined' && module.exports) {
          module.exports = FastClick.attach;
          module.exports.FastClick = FastClick;
      }// else {
      
      window.FastClick = FastClick;
      //}
  }());
  
  
  
  //(function () {
  //	'use strict';
  //
  //	/**
  //	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
  //	 *
  //	 * @codingstandard ftlabs-jsv2
  //	 * @copyright The Financial Times Limited [All Rights Reserved]
  //	 * @license MIT License (see LICENSE.txt)
  //	 */
  //
  //	/*jslint browser:true, node:true*/
  //	/*global define, Event, Node*/
  //
  //
  //	/**
  //	 * Instantiate fast-clicking listeners on the specified layer.
  //	 *
  //	 * @constructor
  //	 * @param {Element} layer The layer to listen on
  //	 * @param {Object} [options={}] The options to override the defaults
  //	 */
  //	function FastClick(layer, options) {
  //		var oldOnClick;
  //
  //		options = options || {};
  //
  //		/**
  //		 * Whether a click is currently being tracked.
  //		 *
  //		 * @type boolean
  //		 */
  //		this.trackingClick = false;
  //
  //
  //		/**
  //		 * Timestamp for when click tracking started.
  //		 *
  //		 * @type number
  //		 */
  //		this.trackingClickStart = 0;
  //
  //
  //		/**
  //		 * The element being tracked for a click.
  //		 *
  //		 * @type EventTarget
  //		 */
  //		this.targetElement = null;
  //
  //
  //		/**
  //		 * X-coordinate of touch start event.
  //		 *
  //		 * @type number
  //		 */
  //		this.touchStartX = 0;
  //
  //
  //		/**
  //		 * Y-coordinate of touch start event.
  //		 *
  //		 * @type number
  //		 */
  //		this.touchStartY = 0;
  //
  //
  //		/**
  //		 * ID of the last touch, retrieved from Touch.identifier.
  //		 *
  //		 * @type number
  //		 */
  //		this.lastTouchIdentifier = 0;
  //
  //
  //		/**
  //		 * Touchmove boundary, beyond which a click will be cancelled.
  //		 *
  //		 * @type number
  //		 */
  //		this.touchBoundary = options.touchBoundary || 10;
  //
  //
  //		/**
  //		 * The FastClick layer.
  //		 *
  //		 * @type Element
  //		 */
  //		this.layer = layer;
  //
  //		/**
  //		 * The minimum time between tap(touchstart and touchend) events
  //		 *
  //		 * @type number
  //		 */
  //		this.tapDelay = options.tapDelay || 200;
  //
  //		/**
  //		 * The maximum time for a tap
  //		 *
  //		 * @type number
  //		 */
  //		this.tapTimeout = options.tapTimeout || 700;
  //
  //		if (FastClick.notNeeded(layer)) {
  //			return;
  //		}
  //
  //		// Some old versions of Android don't have Function.prototype.bind
  //		function bind(method, context) {
  //			return function() { return method.apply(context, arguments); };
  //		}
  //
  //
  //		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
  //		var context = this;
  //		for (var i = 0, l = methods.length; i < l; i++) {
  //			context[methods[i]] = bind(context[methods[i]], context);
  //		}
  //
  //		// Set up event handlers as required
  //		if (deviceIsAndroid) {
  //			layer.addEventListener('mouseover', this.onMouse, true);
  //			layer.addEventListener('mousedown', this.onMouse, true);
  //			layer.addEventListener('mouseup', this.onMouse, true);
  //		}
  //
  //		layer.addEventListener('click', this.onClick, true);
  //		layer.addEventListener('touchstart', this.onTouchStart, false);
  //		layer.addEventListener('touchmove', this.onTouchMove, false);
  //		layer.addEventListener('touchend', this.onTouchEnd, false);
  //		layer.addEventListener('touchcancel', this.onTouchCancel, false);
  //
  //		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
  //		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
  //		// layer when they are cancelled.
  //		if (!Event.prototype.stopImmediatePropagation) {
  //			layer.removeEventListener = function(type, callback, capture) {
  //				var rmv = Node.prototype.removeEventListener;
  //				if (type === 'click') {
  //					rmv.call(layer, type, callback.hijacked || callback, capture);
  //				} else {
  //					rmv.call(layer, type, callback, capture);
  //				}
  //			};
  //
  //			layer.addEventListener = function(type, callback, capture) {
  //				var adv = Node.prototype.addEventListener;
  //				if (type === 'click') {
  //					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
  //						if (!event.propagationStopped) {
  //							callback(event);
  //						}
  //					}), capture);
  //				} else {
  //					adv.call(layer, type, callback, capture);
  //				}
  //			};
  //		}
  //
  //		// If a handler is already declared in the element's onclick attribute, it will be fired before
  //		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
  //		// adding it as listener.
  //		if (typeof layer.onclick === 'function') {
  //
  //			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
  //			// - the old one won't work if passed to addEventListener directly.
  //			oldOnClick = layer.onclick;
  //			layer.addEventListener('click', function(event) {
  //				oldOnClick(event);
  //			}, false);
  //			layer.onclick = null;
  //		}
  //	}
  //
  //	/**
  //	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
  //	*
  //	* @type boolean
  //	*/
  //	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;
  //
  //	/**
  //	 * Android requires exceptions.
  //	 *
  //	 * @type boolean
  //	 */
  //	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;
  //
  //
  //	/**
  //	 * iOS requires exceptions.
  //	 *
  //	 * @type boolean
  //	 */
  //	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;
  //
  //
  //	/**
  //	 * iOS 4 requires an exception for select elements.
  //	 *
  //	 * @type boolean
  //	 */
  //	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);
  //
  //
  //	/**
  //	 * iOS 6.0-7.* requires the target element to be manually derived
  //	 *
  //	 * @type boolean
  //	 */
  //	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);
  //
  //	/**
  //	 * BlackBerry requires exceptions.
  //	 *
  //	 * @type boolean
  //	 */
  //	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;
  //
  //	/**
  //	 * Determine whether a given element requires a native click.
  //	 *
  //	 * @param {EventTarget|Element} target Target DOM element
  //	 * @returns {boolean} Returns true if the element needs a native click
  //	 */
  //	FastClick.prototype.needsClick = function(target) {
  //		switch (target.nodeName.toLowerCase()) {
  //
  //		// Don't send a synthetic click to disabled inputs (issue #62)
  //		case 'button':
  //		case 'select':
  //		case 'textarea':
  //			if (target.disabled) {
  //				return true;
  //			}
  //
  //			break;
  //		case 'input':
  //
  //			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
  //			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
  //				return true;
  //			}
  //
  //			break;
  //		case 'label':
  //		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
  //		case 'video':
  //			return true;
  //		}
  //
  //		return (/\bneedsclick\b/).test(target.className);
  //	};
  //
  //
  //	/**
  //	 * Determine whether a given element requires a call to focus to simulate click into element.
  //	 *
  //	 * @param {EventTarget|Element} target Target DOM element
  //	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
  //	 */
  //	FastClick.prototype.needsFocus = function(target) {
  //		switch (target.nodeName.toLowerCase()) {
  //		case 'textarea':
  //			return true;
  //		case 'select':
  //			return !deviceIsAndroid;
  //		case 'input':
  //			switch (target.type) {
  //			case 'button':
  //			case 'checkbox':
  //			case 'file':
  //			case 'image':
  //			case 'radio':
  //			case 'submit':
  //				return false;
  //			}
  //
  //			// No point in attempting to focus disabled inputs
  //			return !target.disabled && !target.readOnly;
  //		default:
  //			return (/\bneedsfocus\b/).test(target.className);
  //		}
  //	};
  //
  //
  //	/**
  //	 * Send a click event to the specified element.
  //	 *
  //	 * @param {EventTarget|Element} targetElement
  //	 * @param {Event} event
  //	 */
  //	FastClick.prototype.sendClick = function(targetElement, event) {
  //		var clickEvent, touch;
  //        
  //		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
  //		if (document.activeElement && document.activeElement !== targetElement) {
  //			document.activeElement.blur();
  //		}
  //
  //		touch = event.changedTouches[0];
  //
  //		// Synthesise a click event, with an extra attribute so it can be tracked
  //		clickEvent = document.createEvent('MouseEvents');
  //		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
  //		clickEvent.forwardedTouchEvent = true;
  //		targetElement.dispatchEvent(clickEvent);
  //	};
  //
  //	FastClick.prototype.determineEventType = function(targetElement) {
  //
  //		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
  //		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
  //			return 'mousedown';
  //		}
  //
  //		return 'click';
  //	};
  //
  //
  //	/**
  //	 * @param {EventTarget|Element} targetElement
  //	 */
  //	FastClick.prototype.focus = function(targetElement) {
  //		var length;
  //
  //		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
  //		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && //targetElement.type !== 'month') {
  //			length = targetElement.value.length;
  //			targetElement.setSelectionRange(length, length);
  //		} else {
  //			targetElement.focus();
  //		}
  //	};
  //
  //
  //	/**
  //	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
  //	 *
  //	 * @param {EventTarget|Element} targetElement
  //	 */
  //	FastClick.prototype.updateScrollParent = function(targetElement) {
  //		var scrollParent, parentElement;
  //
  //		scrollParent = targetElement.fastClickScrollParent;
  //
  //		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
  //		// target element was moved to another parent.
  //		if (!scrollParent || !scrollParent.contains(targetElement)) {
  //			parentElement = targetElement;
  //			do {
  //				if (parentElement.scrollHeight > parentElement.offsetHeight) {
  //					scrollParent = parentElement;
  //					targetElement.fastClickScrollParent = parentElement;
  //					break;
  //				}
  //
  //				parentElement = parentElement.parentElement;
  //			} while (parentElement);
  //		}
  //
  //		// Always update the scroll top tracker if possible.
  //		if (scrollParent) {
  //			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
  //		}
  //	};
  //
  //
  //	/**
  //	 * @param {EventTarget} targetElement
  //	 * @returns {Element|EventTarget}
  //	 */
  //	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
  //
  //		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
  //		if (eventTarget.nodeType === Node.TEXT_NODE) {
  //			return eventTarget.parentNode;
  //		}
  //
  //		return eventTarget;
  //	};
  //
  //
  //	/**
  //	 * On touch start, record the position and scroll offset.
  //	 *
  //	 * @param {Event} event
  //	 * @returns {boolean}
  //	 */
  //	FastClick.prototype.onTouchStart = function(event) {
  //		var targetElement, touch, selection;
  //
  //		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
  //		if (event.targetTouches.length > 1) {
  //			return true;
  //		}
  //
  //		targetElement = this.getTargetElementFromEventTarget(event.target);
  //		touch = event.targetTouches[0];
  //
  //		if (deviceIsIOS) {
  //
  //			// Only trusted events will deselect text on iOS (issue #49)
  //			selection = window.getSelection();
  //			if (selection.rangeCount && !selection.isCollapsed) {
  //				return true;
  //			}
  //
  //			if (!deviceIsIOS4) {
  //
  //				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
  //				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
  //				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
  //				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
  //				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
  //				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
  //				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
  //				// random integers, it's safe to to continue if the identifier is 0 here.
  //				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
  //					event.preventDefault();
  //					return false;
  //				}
  //
  //				this.lastTouchIdentifier = touch.identifier;
  //
  //				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
  //				// 1) the user does a fling scroll on the scrollable layer
  //				// 2) the user stops the fling scroll with another tap
  //				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
  //				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
  //				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
  //				this.updateScrollParent(targetElement);
  //			}
  //		}
  //
  //		this.trackingClick = true;
  //		this.trackingClickStart = event.timeStamp;
  //		this.targetElement = targetElement;
  //
  //		this.touchStartX = touch.pageX;
  //		this.touchStartY = touch.pageY;
  //
  //		// Prevent phantom clicks on fast double-tap (issue #36)
  //		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
  //			event.preventDefault();
  //		}
  //
  //		return true;
  //	};
  //
  //
  //	/**
  //	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
  //	 *
  //	 * @param {Event} event
  //	 * @returns {boolean}
  //	 */
  //	FastClick.prototype.touchHasMoved = function(event) {
  //		var touch = event.changedTouches[0], boundary = this.touchBoundary;
  //
  //		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
  //			return true;
  //		}
  //
  //		return false;
  //	};
  //
  //
  //	/**
  //	 * Update the last position.
  //	 *
  //	 * @param {Event} event
  //	 * @returns {boolean}
  //	 */
  //	FastClick.prototype.onTouchMove = function(event) {
  //		if (!this.trackingClick) {
  //			return true;
  //		}
  //
  //		// If the touch has moved, cancel the click tracking
  //		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
  //			this.trackingClick = false;
  //			this.targetElement = null;
  //		}
  //
  //		return true;
  //	};
  //
  //
  //	/**
  //	 * Attempt to find the labelled control for the given label element.
  //	 *
  //	 * @param {EventTarget|HTMLLabelElement} labelElement
  //	 * @returns {Element|null}
  //	 */
  //	FastClick.prototype.findControl = function(labelElement) {
  //
  //		// Fast path for newer browsers supporting the HTML5 control attribute
  //		if (labelElement.control !== undefined) {
  //			return labelElement.control;
  //		}
  //
  //		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
  //		if (labelElement.htmlFor) {
  //			return document.getElementById(labelElement.htmlFor);
  //		}
  //
  //		// If no for attribute exists, attempt to retrieve the first labellable descendant element
  //		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
  //		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
  //	};
  //
  //
  //	/**
  //	 * On touch end, determine whether to send a click event at once.
  //	 *
  //	 * @param {Event} event
  //	 * @returns {boolean}
  //	 */
  //	FastClick.prototype.onTouchEnd = function(event) {
  //		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;
  //        
  //        //console.trace('TRACE');
  //        
  //		if (!this.trackingClick) {
  //			return true;
  //		}
  //
  //		// Prevent phantom clicks on fast double-tap (issue #36)
  //		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
  //			this.cancelNextClick = true;
  //			return true;
  //		}
  //
  //		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
  //			return true;
  //		}
  //
  //		// Reset to prevent wrong click cancel on input (issue #156).
  //		this.cancelNextClick = false;
  //
  //		this.lastClickTime = event.timeStamp;
  //
  //		trackingClickStart = this.trackingClickStart;
  //		this.trackingClick = false;
  //		this.trackingClickStart = 0;
  //
  //		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
  //		// is performing a transition or scroll, and has to be re-detected manually. Note that
  //		// for this to function correctly, it must be called *after* the event target is checked!
  //		// See issue #57; also filed as rdar://13048589 .
  //		if (deviceIsIOSWithBadTarget) {
  //			touch = event.changedTouches[0];
  //
  //			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
  //			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
  //			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
  //		}
  //
  //		targetTagName = targetElement.tagName.toLowerCase();
  //		if (targetTagName === 'label') {
  //			forElement = this.findControl(targetElement);
  //			if (forElement) {
  //				this.focus(targetElement);
  //				if (deviceIsAndroid) {
  //					return false;
  //				}
  //
  //				targetElement = forElement;
  //			}
  //		} else if (this.needsFocus(targetElement)) {
  //
  //			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
  //			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
  //			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
  //				this.targetElement = null;
  //				return false;
  //			}
  //
  //			this.focus(targetElement);
  //			this.sendClick(targetElement, event);
  //
  //			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
  //			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
  //			if (!deviceIsIOS || targetTagName !== 'select') {
  //				this.targetElement = null;
  //				event.preventDefault();
  //			}
  //
  //			return false;
  //		}
  //
  //		if (deviceIsIOS && !deviceIsIOS4) {
  //
  //			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
  //			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
  //			scrollParent = targetElement.fastClickScrollParent;
  //			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
  //				return true;
  //			}
  //		}
  //
  //		// Prevent the actual click from going though - unless the target node is marked as requiring
  //		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
  //		if (!this.needsClick(targetElement)) {
  //			event.preventDefault();
  //			this.sendClick(targetElement, event);
  //		}
  //
  //		return false;
  //	};
  //
  //
  //	/**
  //	 * On touch cancel, stop tracking the click.
  //	 *
  //	 * @returns {void}
  //	 */
  //	FastClick.prototype.onTouchCancel = function() {
  //		this.trackingClick = false;
  //		this.targetElement = null;
  //	};
  //
  //
  //	/**
  //	 * Determine mouse events which should be permitted.
  //	 *
  //	 * @param {Event} event
  //	 * @returns {boolean}
  //	 */
  //	FastClick.prototype.onMouse = function(event) {
  //
  //		// If a target element was never set (because a touch event was never fired) allow the event
  //		if (!this.targetElement) {
  //			return true;
  //		}
  //
  //		if (event.forwardedTouchEvent) {
  //			return true;
  //		}
  //
  //		// Programmatically generated events targeting a specific element should be permitted
  //		if (!event.cancelable) {
  //			return true;
  //		}
  //
  //		// Derive and check the target element to see whether the mouse event needs to be permitted;
  //		// unless explicitly enabled, prevent non-touch click events from triggering actions,
  //		// to prevent ghost/doubleclicks.
  //		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
  //
  //			// Prevent any user-added listeners declared on FastClick element from being fired.
  //			if (event.stopImmediatePropagation) {
  //				event.stopImmediatePropagation();
  //			} else {
  //
  //				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
  //				event.propagationStopped = true;
  //			}
  //
  //			// Cancel the event
  //			event.stopPropagation();
  //			event.preventDefault();
  //
  //			return false;
  //		}
  //
  //		// If the mouse event is permitted, return true for the action to go through.
  //		return true;
  //	};
  //
  //
  //	/**
  //	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
  //	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
  //	 * an actual click which should be permitted.
  //	 *
  //	 * @param {Event} event
  //	 * @returns {boolean}
  //	 */
  //	FastClick.prototype.onClick = function(event) {
  //		var permitted;
  //        
  //		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
  //		if (this.trackingClick) {
  //			this.targetElement = null;
  //			this.trackingClick = false;
  //			return true;
  //		}
  //        
  //		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
  //		if (event.target.type === 'submit' && event.detail === 0) {
  //			return true;
  //		}
  //        
  //		permitted = this.onMouse(event);
  //        
  //		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the //browser's click doesn't go through.
  //		if (!permitted) {
  //			this.targetElement = null;
  //		}
  //        
  //		// If clicks are permitted, return true for the action to go through.
  //		return permitted;
  //	};
  //
  //
  //	/**
  //	 * Remove all FastClick's event listeners.
  //	 *
  //	 * @returns {void}
  //	 */
  //	FastClick.prototype.destroy = function() {
  //		var layer = this.layer;
  //
  //		if (deviceIsAndroid) {
  //			layer.removeEventListener('mouseover', this.onMouse, true);
  //			layer.removeEventListener('mousedown', this.onMouse, true);
  //			layer.removeEventListener('mouseup', this.onMouse, true);
  //		}
  //
  //		layer.removeEventListener('click', this.onClick, true);
  //		layer.removeEventListener('touchstart', this.onTouchStart, false);
  //		layer.removeEventListener('touchmove', this.onTouchMove, false);
  //		layer.removeEventListener('touchend', this.onTouchEnd, false);
  //		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
  //	};
  //
  //
  //	/**
  //	 * Check whether FastClick is needed.
  //	 *
  //	 * @param {Element} layer The layer to listen on
  //	 */
  //	FastClick.notNeeded = function(layer) {
  //		var metaViewport;
  //		var chromeVersion;
  //		var blackberryVersion;
  //		var firefoxVersion;
  //
  //		// Devices that don't support touch don't need FastClick
  //		if (typeof window.ontouchstart === 'undefined') {
  //			return true;
  //		}
  //
  //		// Chrome version - zero for other browsers
  //		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];
  //
  //		if (chromeVersion) {
  //
  //			if (deviceIsAndroid) {
  //				metaViewport = document.querySelector('meta[name=viewport]');
  //
  //				if (metaViewport) {
  //					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
  //					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
  //						return true;
  //					}
  //					// Chrome 32 and above with width=device-width or less don't need FastClick
  //					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
  //						return true;
  //					}
  //				}
  //
  //			// Chrome desktop doesn't need FastClick (issue #15)
  //			} else {
  //				return true;
  //			}
  //		}
  //
  //		if (deviceIsBlackBerry10) {
  //			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);
  //
  //			// BlackBerry 10.3+ does not require Fastclick library.
  //			// https://github.com/ftlabs/fastclick/issues/251
  //			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
  //				metaViewport = document.querySelector('meta[name=viewport]');
  //
  //				if (metaViewport) {
  //					// user-scalable=no eliminates click delay.
  //					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
  //						return true;
  //					}
  //					// width=device-width (or less than device-width) eliminates click delay.
  //					if (document.documentElement.scrollWidth <= window.outerWidth) {
  //						return true;
  //					}
  //				}
  //			}
  //		}
  //
  //		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
  //		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
  //			return true;
  //		}
  //
  //		// Firefox version - zero for other browsers
  //		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];
  //
  //		if (firefoxVersion >= 27) {
  //			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896
  //
  //			metaViewport = document.querySelector('meta[name=viewport]');
  //			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
  //				return true;
  //			}
  //		}
  //
  //		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
  //		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
  //		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
  //			return true;
  //		}
  //
  //		return false;
  //	};
  //
  //
  //	/**
  //	 * Factory method for creating a FastClick object
  //	 *
  //	 * @param {Element} layer The layer to listen on
  //	 * @param {Object} [options={}] The options to override the defaults
  //	 */
  //	FastClick.attach = function(layer, options) {
  //		return new FastClick(layer, options);
  //	};
  //
  //
  //	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
  //
  //		// AMD. Register as an anonymous module.
  //		define(function() {
  //			return FastClick;
  //		});
  //	} else if (typeof module !== 'undefined' && module.exports) {
  //		module.exports = FastClick.attach;
  //		module.exports.FastClick = FastClick;
  //	} else {
  //		window.FastClick = FastClick;
  //	}
  //}());
  
  
  
  
  /*
      json_parse.js
      2012-06-20
  
      Public Domain.
  
      NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
  
      This file creates a json_parse function.
  
          json_parse(text, reviver)
              This method parses a JSON text to produce an object or array.
              It can throw a SyntaxError exception.
  
              The optional reviver parameter is a function that can filter and
              transform the results. It receives each of the keys and values,
              and its return value is used instead of the original value.
              If it returns what it received, then the structure is not modified.
              If it returns undefined then the member is deleted.
  
              Example:
  
              // Parse the text. Values that look like ISO date strings will
              // be converted to Date objects.
  
              myData = json_parse(text, function (key, value) {
                  var a;
                  if (typeof value === 'string') {
                      a =
  /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                      if (a) {
                          return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                              +a[5], +a[6]));
                      }
                  }
                  return value;
              });
  
      This is a reference implementation. You are free to copy, modify, or
      redistribute.
  
      This code should be minified before deployment.
      See http://javascript.crockford.com/jsmin.html
  
      USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
      NOT CONTROL.
  */
  
  /*members "", "\"", "\/", "\\", at, b, call, charAt, f, fromCharCode,
      hasOwnProperty, message, n, name, prototype, push, r, t, text
  */
  
  
  window.JSON = window.JSON || {};
  
  window.JSON.parse = (function () {
      "use strict";
  
  // This is a function that can parse a JSON text, producing a JavaScript
  // data structure. It is a simple, recursive descent parser. It does not use
  // eval or regular expressions, so it can be used as a model for implementing
  // a JSON parser in other languages.
  
  // We are defining the function inside of another function to avoid creating
  // global variables.
  
      var at,     // The index of the current character
          ch,     // The current character
          escapee = {
              '"':  '"',
              '\\': '\\',
              '/':  '/',
              b:    '\b',
              f:    '\f',
              n:    '\n',
              r:    '\r',
              t:    '\t'
          },
          text,
  
          error = function (m) {
  
  // Call error when something is wrong.
  
              throw {
                  name:    'SyntaxError',
                  message: m,
                  at:      at,
                  text:    text
              };
          },
  
          next = function (c) {
  
  // If a c parameter is provided, verify that it matches the current character.
  
              if (c && c !== ch) {
                  error("Expected '" + c + "' instead of '" + ch + "'");
              }
  
  // Get the next character. When there are no more characters,
  // return the empty string.
  
              ch = text.charAt(at);
              at += 1;
              return ch;
          },
  
          number = function () {
  
  // Parse a number value.
  
              var number,
                  string = '';
  
              if (ch === '-') {
                  string = '-';
                  next('-');
              }
              while (ch >= '0' && ch <= '9') {
                  string += ch;
                  next();
              }
              if (ch === '.') {
                  string += '.';
                  while (next() && ch >= '0' && ch <= '9') {
                      string += ch;
                  }
              }
              if (ch === 'e' || ch === 'E') {
                  string += ch;
                  next();
                  if (ch === '-' || ch === '+') {
                      string += ch;
                      next();
                  }
                  while (ch >= '0' && ch <= '9') {
                      string += ch;
                      next();
                  }
              }
              number = +string;
              if (!isFinite(number)) {
                  error("Bad number");
              } else {
                  return number;
              }
          },
  
          string = function () {
  
  // Parse a string value.
  
              var hex,
                  i,
                  string = '',
                  uffff;
  
  // When parsing for string values, we must look for " and \ characters.
  
              if (ch === '"') {
                  while (next()) {
                      if (ch === '"') {
                          next();
                          return string;
                      }
                      if (ch === '\\') {
                          next();
                          if (ch === 'u') {
                              uffff = 0;
                              for (i = 0; i < 4; i += 1) {
                                  hex = parseInt(next(), 16);
                                  if (!isFinite(hex)) {
                                      break;
                                  }
                                  uffff = uffff * 16 + hex;
                              }
                              string += String.fromCharCode(uffff);
                          } else if (typeof escapee[ch] === 'string') {
                              string += escapee[ch];
                          } else {
                              break;
                          }
                      } else {
                          string += ch;
                      }
                  }
              }
              error("Bad string");
          },
  
          white = function () {
  
  // Skip whitespace.
  
              while (ch && ch <= ' ') {
                  next();
              }
          },
  
          word = function () {
  
  // true, false, or null.
  
              switch (ch) {
              case 't':
                  next('t');
                  next('r');
                  next('u');
                  next('e');
                  return true;
              case 'f':
                  next('f');
                  next('a');
                  next('l');
                  next('s');
                  next('e');
                  return false;
              case 'n':
                  next('n');
                  next('u');
                  next('l');
                  next('l');
                  return null;
              }
              error("Unexpected '" + ch + "'");
          },
  
          value,  // Place holder for the value function.
  
          array = function () {
  
  // Parse an array value.
  
              var array = [];
  
              if (ch === '[') {
                  next('[');
                  white();
                  if (ch === ']') {
                      next(']');
                      return array;   // empty array
                  }
                  while (ch) {
                      array.push(value());
                      white();
                      if (ch === ']') {
                          next(']');
                          return array;
                      }
                      next(',');
                      white();
                  }
              }
              error("Bad array");
          },
  
          object = function () {
  
  // Parse an object value.
  
              var key,
                  object = {};
  
              if (ch === '{') {
                  next('{');
                  white();
                  if (ch === '}') {
                      next('}');
                      return object;   // empty object
                  }
                  while (ch) {
                      key = string();
                      white();
                      next(':');
                      if (Object.hasOwnProperty.call(object, key)) {
                          error('Duplicate key "' + key + '"');
                      }
                      object[key] = value();
                      white();
                      if (ch === '}') {
                          next('}');
                          return object;
                      }
                      next(',');
                      white();
                  }
              }
              error("Bad object");
          };
  
      value = function () {
  
  // Parse a JSON value. It could be an object, an array, a string, a number,
  // or a word.
  
          white();
          switch (ch) {
          case '{':
              return object();
          case '[':
              return array();
          case '"':
              return string();
          case '-':
              return number();
          default:
              return ch >= '0' && ch <= '9' ? number() : word();
          }
      };
  
  // Return the json_parse function. It will have access to all of the above
  // functions and variables.
  
      return function (source, reviver) {
          var result;
  
          text = source;
          at = 0;
          ch = ' ';
          result = value();
          white();
          if (ch) {
              error("Syntax error");
          }
  
  // If there is a reviver function, we recursively walk the new structure,
  // passing each name/value pair to the reviver function for possible
  // transformation, starting with a temporary root object that holds the result
  // in an empty key. If there is not a reviver function, we simply return the
  // result.
  
          return typeof reviver === 'function'
              ? (function walk(holder, key) {
                  var k, v, value = holder[key];
                  if (value && typeof value === 'object') {
                      for (k in value) {
                          if (Object.prototype.hasOwnProperty.call(value, k)) {
                              v = walk(value, k);
                              if (v !== undefined) {
                                  value[k] = v;
                              } else {
                                  delete value[k];
                              }
                          }
                      }
                  }
                  return reviver.call(holder, key, value);
              }({'': result}, ''))
              : result;
      };
  }());// ##############################################################
  // ################ doT.js AND RELATED FUNCTIONS ################
  // ##############################################################
  
  // Laura Doktorova https://github.com/olado/doT
  // version: 1.0.3
  (function(){function p(b,a,d){return("string"===typeof a?a:a.toString()).replace(b.define||h,function(a,c,e,g){0===c.indexOf("def.")&&(c=c.substring(4));c in d||(":"===e?(b.defineParams&&g.replace(b.defineParams,function(a,b,l){d[c]={arg:b,text:l}}),c in d||(d[c]=g)):(new Function("def","def['"+c+"']="+g))(d));return""}).replace(b.use||h,function(a,c){b.useParams&&(c=c.replace(b.useParams,function(a,b,c,l){if(d[c]&&d[c].arg&&l)return a=(c+":"+l).replace(/'|\\/g,"_"),d.__exp=d.__exp||{},d.__exp[a]=
  d[c].text.replace(new RegExp("(^|[^\\w$])"+d[c].arg+"([^\\w$])","g"),"$1"+l+"$2"),b+"def.__exp['"+a+"']"}));var e=(new Function("def","return "+c))(d);return e?p(b,e,d):e})}function k(b){return b.replace(/\\('|\\)/g,"$1").replace(/[\r\t\n]/g," ")}var f={version:"1.0.3",templateSettings:{evaluate:/\{\{([\s\S]+?(\}?)+)\}\}/g,interpolate:/\{\{=([\s\S]+?)\}\}/g,encode:/\{\{!([\s\S]+?)\}\}/g,use:/\{\{#([\s\S]+?)\}\}/g,useParams:/(^|[^\w$])def(?:\.|\[[\'\"])([\w$\.]+)(?:[\'\"]\])?\s*\:\s*([\w$\.]+|\"[^\"]+\"|\'[^\']+\'|\{[^\}]+\})/g,
  define:/\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,defineParams:/^\s*([\w$]+):([\s\S]+)/,conditional:/\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,iterate:/\{\{~\s*(?:\}\}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,varname:"it",strip:!0,append:!0,selfcontained:!1,doNotSkipEncoded:!1},template:void 0,compile:void 0},m;
  
  
  
  // f.encodeHTMLSource = function(b) {
  //         var a = {
  //                 "&": "&#38;",
  //                 "<": "&#60;",
  //                 ">": "&#62;",
  //                 '"': "&#34;",
  //                 "'": "&#39;",
  //                 "/": "&#47;"
  //             },
  //             d = b ? /[&<>"'\/]/g : /&(?!#?\w+;)|<|>|"|'|\//g;
  //         return function(b) {
  //                 return b ?
  
  f.encodeHTMLSource=function(b){var a={"&":"&#38;","<":"&#60;",">":"&#62;",'"':"&#34;","'":"&#39;","/":"&#47;"},d=b?/[&<>"'\/]/g:/&(?!#?\w+;)|<|>|"|'|\//g;return function(b){return b?
  b.toString().replace(d,function(b){return a[b]||b}):b}}; // replaced :"" with :b so that if you put a zero in encodehtml you get a zero out of encodehtml
  
  
  m=function(){return this||(0,eval)("this")}();
  
  "undefined"!==typeof module&&module.exports?module.exports=f:"function"===typeof define&&define.amd?define(function(){return f}):m.doT=f;
  
  
  
  var r={start:"'+(",end:")+'",startencode:"'+encodeHTML("},s={start:"';out+=(",end:");out+='",startencode:"';out+=encodeHTML("},h=/$^/;f.template=function(b,a,d){a=a||f.templateSettings;var n=a.append?r:s,c,e=0,g;b=a.use||a.define?p(a,b,d||{}):b;b=("var out='"+(a.strip?
  b.replace(/(^|\r|\n)\t* +| +\t*(\r|\n|$)/g," ").replace(/\r|\n|\t|\/\*[\s\S]*?\*\//g,""):b).replace(/'|\\/g,"\\$&").replace(a.interpolate||h,function(b,a){return n.start+k(a)+n.end}).replace(a.encode||h,function(b,a){c=!0;return n.startencode+k(a)+n.end}).replace(a.conditional||h,function(b,a,c){return a?c?"';}else if("+k(c)+"){out+='":"';}else{out+='":c?"';if("+k(c)+"){out+='":"';}out+='"}).replace(a.iterate||h,function(b,a,c,d){if(!a)return"';} } out+='";e+=1;g=d||"i"+e;a=k(a);return"';var arr"+
  e+"="+a+";if(arr"+e+"){var "+c+","+g+"=-1,l"+e+"=arr"+e+".length-1;while("+g+"<l"+e+"){"+c+"=arr"+e+"["+g+"+=1];out+='"}).replace(a.evaluate||h,function(a,b){return"';"+k(b)+"out+='"})+"';return out;").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r").replace(/(\s|;|\}|^|\{)out\+='';/g,"$1").replace(/\+''/g,"");c&&(a.selfcontained||!m||m._encodeHTML||(m._encodeHTML=f.encodeHTMLSource(a.doNotSkipEncoded)),b="var encodeHTML = typeof _encodeHTML !== 'undefined' ? _encodeHTML : ("+f.encodeHTMLSource.toString()+
  "("+(a.doNotSkipEncoded||"")+"));"+b);try{return new Function(a.varname,b)}catch(q){throw"undefined"!==typeof console&&console.log("Could not create a template function: "+b),q;}};f.compile=function(b,a){return f.template(b,null,a)}
  
  
      // we use doT.js in the global space, but sometimes module may be
      //      defined (electron defines module automatically) so we need to copy dot to
      //      the global namespace
      if (!window.doT) { // && window.module
          window.doT = f;
          
          //window.doT.encodeHTMLSource = module.exports.encodeHTMLSource;
          //window.doT.compile = module.exports.compile;
          //window.doT.templateSettings = module.exports.templateSettings;
          //window.doT.template = module.exports.template;
      }
  })();
  
  
  doT.templateSettings = {
      evaluate:    /\{\{([\s\S]+?)\}\}/g,
      interpolate: /\{\{=([\s\S]+?)\}\}/g,
      encode:      /\{\{!([\s\S]+?)\}\}/g,
      use:         /\{\{#([\s\S]+?)\}\}/g,
      define:      /\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,
      conditional: /\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,
      iterate:     /\{\{~\s*(?:}}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,
      varname: 'jo',
      strip: false,
      append: true,
      selfcontained: false
  };
  
  // html encoding function used by doT.js
  function encodeHTML(text) {
      'use strict';
      var encode = {
          "&": "&#38;",
          "<": "&#60;",
          ">": "&#62;",
          '"': "&#34;",
          "'": "&#39;",
          "/": "&#47;"
      };
      return text ? text.toString().replace(/&|<|>|"|'|\//g, function (letter) {
          return encode[letter] || letter;
      }) : text;
  }
  
  // html decoding function
  function decodeHTML(text) {
      'use strict';
      var decode = {
          "&#38;": "&",
          "&amp;": "&",
          
          "&#60;": "<",
          "&#62;": ">",
          
          "&lt;":  "<", // The rose by another name
          "&gt;":  ">", // The rose by another name
          
          "&#34;": '"',
          "&#39;": "'",
          "&#47;": "/"
      };
      return text ? text.toString().replace(/&#38;|&amp;|&#60;|&#62;|&lt;|&gt;|&#34;|&#39;|&#47;/g, function (letter) {
          return decode[letter] || letter;
      }) : text;
  }
  
  // multiline strings in javascript
  //
  // ml(function () {/*
  //     multiline string
  //     hey
  // */console.log});
  function ml(func) {
      'use strict';
      
      func = func.toString();
      
      return func.substring(func.indexOf('/*') + 2, func.indexOf('*/'));
  }
  //global window
  //jslint white:true multivar:true
  
  // #############################################################
  // ################### CROSS PLATFORM EVENTS ###################
  // #############################################################
  
  if (window.evt === undefined) {
      window.evt = {};
  }
  
  // function for testing if the device has touch capibilities
  function touchDeviceTest() {
      'use strict';
      //return 'ontouchstart' in window ||    // works on most browsers
      //       'onmsgesturechange' in window; // works on ie10
      return (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) || false;
  }
  
  // display type based on size
  function getDeviceType() {
      'use strict';
      // if we are not on a touch device than we must be a desktop
      if (evt.touchDevice === false) {
          return 'desktop';
      }
      // if touch device and screen is bigger than normal phone
      if (evt.touchDevice === true && screen.width > 500) {
          return 'tablet';
      }
      // if the screen is small and we are a touch device we are a phone
      return 'phone';
  }
  
  /*DOC
  Name:
      evt.*
  
  Description:
      This is a collection of global variables that are used for browser-type detection and for using different events for different devices.
      The reason for this is because even though the 'mousedown' event works on a phone it is substantially slower than if you had used 'touchstart',
      But if you used 'touchstart' it wouldn't work on the computer so we wrap both under the name evt.mousedown and only give mobile browsers
      'touchstart' and desktop browsers 'mousedown' so that you dont have to differentiate.
      
  List of variables:
      evt.touchDevice  equals true|false depending on whether or not we are on a touch-enabled devide
      evt.deviceType   equals 'desktop'|'tablet'|'phone' depending on what type of device you are on
      
      evt.mousedown    if we are on a touch device: 'touchstart'  else  'mousedown'
      evt.mouseover    if we are on a touch device: 'touchenter'  else  'mouseover'
      evt.mousemove    if we are on a touch device: 'touchmove'   else  'mousemove'
      evt.mouseout     if we are on a touch device: 'touchleave'  else  'mouseout'
      evt.mouseup      if we are on a touch device: 'touchend'    else  'mouseup'
      evt.click        if we are on a touch device: 'touchend'    else  'click'
  
  */
  
  // this is for detecting whether or not we are in an touch device
  evt.touchDevice = touchDeviceTest();
  
  // set global variable for display type
  evt.deviceType = getDeviceType();
  
  evt.mousedown = evt.touchDevice ? 'touchstart': 'mousedown';
  evt.mouseover = evt.touchDevice ? 'touchenter': 'mouseover';
  evt.mousemove = evt.touchDevice ? 'touchmove' : 'mousemove';
  evt.mouseout  = evt.touchDevice ? 'touchleave': 'mouseout';
  evt.mouseup   = evt.touchDevice ? 'touchend'  : 'mouseup';
  evt.click     = 'click';
  
  // ##############################################################
  // ########### PINK BACKGROUND WHEN NOT IN PRODUCTION ###########
  // ##############################################################
  /*
  //DO NOT UNCOMMENT
  //To use:
  //Add this javascript to the test.sh file
  //Append to greyspots.js after the rsync of the web_root files
  window.addEventListener('load', function () {
      var styleElement, helperElement, helperFunction;
      
      styleElement = document.createElement('style');
      styleElement.innerHTML = 'body, body gs-panel, body gs-panel gs-header, body gs-panel gs-body, ' +
                               'body gs-page, body gs-page gs-header, body gs-page gs-body {\n' +
                               '    background-color: #FFBBBB;\n' +
                               '}';
      
      document.head.appendChild(styleElement);
  });
  */
  
  // #############################################################
  // #################### DEFINE GS NAMESPACE ####################
  // #############################################################
  
  if (window.GS === undefined) {
      window.GS = {};
      
      GS.version = function () {
          'use strict';
          return '1.1.1';
      };
      
      window.addEventListener('design-register-element', function () {
          'use strict';
          
          registerDesignSnippet('GS.version', 'GS.version', 'GS.version();');
      });
  }
  
  // ##############################################################
  // ################## DEFINE support NAMESPACE ##################
  // ##############################################################
  
  if (window.shimmed === undefined) {
      window.shimmed = {};
  }
  
  // ##############################################################
  // ############### DEFINE functionality NAMESPACE ###############
  // ##############################################################
  
  if (window.functionality === undefined) {
      window.functionality = {"errors": {}};
  }
  
  // ##############################################################
  // ####################### NO CONSOLE FIX #######################
  // ##############################################################
  
  // in IE8 when the dev tools are not open console.log is not defined so if there was a console.log() the page would error
  //      this defines the console object if it is empty so that if there is a console.log() it will not error in IE8
  if (typeof console === 'undefined' || !console.log) {
      window.console = {
          log:   function () { 'use strict'; },
          info:  function () { 'use strict'; },
          debug: function () { 'use strict'; },
          warn:  function () { 'use strict'; },
          trace: function () { 'use strict'; },
          error: function () { 'use strict'; }
      };
  }
  
  
  // ##############################################################
  // ######## PREVENT WINDOW OVERSCROLLING ON TOUCH DEVICE ########
  // ##############################################################
  /*
  if (evt.touchDevice) {
      (function () {
          var startTime, startTouchTop, endTime, endTouchTop, lastTouchTop, currentTouchTop,
              bolCurrentlyMonitoring = false, bolTouchScrollPrevented = false, currentScrollingElement, scrollingLooper;
          
          window.ontouchstart = function(event){
              lastTouchTop = GS.mousePosition(event).top;
          };
          
          //window.addEventListener('scroll', function (event) {
          //    console.log(event);
          //}, true);
          
          window.ontouchmove = function (event) {
              var currentTouchTop = GS.mousePosition(event).top, currentElement = GS.scrollParent(event.target), bolFoundScrollable = Boolean(currentElement);
              
              //console.log(currentElement,
              //            event.target,
              //            bolFoundScrollable,
              //            currentElement.scrollTop,
              //            currentElement.clientHeight,
              //            currentElement.scrollHeight,
              //            currentTouchTop,
              //            lastTouchTop);
              //console.log(currentElement.scrollTop <= 0,
              //            currentTouchTop > lastTouchTop,
              //            currentElement.scrollTop + currentElement.clientHeight >= currentElement.scrollHeight,
              //            currentTouchTop < lastTouchTop);
              
              if (bolFoundScrollable === false ||
                  (currentElement.scrollTop <= 0 && currentTouchTop > lastTouchTop) ||
                  (currentElement.scrollTop + currentElement.clientHeight >= currentElement.scrollHeight && currentTouchTop < lastTouchTop)) {
                  
                  //console.log('prevent default');
                  
                  bolTouchScrollPrevented = true;
                  event.preventDefault();
                  //event.stopPropagation();
                  
              } else if (bolFoundScrollable === true && bolTouchScrollPrevented === true) {
                  currentElement.scrollTop += (lastTouchTop - currentTouchTop);
              }
              
              currentScrollingElement = currentElement;
              lastTouchTop = currentTouchTop;
          };
          
          window.ontouchend = function () {
              bolTouchScrollPrevented = false;
          };
      })();
  }*/
  
  
  // ##############################################################
  // ################### DATABASE NORMALIZATION ###################
  // ##############################################################
  
  GS.database = {"engine": "", "type": {}};
  GS.database.engine = "postgres";
  
  
  // if db is SQL Server: utf16 else utf8
  (function () {
      "use strict";
      
      // get a cookie from the browser
      function getCookie(c_name) {
          var c_value = document.cookie, c_end,
              c_start = c_value.indexOf(" " + c_name + "=");
  
          if (c_start === -1) {
              c_start = c_value.indexOf(c_name + "=");
          }
          if (c_start === -1) {
              c_value = null;
          } else {
              c_start = c_value.indexOf("=", c_start) + 1;
              c_end = c_value.indexOf(";", c_start);
              if (c_end === -1) {
                  c_end = c_value.length;
              }
              c_value = decodeURIComponent(c_value.substring(c_start, c_end));
          }
          return c_value;
      };
  
      if ((getCookie('DB') || 'PG').toUpperCase() === 'PG') {
          GS.database.engine = 'postgres';
      } else { //ss
          GS.database.engine = 'mssqlserver'
      }
      
      if (GS.database.engine === "postgres") {
          GS.database.type.text = "text";
          GS.database.type.timestamp = "timestamptz";
          
      } else if (GS.database.engine === "mssqlserver") {
          GS.database.type.text = "nvarchar(MAX)";
          GS.database.type.timestamp = "datetime";
      }
  }());
  
  
  
  
  
  // ##############################################################
  // ########### LABEL CLICK: FOCUS USING FOR ATTRIBUTE ###########
  // ##############################################################
  
  window.addEventListener('click', function (event) {
      'use strict';
      var labelElement, targetElement;
      
      //console.log(event.target, GS.findParentTag(event.target, 'LABEL'));
      
      if (event.target.nodeName === 'LABEL') {
          labelElement = event.target;
      } else if (GS.findParentTag(event.target, 'LABEL')) {
          labelElement = GS.findParentTag(event.target, 'LABEL');
      }
      
      //console.log(labelElement, labelElement.getAttribute('for'));
      
      if (labelElement && labelElement.hasAttribute('for')) {
          targetElement = document.getElementById(labelElement.getAttribute('for'));
          
          //console.log(targetElement);
          //console.log(targetElement.focus, !targetElement.hasAttribute('disabled'));
          
          if (targetElement && targetElement.focus && !targetElement.hasAttribute('disabled')) {
              targetElement.focus();
          }
      }
  });
  
  
  // #############################################################
  // ######################### PAGE CURL #########################
  // #############################################################
  (function () {
      function aboutDialog() {
          'use strict';
          var templateElement = document.createElement('template');
          
          templateElement.innerHTML = ml(function () {/*
              <gs-page>
                  <gs-header><center><h3>About Envelope</h3></center></gs-header>
                  <gs-body padded>
                      <gs-grid widths="1,1" reflow-at="767px">
                          <gs-block>
                              <center><h3><a target="_blank" href="http://x-tag.github.io/">X-Tag</a></h3></center>
                          </gs-block>
                          <gs-block>
                              <center><h4>Version Unknown</h4></center>
                          </gs-block>
                          <br />
                          <gs-block>
                              <center><h3><a target="_blank" href="http://olado.github.io/doT/">doT.js</a></h3></center>
                          </gs-block>
                          <gs-block>
                              <center><h4>{{DOT}}</h4></center>
                          </gs-block>
                          <br />
                          <gs-block>
                              <center><h3><a target="_blank" href="http://ace.c9.io/">Ace Editor</a></h3></center>
                          </gs-block>
                          <gs-block>
                              <center><h4>1.2.3</h4></center>
                          </gs-block>
                          <br />
                          <gs-block>
                              <center><h3><a target="_blank" href="http://jsbeautifier.org/">JSBeautifier</a></h3></center>
                          </gs-block>
                          <gs-block>
                              <center><h4>Version Unknown</h4></center>
                          </gs-block>
                          <br />
                          <gs-block>
                              <center>
                                  <h3><a target="_blank" href="https://github.com/douglascrockford/JSON-js">
                                      json_parse.js (modified)
                                  </a></h3>
                              </center>
                          </gs-block>
                          <gs-block>
                              <center><h4>Version Unknown</h4></center>
                          </gs-block>
                          <br />
                          <gs-block>
                              <center>
                                  <h3><a target="_blank" href="https://www.polymer-project.org/1.0/">
                                      HTML Template Polyfill (modified)
                                  </a></h3>
                              </center>
                          </gs-block>
                          <gs-block>
                              <center><h4>Version Unknown</h4></center>
                          </gs-block>
                          <br />
                          <gs-block>
                              <center>
                                  <h3><a target="_blank" href="https://github.com/ftlabs/fastclick">FastClick</a></h3>
                              </center>
                          </gs-block>
                          <gs-block>
                              <center><h4>Version Unknown</h4></center>
                          </gs-block>
                          <br />
                          <gs-block>
                              <center>
                                  <h3><a target="_blank" href="https://code.google.com/archive/p/crypto-js/">CryptoJS (MD5 Portion)</a></h3>
                              </center>
                          </gs-block>
                          <gs-block>
                              <center><h4>3.1.2</h4></center>
                          </gs-block>
                          
                      </gs-grid>
                      
                      <div>
                          All other source code and documentation copyright Workflow Products, LLC. All Rights Reserved.
                          <br /><br />
                          The Envelope platform is available for many platforms and most embedded devices. If you'd like your application built using Envelope technology please contact us.
                          <br /><br />
                          Commercial license terms for the Envelope platform are available for a small fee. Contact us for details.
                          <br /><br />
                          <center><b>Workflow Products, L.L.C.</b></center>
                          <center>7813 Harwood Road</center>
                          <center>North Richland Hills Texas 76180</center>
                          <center>(817) 503-9545</center>
                      </div>
                      <br />
                      <center><small><i>Copyright &copy; 2016-present by Workflow Products, L.L.C. (817) 503-9545</i></small></center>
                  </gs-body>
                  <gs-footer>
                      <gs-button dialogclose>Done</gs-button>
                  </gs-footer>
              </gs-page>
          */}).replace(/\{\{DOT\}\}/gi, doT.version);
          
          GS.openDialog(templateElement);
      }
      
      
      window.addEventListener('load', function () {
          'use strict';
          var bolOpen, intMaxHeight, curlElement, menuElement, strpgManageUName, strHTML, toggleCurl;
          
          if (window.bolCurl !== false) {
              bolOpen = false;
              intMaxHeight = 0;
              curlElement = document.createElement('div');
              menuElement = document.createElement('div');
              strpgManageUName = GS.getCookie('pgmanage_uname');
              strHTML = '';
              
              curlElement.setAttribute('id', 'gs-document-curl-container');
              curlElement.innerHTML = '<div id="gs-document-curl-part-1"></div>' +
                                      '<div id="gs-document-curl-part-2"></div>' +
                                      '<div id="gs-document-curl-part-3"></div>' +
                                      '<div id="gs-document-curl-part-4"></div>';
              
              document.body.appendChild(curlElement);
              
              if (evt.deviceType === 'phone') {
                  curlElement.setAttribute('style', 'font-size: 1.3em;');
              } else {
                  curlElement.setAttribute('style', 'font-size: 0.7em;');
              }
              
              menuElement.setAttribute('id', 'gs-document-menu-container');
              menuElement.setAttribute('style', 'height: 0px;');
              
              // this is for envelope
              if (location.pathname.indexOf('/env/') === 0) {
                  strHTML += '<center><b><a target="_self" href="/env/app/all/index.html">Back To Main Menu</a></b></center>';
                  strHTML += '<center>' +
                                  '<gs-button target="_self" href="/env/auth/?action=logout" inline>Log out</gs-button><br />' +
                                  '<gs-button onclick="GS.userChangePassword()" inline>Change Password</gs-button>' +
                              '</center>';
                  intMaxHeight += 4.8;
                  
              // and this is for pgmanage
              } else {
                  strHTML += '<center>' +
                                  '<gs-button target="_self" href="/pgmanage/auth?action=logout" inline>Log out</gs-button><br />' +
                                  '<gs-button onclick="GS.userChangePassword()" inline>Change Password</gs-button>' +
                              '</center>';
                  intMaxHeight += 3.4;
              }
              
              strHTML += '<center><gs-button onclick="GS.showShimmed()" inline>Browser Support</gs-button></center>';
              intMaxHeight += 1.9;
              
              strHTML += '<center><gs-button onclick="window.location.reload(true);" inline>Update Software</gs-button></center>';
              intMaxHeight += 1.9;
              
              if (location.pathname.indexOf('/env/') === 0) {
                  strHTML += '<center><gs-button id="gs-button-about" inline>About</gs-button></center>';
                  intMaxHeight += 1.9;
              }
              
              intMaxHeight += 1;
              
              menuElement.innerHTML = '<div id="gs-document-menu-link-container" style="height: ' + intMaxHeight + 'em;">' + strHTML + '</div>';
              document.body.appendChild(menuElement);
              
              if (location.pathname.indexOf('/env/') === 0) {
                  document.getElementById('gs-button-about').addEventListener('click', aboutDialog);
              }
              
              // define function for toggling the page curl
              toggleCurl = function () {
                  var intFontSize = GS.pxToEm(document.body, window.innerWidth) / 4,
                      intBottomLine = window.innerHeight - (GS.emToPx(document.body, intFontSize)),
                      closedSize = (evt.deviceType === 'phone' ? '1.3em' : '0.7em'); // replace evt.touchDevice with true to test on a desktop
                  
                  // maximum bottom line
                  if (GS.pxToEm(document.body, intBottomLine) > intMaxHeight) {
                      intBottomLine = GS.emToPx(document.body, intMaxHeight);
                  }
                  
                  //curlElement.classList.add('animating');
                  //menuElement.classList.add('animating');
                  
                  if (bolOpen === false) {
                      document.body.insertBefore(GS.stringToElement('<div id="gs-document-curl-modal-background"></div>'), curlElement);
                      document.getElementById('gs-document-curl-modal-background').addEventListener('click', toggleCurl);
                      
                      curlElement.style.fontSize = intFontSize + 'em';
                      curlElement.style.bottom = intBottomLine + 'px';
                      menuElement.style.height = intBottomLine + 'px';
                      
                      //GS.animateStyle(curlElement, 'font-size', closedSize, intFontSize + 'em', function () {
                      //    curlElement.classList.remove('animating');
                      //}, 185, 14);
                      //
                      //GS.animateStyle(curlElement, 'bottom', '0px', intBottomLine + 'px', function () {
                      //    curlElement.classList.remove('animating');
                      //}, 185, 14);
                      //
                      //GS.animateStyle(menuElement, 'height', '0px', intBottomLine + 'px', function () {
                      //    menuElement.classList.remove('animating');
                      //}, 185, 14);
                      
                      bolOpen = true;
                  } else {
                      document.body.removeChild(document.getElementById('gs-document-curl-modal-background'));
                      
                      curlElement.style.fontSize = closedSize;
                      curlElement.style.bottom = '0px';
                      menuElement.style.height = '0px';
                      
                      //GS.animateStyle(curlElement, 'font-size', intFontSize + 'em', closedSize, function () {
                      //    curlElement.classList.remove('animating');
                      //}, 185, 14);
                      //
                      //GS.animateStyle(curlElement, 'bottom', intBottomLine + 'px', '0px', function () {
                      //    curlElement.classList.remove('animating');
                      //}, 185, 14);
                      //
                      //GS.animateStyle(menuElement, 'height', intBottomLine + 'px', '0px', function () {
                      //    menuElement.classList.remove('animating');
                      //}, 185, 14);
                      
                      bolOpen = false;
                  }
              };
              
              curlElement.addEventListener('click', toggleCurl);
          }
      });
  })();
  
  // ################################################################
  // ###################### FASTCLICK POLYFILL ######################
  // ################################################################
  
  // double clicks will not work while using fastclick
  // click events will not have a delay while using fastclick
  // we chose fastclick :)
  
  // if you need to turn fastclick off for an element use the "needsclick" class
  // if you need to turn fastclick off for an elements children (but not the element itself) use the "childrenneedsclick" class
  // if you need to turn fastclick off for an elements children and the element itself use the "childrenneedsclick" class and the "needsclick" class
  if ('addEventListener' in document) {
      document.addEventListener('DOMContentLoaded', function() {
          'use strict';
          FastClick.attach(document.body);
      }, false);
  }
  
  
  
  // ##################################################################
  // ##################### TEMPLATE GET INERT DOM #####################
  // ##################################################################
  /*
  HTMLTemplateElement.prototype.contentTemplate = function () {
      'use strict';
      
      if (this.content) {
          
      } else {
          
      }
  };
  */
  
  // #################################################################
  // ###################### POLYFILL/SHIM CHECK ######################
  // #################################################################
  
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('GS.showShimmed', 'GS.showShimmed', 'GS.showShimmed();');
  });
  
  window.addEventListener('load', function () {
      'use strict';
      function cleanFunctionForTest(fn) {
          fn = fn.toString().toLowerCase();   // convert function string and turn all text lowercase
          fn = fn.substring(fn.indexOf('{')); // remove everything up until the first open curly brace
          fn = fn.replace(/ /gim, '');        // remove all spaces
          
          return fn;
      }
      
      function nativeTest(fn) {
          // if there is not function: not native: return false
          if (!fn) {
              return false;
          }
          
          // clean function for native testing
          fn = cleanFunctionForTest(fn);
          
          return fn.indexOf('[nativecode]') > -1 ||                   // if '[nativecode]' is found in the cleaned text: native
                 fn === cleanFunctionForTest(document.createElement); // else if the cleaned text matches a native function: native
      }
      
      shimmed.matchesSelector     = !nativeTest(Element.prototype.matchesSelector) &&
                                    !nativeTest(Element.prototype.webkitMatchesSelector) &&
                                    !nativeTest(Element.prototype.mozMatchesSelector) &&
                                    !nativeTest(Element.prototype.msMatchesSelector) &&
                                    !nativeTest(Element.prototype.MSMatchesSelector);
      
      shimmed.MutationObserver    = !nativeTest(window.MutationObserver);
      shimmed.WeakMap             = !nativeTest(window.WeakMap);
      shimmed.registerElement     = !nativeTest(document.registerElement);
      shimmed.DOMTokenList        = !nativeTest(window.DOMTokenList);
      shimmed.HTMLTemplateElement = Boolean(HTMLTemplateElement.bootstrap);
      
      // automated functionality testing
      
      functionality.matchesSelector = false;
      try {
          var bodyElement = document.body
            , matchesSelector = (Element.prototype.matchesSelector
                                  || Element.prototype.webkitMatchesSelector
                                  || Element.prototype.mozMatchesSelector
                                  || Element.prototype.msMatchesSelector
                                  || Element.prototype.MSMatchesSelector);
          
          functionality.matchesSelector = matchesSelector.apply(bodyElement, ['body']);
          
      } catch (e) {
          functionality.matchesSelector = false;
          functionality.errors.matchesSelector = e;
      }
      
      functionality.MutationObserver = false;
      try {
          var testElement = document.createElement('div'), observer;
          
          observer = new MutationObserver(function(mutations) {
              functionality.MutationObserver = (mutations.length > 0);
          });
          
          observer.observe(testElement, {'childList': true});
          testElement.appendChild(document.createElement('div'));
      } catch (e) {
          functionality.MutationObserver = false;
          functionality.errors.MutationObserver = e;
      }
      
      functionality.WeakMap = false;
      try {
          var testMap = new WeakMap(), testObject = function(){};
          
          testMap.set(testObject, 'asdfasdf');
          
          functionality.WeakMap = (testMap.get(testObject) === 'asdfasdf');
          functionality.WeakMap = (functionality.WeakMap && testMap.has(testObject) === true);
          
          testMap.delete(testObject);
          
          functionality.WeakMap = (functionality.WeakMap && testMap.has(testObject) === false);
          
      } catch (e) {
          functionality.WeakMap = false;
          functionality.errors.WeakMap = e;
      }
      
      functionality.registerElement = false;
      try {
          var prototype = Object.create(HTMLElement.prototype);
          prototype.testmethod = function () { return true; };
          document.registerElement('asdf-test', {'prototype': prototype});
          
          var testElement;
          testElement = document.createElement('asdf-test');
          
          functionality.registerElement = testElement.testmethod();
          
      } catch (e) {
          functionality.registerElement = false;
          functionality.errors.registerElement = e;
      }
      
      functionality.DOMTokenList = false;
      try {
          functionality.DOMTokenList = Boolean(document.body.classList);
      } catch (e) {
          functionality.DOMTokenList = false;
          functionality.errors.DOMTokenList = e;
      }
      
      functionality.HTMLTemplateElement = false;
      try {
          var testElement = document.createElement('template');
          
          xtag.register('asdf-test-two', {
              'lifecycle': {
                  'created': function () {
                      var divElement = document.createElement('div');
                      divElement.classList.add('find-me');
                      this.appendChild(divElement);
                  }
              }
          });
          
          testElement.innerHTML = '<div></div><p></p><asdf-test-two></asdf-test-two>';
          
          functionality.HTMLTemplateElement = (xtag.query(testElement, '.find-me').length === 0);
          
      } catch (e) {
          functionality.HTMLTemplateElement = false;
          functionality.errors.HTMLTemplateElement = e;
      }
      
      // function to show shim and functionality results
      GS.showShimmed = function () {
          var strHTML = '', key, templateElement;
          
          strHTML += '<br />\n' +
                     '<center>This dialog is for developers so that they can determine what technologies this browser supports and what technologies are being implemented manually.</center>\n' +
                     '<br />\n' +
                     '<hr />\n';
          
          for (key in shimmed) {
              strHTML += '<gs-grid reflow-at="450px">\n' +
                         '    <gs-block><center>' + encodeHTML(key) + '</center></gs-block>\n' +
                         '    <gs-block>\n' +
                         '        <center><b>' + (shimmed[key] ? 'SHIMMED' : 'NATIVE') + '</center></b>\n' +
                         '    </gs-block>\n' +
                         '    <gs-block>\n' +
                         '        <center>' + (functionality[key] ? '<b style="color: #3F9A3F;">FUNCTION PASS' : '<b style="color: #F00;">FUNCTION FAIL') + '</center></b>\n' +
                         '    </gs-block>\n' +
                         '</gs-grid>\n' +
                         '<hr />\n';
          }
          
          strHTML += '<br />';
          
          
          templateElement = document.createElement('template');
          
          templateElement.innerHTML = ml(function () {/*
              <gs-page>
                  <gs-header><center><h3>Native Detection</h3></center></gs-header>
                  <gs-body padded>
                      {{HTML}}
                  </gs-body>
                  <gs-footer><gs-button dialogclose>Done</gs-button></gs-footer>
              </gs-page>
          */}).replace('{{HTML}}', strHTML);
          
          GS.openDialog(templateElement);
      };
  });
  
  // ##################################################################
  // ################ MULTIPLE ONBEFOREUNLOAD HANDLERS ################
  // ##################################################################
  
  
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('GS.addUnloadEvent', 'GS.addUnloadEvent', 'GS.addUnloadEvent(function () {' +
                                                                      '    $0' +
                                                                      '});');
  });
  
  (function () {
      'use strict';
      var arrFunctions = [],
          unloadFunction = function () {
              var i, len, ret, current;
              
              for (i = 0, len = arrFunctions.length; i < len; i += 1) {
                  current = arrFunctions[i]();
                  
                  if (current && !ret) {
                      ret = current;
                  }
              }
              
              if (ret) {
                  return ret;
              }
          };
      
      window.addEventListener('load', function () {
          if (window.onbeforeunload && window.onbeforeunload !== unloadFunction) {
              console.error('Please use the GS.addUnloadEvent function to run code onbeforeunload.');
          }
      });
      
      GS.addBeforeUnloadEvent = function (functionToCall) {
          if (typeof functionToCall !== 'function') {
              throw new TypeError('GS.addUnloadEvent takes one argument, and it must be a function.');
          }
          
          if (!window.onbeforeunload) {
              window.onbeforeunload = unloadFunction;
              
          } else if (window.onbeforeunload !== unloadFunction) {
              console.error('Please use just the GS.addBeforeUnloadEvent function to run code onbeforeunload.');
              window.onbeforeunload = unloadFunction;
          }
          
          arrFunctions.push(functionToCall);
      };
  })();
  
  
  
  
  
  /*
  CryptoJS v3.1.2
  code.google.com/p/crypto-js
  (c) 2009-2013 by Jeff Mott. All rights reserved.
  code.google.com/p/crypto-js/wiki/License
  */
  var CryptoJS=CryptoJS||function(h,r){var k={},l=k.lib={},n=function(){},f=l.Base={extend:function(a){n.prototype=this;var b=new n;a&&b.mixIn(a);b.hasOwnProperty("init")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
  j=l.WordArray=f.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=r?b:4*a.length},toString:function(a){return(a||s).stringify(this)},concat:function(a){var b=this.words,d=a.words,c=this.sigBytes;a=a.sigBytes;this.clamp();if(c%4)for(var e=0;e<a;e++)b[c+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((c+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)b[c+e>>>2]=d[e>>>2];else b.push.apply(b,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,b=this.sigBytes;a[b>>>2]&=4294967295<<
  32-8*(b%4);a.length=h.ceil(b/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var b=[],d=0;d<a;d+=4)b.push(4294967296*h.random()|0);return new j.init(b,a)}}),m=k.enc={},s=m.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++){var e=b[c>>>2]>>>24-8*(c%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c+=2)d[c>>>3]|=parseInt(a.substr(c,
  2),16)<<24-4*(c%8);return new j.init(d,b/2)}},p=m.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++)d.push(String.fromCharCode(b[c>>>2]>>>24-8*(c%4)&255));return d.join("")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c++)d[c>>>2]|=(a.charCodeAt(c)&255)<<24-8*(c%4);return new j.init(d,b)}},t=m.Utf8={stringify:function(a){try{return decodeURIComponent(escape(p.stringify(a)))}catch(b){throw Error("Malformed UTF-8 data");}},parse:function(a){return p.parse(unescape(encodeURIComponent(a)))}},
  q=l.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new j.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=t.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var b=this._data,d=b.words,c=b.sigBytes,e=this.blockSize,f=c/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;c=h.min(4*a,c);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);b.sigBytes-=c}return new j.init(g,c)},clone:function(){var a=f.clone.call(this);
  a._data=this._data.clone();return a},_minBufferSize:0});l.Hasher=q.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){q.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,d){return(new a.init(d)).finalize(b)}},_createHmacHelper:function(a){return function(b,d){return(new u.HMAC.init(a,
  d)).finalize(b)}}});var u=k.algo={};return k}(Math);
  /*
  CryptoJS v3.1.2
  code.google.com/p/crypto-js
  (c) 2009-2013 by Jeff Mott. All rights reserved.
  code.google.com/p/crypto-js/wiki/License
  */
  (function(E){function h(a,f,g,j,p,h,k){a=a+(f&g|~f&j)+p+k;return(a<<h|a>>>32-h)+f}function k(a,f,g,j,p,h,k){a=a+(f&j|g&~j)+p+k;return(a<<h|a>>>32-h)+f}function l(a,f,g,j,h,k,l){a=a+(f^g^j)+h+l;return(a<<k|a>>>32-k)+f}function n(a,f,g,j,h,k,l){a=a+(g^(f|~j))+h+l;return(a<<k|a>>>32-k)+f}for(var r=CryptoJS,q=r.lib,F=q.WordArray,s=q.Hasher,q=r.algo,a=[],t=0;64>t;t++)a[t]=4294967296*E.abs(E.sin(t+1))|0;q=q.MD5=s.extend({_doReset:function(){this._hash=new F.init([1732584193,4023233417,2562383102,271733878])},
  _doProcessBlock:function(m,f){for(var g=0;16>g;g++){var j=f+g,p=m[j];m[j]=(p<<8|p>>>24)&16711935|(p<<24|p>>>8)&4278255360}var g=this._hash.words,j=m[f+0],p=m[f+1],q=m[f+2],r=m[f+3],s=m[f+4],t=m[f+5],u=m[f+6],v=m[f+7],w=m[f+8],x=m[f+9],y=m[f+10],z=m[f+11],A=m[f+12],B=m[f+13],C=m[f+14],D=m[f+15],b=g[0],c=g[1],d=g[2],e=g[3],b=h(b,c,d,e,j,7,a[0]),e=h(e,b,c,d,p,12,a[1]),d=h(d,e,b,c,q,17,a[2]),c=h(c,d,e,b,r,22,a[3]),b=h(b,c,d,e,s,7,a[4]),e=h(e,b,c,d,t,12,a[5]),d=h(d,e,b,c,u,17,a[6]),c=h(c,d,e,b,v,22,a[7]),
  b=h(b,c,d,e,w,7,a[8]),e=h(e,b,c,d,x,12,a[9]),d=h(d,e,b,c,y,17,a[10]),c=h(c,d,e,b,z,22,a[11]),b=h(b,c,d,e,A,7,a[12]),e=h(e,b,c,d,B,12,a[13]),d=h(d,e,b,c,C,17,a[14]),c=h(c,d,e,b,D,22,a[15]),b=k(b,c,d,e,p,5,a[16]),e=k(e,b,c,d,u,9,a[17]),d=k(d,e,b,c,z,14,a[18]),c=k(c,d,e,b,j,20,a[19]),b=k(b,c,d,e,t,5,a[20]),e=k(e,b,c,d,y,9,a[21]),d=k(d,e,b,c,D,14,a[22]),c=k(c,d,e,b,s,20,a[23]),b=k(b,c,d,e,x,5,a[24]),e=k(e,b,c,d,C,9,a[25]),d=k(d,e,b,c,r,14,a[26]),c=k(c,d,e,b,w,20,a[27]),b=k(b,c,d,e,B,5,a[28]),e=k(e,b,
  c,d,q,9,a[29]),d=k(d,e,b,c,v,14,a[30]),c=k(c,d,e,b,A,20,a[31]),b=l(b,c,d,e,t,4,a[32]),e=l(e,b,c,d,w,11,a[33]),d=l(d,e,b,c,z,16,a[34]),c=l(c,d,e,b,C,23,a[35]),b=l(b,c,d,e,p,4,a[36]),e=l(e,b,c,d,s,11,a[37]),d=l(d,e,b,c,v,16,a[38]),c=l(c,d,e,b,y,23,a[39]),b=l(b,c,d,e,B,4,a[40]),e=l(e,b,c,d,j,11,a[41]),d=l(d,e,b,c,r,16,a[42]),c=l(c,d,e,b,u,23,a[43]),b=l(b,c,d,e,x,4,a[44]),e=l(e,b,c,d,A,11,a[45]),d=l(d,e,b,c,D,16,a[46]),c=l(c,d,e,b,q,23,a[47]),b=n(b,c,d,e,j,6,a[48]),e=n(e,b,c,d,v,10,a[49]),d=n(d,e,b,c,
  C,15,a[50]),c=n(c,d,e,b,t,21,a[51]),b=n(b,c,d,e,A,6,a[52]),e=n(e,b,c,d,r,10,a[53]),d=n(d,e,b,c,y,15,a[54]),c=n(c,d,e,b,p,21,a[55]),b=n(b,c,d,e,w,6,a[56]),e=n(e,b,c,d,D,10,a[57]),d=n(d,e,b,c,u,15,a[58]),c=n(c,d,e,b,B,21,a[59]),b=n(b,c,d,e,s,6,a[60]),e=n(e,b,c,d,z,10,a[61]),d=n(d,e,b,c,q,15,a[62]),c=n(c,d,e,b,x,21,a[63]);g[0]=g[0]+b|0;g[1]=g[1]+c|0;g[2]=g[2]+d|0;g[3]=g[3]+e|0},_doFinalize:function(){var a=this._data,f=a.words,g=8*this._nDataBytes,j=8*a.sigBytes;f[j>>>5]|=128<<24-j%32;var h=E.floor(g/
  4294967296);f[(j+64>>>9<<4)+15]=(h<<8|h>>>24)&16711935|(h<<24|h>>>8)&4278255360;f[(j+64>>>9<<4)+14]=(g<<8|g>>>24)&16711935|(g<<24|g>>>8)&4278255360;a.sigBytes=4*(f.length+1);this._process();a=this._hash;f=a.words;for(g=0;4>g;g++)j=f[g],f[g]=(j<<8|j>>>24)&16711935|(j<<24|j>>>8)&4278255360;return a},clone:function(){var a=s.clone.call(this);a._hash=this._hash.clone();return a}});r.MD5=s._createHelper(q);r.HmacMD5=s._createHmacHelper(q)})(Math);
  /*
  CryptoJS v3.1.2
  code.google.com/p/crypto-js
  (c) 2009-2013 by Jeff Mott. All rights reserved.
  code.google.com/p/crypto-js/wiki/License
  */
  (function(){if("function"==typeof ArrayBuffer){var b=CryptoJS.lib.WordArray,e=b.init;(b.init=function(a){a instanceof ArrayBuffer&&(a=new Uint8Array(a));if(a instanceof Int8Array||a instanceof Uint8ClampedArray||a instanceof Int16Array||a instanceof Uint16Array||a instanceof Int32Array||a instanceof Uint32Array||a instanceof Float32Array||a instanceof Float64Array)a=new Uint8Array(a.buffer,a.byteOffset,a.byteLength);if(a instanceof Uint8Array){for(var b=a.byteLength,d=[],c=0;c<b;c++)d[c>>>2]|=a[c]<<
  24-8*(c%4);e.call(this,d,b)}else e.apply(this,arguments)}).prototype=b}})();
  
  // if db is SQL Server: utf16 else utf8
  (function () {
      "use strict";
      
      // get a cookie from the browser
      function getCookie(c_name) {
          var c_value = document.cookie, c_end,
              c_start = c_value.indexOf(" " + c_name + "=");
  
          if (c_start === -1) {
              c_start = c_value.indexOf(c_name + "=");
          }
          if (c_start === -1) {
              c_value = null;
          } else {
              c_start = c_value.indexOf("=", c_start) + 1;
              c_end = c_value.indexOf(";", c_start);
              if (c_end === -1) {
                  c_end = c_value.length;
              }
              c_value = decodeURIComponent(c_value.substring(c_start, c_end));
          }
          return c_value;
      };
  
      if ((getCookie('DB') || 'PG').toUpperCase() === 'PG') {
          GS.utfSafeMD5 = CryptoJS.MD5;
      } else { //ss
          GS.utfSafeMD5 = function (str) {
              "use strict";
              var buf = new ArrayBuffer(str.length * 2);
              var bufView = new Uint16Array(buf);
              var i;
              var strLen;
  
              for (i = 0, strLen = str.length; i < strLen; i += 1) {
                  bufView[i] = str.charCodeAt(i);
              }
  
              return CryptoJS.MD5(CryptoJS.lib.WordArray.create(bufView));
          }
      }
  }());
  //global registerDesignSnippet
  
  // snippets are in the textmate format more info:
  //      http://blog.macromates.com/2005/the-power-of-snippets/
  
  window.addEventListener('design-register-element', function () {
      // uncategorized snippets
      registerDesignSnippet('Lorem Ipsum', 'Lorem Ipsum', 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.');
  
      registerDesignSnippet('Document Start', 'Document Start',
              '<!DOCTYPE html>\n' +
              '<html>\n' +
              '    <head>\n' +
              '        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />\n' +
              '        <meta name="apple-mobile-web-app-capable" content="yes" />\n' +
              '        <meta name="apple-mobile-web-app-status-bar-style" content="black" />\n' +
              '        <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1.0, maximum-scale=1.0, minimal-ui" />\n' +
              '        <!-- Make this page use standard caching procedure when used as an iframe -->\n' +
              '        <meta http-equiv="Cache-control" content="no-store, must-revalidate" />\n' +
              '        \n' +
              '        <title>${1:New Page}</title>\n' +
              '        \n' +
              '        <script src="/js/greyspots.js" type="text/javascript"></script>\n' +
              '        <link href="/css/greyspots.css" type="text/css" rel="stylesheet" />\n' +
              '    </head>\n' +
              '    <body>\n' +
              '        $0\n' +
              '    </body>\n' +
              '</html>');
  
      registerDesignSnippet('Centered H1', 'Centered H1', '<center><h1>$0</h1></center>');
      registerDesignSnippet('Centered H2', 'Centered H2', '<center><h2>$0</h2></center>');
      registerDesignSnippet('Centered H3', 'Centered H3', '<center><h3>$0</h3></center>');
      registerDesignSnippet('Centered H4', 'Centered H4', '<center><h4>$0</h4></center>');
      registerDesignSnippet('Centered H5', 'Centered H5', '<center><h5>$0</h5></center>');
      registerDesignSnippet('Centered H6', 'Centered H6', '<center><h6>$0</h6></center>');
  
      // javascript snippets
      registerDesignSnippet('Window Load', 'window.addEventListener',
              'window.addEventListener(\'load\', function () {\n' +
              '    $0\n' +
              '});');
  
      registerDesignSnippet('Multiline String', 'Multiline String',
              'ml(function () {/*\n' +
              '    ${0}\n' +
              '})');
  
      registerDesignSnippet('ml()', 'ml()',
              'ml(function () {/*\n' +
              '    ${0}\n' +
              '*/})');
  
      // HTML snippets
      registerDesignSnippet('<style>', '<style>', 'style>\n' +
                                                  '    $0\n' +
                                                  '</style>');
      registerDesignSnippet('<script>', '<script>', 'script>\n' +
                                                    '    $0\n' +
                                                    '</script>');
      registerDesignSnippet('<link>', '<link>', 'link href="${1}" type="text/css" rel="stylesheet" />');
      
      
      // CSS snippets
      registerDesignSnippet('Curved Borders', 'Curved Borders', '-webkit-border-radius: ${1:50%};\n' +
                                                               '-moz-border-radius: ${1:50%};\n' +
                                                               '-ms-border-radius: ${1:50%};\n' +
                                                               '-o-border-radius: ${1:50%};\n' +
                                                               'border-radius: ${1:50%};');
      registerDesignSnippet('border-radius', 'border-radius', '-webkit-border-radius: ${1:50%};\n' +
                                                               '-moz-border-radius: ${1:50%};\n' +
                                                               '-ms-border-radius: ${1:50%};\n' +
                                                               '-o-border-radius: ${1:50%};\n' +
                                                               'border-radius: ${1:50%};');
      registerDesignSnippet('box-sizing', 'box-sizing', '-webkit-box-sizing: ${1:border-box};\n' +
                                                        '-moz-box-sizing: ${1:border-box};\n' +
                                                        '-ms-box-sizing: ${1:border-box};\n' +
                                                        '-o-box-sizing: ${1:border-box};\n' +
                                                        'box-sizing: ${1:border-box};');
      registerDesignSnippet('transform', 'transform', '-webkit-transform: ${1:rotate(42deg)};\n' +
                                                      '-moz-transform: ${1:rotate(42deg)};\n' +
                                                      '-ms-transform: ${1:rotate(42deg)};\n' +
                                                      '-o-transform: ${1:rotate(42deg)};\n' +
                                                      'transform: ${1:rotate(42deg)};');
      
      registerDesignSnippet('Desktop Media Query', 'Desktop Media Query', '@media only screen and (max-width: 5000px) {\n' +
                                                                          '    $0\n' +
                                                                          '}');
      registerDesignSnippet('Tablet Media Query', 'Tablet Media Query', '@media only screen and (max-width: 768px) {\n' +
                                                                        '    $0\n' +
                                                                        '}');
      registerDesignSnippet('Phone Media Query', 'Phone Media Query', '@media only screen and (max-width: 321px) {\n' +
                                                                      '    $0\n' +
                                                                      '}');
  });//global registerDesignSnippet, window, GS, ml, encodeHTML
  //jslint white:true multivar:true
  
  window.addEventListener('design-register-element', function () {
      var strNormalCallbackContent = '    if (!error) {\n' +
                                     '        $0\n' +
                                     '    } else {\n' +
                                     '        GS.ajaxErrorDialog(data);\n' +
                                     '    }\n';
      
      registerDesignSnippet('JSON Ajax', 'JSON Ajax', 'GS.ajaxJSON(\'/env/${1:test.action_ship}\', \'${2:action=ship&id=}\', function (data, error) {\n' +
                                                          strNormalCallbackContent +
                                                      '});');
      registerDesignSnippet('GS.ajaxJSON', 'GS.ajaxJSON', 'GS.ajaxJSON(\'/env/${1:test.action_ship}\', \'${2:action=ship&id=}\', function (data, error) {\n' +
                                                              strNormalCallbackContent +
                                                          '});');
      
      
      registerDesignSnippet('TEXT Ajax', 'TEXT Ajax', 'GS.ajaxText(\'/env/${1:test.action_description}\', \'${2:action=get&id=}\', function (data, error) {\n' +
                                                          strNormalCallbackContent +
                                                      '});');
      registerDesignSnippet('GS.ajaxText', 'GS.ajaxText', 'GS.ajaxText(\'/env/${1:test.action_description}\', \'${2:action=get&id=}\', function (data, error) {\n' +
                                                              strNormalCallbackContent +
                                                          '});');
      
      registerDesignSnippet('PG FUNCTION AJAX', 'PG FUNCTION AJAX', 'GS.ajaxJSON(\'/env/${1:test.action_ship}\', \'${2:action=ship&id=}\', function (data, error) {\n' +
                                                    strNormalCallbackContent +
                                                '});');
      
      registerDesignSnippet('GS.ajaxErrorDialog', 'GS.ajaxErrorDialog', 'GS.ajaxErrorDialog(data,\n' +
                '                   function () {\n' +
                '                       // Try Again Button Callback\n' +
                '                       // delete this function if you dont want a try again button\n' +
                '                   },\n' +
                '                   function () {\n' +
                '                       // Cance Button Callback\n' +
                '                       // if you dont need to do anything when the cancel button is clicked: delete this function\n' +
                '                   });');
      
      registerDesignSnippet('GS.dataFetch', 'GS.dataFetch', 
              'function getData(bolClearPrevious) {\n' +
              '    var data, strLink, dataResultHandler, dataEventFunction;\n' +
              '    \n' +
              '    // create function that will use the data\n' +
              '    dataResultHandler = function (data, error) {\n' +
              '        \n' +
              '    };\n' +
              '    \n' +
              '    // save data from request or\n' +
              '    //     start ajax if it hasn\'t already gotten the data yet or\n' +
              '    //     start new ajax if bolClearPrevious is true\n' +
              '    data = GS.dataFetch(strLink, bolClearPrevious);\n' +
              '    \n' +
              '    // if this request already has been completed\n' +
              '    if (data) {\n' +
              '        // handle result\n' +
              '        dataResultHandler(data.response, data.error);\n' +
              '    } else {\n' +
              '        dataEventFunction = function (event) {\n' +
              '            // unbind data event function\n' +
              '            document.removeEventListener(\'dataready_\' + encodeURIComponent(strLink), dataEventFunction);\n' +
              '            \n' +
              '            // handle result\n' +
              '            dataResultHandler(event.detail.response, event.detail.error);\n' +
              '        };\n' +
              '        \n' +
              '        // bind data event function\n' +
              '        document.addEventListener(\'dataready_\' + encodeURIComponent(strLink), dataEventFunction);\n' +
              '    }\n' +
              '}');
      
  });
  
  (function () {
      'use strict';
      function ajaxCheckJSONResponseForError(request) {
          if (request.responseJSON) {
              if (request.responseJSON.stat === false) {
                  return true;
              }
          } else {
              return true;
          }
          
          return false;
      }
      
      function ajaxNormalizeError (request) {
          var response = request.response, jsnTemp, jsnRet = {
              'error_title': '',
              'error_hint': '',
              'error_text': '',
              'error_file': '',
              'error_context': '',
              'original_response': response
          };
          
          // get error title and error hint
          if (request.bolFrontEndTimeout === true) {
              jsnRet.error_text = 'Front-end Timeout Reached';
              jsnRet.error_title = 'Front-end Timeout Reached';
              jsnRet.error_hint = 'This request took too long. Please report this to a system administrator.';
              
          } else if (response.status === 403) {
              jsnRet.error_title = '403 Link Is Forbidden';
              jsnRet.error_hint = 'You have no permission to use this link. If you need this link contact a system administrator and request permission for this link.';
              
          } else if (response.status === 404) {
              jsnRet.error_title = '404 Link Could Not Be Found';
              jsnRet.error_hint = 'This link does not exist. Please report this to a system administrator.';
              
          } else if (response.status === 408) {
              jsnRet.error_title = '408 Request Took Too Long';
              jsnRet.error_hint = 'This link is broken. Please report this to a system administrator.';
              
          } else if (response.status === 500) {
              jsnRet.error_title = '500 Internal Server Error';
              jsnRet.error_hint = 'This call to the server failed. Please report this to a system administrator.';
              
          } else if (response.status === 502) {
              jsnRet.error_title = '502 Bad Gateway';
              jsnRet.error_hint = 'This link is broken. Please report this to a system administrator.';
              
          } else if (response.status === 504) {
              jsnRet.error_title = '504 Gateway Timeout';
              jsnRet.error_hint = 'This link is broken. Please report this to a system administrator.';
          }
          
          // get error text
          try {
              jsnTemp = JSON.parse(response.responseText || response).dat;
              
              jsnRet.error_text = jsnTemp.error;
              jsnRet.error_file = jsnTemp.filename;
              jsnRet.error_context = jsnTemp.context;
              
              if (!jsnRet.error_text) {
                  jsnRet.error_text = JSON.parse(response.responseText || response).dat;
              }
          } catch (err) {
              if (response) {
                  jsnRet.error_text = response.responseText || JSON.stringify(response);
              } else {
                  jsnRet.error_text = jsnRet.error_text || response;
              }
          }
          
          jsnRet.error_file = jsnRet.error_file || '';
          
          return jsnRet;
      }
      
      GS.ajaxJSON = function (strLink, strParams, callback, intTimeout) {
          var request = new XMLHttpRequest();
          
          callback = callback || function () {};
          
          request.onreadystatechange = function() {
              var normalizedError;
              
              // if expired cookie: go to login page
              if (request.readyState === 4) {
                  if (request.status === 440) {
                      window.location = '/index.html?error=Connection%20timed%20out&redirect=' + encodeURIComponent(window.location.pathname);
                  } else {
                      try {
                          request.responseJSON = JSON.parse(request.responseText || request.response);
                      } catch (e) {
                          //throw e;
                      }
                      
                      if (!ajaxCheckJSONResponseForError(request)) {
                          callback(request.responseJSON);
                          
                      } else {
                          normalizedError = ajaxNormalizeError(request);
                          
                          // if session error: have the user log back in and refresh
                          if ((normalizedError.error_text.indexOf('Session expired') === 0 ||
                              normalizedError.error_text.indexOf('No Cookie') !== -1 ||
                              normalizedError.error_text.indexOf('requires you to login') !== -1) &&
                              strLink.indexOf('action_info') === -1) {
                              GS.normalUserLogin(function () {
                                  window.location.reload();
                              }, '', request.responseJSON.dat.default_subdomain);
                              
                          // else: callback with normalized error
                          } else {
                              callback(normalizedError, 'error');
                          }
                      }
                  }
              }
          };
          
          request.open('POST', strLink + '?anticache=' + ((new Date()).getMilliseconds() + Math.floor(Math.random() * 1e9)), true);
          request.setRequestHeader('Content-type','application/x-www-form-urlencoded; charset=UTF-8');
          request.send(strParams);
          
          // if intTimeout has been set: start a timer to abort
          if (typeof intTimeout === 'number') {
              if (request && request.readyState !== 4) {
                  setTimeout(function() {
                      request.bolFrontEndTimeout = true;
                      request.abort();
                  }, intTimeout);
              }
          }
          
          return request;
      };
      
      GS.ajaxText = function (strLink, strParams, callback, intTimeout) {
          var request = new XMLHttpRequest();
          
          callback = callback || function () {};
          
          request.onreadystatechange = function() {
              var normalizedError;
              
              if (request.readyState === 4) {
                  if (request.status === 200) {
                      callback(request.responseText);
                      
                  } else if (request.status === 440) {
                      window.location = '/index.html?error=Connection%20timed%20out&redirect=' + encodeURIComponent(window.location.pathname);
                      
                  } else {
                      normalizedError = ajaxNormalizeError(request);
                      
                      // if session error: have the user log back in and refresh
                      if ((normalizedError.error_text.indexOf('Session expired') === 0 ||
                          normalizedError.error_text.indexOf('No Cookie') !== -1 ||
                          normalizedError.error_text.indexOf('requires you to login') !== -1) &&
                          strLink.indexOf('action_info') === -1) {
                          GS.normalUserLogin(function () {
                              window.location.reload();
                          }); //, '', JSON.parse(request.responseText || request.response).dat.default_subdomain
                          
                      // else: callback with normalized error
                      } else {
                          callback(normalizedError, 'error');
                      }
                  }
              }
          };
          
          request.open('POST', strLink + '?anticache=' + ((new Date()).getMilliseconds() + Math.floor(Math.random() * 1e9)), true);
          request.setRequestHeader('Content-type','application/x-www-form-urlencoded; charset=UTF-8');
          request.send(strParams);
          
          // if intTimeout has been set: start a timer to abort
          if (typeof intTimeout === 'number') {
              if (request && request.readyState !== 4) {
                  setTimeout(function() {
                      request.bolFrontEndTimeout = true;
                      request.abort();
                  }, intTimeout);
              }
          }
          
          return request;
      };
  }());
  
  (function () {
      "use strict";
      
      function cleanErrorValue(strValue) {
          strValue = strValue || '';
          
          if (strValue.indexOf('DB_exec failed:') !== -1) {
              strValue = strValue.replace(/[.\s\S]*DB_exec\ failed:/mi, '');
          }
          
          if (strValue.indexOf('Query failed:') !== -1) {
              strValue = strValue.replace(/[.\s\S]*Query\ failed:/mi, '');
          }
          
          if (strValue.indexOf('FATAL') !== -1) {
              strValue = strValue.replace(/[.\s\S]*FATAL/mi, '');
          }
          
          strValue = strValue
                          .replace(/\\?\\n/gi, '\n')
                          .replace(/\\?\\t/gi, '\t')
                          .replace(/\[.*\]/gi, '')
                          .replace(/\([0-9]*\)/gi, '');
          
          return GS.trim(strValue.trim(), '"');
      }
      
      function errorJSONToHTML(errorJSON) {
          var errorHTML = '<pre style="word-break: break-all; white-space: pre-wrap;">' +
                      'There was an error:' +
                      (errorJSON.error_text //TODO: maybe make this red -Joseph 09/14/16
                          ? '<br /><br />' + encodeHTML(GS.decodeFromTabDelimited(errorJSON.error_text))
                          : '') +
                      (errorJSON.error_file
                          ? '<br /><br />The error was on file: ' + encodeHTML(GS.decodeFromTabDelimited(errorJSON.error_file))
                          : '') +
                      (errorJSON.error_hint
                          ? '<br /><br />' + encodeHTML(GS.decodeFromTabDelimited(errorJSON.error_hint))
                          : '') +
                      (errorJSON.error_context
                          ? '<br /><br />' + encodeHTML(errorJSON.error_context)                     
                          : '') +
                      (errorJSON.error_addin
                          ? '<br /><br />' + encodeHTML(errorJSON.error_addin)                       
                          : '') +
                  '</pre>';
          return errorHTML;
      }
      
      GS.ajaxErrorDialog = function (jsnError, tryAgainCallback, cancelCallback) {
          'use strict';
          var templateElement = document.createElement('template'), strHTML;
          
          var jsnErrorCopy = {};
          jsnErrorCopy.error_text    = cleanErrorValue(jsnError.error_text);
          jsnErrorCopy.error_file    = cleanErrorValue(jsnError.error_file);
          jsnErrorCopy.error_hint    = cleanErrorValue(jsnError.error_hint);
          jsnErrorCopy.error_context = cleanErrorValue(jsnError.error_context);
          jsnErrorCopy.error_addin   = cleanErrorValue(jsnError.error_addin);
          
          templateElement.setAttribute('data-theme', 'error');
          strHTML = ml(function () {/*
              <gs-page>
                  <gs-header><center><h3>There was an error!</h3></center></gs-header>
                  <gs-body padded>
                      {{HTML}}
                      <gs-button class="error-button-show-full-text">Show Full Error Text</gs-button>
                  </gs-body>
                  <gs-footer>{{BUTTONS}}</gs-footer>
              </gs-page>
          */}).replace('{{HTML}}', errorJSONToHTML(jsnErrorCopy));
          
          
          var openFunction = function () {
              xtag.query(this, '.error-button-show-full-text')[0].addEventListener('click', function () {
                  var templateElement = document.createElement('template');
                  
                  templateElement.innerHTML = ml(function () {/*
                      <gs-page>
                          <gs-header><center><h3>Full Error Text</h3></center></gs-header>
                          <gs-body padded>
                              {{HTML}}
                          </gs-body>
                          <gs-footer><gs-button dialogclose>Done</gs-button></gs-footer>
                      </gs-page>
                  */}).replace('{{HTML}}', errorJSONToHTML(jsnError));
                  
                  GS.openDialog(templateElement);
              });
          };
          
          
          if (typeof tryAgainCallback === 'function') {
              templateElement.innerHTML = strHTML.replace('{{BUTTONS}}',
                          '<gs-grid>' +
                          '   <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>' +
                          '   <gs-block><gs-button dialogclose listen-for-return>Try Again</gs-button></gs-block>' +
                          '</gs-grid>');
              GS.openDialog(templateElement, openFunction, function (event, strAnswer) {
                  if (strAnswer === 'Try Again') {
                      tryAgainCallback(strAnswer);
                  } else {
                      if (typeof cancelCallback === 'function') {
                          cancelCallback(strAnswer);
                      }
                  }
              });
          } else {
              templateElement.innerHTML = strHTML.replace('{{BUTTONS}}', '<gs-button dialogclose listen-for-return>Ok</gs-button>');
              GS.openDialog(templateElement, openFunction);
          }
      };
      
  }());
  
  /*
  
  var strLink = '/env/action_select?view=wtkv2.ttime&where=user_name%20%3D%20\'michael%40tocci.org\'&offset=0&limit=25&order_by=id%20DESC&header=true';
  
  document.addEventListener('dataready_' + encodeURIComponent(strLink), function (event) {
      console.log(event);
  });f
  
  dataFetch(strLink, false);
  
  */
  
  if (GS.dataLedger === undefined) {
      GS.dataLedger = {};
  }
  
  GS.dataFetch = function (strLink, bolClearPrevious) {
      'use strict';
      var arrLinkParts = strLink.split('?'), strId = encodeURIComponent(strLink);
      
      // if something wants to fetch data where the id does not already exist then do an ajax call 
      if (GS.dataLedger[strId] === undefined || bolClearPrevious === true) {
          
          GS.dataLedger[strId] = {'status': 'waiting', 'response': ''};
          
          GS.ajaxJSON(arrLinkParts[0], arrLinkParts[1] || '', function (data, error) {
              var event; // The custom event that will be created
              
              if (document.createEvent) {
                  event = document.createEvent('HTMLEvents');
                  event.initEvent('dataready_' + strId, true, true);
                  event.eventName = 'dataready_' + strId;
              } else {
                  event = document.createEventObject();
                  event.eventType = 'dataready_' + strId;
                  event.eventName = 'dataready_' + strId;
              }
              
              if (!error) {
                  GS.dataLedger[strId].response = (data.dat !== undefined ? data.dat : data);
                  GS.dataLedger[strId].status = 'finished';
                  
                  event.detail = {'response': GS.dataLedger[strId].response};
                  
              } else {
                  GS.dataLedger[strId].data = data;
                  GS.dataLedger[strId].status = 'error';
                  GS.dataLedger[strId].error = 'error';
                  
                  event.detail = {'response': data, 'error': 'error'};
              }
              
              if (document.createEvent) {
                  document.dispatchEvent(event);
              } else {
                  document.fireEvent('on' + event.eventType, event);
              }
          });
          
          return '';
      }
      
      if (GS.dataLedger[strId].status === 'finished' || GS.dataLedger[strId].status === 'error') {
          return GS.dataLedger[strId];
      }
      
      return '';
  };
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('GS.findParentTag', 'GS.findParentTag', 'GS.findParentTag(${1:element}, \'${0:tag-to-find}\');');
      
      registerDesignSnippet('GS.findParentElement', 'GS.findParentElement',
                                                      'GS.findParentElement(${1:element}, ${0:\'selector, element or function\'});');
      
      registerDesignSnippet('GS.insertElementAfter', 'GS.insertElementAfter',
                                                      'GS.insertElementAfter(${1:elementToInsert}, \'${0:elementToInsertAfter}\');');
      
      registerDesignSnippet('GS.getElementOffset', 'GS.getElementOffset', 'GS.getElementOffset(${0:element});');
      
      registerDesignSnippet('GS.animateStyle', 'GS.animateStyle',
                                              'GS.animateStyle(${1:elementToAnimate}, ' +
                                                              '${2:CSSPropertyToAnimate}, ' +
                                                              '${3:startValue}, ' +
                                                              '${4:endValue}, ' +
                                                              '${5:callbackAfterAnimation}, ' +
                                                              '${6:durationInMilliseconds}, ' +
                                                              '${0:numberOfFrames});');
      
      registerDesignSnippet('GS.stringToElement', 'GS.stringToElement', 'GS.stringToElement(\'${0:<div>your HTML here</div>}\');');
      
      registerDesignSnippet('GS.cloneElement', 'GS.cloneElement', 'GS.cloneElement(${0:element});');
      
      registerDesignSnippet('GS.isElementFocusable', 'GS.isElementFocusable', 'GS.isElementFocusable(${0:element});');
      
      registerDesignSnippet('GS.scrollParent', 'GS.scrollParent', 'GS.scrollParent(${0:element});');
      
      registerDesignSnippet('GS.scrollIntoView', 'GS.scrollIntoView', 'GS.scrollIntoView(${0:element});');
      
      registerDesignSnippet('GS.getInputSelection', 'GS.getInputSelection', 'GS.getInputSelection(${0:inputOrTextareaElement});');
      
      registerDesignSnippet('GS.setInputSelection', 'GS.setInputSelection',
                                      'GS.setInputSelection(${1:inputOrTextareaElement}, ${2:startAtNumber}, ${0:endAtNumber});');
      
      registerDesignSnippet('GS.getElementPositionData', 'GS.getElementPositionData', 'GS.getElementPositionData(${0:element});');
  });
  
  // #################################################################
  // #################### DOM TRAVERSAL FUNCTIONS ####################
  // #################################################################
  
  // loop through parents until tag is found
  GS.findParentTag = function (element, strTagName) {
      'use strict';
      var currentElement = element.parentNode;
      
      strTagName = strTagName.toUpperCase();
      
      while (currentElement && currentElement.nodeName !== strTagName && currentElement.nodeName !== 'HTML') {
          currentElement = currentElement.parentNode;
      }
      
      if (!currentElement || currentElement.nodeName !== strTagName) {
          return undefined;
      }
      
      return currentElement;
  };
  
  // loop through parents until checkParameter is satisfied or we run into HTML
  GS.findParentElement = function (element, checkParameter) {
      'use strict';
      var currentElement = element;
      
      // if checkParameter is a function: use it to check the element
      if (typeof checkParameter === 'function') {
          while (currentElement && !checkParameter(currentElement) && currentElement.nodeName !== 'HTML') {
              currentElement = currentElement.parentNode;
          }
          
      // else if checkParameter is a string: use checkParameter as a selector string and use xtag.matchSelector
      } else if (typeof checkParameter === 'string') {
          while (currentElement && !xtag.matchSelector(currentElement, checkParameter) && currentElement.nodeName !== 'HTML') {
              currentElement = currentElement.parentNode;
          }
          
      // else: assume checkParameter is an element and use ===
      } else {
          while (currentElement && currentElement !== checkParameter && currentElement.nodeName !== 'HTML') {
              currentElement = currentElement.parentNode;
          }
      }
      
      if (!currentElement) {
          return undefined;
      }
      
      return currentElement;
  };
  
  
  // ################################################################
  // #################### HTML ELEMENT FUNCTIONS ####################
  // ################################################################
  
  // insert element after another element
  GS.insertElementAfter = function (elementToInsert, target) {
      if (target.nextElementSibling) {
          target.parentNode.insertBefore(elementToInsert, target.nextElementSibling);
      } else {
          target.parentNode.appendChild(elementToInsert);
      }
  };
  
  // get element's position on the screen
  GS.getElementOffset = function (element) {
      'use strict';
      var intX = 0, intY = 0, ret;
      
      if (element.getBoundingClientRect) {
          ret = element.getBoundingClientRect();
          
      } else {
          while (element && element.nodeName !== 'HTML') {
              intX += element.offsetLeft - element.scrollLeft;// + element.clientLeft;
              intY += element.offsetTop - element.scrollTop;// + element.clientTop;
              
              //console.log(element.offsetTop, element.scrollTop, element);
              
              element = element.parentNode; //element.offsetParent
          }
          
          ret = {
              left: intX,
              top: intY
          };
      }
      
      return ret;
  };
  
  //
  GS.animateStyle = function (element, strStyleProperty, strStart, strEnd, callback, intDuration, intFrames) {
      var intStart         = parseInt(strStart, 10),
          intEnd           = parseInt(strEnd, 10),
          strStartUnit     = strStart.replace(/[0-9\.-]/gi, '').toLowerCase(),
          //strEndUnit       = strEnd.replace(/[0-9\.-]/gi, '').toLowerCase(),
          intFrameDuration = intDuration / intFrames,
          i, timeoutFunction, intCurrent, intJump;
      
      //if (strStartUnit !== 'em' && strStartUnit !== 'px' && strStartUnit !== '') {
      //    throw 'animateStyle error: strStart has an invalid unit, use px or em or nothing';
      //    
      //} else if (strEndUnit !== 'em' && strEndUnit !== 'px' && strEndUnit !== '') {
      //    throw 'animateStyle error: strEnd has an invalid unit, use px or em or nothing';
      //    
      //} else {
      intCurrent = intStart;
      intJump = (intEnd - intStart) / intFrames;
      i = 1;
      
      element.style[strStyleProperty] = strStart;
      
      timeoutFunction = function () {
          setTimeout(function () {
              intCurrent += intJump;
              //element.style[strStyleProperty] = intCurrent + strStartUnit;
              //console.log(intCurrent, i, intFrames, element, element.style[strStyleProperty], intStart, intCurrent, strStartUnit);
              
              if (i < intFrames) {
                  element.style[strStyleProperty] = intCurrent + strStartUnit;
                  i += 1;
                  timeoutFunction();
              } else {
                  element.style[strStyleProperty] = strEnd;
                  callback();
              }
          }, intFrameDuration);
      };
      
      timeoutFunction();
      //}
  };
  
  //
  GS.stringToElement = function (strHTML, optionalTargetDocument) {
      var strFirstTagName, parentElement, indexInElement, parsedElement, targetDocument;
      
      if (optionalTargetDocument) {
          targetDocument = optionalTargetDocument;
      } else {
          targetDocument = document;
      }
      
      //console.log(strFirstTagName);
      
      strFirstTagName = strHTML.substring(strHTML.indexOf('<') + 1, strHTML.indexOf('>'));
      
      //console.log(strFirstTagName);
      
      if (strFirstTagName.indexOf(' ') > -1) {
          strFirstTagName = strFirstTagName.substring(0, strFirstTagName.indexOf(' '));
      }
      
      //console.log(strFirstTagName);
      
      if (strFirstTagName === 'body') {
          parentElement = targetDocument.createElement('html');
          indexInElement = 1;
          
      } else if (strFirstTagName === 'thead' || strFirstTagName === 'tbody') {
          parentElement = targetDocument.createElement('table');
          indexInElement = 0;
          
      } else if (strFirstTagName === 'tr') {
          parentElement = targetDocument.createElement('tbody');
          indexInElement = 0;
          
      } else if (strFirstTagName === 'td' || strFirstTagName === 'th') {
          parentElement = targetDocument.createElement('tr');
          indexInElement = 0;
          
      } else if (strFirstTagName === 'li') {
          parentElement = targetDocument.createElement('ul');
          indexInElement = 0;
      } else {
          parentElement = targetDocument.createElement('div');
          indexInElement = 0;
      }
      
      parentElement.innerHTML = strHTML;
      parsedElement = parentElement.children[indexInElement];
      
      //console.log(strFirstTagName, parsedElement);
      
      return parsedElement;
  };
  
  //
  GS.cloneElement = function (element, optionalTargetDocument) {
      // if there is a template element in the element: copy the element without cloneNode because for some reason cloneNode breaks templates on IOS
      if (xtag.query(element, 'template').length > 0 || optionalTargetDocument) {
          return GS.stringToElement(element.outerHTML, optionalTargetDocument);
      }
      
      // else: just use cloneNode
      return element.cloneNode(true);
  };
  
  /*
  // change the tag of an element
  GS.changeElementTag = function (element, strNewTag, alterCallback) {
      var strHTML = element.outerHTML.trim(), newElement;
      
      strHTML = '<' + strNewTag + strHTML.substring(strHTML.indexOf(' '), strHTML.lastIndexOf('</')) + '</' + strNewTag + '>';
      
      //console.log(strHTML);
      
      newElement = GS.stringToElement(strHTML);
      
      if (typeof alterCallback === 'function') {
          alterCallback.apply(newElement);
      }
      
      return newElement;
  };*/
  
  // check to see if an element is focusable
  GS.isElementFocusable = function (element) {
      return  (
                  element.nodeName === 'INPUT' ||
                  element.nodeName === 'TEXTAREA' ||
                  element.nodeName === 'SELECT' ||
                  element.nodeName === 'BUTTON' ||
                  element.nodeName === 'IFRAME' ||
                  (element.hasAttribute('tabindex') && element.getAttribute('tabindex') !== '-1') ||
                  (element.focus &&
                      element.focus.toString().indexOf('[native code]') === -1 &&
                      element.focus.toString() !== document.createElement('div').focus.toString()) ||
                  (
                      element.nodeName === 'A' &&
                      element.hasAttribute('href')
                  ) ||
                  (
                      element.nodeName === 'AREA' &&
                      element.hasAttribute('href')
                  )
              ) &&
              !element.hasAttribute('disabled');
  };
  
  // see function in 006-utl.js
  //// search for a parent with a scrollbar
  //GS.scrollParent = function (element) {
  //    var i = 0, currentElement = element, bolFoundScrollable = false, strOverflow;
  //    
  //    if (currentElement) {
  //        while (currentElement && currentElement.nodeName !== 'HTML' && bolFoundScrollable === false && i < 75) {
  //            strOverflow = GS.getStyle(currentElement, 'overflow');
  //            
  //            if (strOverflow === 'scroll' || (strOverflow === 'auto' && currentElement.clientHeight < currentElement.scrollHeight)) {
  //                bolFoundScrollable = true;
  //            } else {
  //                currentElement = currentElement.parentNode;
  //                i += 1;
  //            }
  //        }
  //        return bolFoundScrollable ? currentElement : undefined;
  //    }
  //    return undefined;
  //};
  // see function in 006-utl.js
  // scroll an element to the middle of its scrollparent
  // GS.scrollIntoView = function (element) {
  //     var scrollingContainer = GS.scrollParent(element), arrSiblings, i, len, intScrollTop;
  //     console.log(scrollingContainer);
  //     if (scrollingContainer) {
  //         //console.log(scrollingContainer);
          
  //         arrSiblings = element.parentNode.children;
          
  //         for (i = 0, intScrollTop = 0, len = arrSiblings.length; i < len; i += 1) {
  //             if (arrSiblings[i] === element) {
  //                 intScrollTop += arrSiblings[i].offsetHeight / 2;
                  
  //                 break;
  //             } else {
  //                 intScrollTop += arrSiblings[i].offsetHeight;
  //             }
  //         }
          
  //         intScrollTop = intScrollTop - (scrollingContainer.offsetHeight / 2);
          
  //         //console.log(intScrollTop);
          
  //         scrollingContainer.scrollTop = intScrollTop;
  //     }
  // };
  
  
  // GS.scrollIntoView = function (element, strDirection) {
  //     var strDirectionText;
  //     if (strDirection) {
  //         strDirectionText = strDirection;
  //     } else {
  //         strDirectionText = 'vertical';
  //     }
  //     var scrollingContainer = GS.scrollParent(element, strDirectionText), arrSiblings, i, len, intScrollTop;
      
      
  //     if (scrollingContainer) {
          
  //         arrSiblings = element.parentNode.children;
          
  //         for (i = 0, intScrollTop = 0, len = arrSiblings.length; i < len; i += 1) {
  //             if (arrSiblings[i] === element) {
  //                 intScrollTop += arrSiblings[i].offsetHeight / 2;
                  
  //                 break;
  //             } else {
  //                 intScrollTop += arrSiblings[i].offsetHeight;
  //             }
  //         }
          
  //         intScrollTop = intScrollTop - (scrollingContainer.offsetHeight / 2);
          
  //         //console.log(intScrollTop);
          
  //         scrollingContainer.scrollTop = intScrollTop;
  //     }
  // };
  
  
  
  
  
  
  // #################################################################
  // ################### INPUT SELECTION FUNCTIONS ###################
  // #################################################################
  
  GS.getInputSelection = function (input) {
      'use strict';
      var start = 0, end = 0, normalizedValue, range, textInputRange, len, endRange;
      
      if (typeof input.selectionStart === "number" && typeof input.selectionEnd === "number") {
          start = input.selectionStart;
          end = input.selectionEnd;
      } else {
          range = (document.createRange() || document.selection.createRange());
          
          if (range && range.parentElement() == input) {
              len = input.value.length;
              normalizedValue = input.value.replace(/\r\n/g, "\n");
              
              // Create a working TextRange that lives only in the input
              textInputRange = input.createTextRange();
              textInputRange.moveToBookmark(range.getBookmark());
              
              // Check if the start and end of the selection are at the very end
              // of the input, since moveStart/moveEnd doesn't return what we want
              // in those cases
              endRange = input.createTextRange();
              endRange.collapse(false);
              
              if (textInputRange.compareEndPoints("StartToEnd", endRange) > -1) {
                  start = end = len;
              } else {
                  start = -textInputRange.moveStart("character", -len);
                  start += normalizedValue.slice(0, start).split("\n").length - 1;
                  
                  if (textInputRange.compareEndPoints("EndToEnd", endRange) > -1) {
                      end = len;
                  } else {
                      end = -textInputRange.moveEnd("character", -len);
                      end += normalizedValue.slice(0, end).split("\n").length - 1;
                  }
              }
          }
      }
      
      return {
          start: start,
          end: end
      };
  };
  
  GS.setInputSelection = function (input, intStart, intEnd) {
      'use strict';
      var range;
      
      if (intStart === undefined || intStart === '' || isNaN(intStart) || intStart === null) {
          intStart = input.value.length;
      }
      
      if (intEnd === undefined || intEnd === '' || isNaN(intEnd) || intEnd === null) {
          intEnd = intStart;
      }
      
      if (input.createTextRange) {
          range = input.createTextRange();
          range.collapse();
          range.moveStart('character', intStart);
          range.collapse();
          range.moveEnd('character', intEnd);
          range.select();
      } else if (input.setSelectionRange) {
          input.focus();
          input.setSelectionRange(intStart, intEnd);
      }
  };
  
  
  // #################################################################
  // ################### ELEMENT POSITION FUNCTION ###################
  // #################################################################
  
  // return a whole bunch of position data variables for an element
  GS.getElementPositionData = function (element) {
      var objElementOffset  = GS.getElementOffset(element),
          intElementWidth   = element.offsetWidth,
          intElementHeight  = element.offsetHeight,
          intElementTop     = objElementOffset.top,
          intElementLeft    = objElementOffset.left,
          intElementBottom  = window.innerHeight - (intElementTop    + intElementHeight),
          intElementRight   = window.innerWidth  - (intElementLeft   + intElementWidth),
          intRoomAbove      = window.innerHeight - (intElementBottom + intElementHeight),
          intRoomBelow      = intElementBottom,
          intRoomLeft       = window.innerWidth  - (intElementRight  + intElementWidth),
          intRoomRight      = intElementRight;
      
      /*console.log(element, '\n' +
                  'intElementWidth:   ' + intElementWidth + '\n' +
                  'intElementHeight:  ' + intElementHeight + '\n' +
                  'intElementTop:     ' + intElementTop + '\n' +
                  'intElementBottom:  ' + intElementBottom + '\n' +
                  'intElementLeft:    ' + intElementLeft + '\n' +
                  'intElementRight:   ' + intElementRight + '\n' +
                  'intRoomAbove:      ' + intRoomAbove + '\n' +
                  'intRoomBelow:      ' + intRoomBelow + '\n' +
                  'intRoomLeft:       ' + intRoomLeft + '\n' +
                  'intRoomRight:      ' + intRoomRight);*/
      
      return {
          'element':           element,
          'objElementOffset':  objElementOffset,
          'intElementWidth':   intElementWidth,
          'intElementHeight':  intElementHeight,
          'intElementTop':     intElementTop,
          'intElementLeft':    intElementLeft,
          'intElementBottom':  intElementBottom,
          'intElementRight':   intElementRight,
          'intRoomAbove':      intRoomAbove,
          'intRoomBelow':      intRoomBelow,
          'intRoomLeft':       intRoomLeft,
          'intRoomRight':      intRoomRight
      };
  };
  
  // #################################################################
  // ####################### DOCUMENT FRAGMENT #######################
  // #################################################################
  /*                                       ,--- the problem with this code is the DOM we get back is not 100% reliably inert. 
                                           V          To make it reliable I believe I have to change how my elements work.
  GS.createDocumentFragment = function (strHTML) {
      'use strict';
      var element = document.createElement('div'),
          fragment = document.createDocumentFragment(),
          arrChildren = element.childNodes;
      
      // fill element with HTML
      element.innerHTML = strHTML;
      
      // append the element to the body (NECCESSARY FOR THE HTML TO BE INERT, I DON'T KNOW WHY -michael)
      document.body.appendChild(element);
      
      // transfer children from element to fragment
      while (arrChildren[0]) {
          fragment.appendChild(arrChildren[0]);
      }
      
      // remove element from the body
      document.body.removeChild(element);
      
      // return inert fragment
      return fragment;
  };
  
  GS.getDocumentFragmentHTML = function (fragment) {
      'use strict';
      var strHTML, i, len, arrChildren = fragment.children;
      
      for (strHTML = '', i = 0, len = arrChildren.length; i < len; i += 1) {
          strHTML += arrChildren[i].outerHTML;
      }
      
      return strHTML;
  };
  */
  
  // #################################################################
  // ########################### INERT DOM ###########################
  // #################################################################
  /*tell papa if you uncomment
  GS.createInertDOM = function (strHTML) {
      'use strict';
      var templateElement = document.createElement('template'), iframeElement;
      
      // if the content property is on a template element: no iframe neccessary
      if ('content' in templateElement) {
          templateElement.innerHTML = strHTML;
          
          return templateElement.content;
          
      // else: use iframe to create inert HTML
      } else {
          if (!document.getElementById('gs-inert-dom-generator')) {
              iframeElement = document.createElement('iframe');
              
              iframeElement.setAttribute('id', 'gs-inert-dom-generator');
              iframeElement.setAttribute('hidden', '');
              
              document.body.appendChild(iframeElement);
              
          } else {
              iframeElement = document.getElementById('gs-inert-dom-generator');
          }
          
          iframeElement.contentWindow.inertDOM = iframeElement.contentWindow.document.createElement('div');
          iframeElement.contentWindow.inertDOM.innerHTML = strHTML;
          
          return iframeElement.contentWindow.inertDOM;
      }
  };
  
  GS.getInertDOMHTML = function (inertDOM) {
      'use strict';
      var strHTML, i, len, arrChildren = inertDOM.children;
      
      for (strHTML = '', i = 0, len = arrChildren.length; i < len; i += 1) {
          strHTML += arrChildren[i].outerHTML;
      }
      
      return strHTML;
  };
  */
  
  // ##################################################################
  // ###################### TABLE COPY/SELECTION ######################
  // ##################################################################
  (function () {
      'use strict';
      function getCellFromTarget(element) {
          var currentElement = element;
          
          while (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH' && currentElement.nodeName !== 'HTML') {
              currentElement = currentElement.parentNode;
          }
          
          if (currentElement && currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH') {
              return undefined;
          }
          
          return currentElement;
      }
      
      function selectHandler(tableElement, dragOrigin, dragCurrentCell, dragMode) {
          var bolThead, bolFirstTh, arrRecords, arrCells, arrRecordsToAffect = [], arrCellsToAffect = [],
              arrNewSelection = [], arrCellsToRemoveFromSelection = [], i, len, intFrom, intTo;
          
          arrRecords = xtag.query(tableElement, 'tr');
          arrCells = xtag.query(tableElement, 'td, th');
          
          if (arrRecords.length > 0) {
              bolThead = Boolean(xtag.queryChildren(tableElement, 'thead')[0]);
              
              if ((bolThead && arrRecords.length > 1) || (!bolThead && arrRecords > 0)) {
                  if (bolThead) {
                      bolFirstTh = arrRecords[1].children[0].nodeName === 'TH';
                  } else {
                      bolFirstTh = arrRecords[0].children[0].nodeName === 'TH';
                  }
              }
              
              // if origin & currentCell are both the top-left cell and the cell is a heading: select all cells
              if (bolThead && bolFirstTh &&
                  dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0 &&
                  dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                  arrCellsToAffect = arrCells;
                  
              // else if origin & currentCell are both first ths: select the records from origin to currentCell
              } else if (bolFirstTh && dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                  arrRecordsToAffect =
                      arrRecords.slice(Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                                       Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1);
                  
                  for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                      Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
                  }
                  
              // else if origin & currentCell are both headings: select the columns from origin to currentCell
              } else if (bolThead && dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0) {
                  intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                  intTo   = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;
                  
                  for (i = 0, len = arrRecords.length; i < len; i += 1) {
                      Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecords[i].children).slice(intFrom, intTo));
                  }
                  
              //// else if origin & currentCell are the same cell: select the record
              //} else if (dragOrigin === dragCurrentCell) {
              //    arrRecordsToAffect = arrRecords.slice(dragOrigin.parentNode.rowIndex, dragOrigin.parentNode.rowIndex + 1);
              //    
              //    for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
              //        Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
              //    }
              //    
              // else select cells from origin to currentCell
              } else {
                  arrRecordsToAffect =
                      arrRecords.slice(Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                                       Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1);
                  
                  intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                  intTo   = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;
                  
                  for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                      Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children).slice(intFrom, intTo));
                  }
              }
              
              if (dragMode === 'select') {
                  // add new cells to tableElement.selectionSelectedCells
                  for (i = 0, len = tableElement.selectionSelectedCells.length; i < len; i += 1) {
                      if (arrCellsToAffect.indexOf(tableElement.selectionSelectedCells[i]) === -1) {
                          arrCellsToRemoveFromSelection.push(tableElement.selectionSelectedCells[i]);
                      }
                  }
                  tableElement.selectionSelectedCells = arrCellsToAffect;
                  
                  // add new cells to tableElement.selectedCells
                  arrNewSelection = tableElement.selectedCells;
                  for (i = 0, len = arrCellsToAffect.length; i < len; i += 1) {
                      GS.listAdd(arrNewSelection, arrCellsToAffect[i]);
                  }
                  for (i = 0, len = arrCellsToRemoveFromSelection.length; i < len; i += 1) {
                      arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToRemoveFromSelection[i]), 1);
                  }
                  tableElement.selectedCells = arrNewSelection;
                  
              } else { // implied if: dragMode === 'deselect'
                  // deselect cells from arrCellsToAffect
                  arrNewSelection = tableElement.selectedCells;
                  
                  for (i = 0, len = arrCellsToAffect.length; i < len; i += 1) {
                      if (arrNewSelection.indexOf(arrCellsToAffect[i]) > -1) {
                          arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToAffect[i]), 1);
                      }
                  }
                  tableElement.selectedCells = arrNewSelection;
              }
          }
      }
      
      
      
      
      
      
      function getSelectedCopyHTML(element) {
          var strHTMLCopyString, intFromRecord, intToRecord, intFromCell = 9999999, intToCell = 0
            , i, len, cell_i, cell_len, arrSelected, strCellHTML, arrRecords, arrCells
            , strHTMLRecordString, strNull, bolColumns;
          
          arrSelected = element.selectedCells;
          
          strNull    = (element.getAttribute('null-values')  || "NULL");
          bolColumns = (element.getAttribute('column-names') || "true") === "true";
          
          // loop through the selected cells and create an html string using the text of the cell
          if (arrSelected.length > 0) {
              intFromRecord = arrSelected[0].parentNode.rowIndex;
              intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;
              
              for (i = 0, len = arrSelected.length; i < len; i += 1) {
                  if (arrSelected[i].cellIndex < intFromCell) {
                      intFromCell = arrSelected[i].cellIndex;
                      intFromCell = (intFromCell === 0 ? 1 : intFromCell);
                  }
                  if (arrSelected[i].cellIndex + 1 > intToCell) {
                      intToCell = arrSelected[i].cellIndex + 1;
                  }
              }
              
              arrRecords = xtag.query(element, 'tr');
              strHTMLCopyString = '';
              
              // if bolColumns is true and the first record is not selected: add first record first
              if (bolColumns && intFromRecord > 0) {
                  arrCells = arrRecords[0].children;
                  strHTMLRecordString = '';
                  
                  for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                      strCellHTML = '';
                      
                      if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) {
                          strCellHTML = arrCells[cell_i].firstElementChild.textValue ||
                                        arrCells[cell_i].firstElementChild.value ||
                                        (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                        arrCells[cell_i].firstElementChild.textContent || '';//.trim();
                          
                      } else if (arrCells[cell_i].lastElementChild) { 
                          strCellHTML = arrCells[cell_i].lastElementChild.textValue ||
                                        arrCells[cell_i].lastElementChild.value ||
                                        (arrCells[cell_i].lastElementChild.checked || '').toString() ||
                                        arrCells[cell_i].lastElementChild.textContent || '';
                      } else {
                          strCellHTML = arrCells[cell_i].textContent;//.trim();
                      }
                      
                      strCellHTML = encodeHTML(strCellHTML).replace(/\n/gim, '<br />');
                      
                      strCellHTML = '<' + 'td rowspan="1" colspan="1">' + (strCellHTML || '') + '</td>'
                      
                      strHTMLRecordString += (cell_i === intFromCell ? '<' + 'tr>' : '');
                      strHTMLRecordString += (strCellHTML || '');
                      strHTMLRecordString += (cell_i === (intToCell - 1) ? '<' + '/tr>' : '');
                  }
                  
                  if (strHTMLRecordString.trim()) {
                      strHTMLCopyString += strHTMLRecordString;
                  }
              }
              
              for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                  arrCells = arrRecords[i].children;
                  strHTMLRecordString = '';
                  
                  if (!arrRecords[i].classList.contains('insert-record')) {
                      for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                          strCellHTML = '';
                          
                          if (arrCells[cell_i].hasAttribute('selected') || (i === 0 && bolColumns)) {
                              if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) {
                                  strCellHTML = arrCells[cell_i].firstElementChild.textValue ||
                                                arrCells[cell_i].firstElementChild.value ||
                                                (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                                arrCells[cell_i].firstElementChild.textContent || '';//.trim();
                                  
                              } else if (arrCells[cell_i].lastElementChild) { 
                                  strCellHTML = arrCells[cell_i].lastElementChild.textValue ||
                                                arrCells[cell_i].lastElementChild.value ||
                                                (arrCells[cell_i].lastElementChild.checked || '').toString() ||
                                                arrCells[cell_i].lastElementChild.textContent || '';
                              } else {
                                  strCellHTML = arrCells[cell_i].textContent;//.trim();
                              }
                              
                              strCellHTML = encodeHTML(strCellHTML).replace(/\n/gim, '<br />');
                              
                              if (strCellHTML === 'NULL' || strCellHTML === '\N') {
                                  strCellHTML = strNull;
                              }
                          }
                          
                          strCellHTML = '<' + 'td rowspan="1" colspan="1">' + (strCellHTML || '') + '</td>'
                          
                          strHTMLRecordString += (cell_i === intFromCell ? '<' + 'tr>' : '');
                          strHTMLRecordString += (strCellHTML || '');
                          strHTMLRecordString += (cell_i === (intToCell - 1) ? '<' + '/tr>' : '');
                      }
                  }
                  if (strHTMLRecordString.trim()) {
                      strHTMLCopyString += strHTMLRecordString;
                  }
              }
              //console.log('*****', strHTMLCopyString);
              if (strHTMLCopyString) {
                  strHTMLCopyString = '<' + 'style>' +
                                          'br { mso-data-placement:same-cell; } ' +
                                          'th, td { white-space: pre-wrap; }' +
                                      '<' + '/style>' +
                                      '<' + 'table border="0" cellpadding="0" cellspacing="0">' + strHTMLCopyString + '<' + '/table>';
              }
          }
          
          return strHTMLCopyString || '';
      }
      
      function getSelectedCopyText(element) {
          var strTextCopyString, intFromRecord, intToRecord, intFromCell = 9999999, intToCell = 0,
              i, len, cell_i, cell_len, arrSelected, strCellText, arrRecords, arrCells, arrCellIndexes, strTextRecordString,
              strQuoteType, strQuoteChar, strFieldDelimiter, strRowDelimiter, strNull, bolColumns, quoteRegex;
          
          strQuoteType      = (element.getAttribute('quote-type')      || "strings");
          strQuoteChar      = (element.getAttribute('quote-char')      || '"');
          strFieldDelimiter = (element.getAttribute('field-delimiter') || "\t");
          strNull           = (element.getAttribute('null-values')     || "NULL");
          bolColumns        = (element.getAttribute('column-names')    || "true") === "true";
          strRowDelimiter   = (element.getAttribute('row-delimiter')   || "\n");
          
          quoteRegex = new RegExp(strQuoteChar, 'g');
          
          arrSelected = element.selectedCells;
          
          // loop through the selected cells and create a tsv string using the text of the cell
          if (arrSelected.length > 0) {
              intFromRecord = arrSelected[0].parentNode.rowIndex;
              intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;
              
              for (i = 0, len = arrSelected.length; i < len; i += 1) {
                  if (arrSelected[i].cellIndex < intFromCell) {
                      intFromCell = arrSelected[i].cellIndex;
                      intFromCell = (intFromCell === 0 ? 1 : intFromCell);
                  }
                  if (arrSelected[i].cellIndex + 1 > intToCell) {
                      intToCell = arrSelected[i].cellIndex + 1;
                  }
              }
              
              arrRecords = xtag.query(element, 'tr');
              strTextCopyString = '';
              
              // if bolColumns is true and the first record is not selected: add first record first
              if (bolColumns && intFromRecord > 0) {
                  arrCells = arrRecords[0].children;
                  strTextRecordString = '';
                  
                  for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                      strCellText = '';
                      
                      if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) {
                          strCellText = arrCells[cell_i].firstElementChild.textValue ||
                                        arrCells[cell_i].firstElementChild.value ||
                                        (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                        arrCells[cell_i].firstElementChild.textContent || '';//.trim();
                          
                      } else if (arrCells[cell_i].lastElementChild) {
                          strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                        arrCells[cell_i].lastElementChild.value ||
                                        (arrCells[cell_i].lastElementChild.checked || '').toString();
                      } else {
                          strCellText = arrCells[cell_i].textContent;//.trim();
                      }
                      
                      strCellText = strCellText.replace(quoteRegex, (strQuoteChar + strQuoteChar));
                      
                      if (strCellText === 'NULL' || strCellText === '\N') {
                          strCellText = strNull;
                      } else {
                          if (strQuoteType === 'all') {
                              strCellText = strQuoteChar + strCellText + strQuoteChar;
                          } else if (strQuoteType === 'strings' && isNaN(strCellText)) {
                              strCellText = strQuoteChar + strCellText + strQuoteChar;
                          }
                      }
                      
                      strTextRecordString += (cell_i !== intFromCell ? strFieldDelimiter : '');
                      strTextRecordString += (strCellText || '');
                  }
                  
                  strTextCopyString += strTextRecordString;
                  strTextCopyString += strRowDelimiter;
              }
              
              for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                  arrCells = arrRecords[i].children;
                  strTextRecordString = '';
                  
                  for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                      strCellText = '';
                      
                      if (arrCells[cell_i].hasAttribute('selected')) {
                          if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) { 
                              strCellText = arrCells[cell_i].firstElementChild.textValue ||
                                            arrCells[cell_i].firstElementChild.value ||
                                            (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                            arrCells[cell_i].firstElementChild.textContent;//.trim();
                              
                          } else if (arrCells[cell_i].lastElementChild) {
                              strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                            arrCells[cell_i].lastElementChild.value ||
                                            (arrCells[cell_i].lastElementChild.checked || '').toString();
                          } else {
                              strCellText = arrCells[cell_i].textContent;//.trim();
                          }
                          
                          strCellText = strCellText.replace(quoteRegex, (strQuoteChar + strQuoteChar));
                          
                          if (strCellText === 'NULL' || strCellText === '\N') {
                              strCellText = strNull;
                          } else {
                              if (strQuoteType === 'all') {
                                  strCellText = strQuoteChar + strCellText + strQuoteChar;
                              } else if (strQuoteType === 'strings' && isNaN(strCellText)) {
                                  strCellText = strQuoteChar + strCellText + strQuoteChar;
                              }
                          }
                      } else {
                          if (strQuoteType === 'all' || strQuoteType === 'strings') {
                              strCellText = strQuoteChar + strCellText + strQuoteChar;
                          }
                      }
                      
                      strTextRecordString += (cell_i !== intFromCell ? strFieldDelimiter : '');
                      strTextRecordString += (strCellText || '');
                  }
                  //if (strTextRecordString.trim()) {
                  strTextCopyString += strTextRecordString;
                  //}
                  if (i + 1 !== len) { //&& strTextRecordString.trim()
                      strTextCopyString += strRowDelimiter;
                  }
              }
          }
          
          return strTextCopyString || '';
      }
      
      function handleClipboardData(event, strCopyString, strType) {
          var clipboardData = event.clipboardData || window.clipboardData, strMime;
          
          if (!clipboardData) { return; }
          if (!clipboardData.setData) { return; }
          
          if (strType === 'text') {
              if (window.clipboardData && window.clipboardData.getData) { // IE
                  strMime = 'Text';
              } else if (event.clipboardData && event.clipboardData.getData) {
                  strMime = 'text/plain';
              }
              
          } else if (strType === 'html') {
              if (window.clipboardData && window.clipboardData.getData) { // IE
                  strMime = '';
              } else if (event.clipboardData && event.clipboardData.getData) {
                  strMime = 'text/html';
              }
              
          } else {
              throw 'handleClipboardData Error: Type "' + strType + '" not recognized, recognized types are "text" and "html".';
          }
          
          if (strMime) {
              if (strCopyString && strMime) {
                  return clipboardData.setData(strMime, strCopyString) !== false;
              } else {
                  return clipboardData.getData(strMime);
              }
          }
      }
      
      
      
      //function handleClipboardData(event, strCopyString) {
      //    var clipboardData = event.clipboardData || window.clipboardData, strMime;
      //    
      //    if (!clipboardData) {
      //        return;
      //    }
      //    if (!clipboardData.setData) {
      //        return;
      //    }
      //    
      //    if (window.clipboardData && window.clipboardData.getData) { // IE
      //        strMime = 'Text';
      //    } else if (event.clipboardData && event.clipboardData.getData) {
      //        strMime = 'text/plain';
      //    }
      //    
      //    if (strCopyString) {
      //        return clipboardData.setData(strMime, strCopyString) !== false;
      //    } else {
      //        return clipboardData.getData(strMime);
      //    }
      //}
  
      GS.makeTableSelectable = function (tableElement, bolSingleRecord) {
          var copyElement;
          
          // tableElement verification
          if (!tableElement || tableElement.nodeName !== 'TABLE') {
              throw 'GS.makeTableSelectable Error: you must provide a <table> element as the first parameter.';
          }
          
          // prevent text selection
          //tableElement.setAttribute('prevent-text-selection', '');
          
          // define selectedCells getter and setter on the table element itself
          Object.defineProperty(tableElement, 'selectedCells', {
              get: function () {
                  return xtag.query(this, '[selected]');
              },
              
              set: function (newValue) {
                  var i, len, intIdIndex, arrCells = this.selectedCells, arrRecords, cell_i, cell_len;
                  
                  // clear old selection
                  for (i = 0, len = arrCells.length; i < len; i += 1) {
                      arrCells[i].removeAttribute('selected');
                  }
                  
                  arrCells = xtag.query(this, '[selected-secondary]');
                  for (i = 0, len = arrCells.length; i < len; i += 1) {
                      arrCells[i].removeAttribute('selected-secondary');
                  }
                  
                  // if newValue is not an array: make it an array
                  if (typeof newValue === 'object' && newValue.length === undefined) {
                      arrCells = [newValue];
                  } else {
                      arrCells = newValue;
                  }
                  
                  // set new selection
                  for (i = 0, len = arrCells.length; i < len; i += 1) {
                      arrCells[i].setAttribute('selected', '');
                  }
                  
                  arrRecords = this.selectedRecords;
                  
                  for (i = 0, len = arrRecords.length; i < len; i += 1) {
                      arrCells = arrRecords[i].children;
                      
                      for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                          if (!arrCells[cell_i].hasAttribute('selected')) {
                              arrCells[cell_i].setAttribute('selected-secondary', '');
                          }
                      }
                  }
                  
                  GS.triggerEvent(this, 'after_selection');
              }
          });
          
          // define selectedRecords getter and setter on the table element itself
          Object.defineProperty(tableElement, 'selectedRecords', {
              get: function () {
                  var i, len, intRecordIndex = -1, arrRecord = [], selected = this.selectedCells;
                  
                  // loop through the selected cells and create an array of trs
                  for (i = 0, len = selected.length; i < len; i += 1) {
                      if (selected[i].parentNode.rowIndex > intRecordIndex && selected[i].parentNode.parentNode.nodeName !== 'THEAD') {
                          intRecordIndex = selected[i].parentNode.rowIndex;
                          
                          arrRecord.push(selected[i].parentNode);
                      }
                  }
                  
                  return arrRecord;
              },
              
              set: function (newValue) {
                  var i, len, cell_i, cell_len, intIdIndex, arrCells = this.selectedCells, arrRecords, arrCellChildren;
                  
                  // clear old selection
                  for (i = 0, len = arrCells.length; i < len; i += 1) {
                      arrCells[i].removeAttribute('selected');
                  }
                  
                  arrCells = xtag.query(this, '[selected-secondary]');
                  for (i = 0, len = arrCells.length; i < len; i += 1) {
                      arrCells[i].removeAttribute('selected-secondary');
                  }
                  
                  // if newValue is not an array: make it an array
                  if (typeof newValue === 'object' && newValue.length === undefined) {
                      arrRecords = [newValue];
                  } else {
                      arrRecords = newValue;
                  }
                  
                  // set new selection
                  for (i = 0, len = arrRecords.length, arrCells = []; i < len; i += 1) {
                      arrCellChildren = arrRecords[i].children;
                      
                      for (cell_i = 0, cell_len = arrCellChildren.length; cell_i < cell_len; cell_i += 1) {
                          arrCells.push(arrCellChildren[cell_i]);
                      }
                  }
                  
                  this.selectedCells = arrCells;
                  
                  GS.triggerEvent(this, 'after_selection');
              }
          });
          
          // if we are on a touchdevice or bolSingleRecord is true: single record selection
          if (evt.touchDevice || bolSingleRecord === true) {
              tableElement.addEventListener(evt.mousedown, function (event) {
                  var target = event.target;
                  
                  if (target.nodeName === 'TD' || target.nodeName === 'TH' || getCellFromTarget(target)) {
                      tableElement.selectedCells = [];
                      
                      // if there is a parent record to the target: select all of the cells in the record
                      if (GS.findParentTag(target, 'tr')) {
                          tableElement.selectedCells = GS.findParentTag(target, 'tr').children;
                      }
                  }
              });
              
          // else: cell/record selection
          } else {
              // mousedown (on selected and unselected) + drag
              //      clear previous selection(s)
              //      select cells from origin cell to current cell
              //
              // shift + mousedown (on selected and unselected) + drag
              //      alter previous selection
              //      select cells from previous origin cell to current cell
              //
              // command + mousedown (on unselected) + drag
              //      maintain previous selection(s)
              //      select cells from origin cell to current cell
              //
              // command + mousedown (on selected) + drag
              //      maintain previous selection(s)
              //      deselect cells from origin cell to current cell
              //
              // collision handling
              //      when colliding with previous selections: dont treat them different
              //
              // copy handling
              //      selection ("X" marks selected cells (imagine all cells contain the letter "a")):
              //          1  2  3  4  5
              //          -------------
              //          a  a  a  a  a
              //          a  X  X  a  a
              //          a  a  X  X  a
              //          a  a  a  a  a
              //
              //      yields ("'" marks an empty cell):
              //          2  3  4 
              //          -------
              //          a  a  ' 
              //          '  a  a 
              
              tableElement.addEventListener(evt.mousedown, function (event) {
                  var target = event.target, cellFromTarget = getCellFromTarget(target), closestCell, arrSelectedCells, i, len;
                  
                  if (GS.findParentTag(event.target, 'table')) {
                      if (cellFromTarget) {
                          closestCell = cellFromTarget;
                      }
                      
                      if (closestCell) {
                          tableElement.dragAllowed = true;
                          tableElement.dragCurrentCell = closestCell;
                          tableElement.selectionSelectedCells = [];
                          
                          // if shift is down and there is a previous origin: use previous origin for current origin
                          if (event.shiftKey && tableElement.selectionPreviousOrigin) {
                              
                              // if there are previously selected cells: deselect the previous selected cells
                              if (tableElement.selectionPreviousSelectedCells) {
                                  arrSelectedCells = tableElement.selectedCells;
                                  
                                  for (i = 0, len = tableElement.selectionPreviousSelectedCells.length; i < len; i += 1) {
                                      arrSelectedCells.splice(arrSelectedCells.indexOf(tableElement.selectionPreviousSelectedCells[i]), 1);
                                  }
                                  
                                  tableElement.selectedCells = arrSelectedCells;
                              }
                              
                              tableElement.dragOrigin = tableElement.selectionPreviousOrigin;
                              tableElement.dragMode = 'select';
                              
                          // else if ctrl or cmd is down and the target cell is not selected: select cells from target cell to current cell
                          } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && !closestCell.hasAttribute('selected')) {
                              tableElement.dragOrigin = closestCell;
                              tableElement.dragMode = 'select';
                              
                          // else if ctrl or cmd is down and the target cell is selected: deselect cells from target cell to current cell
                          } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && closestCell.hasAttribute('selected')) {
                              tableElement.dragOrigin = closestCell;
                              tableElement.dragMode = 'deselect';
                              
                          // else: deselect all cells and start new selection
                          } else {
                              tableElement.selectedCells = [];
                              tableElement.dragOrigin = closestCell;
                              tableElement.dragMode = 'select';
                          }
                          
                          selectHandler(tableElement, tableElement.dragOrigin, tableElement.dragCurrentCell, tableElement.dragMode);
                      }
                  }
              });
              tableElement.addEventListener(evt.mousemove, function (event) {
                  var target, closestCell, cellFromTarget;
                  
                  // if mouse is down
                  if (event.which !== 0) {
                      target = event.target;
                      cellFromTarget = getCellFromTarget(target);
                      
                      if (cellFromTarget) {
                          closestCell = cellFromTarget;
                      }
                      
                      // if selection is allowed at this point and closestCell is different from tableElement.dragCurrentCell
                      if (tableElement.dragAllowed && tableElement.dragCurrentCell !== closestCell) {
                          tableElement.dragCurrentCell = getCellFromTarget(closestCell);
                          selectHandler(tableElement, tableElement.dragOrigin, tableElement.dragCurrentCell, tableElement.dragMode);
                      }
                  } else {
                      tableElement.dragAllowed = false;
                      tableElement.selectionPreviousOrigin = tableElement.dragOrigin;
                      tableElement.selectionPreviousSelectedCells = tableElement.selectionSelectedCells;
                  }
              });
              tableElement.addEventListener(evt.mouseup, function (event) {
                  tableElement.dragAllowed = false;
                  
                  if (tableElement.dragMode === 'select') {
                      tableElement.selectionPreviousOrigin = tableElement.dragOrigin;
                      tableElement.selectionPreviousSelectedCells = tableElement.selectionSelectedCells;
                  }
              });
          }
          
          // add input for clipboard compatibility
          copyElement = document.createElement('input');
          copyElement.value = 'Firefox compatibility input';
          copyElement.setAttribute('gs-dynamic', '');
          copyElement.setAttribute('style', 'position: fixed; left: 50%; top: 50%; z-index: -5000; opacity: 0.00000001;');
          
          tableElement.appendChild(copyElement);
          
          // add tabindex so that we can listen for focus on the table
          tableElement.tabIndex = 0;
          
          // when a focus event happens on the table: focus the copy input if the element that is focused is the table
          tableElement.addEventListener('focus', function (event) {
              if (document.activeElement === tableElement) {
                  tableElement.focus();
                  GS.setInputSelection(copyElement, 0, 'Firefox compatibility input'.length);
              }
          });
          
          // clipboard handling
          document.body.addEventListener('copy', function (event) {
              var elementClosestTable = GS.findParentTag(document.activeElement, 'table')
                , strTextCopyString, strHTMLCopyString;
              
              if (elementClosestTable === tableElement &&
                  (
                      document.activeElement.value === 'Firefox compatibility input' ||
                      document.activeElement.selectionStart === document.activeElement.selectionEnd
                  )) {
                  GS.setInputSelection(document.activeElement, document.activeElement.value.length,
                                              document.activeElement.value.length);
                  
                  strTextCopyString = getSelectedCopyText(tableElement);
                  strHTMLCopyString = getSelectedCopyHTML(tableElement);
                  
                  if (strTextCopyString && strHTMLCopyString) {
                      if (handleClipboardData(event, strTextCopyString, 'text')) {
                          event.preventDefault(event);
                      }
                      if (handleClipboardData(event, strHTMLCopyString, 'html')) {
                          event.preventDefault(event);
                      }
                  }
                  
                  GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
              }
          });
              //var elementClosestTable = GS.findParentTag(document.activeElement, 'table'), strCopyString,
              //    i, len, cell_i, cell_len, arrSelected, intFromRecord = 9999999, intFromCell = 9999999,
              //    intToRecord = 0, intToCell = 0, strCellText, arrRecords, arrCells, strRecordString;
              //
              //if (elementClosestTable === tableElement &&
              //    (
              //        document.activeElement.value === 'Firefox compatibility input' ||
              //        document.activeElement.selectionStart === document.activeElement.selectionEnd
              //    )) {
              //    arrSelected = tableElement.selectedCells;
              //    
              //    // loop through the selected cells and create a tsv string using the text of the cell
              //    if (arrSelected.length > 0) {
              //        for (i = 0, len = arrSelected.length; i < len; i += 1) {
              //            if (arrSelected[i].parentNode.rowIndex < intFromRecord) {
              //                intFromRecord = arrSelected[i].parentNode.rowIndex;
              //            }
              //            if (arrSelected[i].cellIndex < intFromCell) {
              //                intFromCell = arrSelected[i].cellIndex;
              //            }
              //            if (arrSelected[i].parentNode.rowIndex + 1 > intToRecord) {
              //                intToRecord = arrSelected[i].parentNode.rowIndex + 1;
              //            }
              //            if (arrSelected[i].cellIndex + 1 > intToCell) {
              //                intToCell = arrSelected[i].cellIndex + 1;
              //            }
              //        }
              //        
              //        arrRecords = xtag.query(tableElement, 'tr');
              //        strCopyString = '';
              //        
              //        for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
              //            arrCells = arrRecords[i].children;
              //            
              //            for (cell_i = intFromCell, cell_len = intToCell, strRecordString = ''; cell_i < cell_len; cell_i += 1) {
              //                if (arrCells[cell_i].hasAttribute('selected')) {
              //                    if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) { 
              //                        strCellText = arrCells[cell_i].firstElementChild.textValue ||
              //                                      arrCells[cell_i].firstElementChild.value ||
              //                                      (arrCells[cell_i].firstElementChild.checked || '').toString() ||
              //                                      arrCells[cell_i].firstElementChild.textContent.trim();
              //                    } else if (arrCells[cell_i].lastElementChild) { 
              //                        strCellText = arrCells[cell_i].lastElementChild.textValue ||
              //                                      arrCells[cell_i].lastElementChild.value ||
              //                                      (arrCells[cell_i].lastElementChild.checked || '').toString() ||
              //                                      arrCells[cell_i].lastElementChild.textContent.trim();
              //                    } else {
              //                        strCellText = arrCells[cell_i].textContent.trim();
              //                    }
              //                } else {
              //                    strCellText = '';
              //                }
              //                
              //                strRecordString += (cell_i !== intFromCell ? '\t' : '') + (strCellText || '');
              //            }
              //            
              //            if (strRecordString.trim()) {
              //                strCopyString += strRecordString;
              //            }
              //            
              //            if (i + 1 !== len && strRecordString.trim()) {
              //                strCopyString += '\r\n';
              //            }
              //        }
              //    }
              //    
              //    if (strCopyString) {
              //        if (handleClipboardData(event, strCopyString)) {
              //            event.preventDefault(event);
              //        }
              //    }
              //}
      };
  })();
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('GS.qryFromJSON', 'GS.qryFromJSON', 'GS.qryFromJSON(${0:jsnObjectToConvert});');
      
      registerDesignSnippet('GS.qryToJSON', 'GS.qryToJSON', 'GS.qryToJSON(${0:strQueryStringToConvert});');
      
      registerDesignSnippet('GS.qryToWhere', 'GS.qryToWhere',
                                  'GS.qryToWhere(${1:strQueryString}, ${2:strColumnNameInQueryString}, ${0:strColumnNameInTarget});');
      
      registerDesignSnippet('GS.qryGetKeys', 'GS.qryGetKeys', 'GS.qryGetKeys(${0:queryString});');
      
      registerDesignSnippet('GS.qryGetVals', 'GS.qryGetVals', 'GS.qryGetVals(${0:queryString});');
      
      registerDesignSnippet('GS.qryGetVal', 'GS.qryGetVal', 'GS.qryGetVal(${1:queryString}, \'${0:keyToGet}\');');
      
      registerDesignSnippet('GS.qrySetVal', 'GS.qrySetVal', 'GS.qrySetVal(${1:queryString}, \'${0:newKeyValuePair}\');');
      
      registerDesignSnippet('GS.qryDeleteKey', 'GS.qryDeleteKey', 'GS.qryDeleteKey(${1:queryString}, \'${0:keyToDelete}\');');
      
      registerDesignSnippet('GS.getQueryString', 'GS.getQueryString', 'GS.getQueryString();');
      
      registerDesignSnippet('GS.pushQueryString', 'GS.pushQueryString', 'GS.pushQueryString(${0:newQueryString});');
      
      registerDesignSnippet('GS.removeFromQueryString', 'GS.removeFromQueryString', 'GS.removeFromQueryString(${0:removeKeys});');
  });
  
  
  // ########## CONVERSION FUNCTIONS ##########
  GS.qryFromJSON = function (jsnToConvert) {
      'use strict';
      var key, strRet = '', strType, currentValue;
      
      for (key in jsnToConvert) {
          currentValue = jsnToConvert[key];
          strType = typeof currentValue;
          
          if (strType === 'number' || strType === 'string' || strType === 'boolean') {
              strRet += (strRet === '' ? '' : '&') + key + '=' + encodeURIComponent(jsnToConvert[key]);
              
          } else if (currentValue === null || currentValue === undefined) {
              strRet += (strRet === '' ? '' : '&') + key + '=';
              
          } else if (typeof currentValue !== 'object') {
              throw 'GS.qryFromJSON Error: Invalid value: ' + JSON.stringify(currentValue);
          }
      }
      
      return strRet;
  };
  
  GS.qryToJSON = function (strQueryString) {
      'use strict';
      var arrKeyValueList = [], jsnQueryString = {}, strKeyValue, i, len, strKey, strValue, jsnNavigator, arrSubParts, sub_i, sub_len;
      
      if (strQueryString) {
          arrKeyValueList = strQueryString.split('&');
          
          for (i = 0, len = arrKeyValueList.length; i < len; i += 1) {
              strKeyValue = arrKeyValueList[i];
              strKey      = strKeyValue.substring(0, strKeyValue.indexOf('='));
              strValue    = decodeURIComponent(strKeyValue.substring(strKeyValue.indexOf('=') + 1));
              
              jsnQueryString[strKey] = strValue;
              
              // if a dot is found in the key: create a sub JSON structure
              if (strKey.indexOf('.') > -1) {
                  arrSubParts = strKey.split('.');
                  
                  jsnNavigator = jsnQueryString;
                  for (sub_i = 0, sub_len = arrSubParts.length; sub_i < sub_len; sub_i += 1) {
                      if (sub_i < sub_len - 1) {
                          jsnNavigator[arrSubParts[sub_i]] = jsnNavigator[arrSubParts[sub_i]] || {};
                      } else {
                          jsnNavigator[arrSubParts[sub_i]] = jsnNavigator[arrSubParts[sub_i]] || strValue;
                      }
                      
                      jsnNavigator = jsnNavigator[arrSubParts[sub_i]];
                  }
              }
          }
      }
      
      return jsnQueryString;
  };
  
  // get data from query string and turn it into a where clause
  //      (
  //          the second two params are optional
  //              (
  //                  they are for when you want only one column out of a query string to be converted
  //              )
  //      )
  GS.qryToWhere = function (strQS, strColumnNameInQS, strColumnNameInTarget) {
      'use strict';
      var strWhere = '', key, jsnArgs;
      
      if (strColumnNameInQS) {
          strColumnNameInTarget = (strColumnNameInTarget || strColumnNameInQS);
          
          if (!isNaN(GS.qryGetVal(strQS, strColumnNameInQS))) {
              strWhere = strColumnNameInTarget + '=' + GS.qryGetVal(strQS, strColumnNameInQS);
          } else {
              strWhere = 'CAST(' + strColumnNameInTarget + ' AS ' + GS.database.type.text + ') = ' +
                         'CAST($WhereQUOTE$' +
                              encodeURIComponent(GS.qryGetVal(strQS, strColumnNameInQS)) +
                              '$WhereQUOTE$ AS ' + GS.database.type.text + ')';
          }
      } else {
          jsnArgs = GS.qryToJSON(strQS);
  
          for (key in jsnArgs) {
              if (jsnArgs.hasOwnProperty(key)) {
                  if (!isNaN(jsnArgs[key])) {
                      strWhere += (strWhere === '' ? '': ' AND ') + key + '=' + jsnArgs[key];
                  } else {
                      strWhere += (strWhere === '' ? '': ' AND ') +
                                  'CAST(' + key + ' AS ' + GS.database.type.text + ') = ' +
                                  'CAST($WhereQUOTE$' + encodeURIComponent(jsnArgs[key]) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')';
                  }
              }
          }
      }
      
      return strWhere;
  };
  
  
  // ########## LISTING FUNCTIONS ##########
  GS.qryGetKeys = function (strQueryString) {
      'use strict';
      var arrKeyValueList = [], arrKeys = [], i, len, strKeyValue;
      
      if (strQueryString) {
          arrKeyValueList = strQueryString.split('&');
          
          for (i = 0, len = arrKeyValueList.length; i < len; i += 1) {
              strKeyValue = arrKeyValueList[i];
              
              arrKeys.push(strKeyValue.substring(0, strKeyValue.indexOf('=')));
          }
      }
      
      return arrKeys;
  };
  
  GS.qryGetVals = function (strQueryString) {
      'use strict';
      var arrKeyValueList = [], arrValues = [], i, len, strKeyValue;
      
      if (strQueryString) {
          arrKeyValueList = strQueryString.split('&');
          
          for (i = 0, len = arrKeyValueList.length; i < len; i += 1) {
              strKeyValue = arrKeyValueList[i];
              
              arrValues.push(decodeURIComponent(strKeyValue.substring(strKeyValue.indexOf('=') + 1)));
          }
      }
      
      return arrValues;
  };
  
  
  // ########## PARAMETER GET/SET FUNCTIONS ##########
  GS.qryGetVal = function (strQueryString, strKey) {
      'use strict';
      var arrKeyValueList, strSlice, i, len;
      
      if (strQueryString) {
          arrKeyValueList = strQueryString.split('&');
          
          for (i = 0, len = arrKeyValueList.length; i < len; i = i + 1) {
              strSlice = arrKeyValueList[i];
              
              if (strSlice.split('=')[0] === strKey) {
                  return decodeURIComponent(strSlice.substring(strSlice.indexOf('=') + 1));
              }
          }
      }
      
      return '';
  };
  
  GS.qrySetVal = function (strQueryString, strKeyValue) {
      'use strict';
      strQueryString = GS.qryDeleteKey(strQueryString, strKeyValue.split('=')[0]);
      strQueryString = strQueryString + (strQueryString ? '&' : '') + strKeyValue;
      
      return strQueryString;
  };
  
  
  // ########## KEY DELETE FUNCTION ##########
  GS.qryDeleteKey = function (strQueryString, strKey) {
      'use strict';
      var arrKeyValueList, strSlice, i, len;
      
      if (strQueryString) {
          arrKeyValueList = strQueryString.split('&');
          
          for (i = 0, len = arrKeyValueList.length; i < len; i = i + 1) {
              strSlice = arrKeyValueList[i];
              
              if (strSlice.split('=')[0] === strKey) {
                  arrKeyValueList.splice(i, 1);
                  
                  break;
              }
          }
          
          return arrKeyValueList.join('&');
      }
      
      return '';
  };
  
  
  // ########## MISC FUNCTIONS ##########
  GS.getQueryString = function () {
      'use strict';
      return window.location.search.substring(1);
  };
  
  GS.pushQueryString = function (QS) {
      var arrNewQS = QS.split('&'), i, len, newQS = GS.getQueryString();
      for (i = 0, len = arrNewQS.length; i < len; i += 1) {
          newQS = GS.qrySetVal(newQS, arrNewQS[i]);
      }
      GS.pushState({}, '', '?' + newQS);
  };
  
  
  GS.removeFromQueryString = function (keys) {
      var arrRemoveKeys = keys.split(','), i, len, newQS = GS.getQueryString();
      for (i = 0, len = arrRemoveKeys.length; i < len; i += 1) {
          newQS = GS.qryDeleteKey(newQS, arrRemoveKeys[i]);
      }
      GS.pushState({}, '', '?' + newQS);
  };
  
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      //registerDesignSnippet('GS.qryFromJSON', 'GS.qryFromJSON', 'GS.qryFromJSON(${0:jsnObjectToConvert});');
  });
  
  
  
  GS.templateColumnToValue = function (templateHTML) {
      'use strict';
      var templateElementEncoded = document.createElement('template'),
          templateElementNonEncoded = document.createElement('template'),
          arrTemplateElementEncoded, arrTemplateElementNonEncoded,
          jsnTemplates = {}, arrColumnElement = [], templateHTMLEncoded, bolInCommand, i, len, strID;
      
      // get template element encoded with all "&"s (that are not inside a doT command) encoded,
      //      so that html encoded characters are not lost in the next operations
      
      for (i = 0, len = templateHTML.length, templateHTMLEncoded = '', bolInCommand = false; i < len; i += 1) {
          if (!bolInCommand && templateHTML[i] === '{' && templateHTML[i + 1] === '{') {
              bolInCommand = true;
              i += 1;
              templateHTMLEncoded += '{{';
              
          } else if (bolInCommand && templateHTML[i] === '}' && templateHTML[i + 1] === '}') {
              bolInCommand = false;
              i += 1;
              templateHTMLEncoded += '}}';
              
          } else if (!bolInCommand && templateHTML[i] === '&') {
              templateHTMLEncoded += '&amp;';
              
          } else {
              templateHTMLEncoded += templateHTML[i];
          }
      }
      
      //console.log(templateHTML);
      //console.log(templateHTMLEncoded);
      templateElementEncoded.innerHTML = templateHTMLEncoded; //templateHTML.replace(/&/gi, '&amp;');
      
      // get template element non-encoded with everything in it, so that sub templates are not touched
      templateElementNonEncoded.innerHTML = templateHTML;
      
      // go through element encoded and replace templates with tokens
      // go through element non-encoded and gather templates and make sure they reference the same tokens
      arrTemplateElementEncoded = xtag.query(templateElementEncoded.content, 'template');
      arrTemplateElementNonEncoded = xtag.query(templateElementNonEncoded.content, 'template');
      i = 0;
      
      //console.log(arrTemplateElementEncoded);
      //console.log(arrTemplateElementNonEncoded);
      
      //console.log(arrTemplateElementEncoded.length);
      while (arrTemplateElementEncoded.length > 0 && i < 500) {
          //console.log(arrTemplateElementNonEncoded[0].parentNode);
          
          if (arrTemplateElementNonEncoded[0].parentNode &&
              arrTemplateElementNonEncoded[0].parentNode.hasAttribute &&
                  (
                      arrTemplateElementNonEncoded[0].parentNode.hasAttribute('src') ||
                      arrTemplateElementNonEncoded[0].parentNode.hasAttribute('source')
                  )) {
              strID = 'UnIqUE_PLaCEh0LDER-' + GS.GUID() + '-UniQUE_PLaCEh0LdER';
              jsnTemplates[strID] = arrTemplateElementNonEncoded[0].outerHTML;
              arrTemplateElementEncoded[0].outerHTML = strID;
          } else {
              // append any sub templates to the "arrTemplateElementEncoded" and "arrTemplateElementNonEncoded"
              //      variables
              arrTemplateElementEncoded = arrTemplateElementEncoded
                                              .concat(xtag.query(arrTemplateElementEncoded[0].content, 'template'));
              arrTemplateElementNonEncoded = arrTemplateElementNonEncoded
                                                  .concat(xtag.query(arrTemplateElementNonEncoded[0].content, 'template'));
              
              // append any column elements in this template to the "arrColumnElement" variable
              arrColumnElement = arrColumnElement.concat(xtag.query(arrTemplateElementEncoded[0].content, '[column]'));
          }
          
          // remove the current template from the arrays
          arrTemplateElementEncoded.splice(0, 1);
          arrTemplateElementNonEncoded.splice(0, 1);
          
          i += 1;
      }
      
      // go through element encoded and add calculated "value" attribute to any element with a "column"
      //      attribute but no "value" attribute
      arrColumnElement = arrColumnElement.concat(xtag.query(templateElementEncoded.content, '[column]'));
      
      for (i = 0, len = arrColumnElement.length; i < len; i += 1) {
          if (!arrColumnElement[i].hasAttribute('value')) {
              arrColumnElement[i].setAttribute('value', '{{! row[\'' + arrColumnElement[i].getAttribute('column').replace(/\\/gi, '\\\\').replace(/\'/gi, '\\\'') + '\'] }}');
          }
      }
      
      //console.log(templateHTML);
      //console.log(arrColumnElement);
      //console.log(jsnTemplates);
      //console.log(templateElementEncoded.innerHTML);
      
      // save element encoded innerHTML as template HTML
      templateHTML = templateElementEncoded.innerHTML;
      
      // go through template HTML and replace template tokens with template HTML
      for (strID in jsnTemplates) {
          //                                      DO NOT DELETE, this allows single dollar signs to be inside dot notation
          //                                                                                                V
          templateHTML = templateHTML.replace(new RegExp(strID, 'g'), jsnTemplates[strID].replace(/\$/g, '$$$$'));
      }
      
      //console.log(element.templateHTML);
      
      return templateHTML;
  };
  
  
  GS.templateWithQuerystring = function (templateText) {
      'use strict';
      var strWrapperTemplate = '{{##def.snippet:\n' +
                               '    {{ var qs = jo; }} {{# def.template }}\n' +
                               '#}}\n' +
                               '{{#def.snippet}}';
      
      return doT.template(strWrapperTemplate, null, {'template': templateText})(GS.qryToJSON(GS.getQueryString())).trim();
  };
  
  
  GS.templateHideSubTemplates = function (templateHTML, bolRecord) {
      'use strict';
      var templateElement, strID, arrTemplates, i, len, jsnTemplates, strRet, strStart, strEnd;
      
      if (bolRecord) {
          strStart = '<table><tbody>';
          strEnd = '</tbody></table>';
          templateHTML = (strStart + templateHTML + strEnd);
      }
      
      templateElement = document.createElement('template');
      templateElement.innerHTML = templateHTML;
      
      // temporarily remove templates
      // recursively go through templates whose parents do not have the source attribute
      i = 0;
      arrTemplates = xtag.query(templateElement.content, 'template');
      jsnTemplates = {};
      
      //console.log(arrTemplates.length);
      
      while (arrTemplates.length > 0 && i < 100) {
          //console.log(arrTemplates[0], arrTemplates[0].parentNode);
          // if the current template has a source parent: remove temporarily
          if (arrTemplates[0].parentNode &&
              arrTemplates[0].parentNode.hasAttribute && (arrTemplates[0].parentNode.hasAttribute('src') ||
                                                          arrTemplates[0].parentNode.hasAttribute('source'))) {
              strID = 'UNIqUE_PLaCEhOLDER-' + GS.GUID() + '-UNiQUE_PLaCEhOLdER';
              jsnTemplates[strID] = arrTemplates[0].outerHTML;
              arrTemplates[0].outerHTML = strID;
              
          // else: add to the arrTemplates array
          } else if (arrTemplates[0].content) {
              arrTemplates.push.apply(arrTemplates, xtag.query(arrTemplates[0].content, 'template'));
          }
          
          // remove the current template from the arrTemplates array
          arrTemplates.splice(0, 1);
          
          i += 1;
      }
      
      strRet = decodeHTML(templateElement.innerHTML);
      
      if (bolRecord) {
          strRet = strRet.substring(strStart.length, strRet.length - strEnd.length);
      }
      
      return {'templateHTML': strRet, 'templateData': jsnTemplates}
  };
  
  GS.templateShowSubTemplates = function (strRet, jsnTemplate) {
      'use strict';
      var strID;
      
      for (strID in jsnTemplate.templateData) {
          //                                       DO NOT DELETE, this allows single dollar signs to be inside dot notation
          //                                                                  V
          strRet = strRet.replace(new RegExp(strID, 'g'), jsnTemplate.templateData[strID].replace(/\$/g, '$$$$'));
      }
      
      return strRet;
  };
  
  GS.templateWithEnvelopeData = function (templateHTML, data, i, len, rowNumberOffset) {
      'use strict';
      return doT.template(ml(function () {/*
          {{##def.snippet:
              {{ var row, row_number, i, len, col_i, col_len
                   , qs = GS.qryToJSON(GS.getQueryString())
                   , rowNumberOffset = (jo.rowNumberOffset || 0);
              
              if (!isNaN(jo.i)) {
                  i = jo.i;
                  len = (jo.len === undefined || jo.len === null ? jo.i + 1 : jo.len);
                  
              } else {
                  i = 0;
                  len = jo.data.dat.length;
              }
              
              for (; i < len; i += 1) {
                  row = {};
                  row_number = (i + 1) + rowNumberOffset;
                  row.row_number = row_number;
                  
                  for (col_i = 0, col_len = jo.data.arr_column.length; col_i < col_len; col_i += 1) {
                      if (jo.data.dat[i][col_i] === undefined || jo.data.dat[i][col_i] === null) {
                          row[jo.data.arr_column[col_i]] = '';
                      } else {
                          row[jo.data.arr_column[col_i]] = jo.data.dat[i][col_i];
                      }
                  } }}{{# def.record }}
              {{ } }}
          #}}
          {{#def.snippet}}*/console.log;
      }), null, {"record":  templateHTML})({ 'data': data, 'i': i, 'len': len, 'rowNumberOffset': rowNumberOffset });
  };
  
  
  
  
  
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('GS.userChangePassword', 'GS.userChangePassword', 'GS.userChangePassword();');
      //registerDesignSnippet('GS.superChangePassword', 'GS.superChangePassword', 'GS.superChangePassword();');
      //registerDesignSnippet('GS.superUserLogin', 'GS.superUserLogin', 'GS.superUserLogin(${0:loggedInCallback});');
      registerDesignSnippet('GS.normalUserLogin', 'GS.normalUserLogin', 'GS.normalUserLogin(${0:loggedInCallback});');
  });
  
  (function () {
      function changePassword(strLink, strRank) {
          var templateElement = document.createElement('template');
          
          templateElement.innerHTML = ml(function () {/*
              <gs-page>
                  <gs-header><center><h3>Change {{RANK}} Password</h3></center></gs-header>
                  <gs-body padded>
                      <div id="pword-error" style="color: #FF0000;"></div>
                      <label for="old-password">Old Password:</label>
                      <gs-text id="old-password" type="password"></gs-text>
                      <label for="new-password">New Password:</label>
                      <gs-text id="new-password" type="password"></gs-text>
                      <label for="new-password-confirm">Confirm New Password:</label>
                      <gs-text id="new-password-confirm" type="password"></gs-text>
                  </gs-body>
                  <gs-footer>
                      <gs-grid>
                          <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                          <gs-block><gs-button id="button-change-password" disabled>Change {{RANK}} Password</gs-button></gs-block>
                      </gs-grid>
                  </gs-footer>
              </gs-page>
          */}).replace(/\{\{RANK\}\}/gim, strRank);
          
          GS.openDialog(templateElement, function () {
              var dialog = this, keydownHandler;
              
              keydownHandler = function (event) {
                  var intKeyCode = event.which || event.keyCode;
                  
                  if (intKeyCode === 13 &&
                      document.getElementById('old-password').value &&
                      document.getElementById('new-password').value &&
                      document.getElementById('new-password-confirm').value) {
                      GS.triggerEvent(document.getElementById('button-change-password'), 'click');
                      
                  } else {
                      if (document.getElementById('old-password').value &&
                          document.getElementById('new-password').value &&
                          document.getElementById('new-password-confirm').value) {
                          document.getElementById('button-change-password').removeAttribute('disabled');
                      } else {
                          document.getElementById('button-change-password').setAttribute('disabled');
                      }
                  }
              };
              
              document.getElementById('old-password').addEventListener('keydown', keydownHandler);
              document.getElementById('new-password').addEventListener('keydown', keydownHandler);
              document.getElementById('new-password-confirm').addEventListener('keydown', keydownHandler);
              
              document.getElementById('button-change-password').addEventListener('click', function () {
                  var newPassword, parameters;
                  
                  if (document.getElementById('new-password').value === document.getElementById('new-password-confirm').value) {
                      parameters = 'action=change_pw' +
                                  '&password_old=' + encodeURIComponent(document.getElementById('old-password').value) +
                                  '&password_new=' + encodeURIComponent(document.getElementById('new-password').value);
                      
                      document.getElementById('old-password').value = '';
                      document.getElementById('new-password').value = '';
                      document.getElementById('new-password-confirm').value = '';
                      
                      GS.ajaxJSON(
                          location.pathname.indexOf('/env/') === 0 ? 
                          '/env/auth' : '/pgmanage/auth', parameters, function (data, error) {
                          if (!error) {
                              GS.pushMessage('Password Successfully Changed', 1000);
                              GS.closeDialog(dialog, 'change');
                          } else {
                              document.getElementById('pword-error').textContent = data.error_text;
                          }
                      });
                  } else {
                      document.getElementById('pword-error').textContent = 'New Password Doesn\'t Match Confirm New Password.';
                  }
              });
          });
      }
      
      GS.userChangePassword = function () {
          changePassword('env', 'User');
      };
      
      //GS.superChangePassword = function () {
      //    changePassword('pgmanage', 'SUPERUSER');
      //};
  })();
  
  // check if the user is logged in as a normal user
  // if there is no login dialog create it then open it
  GS.normalUserLogin = function (loggedInCallback, strOldError, strDefaultSubDomain) {
      'use strict';
      GS.removeAllLoaders();
      
      if (!window.userLogin) {
          window.userLogin = true;
          
          // this action checks to see if we are logged in as a super user
          // if not, open a login dialog
          GS.ajaxJSON('/env/action_info', '', function (data, error) {
              var templateElement = document.createElement('template');
              
              if (!error && data.dat) {
                  if (typeof loggedInCallback === 'function') {
                      loggedInCallback(data.dat, strDefaultSubDomain);
                  }
              } else {
                  templateElement.innerHTML = ml(function () {/*
                      <gs-page>
                          <gs-header><center><h3>Login</h3></center></gs-header>
                          <gs-body padded>
                              You are not currently logged in, please fill in the login form below.<br /><br />
                              <label for="normal-uname">Username:</label>
                              <gs-text id="normal-uname" autocapitalize="off" autocomplete="off" autocorrect="off"></gs-text>
                              <label for="normal-pword">Password:</label>
                              <gs-text id="normal-pword" type="password"></gs-text>
                              {{ERROR}}
                          </gs-body>
                          <gs-footer>
                              <gs-grid>
                                  <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                                  <gs-block><gs-button id="normal-login">Log In</gs-button></gs-block>
                              </gs-grid>
                          </gs-footer>
                      </gs-page>
                  */}).replace('{{ERROR}}', (strOldError ? '<br /><div style="color: #FF0000">' + strOldError + '</div>' : ''));
                  
                  if (GS.getCookie('greyspots_uname')) {
                      xtag.query(templateElement.content, '#normal-uname')[0].setAttribute('value', decodeURIComponent(GS.getCookie('greyspots_uname')));
                      xtag.query(templateElement.content, '#normal-pword')[0].setAttribute('autofocus', '');
                  } else {
                      xtag.query(templateElement.content, '#normal-uname')[0].setAttribute('autofocus', '');
                  }
                  
                  GS.openDialog(templateElement, function () {
                      var dialog = this;
                      
                      document.getElementById('normal-pword').addEventListener('keydown', function (event) {
                          var intKeyCode = event.which || event.keyCode;
                          
                          if (intKeyCode === 13) {
                              GS.triggerEvent(document.getElementById('normal-login'), 'click');
                          }
                          //if (this.value) {
                          //    document.getElementById('normal-login').removeAttribute('disabled');
                          //} else {
                          //    document.getElementById('normal-login').setAttribute('disabled', '');
                          //}
                      });
                      
                      //document.getElementById('normal-pword').addEventListener('keyup', function () {
                      //    if (this.value) {
                      //        document.getElementById('normal-login').removeAttribute('disabled');
                      //    } else {
                      //        document.getElementById('normal-login').setAttribute('disabled', '');
                      //    }
                      //});
                      
                      document.getElementById('normal-login').addEventListener('click', function () {
                          var strUserName = document.getElementById('normal-uname').value, strLink;
                          
                          if (document.getElementById('normal-pword').value) {
                              GS.addLoader('log-in', 'Logging In...');
                              
                              GS.ajaxJSON('/env/auth', 'action=login' +
                                                         '&username=' + encodeURIComponent(document.getElementById('normal-uname').value) +
                                                         '&password=' + encodeURIComponent(document.getElementById('normal-pword').value),
                                                         function (data, error) {
                                  GS.removeLoader('log-in');
                                  GS.closeDialog(dialog, '');
                                  window.userLogin = false;
                                  
                                  if (!error) {
                                      GS.setCookie('greyspots_uname', strUserName, 30);
                                      
                                      if (typeof loggedInCallback === 'function') {
                                          if (window.location.hostname.substring(0, window.location.hostname.indexOf('.')) ===
                                                          strDefaultSubDomain) {
                                              GS.normalUserLogin(loggedInCallback, '', strDefaultSubDomain);
                                          } else {
                                              loggedInCallback(data.dat, strDefaultSubDomain);
                                          }
                                      }
                                      
                                  } else {
                                      GS.normalUserLogin(loggedInCallback, data.error_text, strDefaultSubDomain);
                                  }
                              });
                          }
                      });
                  });
              }
          });
      }
  };
  //jslint white:true
  
  (function () {
      'use strict';
  
      // encodeForTabDelimited('asdf\\asdf\\asdf\r\nasdf\r\nasdf\tasdf\tasdf')
      function encodeForTabDelimited(strValue) {
          return  strValue === '\\N' ? strValue :
                  strValue.replace(/\\/g, '\\\\') // double up backslashes
                          .replace(/\n/g, '\\n')  // replace newline with the text representation '\n'
                          .replace(/\r/g, '\\r')  // replace carriage return with the text representation '\r'
                          .replace(/\t/g, '\\t')  // replace tab with the text representation '\t'
                          .replace(/^NULL$/g, '\\N');
      }
  
      GS.bolPreventErrors = false;
      function webSocketConnectionErrorDialog(socket, addinText, retryCallback, cancelCallback) {
  
          if (!document.getElementById('dialog-from-dialog-ws-conn-error') && GS.bolPreventErrors === false) {
              var templateElement = document.createElement('template');
  
              GS.removeAllLoaders();
  
              templateElement.setAttribute('id', 'dialog-ws-conn-error');
              templateElement.setAttribute('data-theme', 'error');
              templateElement.innerHTML = ml(function () {/*
                  <gs-page>
                      <gs-header><center><h3>There was an error!</h3></center></gs-header>
                      <gs-body padded>
                          <pre style="white-space: pre-wrap;">
      There has been an error with the Database connection.{{ADDIN}}</pre>
                      </gs-body>
                      <gs-footer>
                          <gs-grid gutter reflow-at="420">
                              <gs-block><gs-button dialogclose>Try to reconnect</gs-button></gs-block>
                              <gs-block><gs-button dialogclose>Dismiss so I can copy my progress</gs-button></gs-block>
                          </gs-grid>
                      </gs-footer>
                  </gs-page>
              */}).replace('{{ADDIN}}', decodeURIComponent((addinText ? '\n\n' + addinText : '')));
  
              GS.openDialog(templateElement, '', function (event, strAnswer) {
                  if (strAnswer === 'Try to reconnect') {
                      GS.closeSocket(GS.envSocket);
                      GS.envSocket = GS.openSocket('env', socket.GSSessionID, socket.notifications);
                  } else {
                      GS.bolPreventErrors = true;
                  }
              });
          }
      }
  
      function webSocketNormalizeError(event) {
          var i;
          var len;
          var arrLines;
          var arrLine;
          var strData;
          var jsnRet = {
              'error_title': '',
              'error_text': '',
              'error_detail': '',
              'error_hint': '',
              'error_query': '',
              'error_context': '',
              'error_position': '',
              'error_notice': '',
              'original_data': event
          };
  
          event = event || {};
  
          jsnRet.error_text = event.reason || '';
  
          // if there is message data: parse it
          if (event.data) {
              strData = event.data;
  
              // strip out messageid
              if (strData.substring(0, strData.indexOf(' ')) === 'messageid') {
                  strData = strData.substring(strData.indexOf('\n') + 1);
              }
  
              // strip out response number
              if (strData.substring(0, strData.indexOf(' ')) === 'responsenumber') {
                  strData = strData.substring(strData.indexOf('\n') + 1);
              }
  
              // strip out response number
              if (strData.substring(0, strData.indexOf(' ')) === 'transactionid') {
                  strData = strData.substring(strData.indexOf('\n') + 1);
              }
  
              // strip out fatal
              if (strData.indexOf('FATAL\n') === 0) {
                  strData = strData.substring(strData.indexOf('\n') + 1);
              }
  
              // strip out "Query failed: "
              if (strData.indexOf('Query failed: ') === 0) {
                  strData = strData.substring('Query failed: '.length);
              }
  
              // save error text in case we dont find any error part labels
              jsnRet.error_text = strData;
              jsnRet.orig_error_text = strData;
  
              // trim and split on return for parsing
              arrLines = strData.trim().split('\n');
  
              for (i = 0, len = arrLines.length; i < len; i += 1) {
                  arrLine = arrLines[i].split('\t');
  
                  jsnRet[arrLine[0]] = GS.decodeFromTabDelimited(arrLine[1] || '');
              }
  
              if (!jsnRet.error_text) {
                  jsnRet = {
                      'error_text': arrLines[0]
                  };
              }
          }
  
          // get error title and error hint
          if (event.code === 1001) {
              jsnRet.error_title = 'Going Away';
              jsnRet.error_hint = 'The server or client closed the connection because of server shutdown or navigating away from the page.';
  
          } else if (event.code === 1002) {
              jsnRet.error_title = 'Protocol';
              jsnRet.error_hint = 'The connection was closed because of error related to the protocol used.';
  
          } else if (event.code === 1003) {
              jsnRet.error_title = 'Unsupported Data';
              jsnRet.error_hint = 'The connection was closed because the data that was received was not it a supported format.';
  
          } else if (event.code === 1005) {
              jsnRet.error_title = 'No Status Received';
              jsnRet.error_hint = 'The connection was closed because it received an empty status.';
  
          } else if (event.code === 1006) {
              jsnRet.error_title = 'Abnormal Closure';
              jsnRet.error_hint = 'The connection was closed because of abnormal circumstances.';
  
          } else if (event.code === 1007) {
              jsnRet.error_title = 'Invalid Payload Data';
              jsnRet.error_hint = 'The connection was closed because the payload type did not match the defined message type.';
  
          } else if (event.code === 1008) {
              jsnRet.error_title = 'Policy Violation';
              jsnRet.error_hint = 'The connection was closed because policy governing this connection was violated.';
  
          } else if (event.code === 1009) {
              jsnRet.error_title = 'Message Too Big';
              jsnRet.error_hint = 'The connection was closed because the message was too long for it to proccess.';
  
          } else if (event.code === 1010) {
              jsnRet.error_title = 'Mandatory Extension';
              jsnRet.error_hint = 'The client closed the connection because the server was supposed to negotiate extension(s) but it did not.';
  
          } else if (event.code === 1011) {
              jsnRet.error_title = 'Internal Server';
              jsnRet.error_hint = 'The server closed the connection because it could not fulfill the request.';
  
          } else if (event.code === 1015) {
              jsnRet.error_title = 'TLS handshake';
              jsnRet.error_hint = 'The connection was closed because the handshake failed.';
          }
  
          //console.log(jsnRet);
  
          return jsnRet;
      }
  
      function cleanErrorValue(strValue) {
          strValue = strValue || '';
  
          if (strValue.indexOf('DB_exec failed:') !== -1) {
              strValue = strValue.replace(/[.\s\S]*DB_exec\ failed:/mi, '');
          }
  
          if (strValue.indexOf('Query failed:') !== -1) {
              strValue = strValue.replace(/[.\s\S]*Query\ failed:/mi, '');
          }
  
          if (strValue.indexOf('FATAL') !== -1) {
              strValue = strValue.replace(/[.\s\S]*FATAL/mi, '');
          }
  
          strValue = strValue
                          .replace(/\\n/gi, '\n')
                          .replace(/\\t/gi, '\t')
                          .replace(/\[.*\]/gi, '')
                          .replace(/\([0-9]*\)/gi, '');
  
          return GS.trim(strValue.trim(), '"');
      }
  
      function errorJSONToHTML(errorJSON) {
          //console.log(errorJSON);
          return '<pre style="word-break: break-all; white-space: pre-wrap;">' +
                      (errorJSON.error_title ?
                          'There was ' +
                              (
                                  ['A', 'E', 'I', 'O', 'U']
                                      .indexOf(errorJSON.error_title[0].toUpperCase()) === -1
                                          ? 'a'
                                          : 'an'
                              ) +
                              ' "' + encodeHTML(errorJSON.error_title) + '" error:' :
                          'There was an error:') +
                          (
                              errorJSON.error_text     ? '<br /><br />' + encodeHTML(errorJSON.error_text)
                              :   (errorJSON.error_hint     ? '<br /><br />HINT: ' + encodeHTML(errorJSON.error_hint) : '') +
                                  (errorJSON.error_detail   ? '<br /><br />DETAIL: ' + encodeHTML(errorJSON.error_detail) : '') +
                                  (errorJSON.error_query    ? '<br /><br />QUERY: ' + encodeHTML(errorJSON.error_query) : '') +
                                  (errorJSON.error_position ? '<br /><br />ERROR POSITION: ' + encodeHTML(errorJSON.error_position) : '') +
                                  (errorJSON.error_context  ? '<br /><br />CONTEXT: ' + encodeHTML(errorJSON.error_context) : '') +
                                  (errorJSON.error_notice   ? '<br /><br /><br />' + encodeHTML(errorJSON.error_notice) : '')
                          ) +
                  '</pre>';
      }
  
      GS.webSocketErrorDialog = function (jsnError, tryAgainCallback, cancelCallback) {
          if (GS.bolPreventErrors === false) {
              var templateElement = document.createElement('template'), strHTML, jsnErrorClean;
  
              jsnErrorClean = {};
  
              jsnErrorClean.error_text     = cleanErrorValue(jsnError.error_text);
              jsnErrorClean.error_hint     = cleanErrorValue(jsnError.error_hint);
              jsnErrorClean.error_detail   = cleanErrorValue(jsnError.error_detail);
              jsnErrorClean.error_query    = cleanErrorValue(jsnError.error_query);
              jsnErrorClean.error_position = cleanErrorValue(jsnError.error_position);
              jsnErrorClean.error_context  = cleanErrorValue(jsnError.error_context);
              jsnErrorClean.error_notice   = cleanErrorValue(jsnError.error_notice);
  
              templateElement.setAttribute('data-theme', 'error');
              strHTML = ml(function () {/*
                  <gs-page>
                      <gs-header><center><h3>There was an error!</h3></center></gs-header>
                      <gs-body padded>
                          {{HTML}}
                          <br />
                          <gs-button class="error-button-show-full-text">Show Full Error Text</gs-button>
                      </gs-body>
                      <gs-footer>{{BUTTONS}}</gs-footer>
                  </gs-page>
              */}).replace('{{HTML}}', errorJSONToHTML(jsnErrorClean));
  
              var openFunction = function () {
                  xtag.query(this, '.error-button-show-full-text')[0].addEventListener('click', function () {
                      var templateElement = document.createElement('template');
  
                      templateElement.innerHTML = ml(function () {/*
                          <gs-page>
                              <gs-header><center><h3>Full Error Text</h3></center></gs-header>
                              <gs-body padded>
                                  {{HTML}}
                              </gs-body>
                              <gs-footer><gs-button dialogclose>Done</gs-button></gs-footer>
                          </gs-page>
                      */}).replace('{{HTML}}', errorJSONToHTML(jsnError));
  
                      GS.openDialog(templateElement);
                  });
              };
  
              if (typeof tryAgainCallback === 'function') {
                  templateElement.innerHTML =
                      strHTML.replace(
                          '{{BUTTONS}}',
                          '<gs-grid>' +
                          '    <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>' +
                          '    <gs-block><gs-button dialogclose listen-for-return>Try Again</gs-button></gs-block>' +
                          '</gs-grid>'
                      );
  
                  GS.openDialog(templateElement, openFunction, function (event, strAnswer) {
                      if (strAnswer === 'Try Again') {
                          tryAgainCallback(strAnswer);
                      } else {
                          if (typeof cancelCallback === 'function') {
                              cancelCallback(strAnswer);
                          }
                      }
                  });
  
              } else {
                  templateElement.innerHTML = strHTML.replace('{{BUTTONS}}', '<gs-button dialogclose listen-for-return>Ok</gs-button>');
                  GS.openDialog(templateElement, openFunction);
              }
          }
      };
  
      GS.websockets = new Array();
  
      GS.closeAllSockets = function () {
          var i, len = GS.websockets.length;
          for (i = 0;i < len;i++) {
              GS.closeSocket(GS.websockets[i]);
          }
      };
  
      var sequence = 0, jsnMessages = {}, arrWaitingCalls = [];
      GS.openSocket = function (strLink, relinkSessionID, relinkSessionNotifications, socketname) {
          var strLoc = window.location.toString(),
              intUrlStart = strLoc.indexOf('/pgmanage/') + 10,
              strConn = strLoc.substring(intUrlStart, strLoc.substring(intUrlStart).indexOf('/') + intUrlStart),
              strURL = '';
  
          if (strLoc.indexOf('/pgmanage/') >= 0) {
              strURL =    (window.location.protocol.toLowerCase().indexOf('https') === 0 ? 'wss' : 'ws') +
                          '://' + (window.location.host || window.location.hostname) + '/pgmanage/' + strConn + '/' + strLink +
                          (relinkSessionID ? '?sessionid=' + relinkSessionID : '');
          } else {
              strURL =    (window.location.protocol.toLowerCase().indexOf('https') === 0 ? 'wss' : 'ws') +
                          '://' + (window.location.host || window.location.hostname) + '/' + strLink +
                          (relinkSessionID ? '?sessionid=' + relinkSessionID : '');
          }
  
          var socket = new WebSocket(strURL);
          if (socketname) {
              GS.websockets[socketname] = socket;
          }
  
          GS.websockets.push(socket);
  
          if (relinkSessionID) {
              socket.GSSessionID = relinkSessionID;
              socket.oldSessionID = relinkSessionID;
          }
          if (relinkSessionNotifications) {
              socket.notifications = relinkSessionNotifications;
          } else {
              socket.notifications = [];
          }
          socket.onmessage = function (event) {
              var message = event.data, messageID, responseNumber, key, strError, arrLines, i, len, jsnMessage, startFrom;
  
              if (typeof (message) === 'object') {
                  //window.binaryTestTEST = message;
                  //console.log(message);
                  var buf = message;
                  message = String.fromCharCode.apply(null, new Uint8Array(buf));
                  //console.log(buf);
                  //console.log(message);
              }
  
              // if sessionid
              if (message.indexOf('sessionid = ') === 0) {
                  socket.GSSessionID = message.substring('sessionid = '.length, message.indexOf('\n'));
                  GS.triggerEvent(window, 'socket-connect');
  
                  for (key in jsnMessages) {
                      jsnMessage = jsnMessages[key];
  
                      if (
                          jsnMessage &&
                          (
                              jsnMessage.session === socket.GSSessionID ||
                              jsnMessage.session === socket.oldSessionID
                          ) &&
                          jsnMessage.bolFinished === false
                      ) {
  
                          jsnMessage.session = socket.GSSessionID;
  
                          startFrom = 1;
                          for (i = 0, len = jsnMessage.arrResponseNumbers.length; i < len; i += 1) {
                              // if there is a difference between the current response number and the
                              //      startFrom: stop looping because startFrom now holds the number that we want
                              if (startFrom !== jsnMessage.arrResponseNumbers[i]) {
                                  break;
                              }
                              startFrom += 1;
                          }
  
                          GS.requestFromSocket(socket, 'SEND FROM\t' + startFrom, '', jsnMessage.id);
                      }
                  }
  
                  for (i = 0, len = arrWaitingCalls.length; i < len; i += 1) {
                      arrWaitingCalls[0]();
                      arrWaitingCalls.splice(0, 1);
                  }
  
              // else
              } else {
                  messageID = message.substring('messageid = '.length, message.indexOf('\n'));
                  message = message.substring(message.indexOf('\n') + 1);
  
                  jsnMessage = jsnMessages[messageID];
  
                  // if there is a message entry for this message ID
                  if (jsnMessage) {
                      arrLines = message.split('\n');
  
                      // if there is no response number: assume this is the last message and mark the message as finished
                      if (message.indexOf('responsenumber = ') === -1 ||
                          (
                              message.indexOf('responsenumber = ') === 0 &&
                              (
                                  arrLines[1] === 'TRANSACTION COMPLETED' ||
                                  arrLines[2] === 'OK'
                              )
                          )) {
                          jsnMessage.bolFinished = true;
                      }
  
                      // if there is a response number
                      if (message.indexOf('responsenumber = ') === 0) {
                          // get message number
                          responseNumber = message.substring('responsenumber = '.length, message.indexOf('\n'));
                          message = message.substring(message.indexOf('\n') + 1);
  
                          // append message number and message content to arrays
                          jsnMessage.arrResponseNumbers.push(parseInt(responseNumber, 10));
                          jsnMessage.arrResponses.push(message);
  
                          // send confirm signal
                          GS.requestFromSocket(socket, 'CONFIRM\t' + responseNumber, '', messageID);
                      }
  
                      // ERROR CHECK
                      arrLines = message.split('\n');
  
                      // if there is a transactionid: look at the second line
                      if (arrLines[0].indexOf('transactionid') === 0 && arrLines[1] === 'FATAL') {
                          strError = 'error';
                          message = message.substring(message.indexOf('\n') + 1);
                          message = message.substring(message.indexOf('\n') + 1);
                          message = arrLines[0] + '\n' + message;
  
                      // else: check the first line
                      } else if (arrLines[0] === 'FATAL') {
                          strError = 'error';
                          message = message.substring(message.indexOf('\n') + 1);
                      }
  
                      // if transaction complete: clear message arrays and mark as finised
                      if (message === 'TRANSACTION COMPLETED') { // || message === 'EMPTY\n\\.'
                          jsnMessage.arrResponseNumbers = [];
                          jsnMessage.arrResponses = [];
                          jsnMessage.bolFinished = true;
                      }
  
                      // if there was a FATAL: mark as finished and apply callback
                      if (strError) {
                          jsnMessage.bolFinished = true;
                          jsnMessage.callback.apply(null, [message, strError, webSocketNormalizeError(event)]);
  
                      // else: call callback with message
                      } else {
                          jsnMessage.callback.apply(null, [message]);
                      }
  
                      if (jsnMessage.bolFinished === true) {
                          delete jsnMessages[messageID];
                      }
  
                  // else if the messageID is 'NULL': notification from the server
                  } else if (messageID === 'NULL') {
                      socket.notifications.push(message);
                      GS.triggerEvent(window, 'notification', {'socket': socket, 'message': message});
                  }
              }
          };
  
          socket.onopen = function (event) {
  
          };
  
          socket.onerror = function (event) {
              var i, len;
  
              console.log('SOCKET ERROR', event);
              socket.bolError = true;
              //socket.stayClosed = true;
  
              //for (i = 0, len = arrWaitingCalls.length; i < len; i += 1) {
              //    arrWaitingCalls[0]();
              //    arrWaitingCalls.splice(0, 1);
              //}
          };
  
          socket.onclose = function (event) {
              console.log('SOCKET CLOSING', socket.stayClosed, socket.bolError, event);
  
              // error closure dialog
              if (socket.bolError && arrWaitingCalls.length > 0) {
                  // abnormal closure
                  if (event.code === 1006) {
                      webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. We cannot display the reasons for this closure because the browser does not give us access to those details, please check the server logs for the error details.');
  
                  // protocol error
                  } else if (event.code === 1002) {
                      webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. Either the server or the browser has closed the connection because of a Websocket Protocol error.');
  
                  // type error
                  } else if (event.code === 1003) {
                      webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. Either the server or the browser has closed the connection because of it was sent a data type it could not understand.');
                  } else {
                      webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. The cause of this is unknown.');
                  }
              }
  
              if (!socket.stayClosed) {
                  setTimeout(function() {
                      console.log('ATTEMPTING SOCKET RE-OPEN', socket);
                      GS.triggerEvent(window, 'socket-reconnect');
                      if (socketname) {
                          GS.closeSocket(GS.websockets[socketname]);
                          GS.websockets[socketname] = GS.openSocket('env', GS.websockets[socketname].GSSessionID, GS.websockets[socketname].notifications);
                      } else {
                          GS.closeSocket(GS.envSocket);
                          GS.envSocket = GS.openSocket('env', GS.envSocket.GSSessionID, GS.envSocket.notifications);
                      }
                  }, 1000);
              } else {
                  if (socket.bolError) {
                      console.log('SOCKET NOT RE-OPENING DUE TO ERROR');
                  } else {
                      console.log('SOCKET NOT RE-OPENING DUE TO MANUAL CLOSE');
                  }
              }
          };
  
          return socket;
      };
  
      GS.requestFromSocket = function (socket, strMessage, callback, forceMessageID) {
          var oldOnOpen, messageID;
  
          if (!socket || socket.readyState === socket.CLOSED) {
              if (!GS.envSocket || GS.envSocket.readyState === socket.CLOSED) {
                  //console.trace('ATTEMPTING SOCKET RE-OPEN 2');
                  GS.envSocket = GS.openSocket('env');
              }
              socket = GS.envSocket;
          }
  
          // if the socket is open: register callback and send request
          if (socket.readyState === socket.OPEN && socket.GSSessionID) {
  
              if (!forceMessageID) {
                  sequence += 1;
                  messageID = socket.GSSessionID + '_' + sequence;
                  jsnMessages[messageID] = {
                      'id': messageID,
                      'session': socket.GSSessionID,
                      'callback': callback,
                      'arrResponseNumbers': [],
                      'arrResponses': [],
                      'bolFinished': false
                  };
  
              } else {
                  messageID = forceMessageID;
              }
  
              if (typeof (strMessage) === 'object') {
                  jsnMessages[messageID].parameters = new Blob(['messageid = ' + messageID + '\n', strMessage], {type: 'application/x-binary'});
              } else {
                  jsnMessages[messageID].parameters = 'messageid = ' + messageID + '\n' + strMessage;
              }
              socket.send(jsnMessages[messageID].parameters);
              //console.log('SOCKET MESSAGE SENT                   ', 'messageid = ' + sequence);// + '\n' + strMessage);
  
              return messageID;
  
          // if the socket is connecting: bind socket onopen to call this funtion again
          } else if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
              //console.log('SOCKET REQUEST WHILE CONNECTING       ');
  
              arrWaitingCalls.push(function () {
                  GS.requestFromSocket(socket, strMessage, callback);
              });
  
          // if the socket is closed: error
          } else if (socket.readyState === socket.CLOSED) {
              //console.log('SOCKET REQUEST WHILE CLOSED           ');
              callback.apply(null, ['Socket Is Closed', 'error', webSocketNormalizeError({'reason': 'Socket Is Closed'})]);
  
          // if the socket is closing: error
          } else if (socket.readyState === socket.CLOSING) {
              //console.log('SOCKET REQUEST WHILE CLOSING          ');
              callback.apply(null, ['Socket Is Closing', 'error', webSocketNormalizeError({'reason': 'Socket Is Closing'})]);
          }
      };
  
  
      GS.requestActionFromSocket = function (socket, strSchema, strObject, strArgs, finalCallback) {
          var strMessage = 'ACTION\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                              '\t' + encodeForTabDelimited(strArgs) + '\n',
              intResponse = 0, strRet;
  
          //console.log(strMessage);
  
          GS.requestFromSocket(socket, strMessage, function (data, error, errorData) {
              var arrLines, i, len;
              if (!error) {
                  if (intResponse === 0) {
                      strRet = data;
  
                  } else {
                      finalCallback(strRet, error);
                  }
  
              } else {
                  finalCallback(errorData, error);
              }
              intResponse += 1;
          });
      };
  
      // abstraction function for ease of use of the RAW format
      GS.requestRawFromSocket = function (socket, strQuery, callback, bolAutocommit) {
          var intResponsePart = 0, intQueryNumber = 0, intCallbackNumber = 0, intCallbackNumberThisQuery = 0
            , intResponseNumberThisQuery = 0, arrMessages, arrColumnNames, arrColumnTypes
            , arrStart, dteStart, arrEnd, dteEnd, intRows;
  
          bolAutocommit = bolAutocommit !== undefined ? bolAutocommit : true;
          return GS.requestFromSocket(socket, 'RAW' + (!bolAutocommit ? '\tDISABLE AUTOCOMMIT\n' : '\n') + strQuery, function (data, error, errorData) {
              var arrRecords, arrLines, i, len, strMode;
  
              if (!error) {
                  if (intResponseNumberThisQuery === 0) {
                      // clear variables
                      strQuery = '';
                      arrMessages = [];
                      arrColumnNames = [];
                      arrColumnTypes = [];
                  }
  
                  // if QUERY is found: reset response part to 0
                  if (data.indexOf('QUERY\n') === 0) {
                      //console.log('Per Query Reset');
                      intResponsePart = 0;
                      intCallbackNumberThisQuery = 0;
                  }
  
                  // if first line is 'Rows Affected': add one to intResponsePart
                  if (data.indexOf('Rows Affected\n') === 0 || data === 'EMPTY' || data === 'TRANSACTION COMPLETED' || data === 'TRANSACTION OPEN') {
                      intResponsePart += 1;
                  }
  
                  //console.log('1***', data);
                  //console.log(intResponsePart, data);
  
                  // response part 0 is:
                  //      strQuery
                  //      arrMessages
                  //      arrColumnNames
                  //      arrColumnTypes
                  if (intResponsePart === 0) {
                      //console.log('2***');
                      // split lines
                      arrLines = data.split('\n');
  
                      // loop through lines
                      for (i = 0, len = arrLines.length; i < len; i += 1) {
                          // if mode line: set mode
                          if (arrLines[i].indexOf('QUERY\t') === 0 ||
                              arrLines[i].indexOf('START\t') === 0 ||
                              arrLines[i].indexOf('END\t') === 0 ||
                              arrLines[i].indexOf('ROWS\t') === 0 ||
                              arrLines[i].indexOf('DEBUG\t') === 0 ||
                              arrLines[i].indexOf('LOG\t') === 0 ||
                              arrLines[i].indexOf('INFO\t') === 0 ||
                              arrLines[i].indexOf('NOTICE\t') === 0 ||
                              arrLines[i].indexOf('WARNING\t') === 0 ||
                              arrLines[i] === 'COLUMNS') {
  
                              if (arrLines[i] === 'COLUMNS') {
                                  strMode = arrLines[i];
                              } else {
                                  strMode = arrLines[i].substring(0, arrLines[i].indexOf('\t'));
                              }
                          }
  
                          //console.log(strMode, arrLines[i]);
  
                          // if mode is QUERY: save query
                          if (strMode === 'QUERY') {
                              strQuery = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1));
                              //console.log(arrLines[i], strQuery);
  
                          // if mode is START: save start
                          } else if (strMode === 'START') {
                              arrStart = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1)).split('\t');
                              dteStart = new Date(arrStart[0] + ' ' + arrStart[1] + ' GMT');
                              if (arrStart[2]) {
                                  dteStart.setMilliseconds(parseInt(arrStart[2], 10) / 1000);
                              }
                              //console.log(strStart, dteStart);
  
                          // if mode is END: save end
                          } else if (strMode === 'END') {
                              arrEnd = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1)).split('\t');
                              dteEnd = new Date(arrEnd[0] + ' ' + arrEnd[1] + ' GMT');
                              if (arrEnd[2]) {
                                  dteEnd.setMilliseconds(parseInt(arrEnd[2], 10) / 1000);
                              }
                              //console.log(strEnd, dteEnd);
  
                          // if mode is ROWS: save total rows
                          } else if (strMode === 'ROWS') {
                              intRows = parseInt(GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1)), 10);
  
                          // if mode is DEBUG: add DEBUG to array
                          } else if (strMode === 'DEBUG') {
                              arrMessages.push({
                                  'level': 'DEBUG',
                                  'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                              });
  
                          // if mode is LOG: add LOG to array
                          } else if (strMode === 'LOG') {
                              arrMessages.push({
                                  'level': 'LOG',
                                  'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                              });
  
                          // if mode is INFO: add INFO to array
                          } else if (strMode === 'INFO') {
                              arrMessages.push({
                                  'level': 'INFO',
                                  'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                              });
  
                          // if mode is NOTICE: add NOTICE to array
                          } else if (strMode === 'NOTICE') {
                              arrMessages.push({
                                  'level': 'NOTICE',
                                  'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                              });
  
                          // if mode is WARNING: add WARNING to array
                          } else if (strMode === 'WARNING') {
                              arrMessages.push({
                                  'level': 'WARNING',
                                  'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                              });
  
                          // if mode is COLUMNS: get COLUMNS
                          } else if (strMode === 'COLUMNS') {
                              arrColumnNames = arrLines[i + 1].split('\t');
                              arrColumnTypes = arrLines[i + 2].split('\t');
                              intResponsePart += 1;
                              break;
                          }
                      }
  
                  } else if (intResponsePart >= 1) {
                      //console.log(intQueryNumber, intCallbackNumber, intCallbackNumberThisQuery,
                      //            strQuery, arrMessages, arrColumnNames, arrColumnTypes, data);
                      //console.log('3***');
                      if (typeof callback === 'function') {
                          //console.log('4*** CALLBACK');
                          callback({
                              'intQueryNumber': intQueryNumber,
                              'intCallbackNumber': intCallbackNumber,
                              'intCallbackNumberThisQuery': intCallbackNumberThisQuery,
                              'strQuery': strQuery,
                              'dteStart': dteStart,
                              'dteEnd': dteEnd,
                              'intRows': intRows,
                              'arrMessages': arrMessages,
                              'arrColumnNames': arrColumnNames,
                              'arrColumnTypes': arrColumnTypes,
                              'strMessage': (data !== 'TRANSACTION COMPLETED' || data === 'TRANSACTION OPEN' ? data : ''),
                              'bolLastMessage': (data === 'TRANSACTION COMPLETED' || data === 'TRANSACTION OPEN'),
                              'bolTransactionOpen': (data === 'TRANSACTION OPEN')
                          }, error);
  
                          intCallbackNumber += 1;
                          intCallbackNumberThisQuery += 1;
                      }
                  }
  
                  intResponseNumberThisQuery += 1;
  
                  if (data === '\\.' || data.indexOf('Rows Affected\n') === 0) {
                      intQueryNumber += 1;
                      intCallbackNumberThisQuery = 0;
                      intResponsePart = 0;
                      intResponseNumberThisQuery = 0;
                  }
  
              } else {
                  // if QUERY is found: reset response part to 0
                  if (data.indexOf('QUERY\n') === 0) {
                      //console.log('Per Query Reset');
                      intResponsePart = 0;
                      intCallbackNumberThisQuery = 0;
                  }
  
                  if (intResponsePart === 0) {
                      //console.log('2***');
                      // split lines
                      arrLines = data.split('\n');
  
                      // loop through lines
                      for (i = 0, len = arrLines.length; i < len; i += 1) {
                          // if mode line: set mode
                          if (arrLines[i].indexOf('QUERY\t') === 0 ||
                              arrLines[i].indexOf('START\t') === 0 ||
                              arrLines[i].indexOf('END\t') === 0 ||
                              arrLines[i].indexOf('ROWS\t') === 0 ||
                              arrLines[i].indexOf('DEBUG\t') === 0 ||
                              arrLines[i].indexOf('LOG\t') === 0 ||
                              arrLines[i].indexOf('INFO\t') === 0 ||
                              arrLines[i].indexOf('NOTICE\t') === 0 ||
                              arrLines[i].indexOf('WARNING\t') === 0 ||
                              arrLines[i] === 'COLUMNS') {
  
                              if (arrLines[i] === 'COLUMNS') {
                                  strMode = arrLines[i];
                              } else {
                                  strMode = arrLines[i].substring(0, arrLines[i].indexOf('\t'));
                              }
                          }
  
                          //console.log(strMode, arrLines[i]);
  
                          // if mode is QUERY: save query
                          if (strMode === 'QUERY') {
                              strQuery = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1));
                              //console.log(arrLines[i], strQuery);
  
                          // if mode is COLUMNS: get COLUMNS
                          } else if (strMode === 'COLUMNS') {
                              break;
                          }
                      }
                  }
  
                  errorData.strQuery = strQuery;
                  errorData.arrMessages = arrMessages
                  if (typeof callback === 'function') {
                      callback(errorData, error);
                  }
              }
          });
      };
  
      GS.requestSelectFromSocket = function (socket, strSchema, strObject, strReturnCols, strWhere, strOrd, strLimit, strOffset, finalCallback) {
          var strMessage = 'SELECT\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                              '\nRETURN\t' + strReturnCols + '\n\n' +
                              'where\t' + (strOrd ? 'order by\t' : '') + 'limit\toffset\n' +
                              encodeForTabDelimited(strWhere || '1=1') + '\t' + (strOrd ? encodeForTabDelimited(strOrd) + '\t' : '') +
                              encodeForTabDelimited(strLimit || 'ALL') + '\t' + encodeForTabDelimited(strOffset || '0'),
              intResponse = 0, intCallback = 0, arrColumnNames, arrColumnTypes, arrDecodedColumnNames, arrDecodedColumnTypes;
  
          //console.log(strMessage);
  
          GS.requestFromSocket(socket, strMessage, function (data, error, errorData) {
              var arrLines, i, len;
              if (!error) {
                  if (intResponse === 0) {
                      arrLines = data.split('\n');
                      arrColumnNames = arrLines[0].split('\t');
                      arrColumnTypes = arrLines[1].split('\t');
                      arrDecodedColumnNames = [];
                      arrDecodedColumnTypes = [];
  
                      for (i = 0, len = arrColumnNames.length; i < len; i += 1) {
                          arrDecodedColumnNames.push(GS.decodeFromTabDelimited(arrColumnNames[i]));
                      }
  
                      for (i = 0, len = arrColumnTypes.length; i < len; i += 1) {
                          arrDecodedColumnTypes.push(GS.decodeFromTabDelimited(arrColumnTypes[i]));
                      }
  
                  } else {
                      finalCallback({
                          'arrColumnNames': arrColumnNames,
                          'arrColumnTypes': arrColumnTypes,
                          'arrDecodedColumnNames': arrDecodedColumnNames,
                          'arrDecodedColumnTypes': arrDecodedColumnTypes,
                          'intCallback': intCallback,
                          'strMessage': data
                      }, error);
                      intCallback += 1;
                  }
  
              } else {
                  finalCallback(errorData, error);
              }
              intResponse += 1;
          });
      };
  
      GS.requestArbitrarySelectFromSocket = function (socket, strSQL, strWhere, strOrd, strLimit, strOffset, finalCallback) {
          var strMessage = (
              'SELECT\t' + encodeForTabDelimited(strSQL) +
              '\nRETURN\t*\n\n' +
              'where\t' +
              (strOrd ? 'order by\t' : '') +
              'limit\t' +
              'offset\n' +
              encodeForTabDelimited(strWhere || '1=1') + '\t' +
              (strOrd ? encodeForTabDelimited(strOrd) + '\t' : '') +
              encodeForTabDelimited(strLimit || 'ALL') + '\t' +
              encodeForTabDelimited(strOffset || '0')
          );
          var intResponse = 0;
          var intCallback = 0;
          var arrColumnNames;
          var arrColumnTypes;
          var arrDecodedColumnNames;
          var arrDecodedColumnTypes;
  
          //console.log(strMessage);
  
          GS.requestFromSocket(socket, strMessage, function (data, error, errorData) {
              var arrLines, i, len;
              if (!error) {
                  if (intResponse === 0) {
                      arrLines = data.split('\n');
                      arrColumnNames = arrLines[0].split('\t');
                      arrColumnTypes = arrLines[1].split('\t');
                      arrDecodedColumnNames = [];
                      arrDecodedColumnTypes = [];
  
                      for (i = 0, len = arrColumnNames.length; i < len; i += 1) {
                          arrDecodedColumnNames.push(GS.decodeFromTabDelimited(arrColumnNames[i]));
                      }
  
                      for (i = 0, len = arrColumnTypes.length; i < len; i += 1) {
                          arrDecodedColumnTypes.push(GS.decodeFromTabDelimited(arrColumnTypes[i]));
                      }
  
                  } else {
                      finalCallback({
                          'arrColumnNames': arrColumnNames,
                          'arrColumnTypes': arrColumnTypes,
                          'arrDecodedColumnNames': arrDecodedColumnNames,
                          'arrDecodedColumnTypes': arrDecodedColumnTypes,
                          'intCallback': intCallback,
                          'strMessage': data
                      }, error);
                      intCallback += 1;
                  }
  
              } else {
                  finalCallback(errorData, error);
              }
              intResponse += 1;
          });
      };
  
      /*
          INSERT	test	rmultiple_pk_test
          RETURN	id1	id2	id3	page_name_pk	id4	test1	test2	test3
          PK	id1	id2	id3	page_name_pk	id4
          SEQ	test.seq1	test.seq2
  
          page_name_pk	test1	test2	test3
          page_name_pk1	test1	test2	test3
          page_name_pk2	test1	test2	test3
          page_name_pk3	test1	test2	test3
          page_name_pk4	test1	test2	test3
  
  
  
          If a column is being inserted, then the SEQ entry for it needs to be empty
      */
      GS.requestInsertFromSocket = function (socket, strSchema, strObject, strReturnCols, strPkCols, strSeqCols, insertData, beginCallback, confirmCallback, finalCallback) {
          var strMessage = 'INSERT\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                           '\nRETURN\t' + strReturnCols +
                           (strPkCols ? '\nPK\t' + strPkCols : '') +
                           (strPkCols ? '\nSEQ\t' + strSeqCols : '') +
                           '\n\n' + insertData;
  
          //console.log(strMessage);
  
          GS.requestBegin(socket, function (data, error) {
              var transactionID;
  
              if (!error) {
                  transactionID = data;
                  if (typeof beginCallback === 'function') { beginCallback(data, error); }
  
                  GS.requestFromSocket(GS.envSocket, 'transactionid = ' + transactionID + '\n' + strMessage, function (data, error, errorData) {
                      var commitFunction, rollbackFunction;
  
                      if (!error) {
                          data = data.substring(data.indexOf('\n') + 1); // transactionid
                          //data = data.substring(data.indexOf('\n') + 1); // responsenumber
                      }
  
                      console.log('INSERT DATA:', data);
                      console.log('INSERT TRANSID:', transactionID);
  
                      commitFunction = function () {
                          GS.requestCommit(socket, transactionID, function (data, error) {
                              if (!error) { data = data.substring(data.indexOf('\n') + 1); }
  
                              finalCallback('COMMIT', data, error);
                          });
                      };
                      rollbackFunction = function () {
                          GS.requestRollback(socket, transactionID, function (data, error) {
                              if (!error) { data = data.substring(data.indexOf('\n') + 1); }
  
                              finalCallback('ROLLBACK', data, error);
                          });
                      };
  
                      if (!error) {
                          confirmCallback(data, error, transactionID, commitFunction, rollbackFunction);
                      } else {
                          confirmCallback(errorData, error, transactionID, commitFunction, rollbackFunction);
                      }
                  });
  
              } else {
                  if (typeof beginCallback === 'function') { beginCallback(data, error); }
              }
          });
      };
  
  
      GS.requestUpdateFromSocket = function (socket, strSchema, strObject, strReturnCols, strHashCols, updateData, beginCallback, confirmCallback, finalCallback) {
          var strMessage = 'UPDATE\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                           '\nRETURN\t' + strReturnCols +
                           (strHashCols ? '\nHASH\t' + strHashCols : '') +
                           '\n\n' + updateData;
  
          //console.log(strMessage);
  
          GS.requestBegin(socket, function (data, error) {
              var transactionID;
  
              if (!error) {
                  transactionID = data;
                  if (typeof beginCallback === 'function') { beginCallback(data, error); }
  
                  GS.requestFromSocket(GS.envSocket, 'transactionid = ' + transactionID + '\n' + strMessage, function (data, error, errorData) {
                      var commitFunction, rollbackFunction;
  
                      if (!error) {
                          data = data.substring(data.indexOf('\n') + 1); // transactionid
                          //data = data.substring(data.indexOf('\n') + 1); // responsenumber
                      }
  
                      commitFunction = function () {
                          GS.requestCommit(socket, transactionID, function (data, error) {
                              if (!error) { data = data.substring(data.indexOf('\n') + 1); }
  
                              finalCallback('COMMIT', data, error);
                          });
                      };
                      rollbackFunction = function () {
                          GS.requestRollback(socket, transactionID, function (data, error) {
                              if (!error) { data = data.substring(data.indexOf('\n') + 1); }
  
                              finalCallback('ROLLBACK', data, error);
                          });
                      };
  
                      if (!error) {
                          confirmCallback(data, error, transactionID, commitFunction, rollbackFunction);
                      } else {
                          confirmCallback(errorData, error, transactionID, commitFunction, rollbackFunction);
                      }
                  });
  
              } else {
                  if (typeof beginCallback === 'function') { beginCallback(data, error); }
              }
          });
      };
  
      GS.requestDeleteFromSocket = function (socket, strSchema, strObject, strHashCols, deleteData, beginCallback, confirmCallback, finalCallback) {
          var strMessage = 'DELETE\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                           (strHashCols ? '\nHASH\t' + strHashCols : '') + '\n\n' +
                           deleteData;
  
          //console.log(strMessage);
  
          GS.requestBegin(socket, function (data, error) {
              var transactionID;
  
              if (!error) {
                  transactionID = data;
                  if (typeof beginCallback === 'function') { beginCallback(data, error); }
  
                  GS.requestFromSocket(GS.envSocket, 'transactionid = ' + transactionID + '\n' + strMessage, function (data, error, errorData) {
                      var commitFunction, rollbackFunction;
  
                      if (!error) {
                          data = data.substring(data.indexOf('\n') + 1); // transactionid
                          //data = data.substring(data.indexOf('\n') + 1); // responsenumber
                      }
  
                      commitFunction = function () {
                          GS.requestCommit(socket, transactionID, function (data, error) {
                              if (!error) { data = data.substring(data.indexOf('\n') + 1); }
  
                              finalCallback('COMMIT', data, error);
                          });
                      };
                      rollbackFunction = function () {
                          GS.requestRollback(socket, transactionID, function (data, error) {
                              if (!error) { data = data.substring(data.indexOf('\n') + 1); }
  
                              finalCallback('ROLLBACK', data, error);
                          });
                      };
  
                      if (!error) {
                          confirmCallback(data, error, transactionID, commitFunction, rollbackFunction);
                      } else {
                          confirmCallback(errorData, error, transactionID, commitFunction, rollbackFunction);
                      }
                  });
  
              } else {
                  if (typeof beginCallback === 'function') { beginCallback(data, error); }
              }
          });
      };
  
      GS.requestBegin = function (socket, callback) {
          GS.requestFromSocket(GS.envSocket, 'BEGIN', function (data, error, errorData) {
              var transactionID;
  
              if (typeof callback === 'function') {
                  if (!error) {
                      transactionID = data.substring('transactionid = '.length, data.indexOf('\n'));
                      callback(transactionID, error);
                  } else {
                      callback(errorData, error);
                  }
              }
          });
      };
  
      GS.requestRollback = function (socket, transactionID, callback) {
          GS.requestFromSocket(socket, 'transactionid = ' + transactionID + '\nROLLBACK', function (data, error, errorData) {
              if (typeof callback === 'function') {
                  if (!error) {
                      callback(data, error);
                  } else {
                      callback(errorData, error);
                  }
              }
          });
      };
  
      GS.requestCommit = function (socket, transactionID, callback) {
          GS.requestFromSocket(socket, 'transactionid = ' + transactionID + '\nCOMMIT', function (data, error, errorData) {
              if (typeof callback === 'function') {
                  if (!error) {
                      callback(data, error);
                  } else {
                      callback(errorData, error);
                  }
              }
          });
      };
  
      GS.rebootSocket = function (socket) {
          socket.stayClosed = false;
          socket.close();
      };
  
      GS.closeSocket = function (socket) {
          socket.stayClosed = true;
          socket.close();
      };
  
  
      var cacheLedger = [];
      window.testtesttest = cacheLedger;
      GS.requestCachingSelect = function (socket, strSchema, strObject, strColumns, strWhere, strOrd, strLimit, strOffset, callback, bolClearCache) {
          var strKey = (strSchema + strObject + strColumns + strWhere + strOrd + strLimit + strOffset)
            , intQueryIndex, i, len, currentEntry;
  
          //console.log(strKey, bolClearCache, cacheLedger[strKey]);
  
          if (bolClearCache) {
              cacheLedger[strKey] = null;
          }
  
          if (cacheLedger[strKey]) {
              for (i = 0, len = cacheLedger[strKey].results.length; i < len; i += 1) {
                  callback(cacheLedger[strKey].results[i][0], cacheLedger[strKey].results[i][1]);
              }
              cacheLedger[strKey].callbacks.push({'callback': callback, 'ready': true});
  
          } else {
              currentEntry = cacheLedger[strKey] = {
                  results: [],
                  callbacks: [
                      {'callback': callback, 'ready': true}
                  ]
              };
  
              //console.log('cache:' + bolClearCache);
              GS.requestSelectFromSocket(socket, strSchema, strObject, strColumns
                                       , strWhere, strOrd, strLimit, strOffset
                                       , function (data, error) {
                  var i, len;
  
                  //console.log('data:', data);
                  currentEntry.results.push([data, error]);
  
                  for (i = 0, len = currentEntry.callbacks.length; i < len; i += 1) {
                      if (currentEntry.callbacks[i].ready) {
                          currentEntry.callbacks[i].callback(data, error);
                      }
                  }
              });
          }
      };
  
      // Nunzio removed on 2017-05-06
      /*
      var cacheQueries = [], cacheCallbacks = [], cacheResults = [];
      GS.requestCachingSelect = function (socket, strSchema, strObject, strColumns, strWhere, strOrd, strLimit, strOffset, callback, bolClearCache) {
          var strKey = (strSchema + strObject + strColumns + strWhere + strOrd + strLimit + strOffset)
            , intQueryIndex, i, len;
  
          if (bolClearCache) {
              intQueryIndex = cacheQueries.indexOf(strKey);
  
              cacheQueries.splice(intQueryIndex, 1);
              cacheCallbacks.splice(intQueryIndex, 1);
              cacheResults.splice(intQueryIndex, 1);
          }
  
          intQueryIndex = cacheQueries.indexOf(strKey);
  
          if (intQueryIndex !== -1) {
              for (i = 0, len = cacheResults[intQueryIndex].length; i < len; i += 1) {
                  callback(cacheResults[intQueryIndex][i][0], cacheResults[intQueryIndex][i][1]);
              }
              cacheCallbacks[intQueryIndex].push({'callback': callback, 'ready': true});
  
          } else {
              //console.log(strKey);
              //console.log(cacheQueries.length);
              cacheQueries.push(strKey);
              cacheCallbacks.push([{'callback': callback, 'ready': true}]);
              cacheResults.push([]);
              //console.log(cacheQueries.length);
              intQueryIndex = (cacheQueries.length - 1);
              //console.log(intQueryIndex);
  
              GS.requestSelectFromSocket(socket, strSchema, strObject, strColumns
                                       , strWhere, strOrd, strLimit, strOffset
                                       , function (data, error) {
                  var i, len;
  
                  cacheResults[intQueryIndex].push([data, error]);
  
                  for (i = 0, len = cacheCallbacks[intQueryIndex].length; i < len; i += 1) {
                      if (cacheCallbacks[intQueryIndex][i].ready) {
                          cacheCallbacks[intQueryIndex][i].callback(data, error);
                      }
                  }
              });
          }
      };*/
  })();
  
  
  // GS.encodeForTabDelimited('asdf\\asdf\\asdf\r\nasdf\r\nasdf\tasdf\tasdf')
  GS.encodeForTabDelimited = function (strValue, nullValue) {
      'use strict';
      strValue = String(strValue || '');
  
      if (strValue === '\\N') {
          return strValue;
      } else {
          strValue = strValue.replace(/\\/g, '\\\\') // double up backslashes
                          .replace(/\n/g, '\\n')     // replace newline with the text representation '\n'
                          .replace(/\r/g, '\\r')     // replace carriage return with the text representation '\r'
                          .replace(/\t/g, '\\t');    // replace tab with the text representation '\t'
  
          if (strValue === nullValue) {
              strValue = '\\N';
          }
  
          return strValue;
      }
  };
  
  // GS.decodeFromTabDelimited('asdf\\\\asdf\\\\asdf\\r\\nasdf\\r\\nasdf\\tasdf\\tasdf')
  GS.decodeFromTabDelimited = function (strValue, nullValue) {
      'use strict';
      var i, len, strRet = '';
      //console.log(strValue, nullValue);
      if (nullValue === undefined) {
          nullValue = '\\N';
      }
  
      for (i = 0, len = strValue.length; i < len; i += 1) {
          if (strValue[i] === '\\' && strValue[i + 1]) {
              i += 1;
  
              if (strValue[i] === 'n') {
                  strRet += '\n';
  
              } else if (strValue[i] === 'r') {
                  strRet += '\r';
  
              } else if (strValue[i] === 't') {
                  strRet += '\t';
  
              } else if (strValue[i] === 'N') {
                  strRet += nullValue;
  
              } else if (strValue[i] === '\\') {
                  strRet += '\\';
  
              } else {
                  strRet += '\\' + strValue[i];
              }
  
          } else {
              strRet += strValue[i];
          }
      }
  
      return strRet;
  
      //return strValue.replace(/\\\\/g, '\\')
      //               .replace(/\\n/g, '\n')
      //               .replace(/\\r/g, '\r')
      //               .replace(/\\t/g, '\t')
      //               .replace(/\\N/g, 'NULL');
  };
  
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('GS.rightPad', 'GS.rightPad',
                                      'GS.rightPad(${1:stringToPad}, \'${2:stringToPadWith}\', ${0:lengthToPadTo});');
      
      registerDesignSnippet('GS.leftPad', 'GS.leftPad',
                                      'GS.leftPad(${1:stringToPad}, \'${2:stringToPadWith}\', ${0:lengthToPadTo});');
      
      registerDesignSnippet('GS.pxToEm', 'GS.pxToEm', 'GS.pxToEm(${1:elementToTestIn}, ${0:pxToConvert});');
      
      registerDesignSnippet('GS.emToPx', 'GS.emToPx', 'GS.emToPx(${1:elementToTestIn}, ${0:emToConvert});');
  
      registerDesignSnippet('GS.keyCode', 'GS.keyCode', 'GS.keyCode(\'${0:characterToGetTheKeyCodeOf}\');');
      
      registerDesignSnippet('GS.charFromKeyCode', 'GS.charFromKeyCode', 'GS.charFromKeyCode(\'${0:eventObject}\');');
      
      registerDesignSnippet('GS.getStyle', 'GS.getStyle', 'GS.getStyle(${1:element}, \'${0:CSSProperty}\');');
      
      registerDesignSnippet('GS.listAdd', 'GS.listAdd', 'GS.listAdd(${1:arrayToAddTo}, \'${0:valueToAddIfUnique}\');');
      
      registerDesignSnippet('GS.triggerEvent', 'GS.triggerEvent', 'GS.triggerEvent(${1:target}, \'${2:eventName}\', ${0:jsnModifiers});');
      
      registerDesignSnippet('GS.strToTitle', 'GS.strToTitle', 'GS.strToTitle(${0:valueToConvert});');
      
      registerDesignSnippet('GS.mousePosition', 'GS.mousePosition', 'GS.mousePosition(${0:event});');
      
      registerDesignSnippet('GS.GUID', 'GS.GUID', 'GS.GUID();');
      
      registerDesignSnippet('GS.safeDecodeURIComponent', 'GS.safeDecodeURIComponent', 'GS.safeDecodeURIComponent(${0:valueToDecode});');
      
      registerDesignSnippet('GS.getTextHeight', 'GS.getTextHeight', 'GS.getTextHeight(${1:elementToTestIn}, ${0:bolNormalLineHeight});');
      
      registerDesignSnippet('GS.getTextWidth', 'GS.getTextWidth', 'GS.getTextWidth(${1:elementToTestIn}, ${0:strTextToGetTheWidthOf});');
      
      registerDesignSnippet('GS.scrollParent', 'GS.scrollParent', 'GS.scrollParent(${0:elementToStartFrom});');
      
      registerDesignSnippet('GS.scrollIntoView', 'GS.scrollIntoView', 'GS.scrollIntoView(${0:elementToScrollIntoView});');
      
      registerDesignSnippet('GS.envGetCell', 'GS.envGetCell', 'GS.envGetCell(${1:envelopeData}, ${2:recordNumber}, \'${0:columnName}\');');
      
      registerDesignSnippet('GS.trim', 'GS.trim', 'GS.trim(${1:stringToBeTrimmed}, \'${0:stringToTrimOff}\');');
      
      registerDesignSnippet('GS.setCookie', 'GS.setCookie', 'GS.setCookie(\'${1:cookieName}\', ${2:newValue}, ${0:daysUntilExpire});');
  
      registerDesignSnippet('GS.getCookie', 'GS.getCookie', 'GS.getCookie(\'${1:cookieName}\');');
  
      registerDesignSnippet('GS.pushState', 'GS.pushState', 'GS.pushState(${1:stateObj}, ${2:title}, ${0:newURL});');
  
      registerDesignSnippet('GS.replaceState', 'GS.replaceState', 'GS.replaceState(${1:stateObj}, ${2:title}, ${0:newURL});');
  
      registerDesignSnippet('GS.searchToWhere', 'GS.searchToWhere', 'GS.searchToWhere(\'${1:columns}\', ${0:searchClause});');
  
      registerDesignSnippet('GS.iconList', 'GS.iconList', 'GS.iconList();');
  
      registerDesignSnippet('GS.lorem', 'GS.lorem', 'GS.lorem();');
  
      registerDesignSnippet('GS.numberSuffix', 'GS.numberSuffix', 'GS.numberSuffix(${1:intNumber});');
  
      registerDesignSnippet('GS.hitLink', 'GS.hitLink', 'GS.hitLink(${1:strLink});');
      
      registerDesignSnippet('GS.log', 'GS.log', 'GS.log(\'${1:send}\', ${2:message});');
  });
  
  function gt(x,y)  { return x >  y; }
  function gte(x,y) { return x >= y; }
  function lt(x,y)  { return x <  y; }
  function lte(x,y) { return x <= y; }
  
  // sometimes, we need to hit a link without paying attention
  //      to the response and without opening a new tab. for
  //      example, mailto: and tel: links
  GS.hitLink = function (strLink) {
      "use strict";
      var iframeElement;
  
      iframeElement = document.createElement('iframe');
      iframeElement.setAttribute('hidden', '');
      iframeElement.addEventListener('load', function () {
          if (iframeElement.parentNode === document.body) {
              document.body.removeChild(iframeElement);
          }
      });
  
      iframeElement.setAttribute("src", strLink);
      document.body.appendChild(iframeElement);
  };
  
  
  GS.log = function (bolsend, message) {
      "use strict";
      var msg = message;
      if (bolsend) {
          var e = new Error();
          if (!e.stack) {
              try {
                  // IE requires the Error to actually be thrown or else the 
                  // Error's 'stack' property is undefined.
                  throw e;
              } catch (e) {
                  if (!e.stack) {
                      //return 0; // IE < 10, likely
                  }
              }
          }
          var stack = e.stack.toString().split(/\r\n|\n/);
          if (msg === '') {
              msg = '""';
          }
          console.log(msg, ' ' + stack[1].trim().substring(stack[1].trim().indexOf('('), stack[1].trim().length) + '');
      }
  };
  
  
  GS.numberSuffix = function(intNumber) {
      'use strict';
      var strNumber = String(intNumber),
          jsnSuffixes = {
              '0': 'th', '1': 'st',
              '2': 'nd', '3': 'rd',
              '4': 'th', '5': 'th',
              '6': 'th', '7': 'th',
              '8': 'th', '9': 'th'
          };
                  
      return strNumber + jsnSuffixes[strNumber[strNumber.length - 1]];
  }
  
  // ###########################################################
  // #################### PADDING FUNCTIONS ####################
  // ###########################################################
  
  // pad a string with another string on the right side of the string
  //      repeating until the pad_str until the str length is >= the padToLength
  
  //  PARAM         "str": string to pad
  //  PARAM   "padString": string to pad with
  //  PARAM "padToLength": number of characters to pad for
  GS.rightPad = function (str, padString, padToLength) {
      'use strict';
      str = String(str);
      
      while (str.length < padToLength) {
          str += padString;
      }
     
      return str;
  };
  
  
  // pad a string with another string on the left side of the string
  //      repeating until the padString until the str length is >= the padToLength
  
  //  PARAM         "str": string to pad
  //  PARAM   "padString": string to pad with
  //  PARAM "padToLength": number of characters to pad for
  GS.leftPad = function (str, padString, padToLength) {
      'use strict';
      str = String(str);
      
      while (str.length < padToLength) {
          str = padString + str;
      }
     
      return str;
  };
  
  
  
  // ################################################################
  // ################ EM AND PX CONVERSION FUNCTIONS ################
  // ################################################################
  
  // convert pixels to ems
  GS.pxToEm = function (elementScope, fromPX) {
      'use strict';
      var intPX = parseFloat(fromPX),
          heightTestElement = document.createElement('div'),
          intElementHeight;
      
      elementScope = elementScope || document.body;
      
      heightTestElement.style.fontSize = '1em';
      heightTestElement.style.margin = '0';
      heightTestElement.style.padding = '0';
      heightTestElement.style.lineHeight = '1';
      heightTestElement.style.border = '0';
      
      heightTestElement.innerHTML = 'a';
      
      elementScope.appendChild(heightTestElement);
      intElementHeight = heightTestElement.offsetHeight;
      elementScope.removeChild(heightTestElement);
      
      return parseFloat((intPX / intElementHeight).toFixed(8), 10);
  };
  
  // convert ems to pixels
  GS.emToPx = function (elementScope, fromEM) {
      'use strict';
      var intEM = parseFloat(fromEM),
          heightTestElement = document.createElement('div'),
          intElementHeight;
      
      elementScope = elementScope || document.body;
      
      heightTestElement.style.fontSize = '1em';
      heightTestElement.style.margin = '0';
      heightTestElement.style.padding = '0';
      heightTestElement.style.lineHeight = '1';
      heightTestElement.style.border = '0';
      
      heightTestElement.innerHTML = 'a';
      
      elementScope.appendChild(heightTestElement);
      intElementHeight = heightTestElement.offsetHeight;
      elementScope.removeChild(heightTestElement);
      
      return Math.round(intEM * intElementHeight); // not sure if we want to round here but the old function did
                                                   // so I will leave it here until there is a problem -michael
  };
  
  
  
  // ################################################################
  // #################### MISC UTILITY FUNCTIONS ####################
  // ################################################################
  
  GS.charFromKeyCode = function (event) {
      // (this function contains a (modified) substantial portion of code from another source
      //    here is the copyright for sake of legality)
      
      // name: jQuery getChar
      // repository: https://github.com/bpeacock/key-to-charCode
      // @author Brian Peacock
      // @version 0.3
      // Copyright 2013, Brian Peacock
      // Licensed under the MIT license.
      
      'use strict';
      
      var code = event.which;
      
      //Ignore Shift Key events & arrows
      var ignoredCodes = {
          16: true,
          37: true,
          38: true,
          39: true,
          40: true,
          20: true,
          17: true,
          18: true,
          91: true
      };
      
      if (ignoredCodes[code] === true) {
          return false;
      }
      
      // These are special cases that don't fit the ASCII mapping
      var exceptions = {
          186: 59, // ;
          187: 61, // =
          188: 44, // ,
          189: 45, // -
          190: 46, // .
          191: 47, // /
          192: 96, // `
          219: 91, // [
          220: 92, // \
          221: 93, // ]
          222: 39, // '
          //numeric keypad
          96: '0'.charCodeAt(0),
          97: '1'.charCodeAt(0),
          98: '2'.charCodeAt(0),
          99: '3'.charCodeAt(0),
          100: '4'.charCodeAt(0),
          101: '5'.charCodeAt(0),
          102: '6'.charCodeAt(0),
          103: '7'.charCodeAt(0),
          104: '8'.charCodeAt(0),
          105: '9'.charCodeAt(0)
      };
  
      if (exceptions[code] !== undefined) {
          code = exceptions[code];
      }
      
      var ch = String.fromCharCode(code);
      
      // Handle Shift
      if (event.shiftKey) {
          var special = {
              1: '!',
              2: '@',
              3: '#',
              4: '$',
              5: '%',
              6: '^',
              7: '&',
              8: '*',
              9: '(',
              0: ')',
              ',': '<',
              '.': '>',
              '/': '?',
              ';': ':',
              "'": '"',
              '[': '{',
              ']': '}',
              '\\': '|',
              '`': '~',
              '-': '_',
              '=': '+'
          };
  
          if (special[ch] !== undefined) {
              ch = special[ch];
          }
      } else {
          ch = ch.toLowerCase();
      }
      
      return ch;
  };
  
  // keyCode string to number
  GS.keyCode = function (inChar) {
      "use strict";
      /*
      Key 	Code
  backspace 	8
  tab 	9
  enter 	13
  shift 	16
  ctrl 	17
  alt 	18
  pause/break 	19
  caps lock 	20
  escape 	27
  (space) 	32
  page up 	33
  page down 	34
  end 	35
  home 	36
  left arrow 	37
  up arrow 	38
  right arrow 	39
  down arrow 	40
  insert 	45
  delete 	46
  0 	48
  1 	49
  2 	50
  3 	51
  4 	52
  5 	53
  6 	54
  7 	55
  8 	56
  9 	57
  a 	65
  b 	66
  c 	67
  d 	68
  
  Key 	Code
  e 	69
  f 	70
  g 	71
  h 	72
  i 	73
  j 	74
  k 	75
  l 	76
  m 	77
  n 	78
  o 	79
  p 	80
  q 	81
  r 	82
  s 	83
  t 	84
  u 	85
  v 	86
  w 	87
  x 	88
  y 	89
  z 	90
  left window key 	91
  right window key 	92
  select key 	93
  numpad 0 	96
  numpad 1 	97
  numpad 2 	98
  numpad 3 	99
  numpad 4 	100
  numpad 5 	101
  numpad 6 	102
  numpad 7 	103
  */
      inChar = inChar.toLowerCase();
      return '\b'          == inChar ? '8' :
             'backspace'   == inChar ? '8' :
             '\t'          == inChar ? '9' :
             'tab'         == inChar ? '9' :
             '\r'          == inChar ? '13' :
             '\n'          == inChar ? '13' :
             'enter'       == inChar ? '13' :
             'return'      == inChar ? '13' :
             'newline'     == inChar ? '13' :
             'shift'       == inChar ? '16' :
             'ctrl'        == inChar ? '17' :
             'alt'         == inChar ? '18' :
             'pause/break' == inChar ? '19' :
             'caps lock'   == inChar ? '20' :
             'escape'      == inChar ? '27' :
             'space'       == inChar ? '32' :
             ' '           == inChar ? '32' :
             'page up'     == inChar ? '33' :
             'page down'   == inChar ? '34' :
             'end'         == inChar ? '35' :
             'home'        == inChar ? '36' :
             'left arrow'  == inChar ? '37' :
             'up arrow'    == inChar ? '38' :
             'right arrow' == inChar ? '39' :
             'down arrow'  == inChar ? '40' :
             'insert'      == inChar ? '45' :
             'delete'      == inChar ? '46' :
             '0'           == inChar ? '48' :
             '1'           == inChar ? '49' :
             '2'           == inChar ? '50' :
             '3'           == inChar ? '51' :
             '4'           == inChar ? '52' :
             '5'           == inChar ? '53' :
             '6'           == inChar ? '54' :
             '7'           == inChar ? '55' :
             '8'           == inChar ? '56' :
             '9'           == inChar ? '57' :
             'a'           == inChar ? '65' :
             'b'           == inChar ? '66' :
             'c'           == inChar ? '67' :
             'd'           == inChar ? '68' :
             'e'           == inChar ? '69' :
             'f'           == inChar ? '70' :
             'g'           == inChar ? '71' :
             'h'           == inChar ? '72' :
             'i'           == inChar ? '73' :
             'j'           == inChar ? '74' :
             'k'           == inChar ? '75' :
             'l'           == inChar ? '76' :
             'm'           == inChar ? '77' :
             'n'           == inChar ? '78' :
             'o'           == inChar ? '79' :
             'p'           == inChar ? '80' :
             'q'           == inChar ? '81' :
             'r'           == inChar ? '82' :
             's'           == inChar ? '83' :
             't'           == inChar ? '84' :
             'u'           == inChar ? '85' :
             'v'           == inChar ? '86' :
             'w'           == inChar ? '87' :
             'x'           == inChar ? '88' :
             'y'           == inChar ? '89' :
             'z'           == inChar ? '90' :
             'left window key'  == inChar ? '91' :
             'right window key' == inChar ? '92' :
             'select key'  == inChar ? '93' :
             'numpad 0'    == inChar ? '96' :
             'numpad 1'    == inChar ? '97' :
             'numpad 2'    == inChar ? '98' :
             'numpad 3'    == inChar ? '99' :
             'numpad 4'    == inChar ? '100' :
             'numpad 5'    == inChar ? '101' :
             'numpad 6'    == inChar ? '102' :
             'numpad 7'    == inChar ? '103' :
             'numpad 8'    == inChar ? '104' :
             'numpad 9'    == inChar ? '105' :
             'multiply'    == inChar ? '106' :
             'add'         == inChar ? '107' :
             '+'           == inChar ? '107' :
             'subtract'    == inChar ? '109' :
             '-'           == inChar ? '109' :
             'decimal point' == inChar ? '110' :
             'divide'      == inChar ? '111' :
             'f1'          == inChar ? '112' :
             'f2'          == inChar ? '113' :
             'f3'          == inChar ? '114' :
             'f4'          == inChar ? '115' :
             'f5'          == inChar ? '116' :
             'f6'          == inChar ? '117' :
             'f7'          == inChar ? '118' :
             'f8'          == inChar ? '119' :
             'f9'          == inChar ? '120' :
             'f10'         == inChar ? '121' :
             'f11'         == inChar ? '122' :
             'f12'         == inChar ? '123' :
             'num lock'    == inChar ? '144' :
             'scroll lock' == inChar ? '145' :
             'semi-colon'  == inChar ? '186' :
             ';'           == inChar ? '186' :
             'equal sign'  == inChar ? '187' :
             '='           == inChar ? '187' :
             'comma'       == inChar ? '188' :
             ','           == inChar ? '188' :
             'dash'        == inChar ? '189' :
             '-'           == inChar ? '189' :
             'period'      == inChar ? '190' :
             '.'           == inChar ? '190' :
             'forward slash' == inChar ? '191' :
             '/'             == inChar ? '191' :
             'grave accent'  == inChar ? '192' :
             'open bracket'  == inChar ? '219' :
             '['             == inChar ? '219' :
             'back slash'    == inChar ? '220' :
             '\\'            == inChar ? '220' :
             'close bracket' == inChar ? '221' :
             ']'             == inChar ? '221' :
             'single quote'  == inChar ? '222' :
             '\''            == inChar ? '222' :
             '';
      /*
  Key 	Code
  numpad 8 	104
  numpad 9 	105
  multiply 	106
  add 	107
  subtract 	109
  decimal point 	110
  divide 	111
  f1 	112
  f2 	113
  f3 	114
  f4 	115
  f5 	116
  f6 	117
  f7 	118
  f8 	119
  f9 	120
  f10 	121
  f11 	122
  f12 	123
  num lock 	144
  scroll lock 	145
  semi-colon 	186
  equal sign 	187
  comma 	188
  dash 	189
  period 	190
  forward slash 	191
  grave accent 	192
  open bracket 	219
  back slash 	220
  close braket 	221
  single quote 	222
  */
  };
  
  // get computed or current style (current style if it is availible)
  GS.getStyle = function (element, style) {
      if (element.currentStyle !== undefined) {
          return element.currentStyle[style];
      }
      
      return document.defaultView.getComputedStyle(element, null)[style];
  };
  
  // push to array if the value is unique
  GS.listAdd = function (arrArray, newValue) {
      'use strict';
      if (arrArray.indexOf(newValue) === -1) {
          arrArray.push(newValue);
      }
  };
  
  // trigger an event on a target
  GS.triggerEvent = function (target, strEventName, jsnConfig) {
      'use strict';
      var event, key;
      
      //console.trace('trigger', target);
      
      if (document.createEvent) {
          event = document.createEvent('HTMLEvents');
          event.initEvent(strEventName, true, true);
      } else {
          event = document.createEventObject();
          event.eventType = strEventName;
      }
      
      event.eventName = strEventName;
      
      if (jsnConfig) {
          for (key in jsnConfig) {
              event[key] = jsnConfig[key];
          }
      }
      
      if (document.createEvent) {
          target.dispatchEvent(event);
      } else {
          target.fireEvent("on" + event.eventType, event);
      }
      
      return event;
  };
  
  // converts a string into a more user readable format
  GS.strToTitle = function (strInput) {
      'use strict';
      var i, len, chrCurrent, chrLast = '', strRet = '';
      
      strInput = strInput || '';
      
      for (i = 0, len = strInput.length; i < len; i += 1) {
          chrCurrent = strInput.charAt(i);
          
          if (!(/[a-zA-Z]/).test(chrLast)) {
              strRet += chrCurrent.toUpperCase();
              
          } else if (chrCurrent === '_') {
              strRet += ' ';
              
          } else {
              strRet += chrCurrent;
          }
          
          chrLast = chrCurrent;
      }
      
      return strRet;
  };
  
  // normalize top, left, bottom and right on a mouse event
  GS.mousePosition = function (event) {
      'use strict';
      var pageX = (evt.touchDevice ? event.touches[0].pageX: event.pageX),// get the left and top of the mouse
          pageY = (evt.touchDevice ? event.touches[0].pageY: event.pageY);//   (or the touch position if we are on a phone)
      
      return {
          'top':    pageY,
          'left':   pageX,
          'bottom': window.innerHeight - pageY,
          'right':  window.innerWidth - pageX,
          
          //'x':      pageY, // alias <== messed these up
          //'y':      pageX  // alias
          
          'x':      pageX, // alias
          'y':      pageY  // alias
      };
  };
  
  // original function found here: http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
  GS.GUID = function () {
      var strTime = new Date().getTime().toString();
      
      function randomString() {
          return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }
      
      return  randomString() + randomString() + '-' +
              randomString() + '-' +
              randomString() + '-' +
              randomString() + '-' +
              strTime.substring(strTime.length - 4) + '-' +
              randomString() + randomString() + randomString();
  };
  
  /*  ,---- no longer works
  //  V
  GS.getSelectedText = function () {
      if (window.getSelection) {
          return window.getSelection() + '';
      }
      
      // FireFox
      if (document.getSelection) {
          return document.getSelection() + '';
      }
      
      // IE 6/7
      if (document.selection) {
          return document.selection.createRange().text + '';
      }
      
      console.warn('GS.getSelectedText warning: no selection collection function found (could not find a way to get the selected text)');
      return '';
  }*/
  
  // decode uri component safe from "URI malformed" error
  GS.safeDecodeURIComponent = function (string) {
      var strRet;
      
      try {
          strRet = decodeURIComponent(string);
          
      } catch (error) {
          if (error.toString().indexOf('URI malformed') > -1) {
              strRet = string;
          } else {
              throw error;
          }
      }
      
      return strRet;
  };
  
  //
  GS.getTextHeight = function (scope, bolNormalLineHeight) {
      var divElement = document.createElement('div'), intHeight;
      
      scope = scope || document.body;
      
      divElement.style.visibility = 'invisible';
      divElement.style.fontSize   = '1em';
      divElement.style.margin     = '0';
      divElement.style.padding    = '0';
      divElement.style.lineHeight = (bolNormalLineHeight ? 'normal' : '1');
      divElement.style.border     = '0';
      divElement.textContent      = 'a';
      
      scope.appendChild(divElement);
      
      intHeight = divElement.clientHeight;
      
      scope.removeChild(divElement);
      
      return intHeight;
  };
  
  
  //
  GS.getTextWidth = function (scope, strText, bolWhitePreserve) {
      var divElement = document.createElement('div'), intWidth;
      
      scope = scope || document.body;
      
      divElement.style.display       = 'inline-block';
      divElement.style.visibility    = 'invisible';
      divElement.style.fontSize      = '1em';
      divElement.style.margin        = '0';
      divElement.style.padding       = '0';
      divElement.style.letterSpacing = 'inherit';
      divElement.style.border        = '0';
      divElement.style.whiteSpace    = (bolWhitePreserve ? 'pre' : '');
      divElement.textContent         = strText;
      
      scope.appendChild(divElement);
      
      intWidth = divElement.clientWidth;
      
      scope.removeChild(divElement);
      
      return intWidth;
  };
  
  
  
  GS.scrollParent = function (element, strDirection) {
      "use strict";
      var strDirectionText;
      if (strDirection) {
          strDirectionText = strDirection;
      } else {
          strDirectionText = 'vertical';
      }
      var i = 0;
      var currentElement = element;
      var bolFoundScrollable = false;
      var strOverflow;
  
      if (currentElement) {
          while (
              currentElement &&
              currentElement.nodeName !== 'HTML' &&
              bolFoundScrollable === false &&
              i < 75
          ) {
              strOverflow = GS.getStyle(currentElement, 'overflow');
              if (
                  strOverflow === 'scroll' ||
                  (
                      strOverflow === 'auto' &&
                      strDirectionText === 'vertical' &&
                      currentElement.clientHeight < currentElement.scrollHeight
                  ) ||
                  (
                      strOverflow === 'auto' &&
                      strDirectionText === 'horizontal' &&
                      currentElement.clientWidth < currentElement.scrollWidth
                  )
              ) {
                  bolFoundScrollable = true;
              } else {
                  currentElement = currentElement.parentNode;
                  i += 1;
              }
          }
  
          //console.log(currentElement.nodeName);
          if (!currentElement || currentElement.nodeName === 'HTML') {
              return document.body;
          }
  
          return (
              bolFoundScrollable
                  ? currentElement
                  : undefined
          );
      }
      return undefined;
  }
  
  
  //
  GS.scrollIntoView = function (element, strDirection) {
      var strDirectionText;
      if (strDirection) {
          strDirectionText = strDirection;
      } else {
          strDirectionText = 'vertical';
      }
      var scrollingContainer = GS.scrollParent(element, strDirectionText), arrSiblings, i, len, intScrollTop, intScrollLeft;
      if (scrollingContainer) {
          //console.log(scrollingContainer);
          if (strDirectionText === 'horizontal') {
              arrSiblings = element.parentNode.children;
              
              for (i = 0, intScrollLeft = 0, len = arrSiblings.length; i < len; i += 1) {
                  if (arrSiblings[i] === element) {
                      intScrollLeft += arrSiblings[i].offsetWidth / 2;
                      
                      break;
                  } else {
                      intScrollLeft += arrSiblings[i].offsetWidth;
                  }
              }
              
              intScrollLeft = intScrollLeft - (scrollingContainer.offsetWidth / 2);
              scrollingContainer.scrollLeft = intScrollLeft;
          } else {
              arrSiblings = element.parentNode.children;
              
              for (i = 0, intScrollTop = 0, len = arrSiblings.length; i < len; i += 1) {
                  if (arrSiblings[i] === element) {
                      intScrollTop += arrSiblings[i].offsetHeight / 2;
                      
                      break;
                  } else {
                      intScrollTop += arrSiblings[i].offsetHeight;
                  }
              }
              
              intScrollTop = intScrollTop - (scrollingContainer.offsetHeight / 2);
              scrollingContainer.scrollTop = intScrollTop;
          }
      }
  };
  
  // return value from: envelope data, record number and column name
  GS.envGetCell = function (data, record_number, column_name) {
      'use strict';
      var index;
      
      if (data.stat) {
          data = data.dat;
      }
      
      index = data.arr_column.indexOf(column_name);
      
      if (index === -1) {
          console.error(column_name, data);
          throw 'Error in GS.envGetCell: column not found';
      }
      
      return data.dat[record_number][index];
  };
  
  GS.trim = function(string, strStringToTrim) {
      "use strict";
      var safeRegexString = strStringToTrim.replace(/([.?*+^$[\]\\(){}|-])/g,'\\$1'),
          trimRegex = new RegExp('^' + safeRegexString + '+|' + safeRegexString + '+$', 'g');
      
      return string.replace(trimRegex, '');
  };
  
  // set a cookie in the browser
  GS.setCookie = function (c_name, value, exdays) {
      'use strict';
      var exDayNum;
      if (!exdays) {
          exDayNum = 30;
      } else {
          exDayNum = exdays;
      }
      
      var hostname = location.hostname;
      var exdate = new Date(), c_value;
      hostname = hostname.substring(hostname.indexOf('.'));
      exdate.setDate(exdate.getDate() + exDayNum);
      
      c_value = encodeURIComponent(value) + ((exDayNum === null || exDayNum === undefined) ? '' : '; expires=' + exdate.toUTCString()) + '; domain=' + hostname + '; path=/';
      
      document.cookie = c_name + '=' + c_value;
  };
  
  // get a cookie from the browser
  GS.getCookie = function (c_name) {
      'use strict';
      var c_value = document.cookie, c_end,
          c_start = c_value.indexOf(" " + c_name + "=");
      
      if (c_start === -1) {
          c_start = c_value.indexOf(c_name + "=");
      }
      
      if (c_start === -1) {
          c_value = null;
      } else {
          c_start = c_value.indexOf("=", c_start) + 1;
          c_end = c_value.indexOf(";", c_start);
          if (c_end === -1) {
              c_end = c_value.length;
          }
          c_value = decodeURIComponent(c_value.substring(c_start, c_end));
      }
      
      return c_value;
  };
  
  GS.pushState = function (stateObj, title, url) {
      history.pushState(stateObj, title, url);
      GS.triggerEvent(window, 'pushstate');
  };
  
  GS.replaceState = function (stateObj, title, url) {
      history.replaceState(stateObj, title, url);
      GS.triggerEvent(window, 'replacestate');
  };
  
  GS.searchToWhere = function (columns, searchClause) {
      //console.log(searchClause);
      var arrToken, arrNoQuotes = [], strNoQuotes = '', arrColumn, arrRequired = [], strRequired = '', arrWhere = [], strWhere = '', strRet = '', token, numTokens, col, numCols, i, len, strSearch;
      
      if (!searchClause) {
          return '1=1';
      }
      
      arrColumn = columns.split(',');
      
      // First get all quoted tokens, leave everything else
      arrToken = searchClause.match(/[\+|\-]?"[^"]*?"/g);
      
      if (arrToken) {
          for (token = 0, numTokens = arrToken.length; token < numTokens; token += 1) {
              arrToken[token] = GS.trim(arrToken[token], '+');
              for (col = 0, numCols = arrColumn.length; col < numCols; col += 1) {
                  if (arrToken[token][0] === '-') {
                      arrToken[token] = GS.trim(arrToken[token], '-');
                      arrRequired[token] =
                          (arrRequired[token] ? arrRequired[token] + ' AND ' : '') +
                          'CASE WHEN ' + arrColumn[col] +
                          ' IS NOT NULL THEN ' + arrColumn[col] +
                          ' NOT ILIKE \'%' + GS.trim(arrToken[token], '"') +
                          '%\' ELSE TRUE END';
                      arrToken[token] = '-' + arrToken[token];
                  } else {
                      arrRequired[token] = 
                          (arrRequired[token] ? arrRequired[token] + ' OR ' : '') +
                          (arrColumn[col] + ' ILIKE \'%' + GS.trim(arrToken[token], '"') + '%\'');
                  }
              }
          }
          
          for (i = 0, len = arrRequired.length; i < len; i += 1) {
              strRequired = (strRequired ? strRequired + ' AND ' : '') + '(' + arrRequired[i] + ')';
          }
          //console.log('strRequired:', strRequired);
      }
      
      // Get non-quoted tokens and remove extra space
      /*
      //NOT CROSS BROWSER
      arrNoQuotes = strSearch.split(/([\+|\-]?"[^"]*?")/);
      strNoQuotes = arrNoQuotes.join(' ');
      arrNoQuotes = strNoQuotes.split(/[ ]+/);
      */
      strSearch = searchClause.trim();
      strSearch = strSearch.replace('-"', '"');
      strSearch = strSearch.replace('+"', '"');
      strSearch = strSearch.replace(/"[^"]*"/, '""');
      arrNoQuotes = strSearch.split('""');
      //console.log("arrNoQuotes: ", arrNoQuotes);
      strNoQuotes = arrNoQuotes.join(' ');
      //console.log("strNoQuotes: >" + strNoQuotes + "<");
      strNoQuotes = strNoQuotes.replace('  ', ' ');
      strNoQuotes = strNoQuotes.replace('  ', ' ');
      arrNoQuotes = strNoQuotes.split(' ');
      //console.log("arrNoQuotes: ", arrNoQuotes);
      /*
      //DIDN'T WORK
      strSearch = searchClause.trim();
      strSearch = strSearch.replace('-"', '"');
      strSearch = strSearch.replace('+"', '"');
      arrNoQuotes = strSearch.split('"');
      strSearch = '';
      if (searchClause.trim()[0] === '"') {
          for (i = 1, len = arrNoQuotes.length; i < len; i += 2) {
              strSearch = strSearch + (strSearch === '' ? '' : ' ') + arrNoQuotes[i].trim();
          }
      } else {
          for (i = 0, len = arrNoQuotes.length; i < len; i += 2) {
              strSearch = strSearch + (strSearch === '' ? '' : ' ') + arrNoQuotes[i].trim();
          }
      }
      //console.log(strSearch);
      strSearch = strSearch.replace('  ', ' ');
      strSearch = strSearch.replace('  ', ' ');
      arrNoQuotes = strSearch.split(' ');
      //console.log(arrNoQuotes);
      */
      // Put items into arrRequired or arrWhere
      arrRequired = [''];
      if (arrNoQuotes.length > 0) {
          //console.log('1');
          for (token = 0, numTokens = arrNoQuotes.length; token < numTokens; token += 1) {
              //console.log('2');
              for (col = 0, numCols = arrColumn.length; col < numCols; col += 1) {
                  //console.log('3 arrNoQuotes[' + token + ']: ' + arrNoQuotes[token]);
                  if (arrNoQuotes[token].length > 0) {
                      //console.log('4');
                      if (arrNoQuotes[token][0] === '-') {
                          arrRequired[token] = 
                              (arrRequired[token] ? arrRequired[token] + ' AND ' : '') +
                              ' CASE WHEN ' + arrColumn[col] +
                              ' IS NOT NULL THEN ' + arrColumn[col] +
                              ' NOT ILIKE $$%' + GS.trim(GS.trim(arrNoQuotes[token], '-'), ' ') +
                              '%$$ ELSE TRUE END ';
                      } else if (arrNoQuotes[token][0] === '+') {
                          arrRequired[token] = 
                              (arrRequired[token] ? arrRequired[token] + ' OR ' : '') +
                              arrColumn[col] + ' ILIKE $$%' +
                              GS.trim(GS.trim(arrNoQuotes[token], '+'), ' ') + '%$$ ';
                      } else {
                          arrWhere[token] = 
                              (arrWhere[token] ? arrWhere[token] + ' OR ' : '') +
                              arrColumn[col] + ' ILIKE $$%' + GS.trim(arrNoQuotes[token], ' ') + '%$$ ';
                      }
                  }
              }
          }
      }
      
      if (arrRequired.length > 0) {
          for (i = 0, len = arrRequired.length; i < len; i += 1) {
              if (arrRequired[i]) {
                  strRequired = (strRequired ? strRequired + ' AND ' : '') + '(' + arrRequired[i] + ')';
              }
          }
      }
      //console.log('strRequired: ', strRequired);
      
      if (arrWhere.length > 0) {
          for (i = 0, len = arrWhere.length; i < len; i += 1) {
              if (arrWhere[i]) {
                  strWhere = (strWhere ? strWhere + ' AND ' : '') + '(' + arrWhere[i] + ')';
              }
          }
      }
      //console.log('strWhere: ', strWhere);
      
      strRet = 
          (
              strWhere && strRequired ? '(' + strWhere + ') AND (' + strRequired + ')' :
              strWhere ? strWhere :
              strRequired
          );
      
      //console.log('strRet: ' + strRet);
      
      return strRet;
  };
  
  GS.iconList = function () {
      return [{"name":"500px","code":"f26e"},{"name":"adjust","code":"f042"},{"name":"adn","code":"f170"},{"name":"align-center","code":"f037"},{"name":"align-justify","code":"f039"},{"name":"align-left","code":"f036"},{"name":"align-right","code":"f038"},{"name":"amazon","code":"f270"},{"name":"ambulance","code":"f0f9"},{"name":"anchor","code":"f13d"},{"name":"android","code":"f17b"},{"name":"angellist","code":"f209"},{"name":"angle-double-down","code":"f103"},{"name":"angle-double-left","code":"f100"},{"name":"angle-double-right","code":"f101"},{"name":"angle-double-up","code":"f102"},{"name":"angle-down","code":"f107"},{"name":"angle-left","code":"f104"},{"name":"angle-right","code":"f105"},{"name":"angle-up","code":"f106"},{"name":"apple","code":"f179"},{"name":"archive","code":"f187"},{"name":"area-chart","code":"f1fe"},{"name":"arrow-circle-down","code":"f0ab"},{"name":"arrow-circle-left","code":"f0a8"},{"name":"arrow-circle-o-down","code":"f01a"},{"name":"arrow-circle-o-left","code":"f190"},{"name":"arrow-circle-o-right","code":"f18e"},{"name":"arrow-circle-o-up","code":"f01b"},{"name":"arrow-circle-right","code":"f0a9"},{"name":"arrow-circle-up","code":"f0aa"},{"name":"arrow-down","code":"f063"},{"name":"arrow-left","code":"f060"},{"name":"arrow-right","code":"f061"},{"name":"arrow-up","code":"f062"},{"name":"arrows","code":"f047"},{"name":"arrows-alt","code":"f0b2"},{"name":"arrows-h","code":"f07e"},{"name":"arrows-v","code":"f07d"},{"name":"asterisk","code":"f069"},{"name":"at","code":"f1fa"},{"name":"automobile","code":"f1b9"},{"name":"backward","code":"f04a"},{"name":"balance-scale","code":"f24e"},{"name":"ban","code":"f05e"},{"name":"bank","code":"f19c"},{"name":"bar-chart","code":"f080"},{"name":"bar-chart-o","code":"f080"},{"name":"barcode","code":"f02a"},{"name":"bars","code":"f0c9"},{"name":"battery-0","code":"f244"},{"name":"battery-1","code":"f243"},{"name":"battery-2","code":"f242"},{"name":"battery-3","code":"f241"},{"name":"battery-4","code":"f240"},{"name":"battery-empty","code":"f244"},{"name":"battery-full","code":"f240"},{"name":"battery-half","code":"f242"},{"name":"battery-quarter","code":"f243"},{"name":"battery-three-quarters","code":"f241"},{"name":"bed","code":"f236"},{"name":"beer","code":"f0fc"},{"name":"behance","code":"f1b4"},{"name":"behance-square","code":"f1b5"},{"name":"bell","code":"f0f3"},{"name":"bell-o","code":"f0a2"},{"name":"bell-slash","code":"f1f6"},{"name":"bell-slash-o","code":"f1f7"},{"name":"bicycle","code":"f206"},{"name":"binoculars","code":"f1e5"},{"name":"birthday-cake","code":"f1fd"},{"name":"bitbucket","code":"f171"},{"name":"bitbucket-square","code":"f172"},{"name":"bitcoin","code":"f15a"},{"name":"black-tie","code":"f27e"},{"name":"bluetooth","code":"f293"},{"name":"bluetooth-b","code":"f294"},{"name":"bold","code":"f032"},{"name":"bolt","code":"f0e7"},{"name":"bomb","code":"f1e2"},{"name":"book","code":"f02d"},{"name":"bookmark","code":"f02e"},{"name":"bookmark-o","code":"f097"},{"name":"briefcase","code":"f0b1"},{"name":"btc","code":"f15a"},{"name":"bug","code":"f188"},{"name":"building","code":"f1ad"},{"name":"building-o","code":"f0f7"},{"name":"bullhorn","code":"f0a1"},{"name":"bullseye","code":"f140"},{"name":"bus","code":"f207"},{"name":"buysellads","code":"f20d"},{"name":"cab","code":"f1ba"},{"name":"calculator","code":"f1ec"},{"name":"calendar","code":"f073"},{"name":"calendar-check-o","code":"f274"},{"name":"calendar-minus-o","code":"f272"},{"name":"calendar-o","code":"f133"},{"name":"calendar-plus-o","code":"f271"},{"name":"calendar-times-o","code":"f273"},{"name":"camera","code":"f030"},{"name":"camera-retro","code":"f083"},{"name":"car","code":"f1b9"},{"name":"caret-down","code":"f0d7"},{"name":"caret-left","code":"f0d9"},{"name":"caret-right","code":"f0da"},{"name":"caret-square-o-down","code":"f150"},{"name":"caret-square-o-left","code":"f191"},{"name":"caret-square-o-right","code":"f152"},{"name":"caret-square-o-up","code":"f151"},{"name":"caret-up","code":"f0d8"},{"name":"cart-arrow-down","code":"f218"},{"name":"cart-plus","code":"f217"},{"name":"cc","code":"f20a"},{"name":"cc-amex","code":"f1f3"},{"name":"cc-diners-club","code":"f24c"},{"name":"cc-discover","code":"f1f2"},{"name":"cc-jcb","code":"f24b"},{"name":"cc-mastercard","code":"f1f1"},{"name":"cc-paypal","code":"f1f4"},{"name":"cc-stripe","code":"f1f5"},{"name":"cc-visa","code":"f1f0"},{"name":"certificate","code":"f0a3"},{"name":"chain","code":"f0c1"},{"name":"chain-broken","code":"f127"},{"name":"check","code":"f00c"},{"name":"check-circle","code":"f058"},{"name":"check-circle-o","code":"f05d"},{"name":"check-square","code":"f14a"},{"name":"check-square-o","code":"f046"},{"name":"chevron-circle-down","code":"f13a"},{"name":"chevron-circle-left","code":"f137"},{"name":"chevron-circle-right","code":"f138"},{"name":"chevron-circle-up","code":"f139"},{"name":"chevron-down","code":"f078"},{"name":"chevron-left","code":"f053"},{"name":"chevron-right","code":"f054"},{"name":"chevron-up","code":"f077"},{"name":"child","code":"f1ae"},{"name":"chrome","code":"f268"},{"name":"circle","code":"f111"},{"name":"circle-o","code":"f10c"},{"name":"circle-o-notch","code":"f1ce"},{"name":"circle-thin","code":"f1db"},{"name":"clipboard","code":"f0ea"},{"name":"clock-o","code":"f017"},{"name":"clone","code":"f24d"},{"name":"close","code":"f00d"},{"name":"cloud","code":"f0c2"},{"name":"cloud-download","code":"f0ed"},{"name":"cloud-upload","code":"f0ee"},{"name":"cny","code":"f157"},{"name":"code","code":"f121"},{"name":"code-fork","code":"f126"},{"name":"codepen","code":"f1cb"},{"name":"codiepie","code":"f284"},{"name":"coffee","code":"f0f4"},{"name":"cog","code":"f013"},{"name":"cogs","code":"f085"},{"name":"columns","code":"f0db"},{"name":"comment","code":"f075"},{"name":"comment-o","code":"f0e5"},{"name":"commenting","code":"f27a"},{"name":"commenting-o","code":"f27b"},{"name":"comments","code":"f086"},{"name":"comments-o","code":"f0e6"},{"name":"compass","code":"f14e"},{"name":"compress","code":"f066"},{"name":"connectdevelop","code":"f20e"},{"name":"contao","code":"f26d"},{"name":"copy","code":"f0c5"},{"name":"copyright","code":"f1f9"},{"name":"creative-commons","code":"f25e"},{"name":"credit-card","code":"f09d"},{"name":"credit-card-alt","code":"f283"},{"name":"crop","code":"f125"},{"name":"crosshairs","code":"f05b"},{"name":"css3","code":"f13c"},{"name":"cube","code":"f1b2"},{"name":"cubes","code":"f1b3"},{"name":"cut","code":"f0c4"},{"name":"cutlery","code":"f0f5"},{"name":"dashboard","code":"f0e4"},{"name":"dashcube","code":"f210"},{"name":"database","code":"f1c0"},{"name":"dedent","code":"f03b"},{"name":"delicious","code":"f1a5"},{"name":"desktop","code":"f108"},{"name":"deviantart","code":"f1bd"},{"name":"diamond","code":"f219"},{"name":"digg","code":"f1a6"},{"name":"dollar","code":"f155"},{"name":"dot-circle-o","code":"f192"},{"name":"download","code":"f019"},{"name":"dribbble","code":"f17d"},{"name":"dropbox","code":"f16b"},{"name":"drupal","code":"f1a9"},{"name":"edge","code":"f282"},{"name":"edit","code":"f044"},{"name":"eject","code":"f052"},{"name":"ellipsis-h","code":"f141"},{"name":"ellipsis-v","code":"f142"},{"name":"empire","code":"f1d1"},{"name":"envelope","code":"f0e0"},{"name":"envelope-o","code":"f003"},{"name":"envelope-square","code":"f199"},{"name":"eraser","code":"f12d"},{"name":"eur","code":"f153"},{"name":"euro","code":"f153"},{"name":"exchange","code":"f0ec"},{"name":"exclamation","code":"f12a"},{"name":"exclamation-circle","code":"f06a"},{"name":"exclamation-triangle","code":"f071"},{"name":"expand","code":"f065"},{"name":"expeditedssl","code":"f23e"},{"name":"external-link","code":"f08e"},{"name":"external-link-square","code":"f14c"},{"name":"eye","code":"f06e"},{"name":"eye-slash","code":"f070"},{"name":"eyedropper","code":"f1fb"},{"name":"facebook","code":"f09a"},{"name":"facebook-f","code":"f09a"},{"name":"facebook-official","code":"f230"},{"name":"facebook-square","code":"f082"},{"name":"fast-backward","code":"f049"},{"name":"fast-forward","code":"f050"},{"name":"fax","code":"f1ac"},{"name":"feed","code":"f09e"},{"name":"female","code":"f182"},{"name":"fighter-jet","code":"f0fb"},{"name":"file","code":"f15b"},{"name":"file-archive-o","code":"f1c6"},{"name":"file-audio-o","code":"f1c7"},{"name":"file-code-o","code":"f1c9"},{"name":"file-excel-o","code":"f1c3"},{"name":"file-image-o","code":"f1c5"},{"name":"file-movie-o","code":"f1c8"},{"name":"file-o","code":"f016"},{"name":"file-pdf-o","code":"f1c1"},{"name":"file-photo-o","code":"f1c5"},{"name":"file-picture-o","code":"f1c5"},{"name":"file-powerpoint-o","code":"f1c4"},{"name":"file-sound-o","code":"f1c7"},{"name":"file-text","code":"f15c"},{"name":"file-text-o","code":"f0f6"},{"name":"file-video-o","code":"f1c8"},{"name":"file-word-o","code":"f1c2"},{"name":"file-zip-o","code":"f1c6"},{"name":"files-o","code":"f0c5"},{"name":"film","code":"f008"},{"name":"filter","code":"f0b0"},{"name":"fire","code":"f06d"},{"name":"fire-extinguisher","code":"f134"},{"name":"firefox","code":"f269"},{"name":"flag","code":"f024"},{"name":"flag-checkered","code":"f11e"},{"name":"flag-o","code":"f11d"},{"name":"flash","code":"f0e7"},{"name":"flask","code":"f0c3"},{"name":"flickr","code":"f16e"},{"name":"floppy-o","code":"f0c7"},{"name":"folder","code":"f07b"},{"name":"folder-o","code":"f114"},{"name":"folder-open","code":"f07c"},{"name":"folder-open-o","code":"f115"},{"name":"font","code":"f031"},{"name":"fonticons","code":"f280"},{"name":"fort-awesome","code":"f286"},{"name":"forumbee","code":"f211"},{"name":"forward","code":"f04e"},{"name":"foursquare","code":"f180"},{"name":"frown-o","code":"f119"},{"name":"futbol-o","code":"f1e3"},{"name":"gamepad","code":"f11b"},{"name":"gavel","code":"f0e3"},{"name":"gbp","code":"f154"},{"name":"ge","code":"f1d1"},{"name":"gear","code":"f013"},{"name":"gears","code":"f085"},{"name":"genderless","code":"f22d"},{"name":"get-pocket","code":"f265"},{"name":"gg","code":"f260"},{"name":"gg-circle","code":"f261"},{"name":"gift","code":"f06b"},{"name":"git","code":"f1d3"},{"name":"git-square","code":"f1d2"},{"name":"github","code":"f09b"},{"name":"github-alt","code":"f113"},{"name":"github-square","code":"f092"},{"name":"gittip","code":"f184"},{"name":"glass","code":"f000"},{"name":"globe","code":"f0ac"},{"name":"google","code":"f1a0"},{"name":"google-plus","code":"f0d5"},{"name":"google-plus-square","code":"f0d4"},{"name":"google-wallet","code":"f1ee"},{"name":"graduation-cap","code":"f19d"},{"name":"gratipay","code":"f184"},{"name":"group","code":"f0c0"},{"name":"h-square","code":"f0fd"},{"name":"hacker-news","code":"f1d4"},{"name":"hand-grab-o","code":"f255"},{"name":"hand-lizard-o","code":"f258"},{"name":"hand-o-down","code":"f0a7"},{"name":"hand-o-left","code":"f0a5"},{"name":"hand-o-right","code":"f0a4"},{"name":"hand-o-up","code":"f0a6"},{"name":"hand-paper-o","code":"f256"},{"name":"hand-peace-o","code":"f25b"},{"name":"hand-pointer-o","code":"f25a"},{"name":"hand-rock-o","code":"f255"},{"name":"hand-scissors-o","code":"f257"},{"name":"hand-spock-o","code":"f259"},{"name":"hand-stop-o","code":"f256"},{"name":"hashtag","code":"f292"},{"name":"hdd-o","code":"f0a0"},{"name":"header","code":"f1dc"},{"name":"headphones","code":"f025"},{"name":"heart","code":"f004"},{"name":"heart-o","code":"f08a"},{"name":"heartbeat","code":"f21e"},{"name":"history","code":"f1da"},{"name":"home","code":"f015"},{"name":"hospital-o","code":"f0f8"},{"name":"hotel","code":"f236"},{"name":"hourglass","code":"f254"},{"name":"hourglass-1","code":"f251"},{"name":"hourglass-2","code":"f252"},{"name":"hourglass-3","code":"f253"},{"name":"hourglass-end","code":"f253"},{"name":"hourglass-half","code":"f252"},{"name":"hourglass-o","code":"f250"},{"name":"hourglass-start","code":"f251"},{"name":"houzz","code":"f27c"},{"name":"html5","code":"f13b"},{"name":"i-cursor","code":"f246"},{"name":"ils","code":"f20b"},{"name":"image","code":"f03e"},{"name":"inbox","code":"f01c"},{"name":"indent","code":"f03c"},{"name":"industry","code":"f275"},{"name":"info","code":"f129"},{"name":"info-circle","code":"f05a"},{"name":"inr","code":"f156"},{"name":"instagram","code":"f16d"},{"name":"institution","code":"f19c"},{"name":"internet-explorer","code":"f26b"},{"name":"intersex","code":"f224"},{"name":"ioxhost","code":"f208"},{"name":"italic","code":"f033"},{"name":"joomla","code":"f1aa"},{"name":"jpy","code":"f157"},{"name":"jsfiddle","code":"f1cc"},{"name":"key","code":"f084"},{"name":"keyboard-o","code":"f11c"},{"name":"krw","code":"f159"},{"name":"language","code":"f1ab"},{"name":"laptop","code":"f109"},{"name":"lastfm","code":"f202"},{"name":"lastfm-square","code":"f203"},{"name":"leaf","code":"f06c"},{"name":"leanpub","code":"f212"},{"name":"legal","code":"f0e3"},{"name":"lemon-o","code":"f094"},{"name":"level-down","code":"f149"},{"name":"level-up","code":"f148"},{"name":"life-bouy","code":"f1cd"},{"name":"life-buoy","code":"f1cd"},{"name":"life-ring","code":"f1cd"},{"name":"life-saver","code":"f1cd"},{"name":"lightbulb-o","code":"f0eb"},{"name":"line-chart","code":"f201"},{"name":"link","code":"f0c1"},{"name":"linkedin","code":"f0e1"},{"name":"linkedin-square","code":"f08c"},{"name":"linux","code":"f17c"},{"name":"list","code":"f03a"},{"name":"list-alt","code":"f022"},{"name":"list-ol","code":"f0cb"},{"name":"list-ul","code":"f0ca"},{"name":"location-arrow","code":"f124"},{"name":"lock","code":"f023"},{"name":"long-arrow-down","code":"f175"},{"name":"long-arrow-left","code":"f177"},{"name":"long-arrow-right","code":"f178"},{"name":"long-arrow-up","code":"f176"},{"name":"magic","code":"f0d0"},{"name":"magnet","code":"f076"},{"name":"mail-forward","code":"f064"},{"name":"mail-reply","code":"f112"},{"name":"mail-reply-all","code":"f122"},{"name":"male","code":"f183"},{"name":"map","code":"f279"},{"name":"map-marker","code":"f041"},{"name":"map-o","code":"f278"},{"name":"map-pin","code":"f276"},{"name":"map-signs","code":"f277"},{"name":"mars","code":"f222"},{"name":"mars-double","code":"f227"},{"name":"mars-stroke","code":"f229"},{"name":"mars-stroke-h","code":"f22b"},{"name":"mars-stroke-v","code":"f22a"},{"name":"maxcdn","code":"f136"},{"name":"meanpath","code":"f20c"},{"name":"medium","code":"f23a"},{"name":"medkit","code":"f0fa"},{"name":"meh-o","code":"f11a"},{"name":"mercury","code":"f223"},{"name":"microphone","code":"f130"},{"name":"microphone-slash","code":"f131"},{"name":"minus","code":"f068"},{"name":"minus-circle","code":"f056"},{"name":"minus-square","code":"f146"},{"name":"minus-square-o","code":"f147"},{"name":"mixcloud","code":"f289"},{"name":"mobile","code":"f10b"},{"name":"mobile-phone","code":"f10b"},{"name":"modx","code":"f285"},{"name":"money","code":"f0d6"},{"name":"moon-o","code":"f186"},{"name":"mortar-board","code":"f19d"},{"name":"motorcycle","code":"f21c"},{"name":"mouse-pointer","code":"f245"},{"name":"music","code":"f001"},{"name":"navicon","code":"f0c9"},{"name":"neuter","code":"f22c"},{"name":"newspaper-o","code":"f1ea"},{"name":"object-group","code":"f247"},{"name":"object-ungroup","code":"f248"},{"name":"odnoklassniki","code":"f263"},{"name":"odnoklassniki-square","code":"f264"},{"name":"opencart","code":"f23d"},{"name":"openid","code":"f19b"},{"name":"opera","code":"f26a"},{"name":"optin-monster","code":"f23c"},{"name":"outdent","code":"f03b"},{"name":"pagelines","code":"f18c"},{"name":"paint-brush","code":"f1fc"},{"name":"paper-plane","code":"f1d8"},{"name":"paper-plane-o","code":"f1d9"},{"name":"paperclip","code":"f0c6"},{"name":"paragraph","code":"f1dd"},{"name":"paste","code":"f0ea"},{"name":"pause","code":"f04c"},{"name":"pause-circle","code":"f28b"},{"name":"pause-circle-o","code":"f28c"},{"name":"paw","code":"f1b0"},{"name":"paypal","code":"f1ed"},{"name":"pencil","code":"f040"},{"name":"pencil-square","code":"f14b"},{"name":"pencil-square-o","code":"f044"},{"name":"percent","code":"f295"},{"name":"phone","code":"f095"},{"name":"phone-square","code":"f098"},{"name":"photo","code":"f03e"},{"name":"picture-o","code":"f03e"},{"name":"pie-chart","code":"f200"},{"name":"pied-piper","code":"f1a7"},{"name":"pied-piper-alt","code":"f1a8"},{"name":"pinterest","code":"f0d2"},{"name":"pinterest-p","code":"f231"},{"name":"pinterest-square","code":"f0d3"},{"name":"plane","code":"f072"},{"name":"play","code":"f04b"},{"name":"play-circle","code":"f144"},{"name":"play-circle-o","code":"f01d"},{"name":"plug","code":"f1e6"},{"name":"plus","code":"f067"},{"name":"plus-circle","code":"f055"},{"name":"plus-square","code":"f0fe"},{"name":"plus-square-o","code":"f196"},{"name":"power-off","code":"f011"},{"name":"print","code":"f02f"},{"name":"product-hunt","code":"f288"},{"name":"puzzle-piece","code":"f12e"},{"name":"qq","code":"f1d6"},{"name":"qrcode","code":"f029"},{"name":"question","code":"f128"},{"name":"question-circle","code":"f059"},{"name":"quote-left","code":"f10d"},{"name":"quote-right","code":"f10e"},{"name":"ra","code":"f1d0"},{"name":"random","code":"f074"},{"name":"rebel","code":"f1d0"},{"name":"recycle","code":"f1b8"},{"name":"reddit","code":"f1a1"},{"name":"reddit-alien","code":"f281"},{"name":"reddit-square","code":"f1a2"},{"name":"refresh","code":"f021"},{"name":"registered","code":"f25d"},{"name":"remove","code":"f00d"},{"name":"renren","code":"f18b"},{"name":"reorder","code":"f0c9"},{"name":"repeat","code":"f01e"},{"name":"reply","code":"f112"},{"name":"reply-all","code":"f122"},{"name":"retweet","code":"f079"},{"name":"rmb","code":"f157"},{"name":"road","code":"f018"},{"name":"rocket","code":"f135"},{"name":"rotate-left","code":"f0e2"},{"name":"rotate-right","code":"f01e"},{"name":"rouble","code":"f158"},{"name":"rss","code":"f09e"},{"name":"rss-square","code":"f143"},{"name":"rub","code":"f158"},{"name":"ruble","code":"f158"},{"name":"rupee","code":"f156"},{"name":"safari","code":"f267"},{"name":"save","code":"f0c7"},{"name":"scissors","code":"f0c4"},{"name":"scribd","code":"f28a"},{"name":"search","code":"f002"},{"name":"search-minus","code":"f010"},{"name":"search-plus","code":"f00e"},{"name":"sellsy","code":"f213"},{"name":"send","code":"f1d8"},{"name":"send-o","code":"f1d9"},{"name":"server","code":"f233"},{"name":"share","code":"f064"},{"name":"share-alt","code":"f1e0"},{"name":"share-alt-square","code":"f1e1"},{"name":"share-square","code":"f14d"},{"name":"share-square-o","code":"f045"},{"name":"shekel","code":"f20b"},{"name":"sheqel","code":"f20b"},{"name":"shield","code":"f132"},{"name":"ship","code":"f21a"},{"name":"shirtsinbulk","code":"f214"},{"name":"shopping-bag","code":"f290"},{"name":"shopping-basket","code":"f291"},{"name":"shopping-cart","code":"f07a"},{"name":"sign-in","code":"f090"},{"name":"sign-out","code":"f08b"},{"name":"signal","code":"f012"},{"name":"simplybuilt","code":"f215"},{"name":"sitemap","code":"f0e8"},{"name":"skyatlas","code":"f216"},{"name":"skype","code":"f17e"},{"name":"slack","code":"f198"},{"name":"sliders","code":"f1de"},{"name":"slideshare","code":"f1e7"},{"name":"smile-o","code":"f118"},{"name":"soccer-ball-o","code":"f1e3"},{"name":"sort","code":"f0dc"},{"name":"sort-alpha-asc","code":"f15d"},{"name":"sort-alpha-desc","code":"f15e"},{"name":"sort-amount-asc","code":"f160"},{"name":"sort-amount-desc","code":"f161"},{"name":"sort-asc","code":"f0de"},{"name":"sort-desc","code":"f0dd"},{"name":"sort-down","code":"f0dd"},{"name":"sort-numeric-asc","code":"f162"},{"name":"sort-numeric-desc","code":"f163"},{"name":"sort-up","code":"f0de"},{"name":"soundcloud","code":"f1be"},{"name":"space-shuttle","code":"f197"},{"name":"spinner","code":"f110"},{"name":"spoon","code":"f1b1"},{"name":"spotify","code":"f1bc"},{"name":"square","code":"f0c8"},{"name":"square-o","code":"f096"},{"name":"stack-exchange","code":"f18d"},{"name":"stack-overflow","code":"f16c"},{"name":"star","code":"f005"},{"name":"star-half","code":"f089"},{"name":"star-half-empty","code":"f123"},{"name":"star-half-full","code":"f123"},{"name":"star-half-o","code":"f123"},{"name":"star-o","code":"f006"},{"name":"steam","code":"f1b6"},{"name":"steam-square","code":"f1b7"},{"name":"step-backward","code":"f048"},{"name":"step-forward","code":"f051"},{"name":"stethoscope","code":"f0f1"},{"name":"sticky-note","code":"f249"},{"name":"sticky-note-o","code":"f24a"},{"name":"stop","code":"f04d"},{"name":"stop-circle","code":"f28d"},{"name":"stop-circle-o","code":"f28e"},{"name":"street-view","code":"f21d"},{"name":"strikethrough","code":"f0cc"},{"name":"stumbleupon","code":"f1a4"},{"name":"stumbleupon-circle","code":"f1a3"},{"name":"subscript","code":"f12c"},{"name":"subway","code":"f239"},{"name":"suitcase","code":"f0f2"},{"name":"sun-o","code":"f185"},{"name":"superscript","code":"f12b"},{"name":"support","code":"f1cd"},{"name":"table","code":"f0ce"},{"name":"tablet","code":"f10a"},{"name":"tachometer","code":"f0e4"},{"name":"tag","code":"f02b"},{"name":"tags","code":"f02c"},{"name":"tasks","code":"f0ae"},{"name":"taxi","code":"f1ba"},{"name":"television","code":"f26c"},{"name":"tencent-weibo","code":"f1d5"},{"name":"terminal","code":"f120"},{"name":"text-height","code":"f034"},{"name":"text-width","code":"f035"},{"name":"th","code":"f00a"},{"name":"th-large","code":"f009"},{"name":"th-list","code":"f00b"},{"name":"thumb-tack","code":"f08d"},{"name":"thumbs-down","code":"f165"},{"name":"thumbs-o-down","code":"f088"},{"name":"thumbs-o-up","code":"f087"},{"name":"thumbs-up","code":"f164"},{"name":"ticket","code":"f145"},{"name":"times","code":"f00d"},{"name":"times-circle","code":"f057"},{"name":"times-circle-o","code":"f05c"},{"name":"tint","code":"f043"},{"name":"toggle-down","code":"f150"},{"name":"toggle-left","code":"f191"},{"name":"toggle-off","code":"f204"},{"name":"toggle-on","code":"f205"},{"name":"toggle-right","code":"f152"},{"name":"toggle-up","code":"f151"},{"name":"trademark","code":"f25c"},{"name":"train","code":"f238"},{"name":"transgender","code":"f224"},{"name":"transgender-alt","code":"f225"},{"name":"trash","code":"f1f8"},{"name":"trash-o","code":"f014"},{"name":"tree","code":"f1bb"},{"name":"trello","code":"f181"},{"name":"tripadvisor","code":"f262"},{"name":"trophy","code":"f091"},{"name":"truck","code":"f0d1"},{"name":"try","code":"f195"},{"name":"tty","code":"f1e4"},{"name":"tumblr","code":"f173"},{"name":"tumblr-square","code":"f174"},{"name":"turkish-lira","code":"f195"},{"name":"tv","code":"f26c"},{"name":"twitch","code":"f1e8"},{"name":"twitter","code":"f099"},{"name":"twitter-square","code":"f081"},{"name":"umbrella","code":"f0e9"},{"name":"underline","code":"f0cd"},{"name":"undo","code":"f0e2"},{"name":"university","code":"f19c"},{"name":"unlink","code":"f127"},{"name":"unlock","code":"f09c"},{"name":"unlock-alt","code":"f13e"},{"name":"unsorted","code":"f0dc"},{"name":"upload","code":"f093"},{"name":"usb","code":"f287"},{"name":"usd","code":"f155"},{"name":"user","code":"f007"},{"name":"user-md","code":"f0f0"},{"name":"user-plus","code":"f234"},{"name":"user-secret","code":"f21b"},{"name":"user-times","code":"f235"},{"name":"users","code":"f0c0"},{"name":"venus","code":"f221"},{"name":"venus-double","code":"f226"},{"name":"venus-mars","code":"f228"},{"name":"viacoin","code":"f237"},{"name":"video-camera","code":"f03d"},{"name":"vimeo","code":"f27d"},{"name":"vimeo-square","code":"f194"},{"name":"vine","code":"f1ca"},{"name":"vk","code":"f189"},{"name":"volume-down","code":"f027"},{"name":"volume-off","code":"f026"},{"name":"volume-up","code":"f028"},{"name":"warning","code":"f071"},{"name":"wechat","code":"f1d7"},{"name":"weibo","code":"f18a"},{"name":"weixin","code":"f1d7"},{"name":"whatsapp","code":"f232"},{"name":"wheelchair","code":"f193"},{"name":"wifi","code":"f1eb"},{"name":"wikipedia-w","code":"f266"},{"name":"windows","code":"f17a"},{"name":"won","code":"f159"},{"name":"wordpress","code":"f19a"},{"name":"wrench","code":"f0ad"},{"name":"xing","code":"f168"},{"name":"xing-square","code":"f169"},{"name":"y-combinator","code":"f23b"},{"name":"y-combinator-square","code":"f1d4"},{"name":"yahoo","code":"f19e"},{"name":"yc","code":"f23b"},{"name":"yc-square","code":"f1d4"},{"name":"yelp","code":"f1e9"},{"name":"yen","code":"f157"},{"name":"youtube","code":"f167"},{"name":"youtube-play","code":"f16a"},{"name":"youtube-square","code":"f166"}];
  };
  
  GS.lorem = function () {
      return 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';
  };
  
  if (!String.prototype.repeat) {
    String.prototype.repeat = function(count) {
      'use strict';
      if (this == null) {
        throw new TypeError('can\'t convert ' + this + ' to object');
      }
      var str = '' + this;
      count = +count;
      if (count != count) {
        count = 0;
      }
      if (count < 0) {
        throw new RangeError('repeat count must be non-negative');
      }
      if (count == Infinity) {
        throw new RangeError('repeat count must be less than infinity');
      }
      count = Math.floor(count);
      if (str.length == 0 || count == 0) {
        return '';
      }
      // Ensuring count is a 31-bit integer allows us to heavily optimize the
      // main part. But anyway, most current (August 2014) browsers can't handle
      // strings 1 << 28 chars or longer, so:
      if (str.length * count >= 1 << 28) {
        throw new RangeError('repeat count must not overflow maximum string size');
      }
      var rpt = '';
      for (;;) {
        if ((count & 1) == 1) {
          rpt += str;
        }
        count >>>= 1;
        if (count == 0) {
          break;
        }
        str += str;
      }
      // Could we try:
      // return Array(count + 1).join(this);
      return rpt;
    }
  }
  if (!String.prototype.trim) {
    String.prototype.trim = function () {
      return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    };
  }
  window.addEventListener('design-register-element', function () {
      registerDesignSnippet('Add Loader (to page)', 'GS.addLoader', 'addLoader(\'${0:class-name}\', \'${1:Loading...}\');');
      registerDesignSnippet('Add Loader (to element)', 'GS.addLoader', 'addLoader(${0:document.getElementById(\'id\')}, \'${1:Loading...}\');');
      registerDesignSnippet('Remove Loader (from page)', 'GS.removeLoader', 'removeLoader(\'${0:class-name}\');');
      registerDesignSnippet('Remove Loader (from element)', 'GS.removeLoader', 'removeLoader(${0:document.getElementById(\'id\')});');
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      xtag.register('gs-loader', {
          lifecycle: {},
          events: {},
          accessors: {},
          methods: {}
      });
  });
  
  GS.addLoader = function (loaderClassOrTarget, loaderContent) {
      var loaderElement = document.createElement('gs-loader'), loaderClass, loaderTarget;
      
      // turn loaderClassOrTarget into class or target
      if (typeof loaderClassOrTarget === 'string') {
          loaderClass = loaderClassOrTarget;
          
      } else if (typeof loaderClassOrTarget === 'object') {
          loaderTarget = loaderClassOrTarget;
      }
      
      // if there is a loader class: add class to loader for future identification
      if (loaderClass) {
          loaderElement.classList.add('loader-' + loaderClass);
      }
      
      // default loader target to body
      if (!loaderTarget) {
          loaderTarget = document.body;
      }
      
      // add spinning elements and loader content to loader container
      loaderElement.innerHTML =   '<div class="loader-positioning" gs-dynamic>' +
                                      '<div class="loader" gs-dynamic></div>' +
                                      '<div class="loader-inner spinning" gs-dynamic></div>' +
                                      '<div class="loader-inner-inner spinning" gs-dynamic></div>' +
                                      '<div class="loader-inner-inner-inner spinning" gs-dynamic></div>' +
                                      (loaderContent ? '<div class="loader-content" gs-dynamic>' + loaderContent + '</div>' : '') +
                                  '</div>';
      
      // prevent scrolling on a loader
      loaderElement.addEventListener('mousewheel', function (event) {
          event.preventDefault();
      });
      
      // append loader to target
      loaderTarget.appendChild(loaderElement); // document.body
  };
  
  GS.removeLoader = function (loaderClassOrTarget) {
      var element, i, len, arrLoaders, loaderClass, loaderTarget;
      
      if (typeof loaderClassOrTarget === 'string') {
          loaderClass = loaderClassOrTarget;
          
      } else if (typeof loaderClassOrTarget === 'object') {
          loaderTarget = loaderClassOrTarget;
      }
      
      if (loaderClass) {
          element = document.getElementsByClassName('loader-' + loaderClass)[0];
          
      } else if (loaderTarget) {
          element = xtag.queryChildren(loaderTarget, 'gs-loader')[0];
          
      } else {
          arrLoaders = xtag.queryChildren(document.body, 'gs-loader');
          
          for (i = 0, len = arrLoaders.length; i < len; i += 1) {
              if (!arrLoaders[i].hasAttribute('id')) {
                  element = arrLoaders[i];
                  break;
              }
          }
      }
      
      if (element) {
          element.parentNode.removeChild(element);
      } else {
          console.warn('GS.removeLoader Error: loader' + (loaderClass ? ' class: "' + loaderClass + '"' : '') + ' not found');
      }
  };
  
  GS.removeAllLoaders = function () {
      'use strict';
      var i, len, arrLoaders;
      
      arrLoaders = xtag.query(document.body, 'gs-loader');
      
      for (i = 0, len = arrLoaders.length; i < len; i += 1) {
          if (!arrLoaders[i].hasAttribute('id')) {
              arrLoaders[i].parentNode.removeChild(arrLoaders[i]);
          }
      }
  };
  window.addEventListener('design-register-element', function () {
      window.designElementProperty_GSBODY = function(selectedElement) {
          addFlexContainerProps(selectedElement);
          //addFlexProps(selectedElement);
          
          addProp('Padded', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('padded')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'padded', (this.value === 'true'), true);
          });
      };
      
      registerDesignSnippet('<gs-body>', '<gs-body>', 'gs-body>\n' +
                                                      '    $0\n' +
                                                      '</gs-body>');
      
      designRegisterElement('gs-body', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-page.html');
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      xtag.register('gs-body', {
          lifecycle: {},
          events: {},
          accessors: {},
          methods: {}
      });
  });
  
  (function () {
      'use strict';
  
      function defineButton(strTagName, strDocLink, arrDisableWhenEmptyAttributes, designAdditionalFunction, clickFunction) {
          strDocLink = strDocLink || '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-buttons-toggle.html';
          designAdditionalFunction = designAdditionalFunction || function () {};
          clickFunction = clickFunction || function () {};
  
          window.addEventListener('design-register-element', function () {
              registerDesignSnippet('<' + strTagName + '>', '<' + strTagName + '>', strTagName + '>${1}</' + strTagName + '>');
  
              designRegisterElement(strTagName, strDocLink);
  
              window['designElementProperty_' + strTagName.replace(/[^a-z0-9]/gi, '').toUpperCase()] = function (selectedElement) {
                  var strIconPos = '', strIconRotation = '', strVisibilityAttribute = '', strFontAttribute = '', strBackgroundAttribute = '';
  
                  addProp('Icon', true, '<div flex-horizontal>' +
                                        '     <gs-text id="prop-icon-input" class="target" value="' + (selectedElement.getAttribute('icon') || '') +
                                                                                                              '" mini flex></gs-text>' +
                                        '     <gs-button id="prop-icon-picker-button" mini icononly icon="list"></gs-button>' +
                                        '     <style>#prop-icon-picker-button:after {font-size: 1em;}</style>' +
                                        '</div>', function () {
                      return setOrRemoveTextAttribute(selectedElement, 'icon', this.value, false);
                  });
  
                  document.getElementById('prop-icon-picker-button').addEventListener('click', function () {
                      var i, len, html, arrIcons = GS.iconList(), strName, templateElement;
  
                      for (i = 0, len = arrIcons.length, html = ''; i < len; i += 1) {
                          strName = arrIcons[i].name;
                          html += '<gs-block>' +
                                      '<gs-button iconleft icon="' + strName + '" dialogclose>' + strName + '</gs-button>' +
                                  '</gs-block>';
                      }
  
                      templateElement = document.createElement('template');
                      templateElement.setAttribute('data-max-width', '1100px');
                      templateElement.innerHTML =
                          '<gs-page>' +
                          '    <gs-header><center><h3>Choose An Icon</h3></center></gs-header>' +
                          '    <gs-body padded><gs-grid widths="1,1,1,1" reflow-at="767px">' + html + '</gs-grid></gs-body>' +
                          '    <gs-footer><gs-button dialogclose>Cancel</gs-button></gs-footer>' +
                          '</gs-page>';
  
                      GS.openDialog(templateElement, '', function (event, strAnswer) {
                          var propInput = document.getElementById('prop-icon-input');
  
                          if (strAnswer !== 'Cancel') {
                              propInput.value = strAnswer;
                              GS.triggerEvent(propInput, 'change');
                          }
                      });
                  });
  
                         if (selectedElement.hasAttribute('iconleft'))   { strIconPos = 'iconleft';
                  } else if (selectedElement.hasAttribute('iconright'))  { strIconPos = 'iconright';
                  } else if (selectedElement.hasAttribute('icontop'))    { strIconPos = 'icontop';
                  } else if (selectedElement.hasAttribute('iconbottom')) { strIconPos = 'iconbottom';
                  } else if (selectedElement.hasAttribute('icononly'))   { strIconPos = 'icononly'; }
  
                  addProp('Icon Position', true, '<gs-select class="target" value="' + strIconPos + '" mini>' +
                                                      '   <option value="">Default</option>' +
                                                      '   <option value="iconleft">Left</option>' +
                                                      '   <option value="iconright">Right</option>' +
                                                      '   <option value="icontop">Top</option>' +
                                                      '   <option value="iconbottom">Bottom</option>' +
                                                      '   <option value="icononly">Icononly</option>' +
                                                      '</gs-select>', function () {
                      selectedElement.removeAttribute('iconleft');
                      selectedElement.removeAttribute('iconright');
                      selectedElement.removeAttribute('icontop');
                      selectedElement.removeAttribute('iconbottom');
                      selectedElement.removeAttribute('icononly');
  
                      if (this.value) {
                          selectedElement.setAttribute(this.value, '');
                      }
  
                      return selectedElement;
                  });
  
                         if (selectedElement.hasAttribute('iconrotateright')) { strIconRotation = 'iconrotateright';
                  } else if (selectedElement.hasAttribute('iconrotatedown'))  { strIconRotation = 'iconrotatedown';
                  } else if (selectedElement.hasAttribute('iconrotateleft'))  { strIconRotation = 'iconrotateleft'; }
                  
                  addProp('Icon&nbsp;Rotation', true, '<gs-select class="target" value="' + strIconRotation + '" mini>' +
                                                      '   <option value="">None</option>' +
                                                      '   <option value="iconrotateright">90 degrees</option>' +
                                                      '   <option value="iconrotatedown">180 degrees</option>' +
                                                      '   <option value="iconrotateleft">270 degrees</option>' +
                                                      '</gs-select>', function () {
                      selectedElement.removeAttribute('iconrotateright');
                      selectedElement.removeAttribute('iconrotatedown');
                      selectedElement.removeAttribute('iconrotateleft');
                      
                      if (this.value) {
                          selectedElement.setAttribute(this.value, '');
                      }
                      
                      return selectedElement;
                  });
                  
                  addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
                      return setOrRemoveTextAttribute(selectedElement, 'column', this.value, false);
                  });
                  
                  addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
                      return setOrRemoveTextAttribute(selectedElement, 'value', this.value, false);
                  });
                  
                  addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
                      return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
                  });
                  
                  addProp('Jumbo', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('jumbo')) + '" mini></gs-checkbox>', function () {
                      return setOrRemoveBooleanAttribute(selectedElement, 'jumbo', (this.value === 'true'), true);
                  });
                  
                  addProp('Focusable', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-focus')) + '" mini></gs-checkbox>', function () {
                      return setOrRemoveBooleanAttribute(selectedElement, 'no-focus', (this.value === 'true'), false);
                  });
                  /* TODO: remove emphasis and add other colors
                  addProp('Emphasis', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('emphasis')) + '" mini></gs-checkbox>', function () {
                      return setOrRemoveBooleanAttribute(selectedElement, 'emphasis', (this.value === 'true'), true);
                  });
                  */
  
  
                  //<gs-delete-button>
  
                  // Font Color attributes
                  strFontAttribute = '';
                  if (selectedElement.hasAttribute('txt-primary'))  { strFontAttribute = 'txt-primary'; }
                  if (selectedElement.hasAttribute('txt-success'))  { strFontAttribute = 'txt-success'; }
                  if (selectedElement.hasAttribute('txt-info'))     { strFontAttribute = 'txt-info'; }
                  if (selectedElement.hasAttribute('txt-warning'))  { strFontAttribute = 'txt-warning'; }
                  if (selectedElement.hasAttribute('txt-danger'))   { strFontAttribute = 'txt-danger'; }
                  
                  addProp('Font Color', true, '<gs-select class="target" value="' + strFontAttribute + '" mini>' +
                                                  '<option value="">Default</option>' +
                                                  '<option value="txt-primary">Primary</option>' +
                                                  '<option value="txt-success">Success</option>' +
                                                  '<option value="txt-info">Info</option>' +
                                                  '<option value="txt-warning">Warning</option>' +
                                                  '<option value="txt-danger">Danger</option>' +
                                              '</gs-select>', function () {
                      selectedElement.removeAttribute('txt-primary');
                      selectedElement.removeAttribute('txt-success');
                      selectedElement.removeAttribute('txt-info');
                      selectedElement.removeAttribute('txt-warning');
                      selectedElement.removeAttribute('txt-danger');
                      
                      if (this.value) {
                          selectedElement.setAttribute(this.value, '');
                      }
                      
                      return selectedElement;
                  });
  
                  // Background Color attributes
                  strBackgroundAttribute = '';
                  if (selectedElement.hasAttribute('bg-primary'))  { strBackgroundAttribute = 'bg-primary'; }
                  if (selectedElement.hasAttribute('bg-success'))  { strBackgroundAttribute = 'bg-success'; }
                  if (selectedElement.hasAttribute('bg-info'))     { strBackgroundAttribute = 'bg-info'; }
                  if (selectedElement.hasAttribute('bg-warning'))  { strBackgroundAttribute = 'bg-warning'; }
                  if (selectedElement.hasAttribute('bg-danger'))   { strBackgroundAttribute = 'bg-danger'; }
  
                  addProp('Background Color', true, '<gs-select class="target" value="' + strBackgroundAttribute + '" mini>' +
                                                  '<option value="">Default</option>' +
                                                  '<option value="bg-primary">Primary</option>' +
                                                  '<option value="bg-success">Success</option>' +
                                                  '<option value="bg-info">Info</option>' +
                                                  '<option value="bg-warning">Warning</option>' +
                                                  '<option value="bg-danger">Danger</option>' +
                                              '</gs-select>', function () {
                      selectedElement.removeAttribute('bg-primary');
                      selectedElement.removeAttribute('bg-success');
                      selectedElement.removeAttribute('bg-info');
                      selectedElement.removeAttribute('bg-warning');
                      selectedElement.removeAttribute('bg-danger');
  
                      if (this.value) {
                          selectedElement.setAttribute(this.value, '');
                      }
  
                      return selectedElement;
                  });
  
                  addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '0') + '" mini></gs-number>', function () {
                      return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
                  });
  
                  addProp('Inline', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('inline')) + '" mini></gs-checkbox>', function () {
                      return setOrRemoveBooleanAttribute(selectedElement, 'inline', (this.value === 'true'), true);
                  });
                  addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
                      return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
                  });
  
                  addProp('Key', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('key') || '') + '" mini></gs-text>', function () {
                      return setOrRemoveTextAttribute(selectedElement, 'key', this.value, false);
                  });
  
                  addProp('No Modifier Key For Hot Key', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-modifier-key') || '') + '" mini></gs-checkbox>', function () {
                      return setOrRemoveBooleanAttribute(selectedElement, 'no-modifier-key', this.value === 'true', true);
                  });
  
                  // TITLE attribute
                  addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
                      return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
                  });
  
                  // DISABLED attribute
                  addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
                      return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
                  });
  
                  // SUSPEND-INSERTED attribute
                  addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
                      return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
                  });
  
                  // visibility attributes
                  if (selectedElement.hasAttribute('hidden'))          { strVisibilityAttribute = 'hidden'; }
                  if (selectedElement.hasAttribute('hide-on-desktop')) { strVisibilityAttribute = 'hide-on-desktop'; }
                  if (selectedElement.hasAttribute('hide-on-tablet'))  { strVisibilityAttribute = 'hide-on-tablet'; }
                  if (selectedElement.hasAttribute('hide-on-phone'))   { strVisibilityAttribute = 'hide-on-phone'; }
                  if (selectedElement.hasAttribute('show-on-desktop')) { strVisibilityAttribute = 'show-on-desktop'; }
                  if (selectedElement.hasAttribute('show-on-tablet'))  { strVisibilityAttribute = 'show-on-tablet'; }
                  if (selectedElement.hasAttribute('show-on-phone'))   { strVisibilityAttribute = 'show-on-phone'; }
  
                  addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                                  '<option value="">Visible</option>' +
                                                  '<option value="hidden">Invisible</option>' +
                                                  '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                                  '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                                  '<option value="hide-on-phone">Invisible at phone size</option>' +
                                                  '<option value="show-on-desktop">Visible at desktop size</option>' +
                                                  '<option value="show-on-tablet">Visible at tablet size</option>' +
                                                  '<option value="show-on-phone">Visible at phone size</option>' +
                                              '</gs-select>', function () {
                      selectedElement.removeAttribute('hidden');
                      selectedElement.removeAttribute('hide-on-desktop');
                      selectedElement.removeAttribute('hide-on-tablet');
                      selectedElement.removeAttribute('hide-on-phone');
                      selectedElement.removeAttribute('show-on-desktop');
                      selectedElement.removeAttribute('show-on-tablet');
                      selectedElement.removeAttribute('show-on-phone');
                      
                      if (this.value) {
                          selectedElement.setAttribute(this.value, '');
                      }
                      
                      return selectedElement;
                  });
                  
                  // addProp('Corners', true,   '<div class="target">' +
                  //                                 '<gs-grid>\n' +
                  //                                 '    <gs-block>\n' +
                  //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                  //                                                             selectedElement.hasAttribute('remove-top') ||
                  //                                                             selectedElement.hasAttribute('remove-left') ||
                  //                                                             selectedElement.hasAttribute('remove-top-left'))).toString() + 
                  //                                             '" remove-right remove-bottom id="round-top-left-corner________"></gs-checkbox>' +
                                                          
                  //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                  //                                                             selectedElement.hasAttribute('remove-bottom') ||
                  //                                                             selectedElement.hasAttribute('remove-left') ||
                  //                                                             selectedElement.hasAttribute('remove-bottom-left'))).toString() + 
                  //                                             '" remove-right remove-top id="round-bottom-left-corner________"></gs-checkbox>' +
                  //                                 '    </gs-block>\n' +
                  //                                 '    <gs-block>\n' +
                  //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                  //                                                             selectedElement.hasAttribute('remove-top') ||
                  //                                                             selectedElement.hasAttribute('remove-right') ||
                  //                                                             selectedElement.hasAttribute('remove-top-right'))).toString() + 
                  //                                             '" remove-left remove-bottom id="round-top-right-corner________"></gs-checkbox>' +
                                                          
                  //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                  //                                                             selectedElement.hasAttribute('remove-bottom') ||
                  //                                                             selectedElement.hasAttribute('remove-right') ||
                  //                                                             selectedElement.hasAttribute('remove-bottom-right'))).toString() + 
                  //                                             '" remove-left remove-top id="round-bottom-right-corner________"></gs-checkbox>' +
                  //                                 '    </gs-block>\n' +
                  //                                 '</gs-grid>\n' +
                  //                             '</div>', function () {
                  //     var topLeft     = document.getElementById('round-top-left-corner________').value === 'true',
                  //         topRight    = document.getElementById('round-top-right-corner________').value === 'true',
                  //         bottomLeft  = document.getElementById('round-bottom-left-corner________').value === 'true',
                  //         bottomRight = document.getElementById('round-bottom-right-corner________').value === 'true',
                  //         arrStrAttr = [], i, len;
                      
                  //     selectedElement.removeAttribute('remove-all');
                  //     selectedElement.removeAttribute('remove-top');
                  //     selectedElement.removeAttribute('remove-bottom');
                  //     selectedElement.removeAttribute('remove-left');
                  //     selectedElement.removeAttribute('remove-right');
                  //     selectedElement.removeAttribute('remove-top-left');
                  //     selectedElement.removeAttribute('remove-top-right');
                  //     selectedElement.removeAttribute('remove-bottom-left');
                  //     selectedElement.removeAttribute('remove-bottom-right');
                      
                  //     if (!topLeft && !topRight && !bottomLeft && !bottomRight) {
                  //         arrStrAttr.push('remove-all');
                  //     } else if (!topLeft && !topRight) {
                  //         arrStrAttr.push('remove-top');
                  //     } else if (!bottomLeft && !bottomRight) {
                  //         arrStrAttr.push('remove-bottom');
                          
                  //     } else if (!topLeft && !bottomLeft) {
                  //         arrStrAttr.push('remove-left');
                  //     } else if (!topRight && !bottomRight) {
                  //         arrStrAttr.push('remove-right');
                  //     }
                      
                  //     if (!topLeft && !bottomLeft && arrStrAttr[0] !== 'remove-all') {
                  //         arrStrAttr.push('remove-left');
                  //     } else if (!topLeft && topRight) {
                  //         arrStrAttr.push('remove-top-left');
                  //     } else if (!bottomLeft && bottomRight) {
                  //         arrStrAttr.push('remove-bottom-left');
                  //     }
  
                  //     if (!topRight && !bottomRight && arrStrAttr[0] !== 'remove-all') {
                  //         arrStrAttr.push('remove-right');
                  //     } else if (topLeft && !topRight) {
                  //         arrStrAttr.push('remove-top-right');
                  //     } else if (bottomLeft && !bottomRight) {
                  //         arrStrAttr.push('remove-bottom-right');
                  //     }
  
                  //     for (i = 0, len = arrStrAttr.length; i < len; i += 1) {
                  //         selectedElement.setAttribute(arrStrAttr[i], '');
                  //     }
  
                  //     return selectedElement;
                  // });
  
                  designAdditionalFunction(selectedElement);
              };
          });
          
          document.addEventListener('DOMContentLoaded', function () {
              function handleDisable(element) {
                  var i, len;
  
                  element.removeAttribute('disabled');
  
                  for (i = 0, len = arrDisableWhenEmptyAttributes.length; i < len; i += 1) {
                      if (!element.getAttribute(arrDisableWhenEmptyAttributes[i])) {
                          element.setAttribute('disabled', '');
                          break;
                      }
                  }
              }
  
              //function pushReplacePopHandler(element) {
              //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
  
              //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
              //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
              //    }
              //}
              function saveDefaultAttributes(element) {
                  var i;
                  var len;
                  var arrAttr;
                  var jsnAttr;
          
                  // we need a place to store the attributes
                  element.internal.defaultAttributes = {};
          
                  // loop through attributes and store them in the internal defaultAttributes object
                  arrAttr = element.attributes;
                  i = 0;
                  len = arrAttr.length;
                  while (i < len) {
                      jsnAttr = arrAttr[i];
          
                      element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
          
                      i += 1;
                  }
              }
          
              function pushReplacePopHandler(element) {
                  var i;
                  var len;
                  var strQS = GS.getQueryString();
                  var strQSCol = element.getAttribute('qs');
                  var strQSValue;
                  var strQSAttr;
                  var arrQSParts;
                  var arrAttrParts;
                  var strOperator;
  
                  if (strQSCol.indexOf('=') !== -1) {
                      arrAttrParts = strQSCol.split(',');
                      i = 0;
                      len = arrAttrParts.length;
                      while (i < len) {
                          strQSCol = arrAttrParts[i];
  
                          if (strQSCol.indexOf('!=') !== -1) {
                              strOperator = '!=';
                              arrQSParts = strQSCol.split('!=');
                          } else {
                              strOperator = '=';
                              arrQSParts = strQSCol.split('=');
                          }
  
                          strQSCol = arrQSParts[0];
                          strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                          // if the key is not present or we've got the negator: go to the attribute's default or remove it
                          if (strOperator === '!=') {
                              // if the key is not present: add the attribute
                              if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                                  element.setAttribute(strQSAttr, '');
                              // else: remove the attribute
                              } else {
                                  element.removeAttribute(strQSAttr);
                              }
                          } else {
                              // if the key is not present: go to the attribute's default or remove it
                              if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                                  if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                      element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                                  } else {
                                      element.removeAttribute(strQSAttr);
                                  }
                              // else: set attribute to exact text from QS
                              } else {
                                  element.setAttribute(strQSAttr, (
                                      GS.qryGetVal(strQS, strQSCol) ||
                                      element.internal.defaultAttributes[strQSAttr] ||
                                      ''
                                  ));
                              }
                          }
                          i += 1;
                      }
                  } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                      strQSValue = GS.qryGetVal(strQS, strQSCol);
  
                      if (element.internal.bolQSFirstRun !== true) {
                          if (strQSValue !== '' || !element.getAttribute('value')) {
                              element.setAttribute('value', strQSValue);
                          }
                      } else {
                          element.setAttribute('value', strQSValue);
                      }
                  }
  
                  element.internal.bolQSFirstRun = true;
              }
  
              // dont do anything that modifies the element here
              function elementCreated(element) {
                  // if "created" hasn't been suspended: run created code
                  if (!element.hasAttribute('suspend-created')) {
  
                  }
              }
  
              //
              function elementInserted(element) {
                  var strKey, strQSValue;
  
                  if (element.tagName.toUpperCase() === 'GS-DELETE-BUTTON' && !element.hasAttribute('src')) {
                      console.warn(element, 'gs-delete-button needs a [src=""] attribute!');
                  }
  
                  // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
                  if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                      // if this is the first time inserted has been run: continue
                      if (!element.inserted) {
                          element.inserted = true;
                          element.internal = {};
                          saveDefaultAttributes(element);
  
                          if (element.getAttribute('qs')) {
                              //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                              //if (strQSValue !== '' || !element.getAttribute('value')) {
                              //    element.setAttribute('value', strQSValue);
                              //}
                              pushReplacePopHandler(element);
                              window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                              window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                              window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                          }
  
                          // add a tabindex to allow focus (if allowed)
                          if (!element.hasAttribute('no-focus')) {
                              if ((!element.tabIndex) || element.tabIndex === -1) {
                                  element.tabIndex = 0;
                              }
                          } else {
                              element.removeAttribute('tabindex');
                          }
                          
                          if (!evt.touchDevice) {
                              element.addEventListener('focus', function (event) {
                                  element.classList.add('focus');
                              });
                              
                              element.addEventListener('blur', function (event) {
                                  element.classList.remove('focus');
                              });
                              
                              
                              element.addEventListener(evt.mousedown, function (event) {
                                  element.classList.add('down');
                              });
                              
                              element.addEventListener(evt.mouseout, function (event) {
                                  element.classList.remove('down');
                                  element.classList.remove('hover');
                              });
                              
                              element.addEventListener(evt.mouseover, function (event) {
                                  element.classList.remove('down');
                                  element.classList.add('hover');
                              });
                              
                              element.addEventListener('keydown', function (event) {
                                  if (!element.hasAttribute('disabled') && !element.classList.contains('down') &&
                                      (event.keyCode === 13 || event.keyCode === 32)) {
                                      
                                      element.classList.add('down');
                                  }
                              });
                              
                              element.addEventListener('keyup', function (event) {
                                  // if we are not disabled and we pressed return (13) or space (32): trigger click
                                  if (!element.hasAttribute('disabled') && element.classList.contains('down') &&
                                      (event.keyCode === 13 || event.keyCode === 32)) {
                                      GS.triggerEvent(element, 'click');
                                  }
                              });
                          }
                          
                          element.addEventListener('click', function (event) {
                              element.classList.remove('down');
                              clickFunction(element);
                          });
                          
                          element.addEventListener('keypress', function (event) {
                              // if we pressed return (13) or space (32): prevent default and stop propagation (to prevent scrolling of the page)
                              if (event.keyCode === 13 || event.keyCode === 32) {
                                  event.preventDefault();
                                  event.stopPropagation();
                              }
                          });
                          
                          if (element.getAttribute('key')) {
                              strKey = element.getAttribute('key');
                              
                              if (GS.keyCode(strKey)) {
                                  if (strKey.match(/[arfcvxzntypq]/gim)) {
                                      console.warn('gs-skype-button Warning: by setting the hot key of this button to "' + strKey + '" you may be overriding browser functionality.', element);
                                  }
                                  
                                  window.addEventListener('keydown', function (event) {
                                      if (String(event.keyCode || event.which) === GS.keyCode(strKey) &&
                                          (
                                              (element.hasAttribute('no-modifier-key') && !event.metaKey && !event.ctrlKey) ||
                                              (!element.hasAttribute('no-modifier-key') && (event.metaKey || event.ctrlKey))
                                          )) {
                                          event.preventDefault();
                                          event.stopPropagation();
                                          
                                          element.focus();
                                          GS.triggerEvent(element, 'click');
                                      }
                                  });
                                  
                              } else if (strKey.length > 1) {
                                  console.error('gs-skype-button Error: \'key="' + strKey + '"\' is not a valid hot-key.', element);
                              }
                          }
                          
                          handleDisable(element);
                      }
                  }
              }
              
              xtag.register(strTagName, {
                  lifecycle: {
                      created: function () {
                          elementCreated(this);
                      },
                      
                      inserted: function () {
                          elementInserted(this);
                      },
                      
                      attributeChanged: function (strAttrName, oldValue, newValue) {
                          // if "suspend-created" has been removed: run created and inserted code
                          if (strAttrName === 'suspend-created' && newValue === null) {
                              elementCreated(this);
                              elementInserted(this);
                              
                          // if "suspend-inserted" has been removed: run inserted code
                          } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                              elementInserted(this);
                              
                          } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                              if (strAttrName === 'no-focus') {
                                  if (!this.hasAttribute('no-focus')) {
                                      if ((!this.tabIndex) || this.tabIndex === -1) {
                                          this.tabIndex = 0;
                                      }
                                  } else {
                                      this.removeAttribute('tabindex');
                                  }
                              } else if (strAttrName === 'disabled') {
                                  this.classList.remove('down');
                              } else if (arrDisableWhenEmptyAttributes.indexOf(strAttrName) > -1) {
                                  handleDisable(this);
                              }
                          }
                      }
                  },
                  accessors: {
                      value: {
                          get: function () {
                              return this.getAttribute('value');
                          },
                          set: function (newValue) {
                              this.setAttribute('value', newValue);
                          }
                      }
                  }
              });
          });
      }
      
      
      
      defineButton('gs-email-button', '', ['value'], '', function (element) {
          var emailAddress = element.getAttribute('value'), linkIframe, mousedownHandler;
          
          if (emailAddress) {
              linkIframe = document.createElement('iframe');
              document.body.appendChild(linkIframe);
              
              linkIframe.setAttribute('src', 'mailto:' + emailAddress);
              
              mousedownHandler = function () {
                  document.body.removeChild(linkIframe);
                  window.removeEventListener('mousedown', mousedownHandler);
              };
              
              window.addEventListener('mousedown', mousedownHandler);
          }
      });
      
      defineButton('gs-facetime-button', '', ['value'], '', function (element) {
          var appleID = element.getAttribute('value');
          
          if (appleID) {
              window.open('facetime:' + appleID);
          }
      });
      
      defineButton('gs-map-button', '', ['value'], '', function (element) {
          var strLocation = encodeURIComponent(element.getAttribute('value'));
          
          if (strLocation) {
              if (element.hasAttribute('google') === true) {
                  window.open('https://maps.google.com/maps?q=' + strLocation);
              } else if (element.hasAttribute('bing') === true) {
                  window.open('http://www.bing.com/maps/default.aspx?q=' + strLocation);
              } else {
                  window.open('https://maps.google.com/maps?q=' + strLocation);
              }
          }
      });
      
      defineButton('gs-phone-button', '', ['value'], '', function (element) {
          var phoneNumber = element.getAttribute('value');
          
          if (phoneNumber) {
              if (evt.deviceType === 'phone') {
                  window.open('tel:' + phoneNumber);
                     
              } else {
                  GS.msgbox('Phone Number', '<center>' + phoneNumber + '</center>', ['Done']);
              }
          }
      });
      
      defineButton('gs-tracking-button', '', ['value'], function (selectedElement) {
          var strService = '';
          
                 if (selectedElement.hasAttribute('usps'))  { strService = 'usps';
          } else if (selectedElement.hasAttribute('ups'))   { strService = 'ups';
          } else if (selectedElement.hasAttribute('fedex')) { strService = 'fedex';
          } else if (selectedElement.hasAttribute('royal')) { strService = 'royal';
          } else if (selectedElement.hasAttribute('amz'))   { strService = 'amz'; }
          
          addProp('Service', true, '<gs-select class="target" value="' + strService + '" mini>' +
                                              '   <option value="">None</option>' +
                                              '   <option value="usps">USPS</option>' +
                                              '   <option value="ups">UPS</option>' +
                                              '   <option value="fedex">FEDEX</option>' +
                                              '   <option value="royal">Royal Mail</option>' +
                                              '   <option value="amz">Amazon</option>' +
                                              '</gs-select>', function () {
              selectedElement.removeAttribute('usps');
              selectedElement.removeAttribute('ups');
              selectedElement.removeAttribute('fedex');
              selectedElement.removeAttribute('royal');
              selectedElement.removeAttribute('amazon');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
      }, function (element) {
          var strTrackingNumber = element.getAttribute('value');
          
          if (strTrackingNumber) {
              if (element.hasAttribute('usps') === true) {
                  window.open(' https://tools.usps.com/go/TrackConfirmAction?tLabels=' + strTrackingNumber);
                  
              } else if (element.hasAttribute('ups') === true) {
                  window.open('http://www.ups.com/WebTracking/processInputRequest?tracknum=' + strTrackingNumber);
                  
              } else if (element.hasAttribute('fedex') === true) {
                  window.open('https://www.fedex.com/apps/fedextrack/index.html?tracknumbers=' + strTrackingNumber);
                  
              } else if (element.hasAttribute('royal') === true) {
                  window.open('https://www.royalmail.com/track-your-item?trackNumber=' + strTrackingNumber);
                  
              } else if (element.hasAttribute('amz') === true) {
                  window.open(decodeURIComponent(strTrackingNumber));
                  
              } else {
                  GS.msgbox('Please Choose...',
                            '<center>Please Choose UPS, USPS, Fedex, Royal Mail or Amazon</center>',
                            ['UPS', 'USPS', 'Fedex', 'Royal Mail', 'Amazon'],
                            function (strAnswer) {
                      if (strAnswer === 'UPS') {
                          window.open('http://www.ups.com/WebTracking/processInputRequest?tracknum=' + strTrackingNumber);
                      } else if (strAnswer === 'USPS') {
                           window.open('https://tools.usps.com/go/TrackConfirmAction?tLabels=' + strTrackingNumber);
                      } else if (strAnswer === 'Fedex') {
                           window.open('https://www.fedex.com/apps/fedextrack/index.html?tracknumbers=' + strTrackingNumber);
                      } else if (strAnswer === 'Royal Mail') {
                           window.open('https://www.royalmail.com/track-your-item?trackNumber' + strTrackingNumber);
                      } else if (strAnswer === 'Amazon') {
                           window.open(strTrackingNumber);
                      }
                  });
              }
          }
      });
      
      defineButton('gs-skype-button', '', ['value'], '', function (element) {
          if (element.getAttribute('value')) {
              window.open('skype:' + element.getAttribute('value'));
          }
      });
      
      defineButton('gs-delete-button',
                   '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-delete-button.html',
                   ['value', 'src'],
                   function (selectedElement) {
          addProp('Source', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('src') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'src', this.value, false);
          });
          
          addProp('Delete Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-delete') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'action-delete', this.value);
          });
          
      }, function (element) {
          if (element.getAttribute('value')) {
              var arrSrcParts = element.getAttribute('src').split('.')
                , strSchema = arrSrcParts[0]
                , strObject = arrSrcParts[1]
                , strPkColumn, strLockColumn
                , deleteRecordData, strHashColumns, strRoles, strColumns, strRecord
                , strDeleteData, strHash, strPkValue, strLockValue;
              
              element.classList.remove('down');
              
              strPkColumn = element.getAttribute('column') || 'id';
              strLockColumn = strPkColumn;
              strHashColumns = strLockColumn;
              
              strPkValue = GS.encodeForTabDelimited(element.getAttribute('value') || '');
              strLockValue = element.getAttribute('value') || '';
              
              strRoles = 'pk\thash';
              strColumns = strPkColumn + '\thash';
              
              strHash = CryptoJS.MD5(strLockValue === 'NULL' ? '' : strLockValue).toString();
              
              strDeleteData = strPkValue + '\t' + strHash + '\n';
              strDeleteData = strRoles + '\n' + strColumns + '\n' + strDeleteData;
              
              // create delete transaction
              GS.addLoader(element, 'Creating Delete Transaction...');
              GS.requestDeleteFromSocket(
                  GS.envSocket, strSchema, strObject, strHashColumns, strDeleteData
                  , function (data, error, transactionID) {
                      if (error) {
                          GS.removeLoader(element);
                          GS.webSocketErrorDialog(data);
                      }
                  }
                  , function (data, error, transactionID, commitFunction, rollbackFunction) {
                      var arrElements, i, len, templateElement;
                      GS.removeLoader(element);
  
                      if (!error) {
                          if (data !== 'TRANSACTION COMPLETED') {
  
                          } else {
                              templateElement = document.createElement('template');
                              templateElement.innerHTML = ml(function () {/*
                                  <gs-page>
                                      <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                      <gs-body padded>
                                          <center>Are you sure you want to delete?</center>
                                      </gs-body>
                                      <gs-footer>
                                          <gs-grid>
                                              <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                              <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                          </gs-grid>
                                      </gs-footer>
                                  </gs-page>
                              */});
  
                              GS.openDialog(templateElement, function () {
                                  document.getElementById('datasheet-focus-me').focus();
  
                              }, function (event, strAnswer) {
                                  if (strAnswer === 'Yes') {
                                      commitFunction();
                                      GS.addLoader(element, 'Commiting Delete Transaction...');
                                  } else {
                                      rollbackFunction();
                                      GS.addLoader(element, 'Rolling Back Delete Transaction...');
                                  }
                              });
                          }
  
                      } else {
                          rollbackFunction();
                          GS.webSocketErrorDialog(data);
                      }
                  }
                  , function (strAnswer, data, error) {
                      var arrElements, i, len;
                      GS.removeLoader(element);
  
                      if (!error) {
                          if (strAnswer === 'COMMIT') {
                              GS.triggerEvent(element, 'success');
                              if (element.hasAttribute('onsuccess')) {
                                  new Function(element.getAttribute('onsuccess')).apply(element);
                              }
                          }
  
                      } else {
                          getData(element);
                          GS.webSocketErrorDialog(data);
                      }
                  }
              );
          }
      });
      
      defineButton('gs-option',
                   '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-optionbox.html',
                   [],
                   function (selectedElement) {},
                   function (element) {});
      
      defineButton('gs-dialog-button',
          '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-dialog-button.html',
          [],
          function (selectedElement) { // design code
              addProp('Template', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('template') || '') + '" mini></gs-text>', function () {
                  return setOrRemoveTextAttribute(selectedElement, 'template', this.value, false);
              });
              
              addProp('Attach To Element', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('target-element') || '') + '" mini></gs-text>', function () {
                  return setOrRemoveTextAttribute(selectedElement, 'target-element', this.value, false);
              });
              
              addProp('Attachment Direction', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('direction') || '') + '" mini>' +
                                                          '<option value="">Default</option>' +
                                                          '<option value="left">Left</option>' +
                                                          '<option value="right">Right</option>' +
                                                          '<option value="up">Up</option>' +
                                                          '<option value="down">Down</option>' +
                                                    '</gs-select>', function () {
                  return setOrRemoveTextAttribute(selectedElement, 'direction', this.value, false);
              });
              
              addProp('Before Open JS', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('before-open') || '') + '" mini></gs-text>', function () {
                  return setOrRemoveTextAttribute(selectedElement, 'before-open', this.value, false);
              });
              
              addProp('After Open JS', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('after-open') || '') + '" mini></gs-text>', function () {
                  return setOrRemoveTextAttribute(selectedElement, 'after-open', this.value, false);
              });
              
              addProp('Before Close JS', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('before-close') || '') + '" mini></gs-text>', function () {
                  return setOrRemoveTextAttribute(selectedElement, 'before-close', this.value, false);
              });
              
              addProp('After Close JS', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('after-close') || '') + '" mini></gs-text>', function () {
                  return setOrRemoveTextAttribute(selectedElement, 'after-close', this.value, false);
              });
          },
          function (element) {// on click
              var targetElement
                , strTemplate = element.getAttribute('template')
                , templateElement
                , strTargetSelector = element.getAttribute('target')
                , strDirection = element.getAttribute('direction')
                , strBeforeOpen = element.getAttribute('before-open')
                , strAfterOpen = element.getAttribute('after-open')
                , strBeforeClose = element.getAttribute('before-close')
                , strAfterClose = element.getAttribute('after-close')
                , afterOpenFunction
                , beforeCloseFunction
                , afterCloseFunction;
              
              templateElement = (strTemplate ? document.getElementById(strTemplate) : xtag.queryChildren(element, 'template')[0]);
              //console.log(templateElement);
              
              if (templateElement) {
                  if (strBeforeOpen) {
                      new Function(strBeforeOpen).apply(element);
                  }
                  GS.triggerEvent(element, 'before-open');
                  
                  afterOpenFunction = function () {
                      if (strAfterOpen) {
                          new Function(strAfterOpen).apply(this);
                      }
                      GS.triggerEvent(element, 'after-open');
                  };
                  
                  beforeCloseFunction = function (event, strAnswer) {
                      // if there is a before close function: run the code
                      if (strBeforeClose) {
                          // append a definition for the "strAnswer" variable before the code (the replace calls are to make the string safe)
                          new Function('var strAnswer = \'' + strAnswer.replace(/'/g, 'donTGueSsThiSUniTokEN1975') + '\'' +
                                                      '.replace(/donTGueSsThiSUniTokEN1975/g, \'\\\'\');\n' + strBeforeClose).apply(this);
                      }
                      GS.triggerEvent(element, 'before-close', {'strAnswer': strAnswer});
                  };
                  
                  afterCloseFunction = function (event, strAnswer) {
                      // if there is a after close function: run the code
                      if (strAfterClose) {
                          // append a definition for the "strAnswer" variable before the code (the replace calls are to make the string safe)
                          new Function('var strAnswer = \'' + strAnswer.replace(/'/g, 'donTGueSsThiSUniTokEN1975') + '\'' +
                                                      '.replace(/donTGueSsThiSUniTokEN1975/g, \'\\\'\');\n' + strAfterClose).apply(element);
                      }
                      GS.triggerEvent(element, 'after-close', {'strAnswer': strAnswer});
                  };
                  
                  if (strTargetSelector || element.hasAttribute('target')) {
                      strTargetSelector = (strTargetSelector || 'this');
                      targetElement = (strTargetSelector === 'this' ? element : document.querySelector(strTargetSelector));
                      strDirection = (strDirection || 'down');
                      
                      GS.openDialogToElement(targetElement, templateElement, strDirection,
                                              afterOpenFunction, beforeCloseFunction, afterCloseFunction);
                      
                  } else {
                      GS.openDialog(templateElement, afterOpenFunction, beforeCloseFunction, afterCloseFunction);
                  }
              }
          });
  })();
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  window.addEventListener('design-register-element', function () {
      
      registerDesignSnippet('<gs-button>', '<gs-button>', 'gs-button>${1}</gs-button>');
      
      designRegisterElement('gs-button', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-buttons-toggle.html');
      
      window.designElementProperty_GSBUTTON = function(selectedElement) {
          var strIconPos, strIconRotation;
          
          addProp('Icon', true, '<div flex-horizontal>' +
                                '     <gs-text id="prop-icon-input" class="target" value="' + (selectedElement.getAttribute('icon') || '') + '" mini flex></gs-text>' +
                                '     <gs-button id="prop-icon-picker-button" mini icononly icon="list"></gs-button>' +
                                '     <style>#prop-icon-picker-button:after {font-size: 1em;}</style>' +
                                '</div>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'icon', this.value);
          });
          
          document.getElementById('prop-icon-picker-button').addEventListener('click', function () {
              var i, len, html, arrIcons = GS.iconList(), strName, templateElement;
              
              for (i = 0, len = arrIcons.length, html = ''; i < len; i += 1) {
                  strName = arrIcons[i].name;
                  html += '<gs-block>' +
                              '<gs-button iconleft icon="' + strName + '" dialogclose>' + strName + '</gs-button>' +
                          '</gs-block>';
              }
              
              templateElement = document.createElement('template');
              templateElement.setAttribute('data-max-width', '1100px');
              
              templateElement.innerHTML = ml(function () {/*
                  <gs-page>
                      <gs-header><center><h3>Choose An Icon</h3></center></gs-header>
                      <gs-body padded>
                          <gs-grid widths="1,1,1,1" reflow-at="767px">{{HTML}}</gs-grid>
                      </gs-body>
                      <gs-footer><gs-button dialogclose>Cancel</gs-button></gs-footer>
                  </gs-page>
              */}).replace('{{HTML}}', html);
              
              GS.openDialog(templateElement, '', function (event, strAnswer) {
                  var propInput = document.getElementById('prop-icon-input');
                  
                  if (strAnswer !== 'Cancel') {
                      propInput.value = strAnswer;
                      GS.triggerEvent(propInput, 'change');
                  }
              });
          });
          
          // iconleft
          // iconright
          // icontop
          // iconbottom
          // icononly
                 if (selectedElement.hasAttribute('iconleft'))   { strIconPos = 'iconleft';
          } else if (selectedElement.hasAttribute('iconright'))  { strIconPos = 'iconright';
          } else if (selectedElement.hasAttribute('icontop'))    { strIconPos = 'icontop';
          } else if (selectedElement.hasAttribute('iconbottom')) { strIconPos = 'iconbottom';
          } else if (selectedElement.hasAttribute('icononly'))   { strIconPos = 'icononly';
          } else { strIconPos = ''; }
          
          addProp('Icon Position', true, '<gs-select class="target" value="' + strIconPos + '" mini>' +
                                          '   <option value="">Default</option>' +
                                          '   <option value="iconleft">Left</option>' +
                                          '   <option value="iconright">Right</option>' +
                                          '   <option value="icontop">Top</option>' +
                                          '   <option value="iconbottom">Bottom</option>' +
                                          '   <option value="icononly">Icononly</option>' +
                                          '</gs-select>', function () {
              selectedElement.removeAttribute('iconleft');
              selectedElement.removeAttribute('iconright');
              selectedElement.removeAttribute('icontop');
              selectedElement.removeAttribute('iconbottom');
              selectedElement.removeAttribute('icononly');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          // None
          // 90 degrees  (iconrotateright)
          // 180 degrees (iconrotatedown)
          // 270 degrees (iconrotateleft)
                 if (selectedElement.hasAttribute('iconrotateright')) { strIconRotation = 'iconrotateright';
          } else if (selectedElement.hasAttribute('iconrotatedown'))  { strIconRotation = 'iconrotatedown';
          } else if (selectedElement.hasAttribute('iconrotateleft'))  { strIconRotation = 'iconrotateleft';
          } else { strIconRotation = ''; }
          
          addProp('Icon&nbsp;Rotation', true, '<gs-select class="target" value="' + strIconRotation + '" mini>' +
                                              '   <option value="">None</option>' +
                                              '   <option value="iconrotateright">90 degrees</option>' +
                                              '   <option value="iconrotatedown">180 degrees</option>' +
                                              '   <option value="iconrotateleft">270 degrees</option>' +
                                              '</gs-select>', function () {
              selectedElement.removeAttribute('iconrotateright');
              selectedElement.removeAttribute('iconrotatedown');
              selectedElement.removeAttribute('iconrotateleft');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          addProp('Href', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('href') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'href', this.value, false);
          });
          if (selectedElement.getAttribute('href')) {
              addProp('Target', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('target') || '') + '" mini>' +
                                          '<option value="">New Window</option>' +
                                          '<option value="_self">Current Window</option>' +
                                      '</gs-select>', function () {
                  return setOrRemoveTextAttribute(selectedElement, 'target', this.value, false);
              });
          }
          
          addProp('Jumbo', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('jumbo')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'jumbo', (this.value === 'true'), true);
          });
          
          addProp('Focusable', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-focus')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-focus', (this.value === 'true'), false);
          });
          
          // TABINDEX attribute
          addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '0') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
          });
          
          addProp('Inline', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('inline')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'inline', (this.value === 'true'), true);
          });
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
          /*
          addProp('Emphasis', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('emphasis')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'emphasis', (this.value === 'true'), true);
          });
          */
          
          //<gs-button txt-info bg-success>
          
          // Font Color attributes
          var strFontAttribute = '';
          if (selectedElement.hasAttribute('txt-primary'))  { strFontAttribute = 'txt-primary'; }
          if (selectedElement.hasAttribute('txt-success'))  { strFontAttribute = 'txt-success'; }
          if (selectedElement.hasAttribute('txt-info'))     { strFontAttribute = 'txt-info'; }
          if (selectedElement.hasAttribute('txt-warning'))  { strFontAttribute = 'txt-warning'; }
          if (selectedElement.hasAttribute('txt-danger'))   { strFontAttribute = 'txt-danger'; }
          
          addProp('Font Color', true, '<gs-select class="target" value="' + strFontAttribute + '" mini>' +
                                          '<option value="">Default</option>' +
                                          '<option value="txt-primary">Primary</option>' +
                                          '<option value="txt-success">Success</option>' +
                                          '<option value="txt-info">Info</option>' +
                                          '<option value="txt-warning">Warning</option>' +
                                          '<option value="txt-danger">Danger</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('txt-primary');
              selectedElement.removeAttribute('txt-success');
              selectedElement.removeAttribute('txt-info');
              selectedElement.removeAttribute('txt-warning');
              selectedElement.removeAttribute('txt-danger');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          // Background Color attributes
          var strBackgroundAttribute = '';
          if (selectedElement.hasAttribute('bg-primary'))  { strBackgroundAttribute = 'bg-primary'; }
          if (selectedElement.hasAttribute('bg-success'))  { strBackgroundAttribute = 'bg-success'; }
          if (selectedElement.hasAttribute('bg-info'))     { strBackgroundAttribute = 'bg-info'; }
          if (selectedElement.hasAttribute('bg-warning'))  { strBackgroundAttribute = 'bg-warning'; }
          if (selectedElement.hasAttribute('bg-danger'))   { strBackgroundAttribute = 'bg-danger'; }
          
          addProp('Background Color', true, '<gs-select class="target" value="' + strBackgroundAttribute + '" mini>' +
                                          '<option value="">Default</option>' +
                                          '<option value="bg-primary">Primary</option>' +
                                          '<option value="bg-success">Success</option>' +
                                          '<option value="bg-info">Info</option>' +
                                          '<option value="bg-warning">Warning</option>' +
                                          '<option value="bg-danger">Danger</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('bg-primary');
              selectedElement.removeAttribute('bg-success');
              selectedElement.removeAttribute('bg-info');
              selectedElement.removeAttribute('bg-warning');
              selectedElement.removeAttribute('bg-danger');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          addProp('Key', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('key') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'key', this.value, false);
          });
          
          addProp('No Modifier Key For Hot Key', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-modifier-key') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-modifier-key', this.value === 'true', true);
          });
          
          // TEXT CONTENT
          addProp('Text', true, '<gs-text class="target" value="' + (selectedElement.textContent || '') + '" mini></gs-text>', function () {
              selectedElement.textContent = this.value;
              
              return selectedElement;
          });
          
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          // DISABLED attribute
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
          
          // DIALOGCLOSE attribute
          addProp('Dialog Close', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('dialogclose') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'dialogclose', this.value === 'true', true);
          });
          
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))          { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop')) { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))  { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))   { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop')) { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))  { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))   { strVisibilityAttribute = 'show-on-phone'; }
          
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          // addProp('Corners', true,   '<div class="target">' +
          //                                 '<gs-grid>\n' +
          //                                 '    <gs-block>\n' +
          //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
          //                                                             selectedElement.hasAttribute('remove-top') ||
          //                                                             selectedElement.hasAttribute('remove-left') ||
          //                                                             selectedElement.hasAttribute('remove-top-left'))).toString() + 
          //                                             '" remove-right remove-bottom id="round-top-left-corner________"></gs-checkbox>' +
                                                  
          //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
          //                                                             selectedElement.hasAttribute('remove-bottom') ||
          //                                                             selectedElement.hasAttribute('remove-left') ||
          //                                                             selectedElement.hasAttribute('remove-bottom-left'))).toString() + 
          //                                             '" remove-right remove-top id="round-bottom-left-corner________"></gs-checkbox>' +
          //                                 '    </gs-block>\n' +
          //                                 '    <gs-block>\n' +
          //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
          //                                                             selectedElement.hasAttribute('remove-top') ||
          //                                                             selectedElement.hasAttribute('remove-right') ||
          //                                                             selectedElement.hasAttribute('remove-top-right'))).toString() + 
          //                                             '" remove-left remove-bottom id="round-top-right-corner________"></gs-checkbox>' +
                                                  
          //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
          //                                                             selectedElement.hasAttribute('remove-bottom') ||
          //                                                             selectedElement.hasAttribute('remove-right') ||
          //                                                             selectedElement.hasAttribute('remove-bottom-right'))).toString() + 
          //                                             '" remove-left remove-top id="round-bottom-right-corner________"></gs-checkbox>' +
          //                                 '    </gs-block>\n' +
          //                                 '</gs-grid>\n' +
          //                             '</div>', function () {
          //     var topLeft     = document.getElementById('round-top-left-corner________').value === 'true',
          //         topRight    = document.getElementById('round-top-right-corner________').value === 'true',
          //         bottomLeft  = document.getElementById('round-bottom-left-corner________').value === 'true',
          //         bottomRight = document.getElementById('round-bottom-right-corner________').value === 'true',
          //         arrStrAttr = [], i, len;
              
          //     selectedElement.removeAttribute('remove-all');
          //     selectedElement.removeAttribute('remove-top');
          //     selectedElement.removeAttribute('remove-bottom');
          //     selectedElement.removeAttribute('remove-left');
          //     selectedElement.removeAttribute('remove-right');
          //     selectedElement.removeAttribute('remove-top-left');
          //     selectedElement.removeAttribute('remove-top-right');
          //     selectedElement.removeAttribute('remove-bottom-left');
          //     selectedElement.removeAttribute('remove-bottom-right');
              
          //     if (!topLeft && !topRight && !bottomLeft && !bottomRight) {
          //         arrStrAttr.push('remove-all');
          //     } else if (!topLeft && !topRight) {
          //         arrStrAttr.push('remove-top');
          //     } else if (!bottomLeft && !bottomRight) {
          //         arrStrAttr.push('remove-bottom');
          //     } else if (!topLeft && !bottomLeft) {
          //         arrStrAttr.push('remove-left');
          //     } else if (!topRight && !bottomRight) {
          //         arrStrAttr.push('remove-right');
          //     }
              
          //     if (!topLeft && !bottomLeft && arrStrAttr[0] !== 'remove-all') {
          //         arrStrAttr.push('remove-left');
          //     } else if (!topLeft && topRight) {
          //         arrStrAttr.push('remove-top-left');
          //     } else if (!bottomLeft && bottomRight) {
          //         arrStrAttr.push('remove-bottom-left');
          //     }
              
          //     if (!topRight && !bottomRight && arrStrAttr[0] !== 'remove-all') {
          //         arrStrAttr.push('remove-right');
          //     } else if (topLeft && !topRight) {
          //         arrStrAttr.push('remove-top-right');
          //     } else if (bottomLeft && !bottomRight) {
          //         arrStrAttr.push('remove-bottom-right');
          //     }
              
          //     for (i = 0, len = arrStrAttr.length; i < len; i += 1) {
          //         selectedElement.setAttribute(arrStrAttr[i], '');
          //     }
              
          //     return selectedElement;
          // });
          
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
          
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
          
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
      };
  });
  
  
  
  
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      
      function refreshAnchor(element) {
          var strLink = element.getAttribute('href') || element.getAttribute('value');
          
          if (element.anchorElement) {
              element.removeChild(element.anchorElement);
          }
          if (strLink) {
              element.anchorElement = document.createElement('a');
              element.anchorElement.setAttribute('gs-dynamic', '');
              element.anchorElement.setAttribute('target', element.getAttribute('target') || '_blank');
              element.anchorElement.setAttribute('href', strLink);
              
              if (element.getAttribute('onclick')) {
                  element.anchorElement.setAttribute('onclick', element.getAttribute('onclick'));
              }
              
              if (element.hasAttribute('download')) {
                  element.anchorElement.setAttribute('download', element.getAttribute('download'));
              }
              
              element.appendChild(element.anchorElement);
              
          }
      }
      
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          arrAttr = element.attributes;
          i = 0;
          len = arrAttr.length;
          while (i < len) {
              jsnAttr = arrAttr[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  if (strQSValue !== '' || !element.getAttribute('value')) {
                      element.setAttribute('value', strQSValue);
                  }
              } else {
                  element.setAttribute('value', strQSValue);
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              
          }
      }
      
      //
      function elementInserted(element) {
          var strKey;
          
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
  
                  if (element.getAttribute('qs')) {
                      //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                      //if (strQSValue !== '' || !element.getAttribute('value')) {
                      //    element.setAttribute('value', strQSValue);
                      //}
                      pushReplacePopHandler(element);
                      window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                      window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                      window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                  }
                  
                  // add a tabindex to allow focus (if allowed)
                  if (!element.hasAttribute('no-focus')) {
                      if ((!element.tabIndex) || element.tabIndex === -1) {
                          element.tabIndex = 0;
                      }
                  } else {
                      element.removeAttribute('tabindex');
                  }
                  
                  element.classList.remove('down');
                  element.classList.remove('hover');
                  
                  if (!evt.touchDevice) {
                      element.addEventListener('focus', function (event) {
                          element.classList.add('focus');
                      });
                      
                      element.addEventListener('blur', function (event) {
                          element.classList.remove('focus');
                      });
                      
                      element.addEventListener(evt.mousedown, function (event) {
                          element.classList.add('down');
                      });
                      
                      element.addEventListener(evt.mouseout, function (event) {
                          element.classList.remove('down');
                          element.classList.remove('hover');
                      });
                      
                      element.addEventListener(evt.mouseover, function (event) {
                          element.classList.remove('down');
                          element.classList.add('hover');
                      });
                      
                      element.addEventListener('keydown', function (event) {
                          if (!element.hasAttribute('disabled') &&
                              (event.keyCode === 13 || event.keyCode === 32)) {
                              element.classList.add('down');
                          }
                      });
                      
                      element.addEventListener('keyup', function (event) {
                          // if we are not disabled and we pressed return (13) or space (32): trigger click
                          if (!element.hasAttribute('disabled') && element.classList.contains('down') &&
                              (event.keyCode === 13 || event.keyCode === 32)) {
                              GS.triggerEvent(element, 'click');
                          }
                      });
                  }
                  
                  refreshAnchor(element);
                  
                  element.addEventListener('click', function (event) {
                      element.classList.remove('down');
                  });
                  
                  element.addEventListener('keypress', function (event) {
                      // if we pressed return (13) or space (32): prevent default and stop propagation (to prevent scrolling of the page)
                      if (event.keyCode === 13 || event.keyCode === 32) {
                          event.preventDefault();
                          event.stopPropagation();
                      }
                  });
                  
                  strKey = element.getAttribute('key');
                  
                  if (strKey) {
                      if (GS.keyCode(strKey)) {
                          if (strKey.match(/[arfcvxzntypq]/gim)) {
                              console.warn('gs-button Warning: by setting the hot key of this button to "' + strKey + '" you may be overriding browser functionality.', element);
                          }
                          
                          window.addEventListener('keydown', function (event) {
                              if (
                                      String(event.keyCode || event.which) === GS.keyCode(strKey) &&
                                      (
                                          (
                                              element.hasAttribute('no-modifier-key') &&
                                              !event.metaKey &&
                                              !event.ctrlKey
                                          ) ||
                                          (
                                              !element.hasAttribute('no-modifier-key') &&
                                              (event.metaKey || event.ctrlKey)
                                          )
                                      )
                                  ) {
                                  event.preventDefault();
                                  event.stopPropagation();
                                  
                                  element.focus();
                                  GS.triggerEvent(element, 'click');
                              }
                          });
                          
                      } else if (strKey.length > 1) {
                          console.error('gs-button Error: \'key="' + strKey + '"\' is not a valid hot-key.', element);
                      }
                  }
              }
          }
      }
      
      xtag.register('gs-button', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      if (strAttrName === 'no-focus') {
                          if (!this.hasAttribute('no-focus') && !this.hasAttribute('tabindex')) {
                              this.setAttribute('tabindex', 0);
                          } else if (this.hasAttribute('no-focus')) {
                              this.removeAttribute('tabindex');
                          }
                      } else if (strAttrName === 'disabled') {
                          this.classList.remove('down');
                          
                      } else if (strAttrName === 'href' || strAttrName === 'target' || strAttrName === 'onclick' || strAttrName === 'download') {
                          refreshAnchor(this);
                      }
                  }
              }
          },
          events: {},
          accessors: {},
          methods: {}
      });
  });//global addProp, encodeHTML, window, GS, setOrRemoveBooleanAttribute, setOrRemoveTextAttribute, addFlexProps, registerDesignSnippet, designRegisterElement
  
  window.addEventListener('design-register-element', function () {
      'use strict';
  
      registerDesignSnippet(
          '<gs-checkbox>',
          '<gs-checkbox>',
          'gs-checkbox type="smallint" column="${1:ready_to_ship}">${2}</gs-checkbox>'
      );
      registerDesignSnippet(
          '<gs-checkbox> With Label',
          '<gs-checkbox>',
          'label for="${1:date-insert-ready_to_ship}">${2:Ready To Ship?}:</label>\n' +
                  '<gs-checkbox id="${1:date-insert-ready_to_ship}" type="smallint" column="${3:ready_to_ship}"></gs-checkbox>'
      );
  
      designRegisterElement(
          'gs-checkbox',
          '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-checkbox.html'
      );
  
      window.designElementProperty_GSCHECKBOX = function (selectedElement) {
          var strVisibilityAttribute;
  
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
  
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
  
          addProp('Triple State', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('triplestate')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'triplestate', (this.value === 'true'), true);
          });
  
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
  
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
  
          addProp('Inline', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('inline')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'inline', (this.value === 'true'), true);
          });
  
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // TABINDEX attribute
          addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
          });
  
          addProp('Type', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('type') || '') + '" mini>' +
                                          '<option value="">Detect</option>' +
                                          '<option value="smallint">Smallint</option>' +
                                          '<option value="boolean">Boolean</option>' +
                                      '</gs-select>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'type', this.value);
          });
  
          // visibility attributes
          strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp(
              'Visibility',
              true,
              '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                      '    <option value="">Visible</option>' +
                      '    <option value="hidden">Invisible</option>' +
                      '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                      '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                      '    <option value="hide-on-phone">Invisible at phone size</option>' +
                      '    <option value="show-on-desktop">Visible at desktop size</option>' +
                      '    <option value="show-on-tablet">Visible at tablet size</option>' +
                      '    <option value="show-on-phone">Visible at phone size</option>' +
                      '</gs-select>',
              function () {
                  selectedElement.removeAttribute('hidden');
                  selectedElement.removeAttribute('hide-on-desktop');
                  selectedElement.removeAttribute('hide-on-tablet');
                  selectedElement.removeAttribute('hide-on-phone');
                  selectedElement.removeAttribute('show-on-desktop');
                  selectedElement.removeAttribute('show-on-tablet');
                  selectedElement.removeAttribute('show-on-phone');
  
                  if (this.value) {
                      selectedElement.setAttribute(this.value, '');
                  }
  
                  return selectedElement;
              }
          );
  
          // DISABLED attribute
          addProp(
              'Disabled',
              true,
              '<gs-checkbox class="target" value="' + (
                  selectedElement.hasAttribute('disabled') || ''
              ) +
                      '" mini></gs-checkbox>',
              function () {
                  return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
              }
          );
  
          // READONLY attribute
          addProp(
              'Readonly',
              true,
              '<gs-checkbox class="target" value="' + (
                  selectedElement.hasAttribute('readonly') || ''
              ) +
                      '" mini></gs-checkbox>',
              function () {
                  return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
              }
          );
  
          // addProp('Corners', true, '<div class="target">' +
          //             '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
          //                                         selectedElement.hasAttribute('remove-top') ||
          //                                         selectedElement.hasAttribute('remove-left') ||
          //                                         selectedElement.hasAttribute('remove-top-left'))).toString() + 
          //                     '" remove-right remove-bottom id="round-top-left-corner________" inline></gs-checkbox>' +
  
          //             '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
          //                                         selectedElement.hasAttribute('remove-top') ||
          //                                         selectedElement.hasAttribute('remove-right') ||
          //                                         selectedElement.hasAttribute('remove-top-right'))).toString() + 
          //                     '" remove-left remove-bottom id="round-top-right-corner________" inline></gs-checkbox><br />' +
  
          //             '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
          //                                         selectedElement.hasAttribute('remove-bottom') ||
          //                                         selectedElement.hasAttribute('remove-left') ||
          //                                         selectedElement.hasAttribute('remove-bottom-left'))).toString() + 
          //                     '" remove-right remove-top id="round-bottom-left-corner________" inline></gs-checkbox>' +
  
          //             '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
          //                                         selectedElement.hasAttribute('remove-bottom') ||
          //                                         selectedElement.hasAttribute('remove-right') ||
          //                                         selectedElement.hasAttribute('remove-bottom-right'))).toString() + 
          //                     '" remove-left remove-top id="round-bottom-right-corner________" inline></gs-checkbox>' +
          //         '</div>', function () {
          //     var topLeft = document.getElementById('round-top-left-corner________').value === 'true';
          //     var topRight = document.getElementById('round-top-right-corner________').value === 'true';
          //     var bottomLeft = document.getElementById('round-bottom-left-corner________').value === 'true';
          //     var bottomRight = document.getElementById('round-bottom-right-corner________').value === 'true';
          //     var arrStrAttr = [];
          //     var i;
          //     var len;
  
          //     selectedElement.removeAttribute('remove-all');
          //     selectedElement.removeAttribute('remove-top');
          //     selectedElement.removeAttribute('remove-bottom');
          //     selectedElement.removeAttribute('remove-left');
          //     selectedElement.removeAttribute('remove-right');
          //     selectedElement.removeAttribute('remove-top-left');
          //     selectedElement.removeAttribute('remove-top-right');
          //     selectedElement.removeAttribute('remove-bottom-left');
          //     selectedElement.removeAttribute('remove-bottom-right');
  
          //     if (!topLeft && !topRight && !bottomLeft && !bottomRight) {
          //         arrStrAttr.push('remove-all');
          //     } else if (!topLeft && !topRight) {
          //         arrStrAttr.push('remove-top');
          //     } else if (!bottomLeft && !bottomRight) {
          //         arrStrAttr.push('remove-bottom');
          //     } else if (!topLeft && !bottomLeft) {
          //         arrStrAttr.push('remove-left');
          //     } else if (!topRight && !bottomRight) {
          //         arrStrAttr.push('remove-right');
          //     }
  
          //     if (!topLeft && !bottomLeft && arrStrAttr[0] !== 'remove-all') {
          //         arrStrAttr.push('remove-left');
          //     } else if (!topLeft && topRight) {
          //         arrStrAttr.push('remove-top-left');
          //     } else if (!bottomLeft && bottomRight) {
          //         arrStrAttr.push('remove-bottom-left');
          //     }
  
          //     if (!topRight && !bottomRight && arrStrAttr[0] !== 'remove-all') {
          //         arrStrAttr.push('remove-right');
          //     } else if (topLeft && !topRight) {
          //         arrStrAttr.push('remove-top-right');
          //     } else if (bottomLeft && !bottomRight) {
          //         arrStrAttr.push('remove-bottom-right');
          //     }
  
          //     i = 0;
          //     len = arrStrAttr.length;
          //     while (i < len) {
          //         selectedElement.setAttribute(arrStrAttr[i], '');
          //         i += 1;
          //     }
  
          //     return selectedElement;
          // });
  
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
  
          //// SUSPEND-CREATED attribute
          //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
          //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          //});
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          i = 0;
          len = element.attributes.length;
          arrAttr = element.attributes;
          while (i < len) {
              jsnAttr = element.attributes[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
  
          } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  element.internal.bolQSFirstRun = true;
                  if (strQSValue !== '' || !element.getAttribute('value')) {
                      element.setAttribute('value', strQSValue);
                  }
              } else {
                  element.value = strQSValue;
              }
          }
      }
  
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
  
          }
      }
  
      //
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
  
                  // save default attribute settings so that the qs code can access those values
                  saveDefaultAttributes(element);
  
                  // if this checkbox has the "qs" attribute: fill from querystring and bind to querystring
                  if (element.hasAttribute('qs')) {
                      pushReplacePopHandler(element);
  
                      window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                      window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                      window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                  }
  
                  element.addEventListener('focus', function (event) {
                      element.classList.add('focus');
                  });
  
                  element.addEventListener('blur', function (event) {
                      element.classList.remove('focus');
                  });
  
                  element.addEventListener(evt.mouseout, function (event) {
                      element.classList.remove('hover');
                  });
  
                  element.addEventListener(evt.mouseover, function (event) {
                      element.classList.add('hover');
                  });
  
                  // default value to false
                  if (element.getAttribute('type') === 'smallint') {
                      element.value = element.getAttribute('value') || 0;
                  } else {
                      element.value = element.getAttribute('value') || false;
                  }
  
                  // add a tabindex to allow focus
                  if (!element.hasAttribute('tabindex')) {
                      element.tabIndex = 0;
                  }
              }
          }
      }
  
      xtag.register('gs-checkbox', {
          lifecycle: {
              created: function () {
                  var element = this;
                  // if the value was set before the "created" lifecycle code runs: set attribute
                  //      (discovered when trying to set a value of a date control in the after_open of a dialog)
                  //      ("delete" keyword added because of firefox)
                  if (
                      !element.getAttribute('value') &&
                      element.value !== null &&
                      element.value !== undefined &&
                      (
                          typeof element.value === 'boolean' ||
                          element.value === '-1' ||
                          element.value === '0' ||
                          element.value === 'true' ||
                          element.value === 'false' ||
                          element.value === 'null' ||
                          element.value === 'n'
                      )
                  ) {
                      element.setAttribute('value', element.value);
                      delete element.value;
                  }
  
                  elementCreated(element);
              },
  
              inserted: function () {
                  elementInserted(this);
              },
  
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
  
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
  
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      // attribute code
                  }
              }
          },
          events: {
              'mousedown': function () {
                  if (!this.hasAttribute('suspend-created') &&
                      !this.hasAttribute('suspend-inserted') &&
                      !this.hasAttribute('readonly')) {
                      this.classList.add('down');
                  }
              },
              'mouseout': function () {
                  if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      if (this.classList.contains('down')) {
                          this.classList.remove('down');
                      }
                  }
              },
              'click': function (event) {
                  var bolTripleState;
                  var strValue;
                  var strType;
  
                  if (!this.hasAttribute('suspend-created') &&
                      !this.hasAttribute('suspend-inserted') &&
                      !this.hasAttribute('readonly')) {
                      bolTripleState = this.hasAttribute('triplestate');
                      strValue = this.getAttribute('value').trim().toLowerCase();
  
                      // get type from type attribute
                      strType = this.getAttribute('type');
  
                      // if type is not valid, get type from current value
                      if (strType !== 'smallint' && strType !== 'boolean') {
                          if (strValue === 'false' || strValue === 'true' || strValue === 'null') {
                              strType = 'boolean';
                          } else if (strValue === '0' || strValue === '-1' || strValue === 'n') {
                              strType = 'smallint';
                      // else default to boolean (backwards compatibility)
                          } else {
                              strType = 'boolean';
                          }
                      }
  
                      // resolve current value to the correct type
                      if (strType === 'smallint') {
                          if (strValue === '0' || strValue === 'false') {
                              strValue = '0';
                          } else if (strValue === '-1' || strValue === 'true') {
                              strValue = '-1';
                          } else if (strValue === 'n' || strValue === 'null') {
                              strValue = 'n';
                          } else {
                              strValue = '0';
                          }
                      } else if (strType === 'boolean') {
                          if (strValue === '0' || strValue === 'false') {
                              strValue = 'false';
                          } else if (strValue === '-1' || strValue === 'true') {
                              strValue = 'true';
                          } else if (strValue === 'n' || strValue === 'null') {
                              strValue = 'null';
                          } else {
                              strValue = 'false';
                          }
                      }
  
                      // get new value based on current value
                      if (strType === 'smallint') {
                          if (strValue === '0') {
                              strValue = '-1';
                          } else if (strValue === '-1') {
                              if (bolTripleState) {
                                  strValue = 'n';
                              } else {
                                  strValue = '0';
                              }
                          } else if (strValue === 'n') {
                              strValue = '0';
                          }
                      } else if (strType === 'boolean') {
                          if (strValue === 'false') {
                              strValue = 'true';
                          } else if (strValue === 'true') {
                              if (bolTripleState) {
                                  strValue = 'null';
                              } else {
                                  strValue = 'false';
                              }
                          } else if (strValue === 'null') {
                              strValue = 'false';
                          }
                      }
  
                      // set new value
                      this.setAttribute('value', strValue);
  
                      //// here be dragons
                      //if (strValue === 'false') {
                      //    this.setAttribute('value', 'true');
                      //} else if (strValue === 'true') {
                      //    if (bolTripleState) {
                      //        this.setAttribute('value', 'null');
                      //    } else {
                      //        this.setAttribute('value', 'false');
                      //    }
                      //} else if (strValue === 'null') {
                      //    this.setAttribute('value', 'false');
                      //} else if (strValue === '0') {
                      //    this.setAttribute('value', '-1');
                      //} else if (strValue === '-1') {
                      //    if (bolTripleState) {
                      //        this.setAttribute('value', 'n');
                      //    } else {
                      //        this.setAttribute('value', '0');
                      //    }
                      //} else if (strValue === 'n') {
                      //    this.setAttribute('value', '0');
                      //} else if (strValue === 0) {
                      //    this.setAttribute('value', -1);
                      //} else if (strValue === -1) {
                      //    if (bolTripleState) {
                      //        this.setAttribute('value', 'n');
                      //    } else {
                      //        this.setAttribute('value', 0);
                      //    }
                      //} else if (strValue === 'n') {
                      //    this.setAttribute('value', 0);
                      //} else if (strValue === false) {
                      //    this.setAttribute('value', true);
                      //} else if (strValue === true) {
                      //    if (bolTripleState) {
                      //        this.setAttribute('value', null);
                      //    } else {
                      //        this.setAttribute('value', false);
                      //    }
                      //} else if (strValue === null) {
                      //    //this.setAttribute('value', false);
                      //    if (this.getAttribute('type') === 'smallint') {
                      //        this.setAttribute('value', '-1');
                      //    } else {
                      //        this.setAttribute('value', 'true');
                      //    }
                      //} else {
                      //    if (this.getAttribute('type') === 'smallint') {
                      //        this.setAttribute('value', '-1');
                      //    } else {
                      //        this.setAttribute('value', 'true');
                      //    }
                      //}
  
                      this.classList.remove('down');
                      xtag.fireEvent(this, 'change', {bubbles: true, cancelable: true});
                  }
              },
              'keydown': function (event) {
                  if (!this.hasAttribute('suspend-created') &&
                      !this.hasAttribute('suspend-inserted') &&
                      !this.hasAttribute('readonly')) {
                      // if we pressed return (13) or space (32)
                      if (event.keyCode === 13 || event.keyCode === 32) {
                          // prevent default and stop propagation (to prevent scrolling of the page)
                          event.preventDefault();
                          event.stopPropagation();
                      }
  
                      // if we are not disabled and we pressed return (13) or space (32): trigger click
                      if (!this.attributes.disabled && (event.keyCode === 13 || event.keyCode === 32)) {
                          xtag.fireEvent(this, 'click', { bubbles: true, cancelable: true });
                      }
                  }
              }
          },
          accessors: {
              value: {
                  // get value straight from the attribute
                  get: function () {
                      return this.getAttribute('value');
                  },
  
                  // set the value attribute
                  set: function (newValue) {
                      this.setAttribute('value', newValue);
                  }
              },
              textValue: {
                  // return a text representation of the value
                  get: function () {
                      var currentValue = this.getAttribute('value');
  
                      // if value is true: return YES
                      if (currentValue === '-1' || currentValue === 'true') {
                          return 'YES';
                      }
  
                      // if value is false: return NO
                      if (currentValue === '0' || currentValue === 'false') {
                          return 'NO';
                      }
  
                      // if value is null: return empty string
                      return '';
                  },
  
                  // set the value attribute
                  set: function (newValue) {
                      if (newValue === 'YES') {
                          newValue = 'true';
                      }
                      if (newValue === 'NO') {
                          newValue = 'false';
                      }
                      this.setAttribute('value', newValue);
                  }
              }
          },
          methods: {
  
          }
      });
  });
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('<gs-combo>', '<gs-combo>', 'gs-combo src="${1:test.tpeople}" column="${2}"></gs-combo>');
      
      designRegisterElement('gs-combo', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-combo.html');
      
      window.designElementProperty_GSCOMBO = function (selectedElement) {
          addProp('Source', true,
                  '<gs-memo class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('src') ||
                                                                          selectedElement.getAttribute('source') || '')) + '" mini></gs-memo>',
                  function () {
              return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
          });
          
          addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                  function () {
              return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
          });
          
          addProp('Initialize Source', true,
                  '<gs-memo class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('initialize') || '')) + '" mini></gs-memo>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'initialize', encodeURIComponent(this.value));
          });
          
          addProp('Hide Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('hide') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'hide', this.value);
          });
          
          addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('where') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'where', this.value);
          });
          
          addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
          });
          
          addProp('Limit', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
          });
          
          addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
          });
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
          
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
          
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
          
          addProp('Allow Empty', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('allow-empty')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'allow-empty', (this.value === 'true'), true);
          });
          
          addProp('Limit&nbsp;To&nbsp;List', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('limit-to-list')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'limit-to-list', (this.value === 'true'), true);
          });
          
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
          
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          // TABINDEX attribute
          addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
          });
          
          addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
          });
          
          addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
          });
          
          addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
          });
          
          addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
          });
          
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))          { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop')) { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))  { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))   { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop')) { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))  { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))   { strVisibilityAttribute = 'show-on-phone'; }
          
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          // DISABLED attribute
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
          
          // READONLY attribute
          addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
          });
          
          addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
              this.removeAttribute('refresh-on-querystring-change');
              return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
          });
          
          addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
              this.removeAttribute('refresh-on-querystring-values');
              return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
          });
          
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
          
          //// SUSPEND-CREATED attribute
          //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
          //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          //});
          
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      // scroll the dropdown to the selected record
      function scrollToSelectedRecord(element) {
          var positioningContainer, scrollingContainer, arrTrs, i, len, intScrollTop, bolFoundSelected = false;
          
          if (element.currentDropDownContainer) {
              positioningContainer = xtag.queryChildren(element.currentDropDownContainer, '.gs-combo-positioning-container')[0];
              scrollingContainer = xtag.queryChildren(positioningContainer, '.gs-combo-scroll-container')[0];
              arrTrs = xtag.query(element.dropDownTable, 'tr');
              
              for (i = 0, intScrollTop = 0, len = arrTrs.length; i < len; i += 1) {
                  if (arrTrs[i].hasAttribute('selected')) {
                      intScrollTop += arrTrs[i].offsetHeight / 2;
                      
                      bolFoundSelected = true;
                      
                      break;
                  } else {
                      intScrollTop += arrTrs[i].offsetHeight;
                  }
              }
              
              if (bolFoundSelected) {
                  intScrollTop = intScrollTop - scrollingContainer.offsetHeight / 2;
              } else {
                  intScrollTop = 0;
              }
              
              scrollingContainer.scrollTop = intScrollTop;
          }
      }
      
      // removes selected class from old selected records
      function clearSelection(element) {
          var i, len, arrSelectedTrs;
          
          // clear previous selection
          arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr[selected]');
          
          for (i = 0, len = arrSelectedTrs.length; i < len; i += 1) {
              arrSelectedTrs[i].removeAttribute('selected');
          }
      }
      
      // clears old selection and adds selected class to record
      function highlightRecord(element, record) {
          // clear previous selection
          clearSelection(element);
          
          // select/highlight the record that was provided
          record.setAttribute('selected', '');
      }
      
      // loops through the records and finds a record using the parameter (if bolPartialMatchAllowed === true then only search the first td text)
      function findRecordFromString(element, strSearchString, bolPartialMatchAllowed) {
          var i, len, matchedRecord, arrTrs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr');
          
          // if bolPartialMatchAllowed is true: only search the first td text (case insensitive)
          if (bolPartialMatchAllowed === true) {
              strSearchString = strSearchString.toLowerCase();
              
              for (i = 0, len = arrTrs.length; i < len; i += 1) {
                  if (xtag.queryChildren(arrTrs[i], 'td')[0].textContent.toLowerCase().indexOf(strSearchString) === 0) {
                      matchedRecord = arrTrs[i];
                      
                      break;
                  }
              }
              
          // else: search exact text and search both the value attribute (if present) and the first td text
          } else {
              for (i = 0, len = arrTrs.length; i < len; i += 1) {
                  if (arrTrs[i].getAttribute('value') === strSearchString ||
                      xtag.queryChildren(arrTrs[i], 'td')[0].textContent === strSearchString) {
                      matchedRecord = arrTrs[i];
                      
                      break;
                  }
              }
          }
          
          return matchedRecord;
      }
      
      // highlights record, sets value of the combobox using record
      function selectRecord(element, record, bolChange) {
          // add the yellow selection to the record
          highlightRecord(element, record);
          
          handleChange(element, bolChange);
      }
      
      // highlights record, sets value of the combobox using value attribute
      //      if bolChange === true then:
      //          change event and check for limit to list
      function selectRecordFromValue(element, strValue, bolChange) {
          var record = findRecordFromString(element, strValue, false);
          
          // if a record was found: select it
          if (record) {
              selectRecord(element, record, bolChange);
              
          // else if limit to list (and no record was found):
          } else if (element.hasAttribute('limit-to-list') && bolChange) {
              if (strValue === '' && element.hasAttribute('allow-empty')) {
                  handleChange(element, bolChange);
                  
              } else {
                  alert('The text you entered is not in the list');
                  openDropDown(element);
                  GS.setInputSelection(element.control, 0, strValue.length);
              }
              
          // else (not limit to list and no record found):
          } else {
              clearSelection(element);
              
              if (!element.hasAttribute('limit-to-list')) {
                  element.control.value = strValue;
                  element.innerValue = strValue;
              }
              
              handleChange(element, bolChange);
          }
      }
      
      function handleChange(element, bolChange) {
          var arrSelectedTrs, strHiddenValue = '', strTextValue = '', beforechangeevent, oldRecord,
              oldInnerValue = element.innerValue, oldControlValue = element.control.value;
          
          if (element.dropDownTable) {
              arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr[selected]');
              
              // if there is a selected record
              if (arrSelectedTrs.length > 0) {
                  // gather values from the selected record
                  strHiddenValue = arrSelectedTrs[0].getAttribute('value');
                  var firstTd = xtag.queryChildren(arrSelectedTrs[0], 'td')[0],
                      lastChild = firstTd.lastElementChild;
                  if (lastChild && lastChild.tagName.substring(0, 3) === 'GS-') {
                      strTextValue = lastChild.textValue || lastChild.value || lastChild.textContent;
                  } else {
                      strTextValue = firstTd.textContent;
                  }
                  
              } else {
                  strTextValue = element.control.value;
              }
              
          } else {
              strTextValue = element.control.value;
          }
          
          // set innervalue and control value using the values we gather from the record
          element.innerValue = strHiddenValue || strTextValue;
          element.control.value = strTextValue || strHiddenValue;
          
          if (bolChange) {
              if (document.createEvent) {
                  beforechangeevent = document.createEvent('HTMLEvents');
                  beforechangeevent.initEvent('beforechange', true, true);
              } else {
                  beforechangeevent = document.createEventObject();
                  beforechangeevent.eventType = 'beforechange';
              }
              
              beforechangeevent.eventName = 'beforechange';
              
              if (document.createEvent) {
                  element.dispatchEvent(beforechangeevent);
              } else {
                  element.fireEvent("on" + beforechangeevent.eventType, beforechangeevent);
              }
              
              // xtag.fireEvent(element, 'beforechange', { bubbles: true, cancelable: true });
              
              //console.log(beforechangeevent.defaultPrevented);
              if (beforechangeevent.defaultPrevented !== true) {
                  xtag.fireEvent(element, 'change', { bubbles: true, cancelable: true });
                  
              } else {
                  element.innerValue = oldInnerValue;
                  element.control.value = oldControlValue;
                  
                  oldRecord = findRecordFromString(element, oldInnerValue, false);
                  
                  if (oldRecord) {
                      highlightRecord(element, oldRecord);
                  } else {
                      clearSelection(element);
                  }
              }
              
              element.ignoreChange = false;
          }
      }
      
      // open dropdown
      function openDropDown(element) {
          // if we are not already dropping down
          if (!element.droppingDown) {
              // if there is a source attribute on the combobox: refresh data
              if (element.getAttribute('src') || element.getAttribute('source')) {
                  getData(element, false, true, function () {
                      dropDown(element);
                  });
              } else {
                  dropDown(element);
              }
              element.droppingDown = true;
          }
      }
      
      function dropDown(element) {
          var dropDownContainer = document.createElement('div'), overlay, positioningContainer, scrollContainer, observer;
          
          // focus control
          element.control.focus();
          
          // create the dropdown element (and its children)
          dropDownContainer.classList.add('gs-combo-dropdown-container');
          dropDownContainer.setAttribute('gs-dynamic', '');
          dropDownContainer.innerHTML =   '<div class="gs-combo-positioning-container" gs-dynamic>' +
                                          '    <div class="gs-combo-scroll-container" gs-dynamic></div>' +
                                          '</div>';
          
          // append dropdown to the body
          document.body.appendChild(dropDownContainer);
          
          // set variables for the various elements that we will need for calculation
          positioningContainer = xtag.queryChildren(dropDownContainer, '.gs-combo-positioning-container')[0];
          scrollContainer =      xtag.queryChildren(positioningContainer, '.gs-combo-scroll-container')[0];
          
          element.currentDropDownContainer = dropDownContainer;
          
          //console.log(element.currentDropDownContainer);
          //console.log(element.dropDownTable);
          
          // fill dropdown with content
          if (element.dropDownTable) {
              //element.dropDownTable = GS.cloneElement(element.staticDropDownTable);
              scrollContainer.appendChild(element.dropDownTable);
              
          //} else if (element.tableTemplate) {
          //    scrollContainer.innerHTML = element.tableTemplate;
          //    
          } else {
              scrollContainer.innerHTML = element.initalHTML;
          }
          
          // create an observer instance
          observer = new MutationObserver(function(mutations) {
              dropDownSize(element);
          });
          
          // pass in the element node, as well as the observer options
          observer.observe(scrollContainer, {childList: true, subtree: true});
          
          //console.log(scrollContainer);
          
          dropDownSize(element);
      }
      
      function dropDownSize(element) {
          var dropDownContainer    = element.currentDropDownContainer,
              positioningContainer = xtag.queryChildren(dropDownContainer, '.gs-combo-positioning-container')[0],
              scrollContainer      = xtag.queryChildren(positioningContainer, '.gs-combo-scroll-container')[0],
              overlay, jsnComboOffset, intComboHeight, intComboWidth, intViewportWidth, intViewportHeight,
              intFromControlToBottomHeight, intFromControlToTopHeight, intContentHeight, intNewWidth,
              strWidth = '', strHeight = '', strLeft = '', strTop = '', strBottom = '';
          
          // set variables needed for position calculation
          intComboHeight               = element.offsetHeight;
          intComboWidth                = element.offsetWidth;
          intViewportHeight            = window.innerHeight;
          intViewportWidth             = window.innerWidth;
          jsnComboOffset               = GS.getElementOffset(element);
          intContentHeight             = scrollContainer.scrollHeight;
          intFromControlToBottomHeight = intViewportHeight - (jsnComboOffset.top + intComboHeight);
          intFromControlToTopHeight    = jsnComboOffset.top;
          
          
          //console.log(intFromControlToBottomHeight, intFromControlToTopHeight);
          
          
          // set position, height and (top or bottom) variables
          // if desktop:
          if (!evt.touchDevice) {
              // if viewport is too small go full page
              if (window.innerHeight < 500 &&
                  intContentHeight > intFromControlToTopHeight &&
                  intContentHeight > intFromControlToBottomHeight) {
                  strHeight = window.innerHeight + 'px';
                  strTop =  '0px';
                  
              // try 200px
              } else if (intContentHeight < 500) {
                  strHeight = '200px';
                  
                  if (intFromControlToBottomHeight > intFromControlToTopHeight || intFromControlToBottomHeight > 200) {
                      strTop = (intFromControlToTopHeight + intComboHeight) + 'px';
                  } else {
                      strBottom = (intFromControlToBottomHeight + intComboHeight) + 'px';
                  }
                  
              // try height from control to bottom of viewport
              } else if (intFromControlToBottomHeight >= intFromControlToTopHeight) {
                  strHeight = intFromControlToBottomHeight + 'px';
                  strTop = (intFromControlToTopHeight + intComboHeight) + 'px';
                  
              // else height from control to top of viewport
              } else {// if (intFromControlToTopHeight >= intFromControlToBottomHeight) {
                  strHeight = intFromControlToTopHeight + 'px';
                  strBottom = (intFromControlToBottomHeight + intComboHeight) + 'px';
              }
              
          // else mobile:
          } else {
              // try 200px bottom
              if (intFromControlToBottomHeight > 200 && intContentHeight < 500) {
                  strHeight = intFromControlToBottomHeight + 'px';
                  strTop = (intFromControlToTopHeight + intComboHeight) + 'px';
                  
              // try 200px top
              } else if (intFromControlToTopHeight > 200 && intContentHeight < 500) {
                  strHeight = intFromControlToTopHeight + 'px';
                  strBottom = (intFromControlToBottomHeight + intComboHeight) + 'px';
              
              // else full page
              } else {
                  strHeight = window.innerHeight + 'px';
                  strTop =  '0px';
              }
          }
          
          
          // set width and left variables
          // try regular
          if (scrollContainer.scrollWidth <= scrollContainer.offsetWidth) {
              if (intComboWidth < 150) {
                  intNewWidth = (window.innerWidth - jsnComboOffset.left) - 20;
                  
                  if (intNewWidth < 300) {
                      strWidth = intNewWidth + 'px';
                  } else {
                      strWidth = '300px';
                  }
                  
              } else {
                  strWidth = intComboWidth + 'px';
              }
              strLeft = jsnComboOffset.left + 'px';
              
          // else full width
          } else {
              strWidth = '100%';
              strLeft = '0px';
          }
          
          
          // set position and size using variables
          positioningContainer.style.left   = strLeft;
          positioningContainer.style.top    = strTop;
          positioningContainer.style.bottom = strBottom;
          positioningContainer.style.width  = strWidth;
          positioningContainer.style.height = strHeight;
          
          if (strTop) {
              dropDownContainer.classList.add('below');
          } else {
              dropDownContainer.classList.add('above');
          }
          
          
          // if the table is wider than the drop down: reflow
          if (scrollContainer.clientWidth < scrollContainer.scrollWidth &&
              xtag.query(scrollContainer, 'tbody tr:first-child td, tbody tr:first-child th').length > 1) {
              scrollContainer.classList.add('reflow');
          }
          
          
          // if the table is shorter than the drop down: resize the dropdown to be as short as the table
          if (intContentHeight < scrollContainer.clientHeight) {
              positioningContainer.style.height = intContentHeight + 'px';
          }
          
          
          // make combobox float over overlay so that you can focus into the input box
          element.classList.add('open');
          
          //// if there is already a placeholder: delete the old one
          //if (element.placeholderElement) {
          //    element.parentNode.removeChild(element.placeholderElement);
          //    element.placeholderElement = undefined;
          //    
          //    element.style.left   = element.oldLeft;
          //    element.style.right  = element.oldRight;
          //    element.style.top    = element.oldTop;
          //    element.style.bottom = element.oldBottom;
          //    element.style.width  = element.oldWidth;
          //    element.style.height = element.oldHeight;
          //}
          //
          //// save old styles
          //element.oldLeft   = element.style.left;
          //element.oldRight  = element.style.right;
          //element.oldTop    = element.style.top;
          //element.oldBottom = element.style.bottom;
          //element.oldWidth  = element.style.width;
          //element.oldHeight = element.style.height;
          //
          //element.style.left = '';
          //element.style.right = '';
          //element.style.top = '';
          //element.style.bottom = '';
          //element.style.width = '';
          //element.style.height = '';
          //
          //element.style.left   = jsnComboOffset.left + 'px';
          //element.style.top    = jsnComboOffset.top + 'px';
          //element.style.width  = intComboWidth + 'px';
          //element.style.height = intComboHeight + 'px';
          //
          //// put a placeholder element so that elements dont jump under where the combobox was
          //element.placeholderElement = document.createElement('div');
          //
          //element.placeholderElement.setAttribute('gs-dynamic', '');
          //element.placeholderElement.style.left   = element.oldLeft;
          //element.placeholderElement.style.right  = element.oldRight;
          //element.placeholderElement.style.top    = element.oldTop;
          //element.placeholderElement.style.bottom = element.oldBottom;
          //element.placeholderElement.style.width  = element.oldWidth;      // this will set the width of the placholder if
          //                                                                 //     the combobox had a set width
          //element.placeholderElement.style.height = intComboHeight + 'px'; // set the height of the placeholder to the
          //                                                                 //     actual height of the combobox
          //
          //element.parentNode.insertBefore(element.placeholderElement, element);
          
          // change element open state variable
          element.open = true;
          
          
          // bind drop down
          bindDropDown(element);
          
          
          // scroll to the selected record (if any)
          scrollToSelectedRecord(element);
      }
      
      // bind dropdown events
      function bindDropDown(element) {
          var selectableTrs, closeDropDownHandler, selectRecordHandler, i, len,
              unbindSelectRecordHandler, unbindDropDownEvents, wheelHandler;
          
          wheelHandler = function (event) {
              var tableElement = GS.findParentElement(event.target, '.gs-combo-dropdown-container');
              
              if (tableElement !== element.currentDropDownContainer) {
                  closeDropDownHandler();
              }
          };
          
          // unbind function
          unbindDropDownEvents = function () {
              var i, len;
              
              for (i = 0, len = selectableTrs.length; i < len; i += 1) {
                  selectableTrs[i].removeEventListener('click', selectRecordHandler);
              }
              
              window.removeEventListener('resize', closeDropDownHandler);
              window.removeEventListener('orientationchange', closeDropDownHandler);
              window.removeEventListener('mousewheel', wheelHandler);
              document.body.removeEventListener('click', closeDropDownHandler);
          };
          
          // handle record click
          selectableTrs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr');
          
          selectRecordHandler = function (event) {
              selectRecord(element, GS.findParentTag(event.target, 'tr'), true);
              closeDropDownHandler();
          };
          
          for (i = 0, len = selectableTrs.length; i < len; i += 1) {
              selectableTrs[i].addEventListener('click', selectRecordHandler);
          }
          
          // handle dropdown close
          closeDropDownHandler = function (event) {
              closeDropDown(element);
              unbindDropDownEvents();
          };
          
          window.addEventListener('resize', closeDropDownHandler);
          window.addEventListener('orientationchange', closeDropDownHandler);
          window.addEventListener('mousewheel', wheelHandler);
          document.body.addEventListener('click', closeDropDownHandler);
      }
      
      // remove dropdown from screen
      function closeDropDown(element) {
          // if there is a dropdown to remove: remove the dropdown
          if (element.currentDropDownContainer) {
              document.body.removeChild(element.currentDropDownContainer);
              element.currentDropDownContainer = undefined;
              
              element.classList.remove('open');
              element.open = false;
              element.droppingDown = false;
              
              //element.parentNode.removeChild(element.placeholderElement);
              //element.placeholderElement = undefined;
              //
              //element.style.left   = element.oldLeft;
              //element.style.right  = element.oldRight;
              //element.style.top    = element.oldTop;
              //element.style.bottom = element.oldBottom;
              //element.style.width  = element.oldWidth;
              //element.style.height = element.oldHeight;
          }
      }
      
      // handle behaviours on keydown
      function handleKeyDown(element, event) {
          var intKeyCode = event.keyCode || event.which, selectedTr, trs, i, len, selectedRecordIndex, firstTd, lastChild, strTextValue;
          
          if (!element.hasAttribute('disabled') && !element.hasAttribute('readonly')) {
              if ((intKeyCode === 40 || intKeyCode === 38) && !event.shiftKey && !event.metaKey && !event.ctrlKey && !element.error) {
                  if (!element.open) {
                      openDropDown(element);
                      
                  } else {
                      trs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr');
                      
                      for (i = 0, len = trs.length; i < len; i += 1) {
                          if (trs[i].hasAttribute('selected')) {
                              selectedRecordIndex = i;
                              selectedTr = trs[i];
                              trs[i].removeAttribute('selected');
                              
                              break;
                          }
                      }
                      
                      if (intKeyCode === 40) {// next record or circle to first record or start selection at the first
                          if (!selectedTr || selectedRecordIndex === trs.length - 1) {
                              highlightRecord(element, trs[0]);
                              selectedTr = trs[0];
                              
                          } else {
                              highlightRecord(element, trs[selectedRecordIndex + 1]);
                              selectedTr = trs[selectedRecordIndex + 1];
                          }
                          
                      } else if (intKeyCode === 38) {// prev record or circle to last record or start selection at the last
                          if (!selectedTr || selectedRecordIndex === 0) {
                              highlightRecord(element, trs[trs.length - 1]);
                              selectedTr = trs[trs.length - 1];
                              
                          } else {
                              highlightRecord(element, trs[selectedRecordIndex - 1]);
                              selectedTr = trs[selectedRecordIndex - 1];
                          }
                      }
                      scrollToSelectedRecord(element);
                  }
                  if (selectedTr) {
                      element.control.value = xtag.queryChildren(selectedTr, 'td')[0].textContent;
                  }
                  
                  GS.setInputSelection(element.control, 0, element.control.value.length);
                  
                  event.preventDefault();
                  event.stopPropagation();
                  
              } else if ((intKeyCode === 39) && !event.shiftKey && !event.metaKey && !event.ctrlKey && !element.error) {
                  selectedTr = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr[selected]')[0];
                  
                  if (selectedTr) {
                      firstTd = xtag.queryChildren(selectedTr, 'td')[0];
                      lastChild = firstTd.lastElementChild;
                      
                      if (lastChild && lastChild.tagName.substring(0, 3) === 'GS-') {
                          strTextValue = lastChild.textValue || lastChild.value || lastChild.textContent;
                      } else {
                          strTextValue = firstTd.textContent;
                      }
                      
                      //console.log(element.innerValue, element.control.value, selectedTr.getAttribute('value'), strTextValue);
                      
                      selectRecord(element, selectedTr,
                                  element.innerValue !== (selectedTr.getAttribute('value') || strTextValue));
                  }
                  
                  event.stopPropagation();
                  
              } else if (event.keyCode === 13 || event.keyCode === 9) {
                  if (element.dropDownTable && xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr[selected]').length > 0) {
                      selectRecordFromValue(element, element.control.value, true);
                      element.ignoreChange = true;
                  }
                  
                  closeDropDown(element);
                  
              } else if (!event.metaKey &&       // not command key
                         !event.ctrlKey &&       // not control key
                         event.keyCode !== 37 && // not arrow keys
                         event.keyCode !== 38 &&
                         event.keyCode !== 39 &&
                         event.keyCode !== 40 &&
                         event.keyCode !== 46 && // not forward delete key
                         event.keyCode !== 8) {  // not delete key
                  element.attemptSearchOnNextKeyup = true;
              }
          } else {
              if (event.keyCode !== 9) {
                  event.preventDefault();
                  event.stopPropagation();
              }
          }
      }
      
      // search on keyup
      //      the reason we are using keyup for search is because on keydown the letter has not been typed in yet and
      //      it would be harder if we tried to use the keycode to get the letter that was typed. so on keydown
      //      (which is where we can tell if CMD or CTRL and other keys that we dont want to search on and pressed)
      //      if we didn't type something that we dont want to search on but we typed somthing else: set this.attemptSearchOnNextKeyup
      //      to true and on keyup we read that and if it is set to true then we do a search and set it back to false
      function handleKeyUp(element, event) {
          var intKeyCode = event.keyCode || event.which, strSearch = element.control.value, matchRecord;
          
          // if element.attemptSearchOnNextKeyup is true and
          //      there is a search string and
          //      the user has their text selection at the end of the of the input
          if (element.attemptSearchOnNextKeyup === true &&
              strSearch &&
              GS.getInputSelection(element.control).start === strSearch.length) {
              
              // ######### FOR CROSS
              // you need to comment the code inside this block.
              // you need an if statment for >2000 records.
              // you need to use the currently commented code for <=2000 records.
              // you need new code for >2000.
              // you need to get the template and put it inside a virtual template element.
              // a virtual template element is just a template element inside a javascript variable.
              //      var templateElement = document.createElement('template');
              // you need to fill templateElement with the record template string, don't use the thead. (you'll find most everything in element.tableTemplate)
              // you need to extract the contents of the first td and put that into a variable.
              // you need to extract the contents of the "value" attribute on the tr (if present).
              // because you extracted the contents before templating, the variables are untemplated.
              // you need to get the column name from the first td template.
              //      there are three things you need to try:
              //          do a regex for "row.something", cut off the row
              //              OR
              //          do a regex for "row['something']", cut off the row[' and ']
              //              OR
              //          do a regex for "row["something"]", cut off the row[" and "]
              //
              //      that should be good enough. if you can't get the column: stop and
              //          console.warn to tell the developer to stick <!-- row.column -->
              //          at the top of the first td 
              // you need to run an AJAX call on the postgres object in "src" with a where clause.
              // the where clause will be something like this:
              //          (OLDWHERE) AND COLUMN ILIKE $UnCOPYQTE$ strSearch%$UnCOPYQTE$
              // the ajax call should only get one record.
              // use the two templates to set the value (copy the original code).
              //
              // after you're done, leave these comments for future developers
              
              
              
              //<gs-combo src="test.tpeople" column="">
              //    <template>
              //        <table>
              //            <thead>
              //                <tr>
              //                    <th>asdf</th>
              //                    <th>fdsa</th>
              //                </tr>
              //            </thead>
              //            <tbody>
              //                <tr value="{{! row.id }}"> <--- hidden value, if present
              //                    <td>{{! row.asdf }}</td> <--- visible value
              //                    <td>{{! row.fdsa }}</td>
              //                </tr>
              //            </tbody>
              //        </table>
              //    </template>
              //</gs-combo>
              
              if (xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr').length > 2000) {
                  var strSearchCol = '', templateElement = element.tableTemplate;
                  
                  templateElement = templateElement.substring(templateElement.indexOf('td'), templateElement.indexOf('/td') - 1);
                  templateElement = templateElement.substring(templateElement.indexOf('{'), templateElement.length);
                  if (templateElement.indexOf('row.') === -1) {
                      if (templateElement.indexOf('row[') === -1) {
                          console.warn('There is no doT.js in the first "<td>" in your template please fill your first "<td>" with templating code.');
                      } else {
                          templateElement = templateElement.substring(parseInt(templateElement.indexOf('row['), 10) + 5, templateElement.length - 2 - 3).trim();
                      }
                  } else {
                      templateElement = templateElement.substring(parseInt(templateElement.indexOf('row.'), 10) + 4, templateElement.length - 3).trim();
                  }
                  
                  
                  strSearchCol = templateElement;
                  
                  var strSrc     = GS.templateWithQuerystring(element.getAttribute('src'))
                    , srcParts   = strSrc[0] === '(' ? [strSrc, ''] : strSrc.split('.')
                    , strSchema  = srcParts[0]
                    , strObject  = srcParts[1]
                    , strColumns = GS.templateWithQuerystring(element.getAttribute('cols') || '*').split(',').join('\t')
                    , strWhere   = (
                        element.hasAttribute('where')
                          ? GS.templateWithQuerystring(element.getAttribute('where') || '') + ' AND ' + strSearchCol + '::text ILIKE $UnCOPYQTE$' + strSearch + '%$UnCOPYQTE$'
                          : strSearchCol + '::text ILIKE $UnCOPYQTE$' + strSearch + '%$UnCOPYQTE$'
                        )
                    , strOrd     = GS.templateWithQuerystring(element.getAttribute('ord') || '')
                    , strLimit   = '1'
                    , strOffset  = GS.templateWithQuerystring(element.getAttribute('offset') || '')
                    , response_i = 0, response_len = 0, arrTotalRecords = [];
                  
                  //console.log(strLink);
                  //console.log(strSearchCol);
                  
                  
                  if (strSearchCol) {
                      GS.requestSelectFromSocket(GS.envSocket, strSchema, strObject, strColumns
                                               , strWhere, strOrd, strLimit, strOffset
                                               , function (data, error) {
                          var arrCells, cell_i, cell_len;
                          
                          if (!error) {
                              if (data.strMessage !== 'TRANSACTION COMPLETED') {
                                  arrCells = arrRecords[i].split('\t');
                                  
                                  element.control.value = arrCells[0] = arrCells[0] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[0]);
                                  GS.setInputSelection(element.control, strSearch.length, element.control.value.length);
                                  if (element.open) {
                                      matchRecord = findRecordFromString(element, strSearch, true);
                                      if (matchRecord) {
                                          highlightRecord(element, matchRecord);
                                          scrollToSelectedRecord(element);
                                      }
                                  }
                              }
                          } else {
                              handleData(element, bolInitalLoad, data, error);
                              //GS.removeLoader(element);
                          }
                      });
                  }
                  
                  
                  
              } else {
                  matchRecord = findRecordFromString(element, strSearch, true);
                  
                  // if we found a record and its was already selected: selected the matched record and dont 
                  if (matchRecord) {
                      highlightRecord(element, matchRecord);
                      element.control.value = xtag.queryChildren(matchRecord, 'td')[0].textContent;
                      GS.setInputSelection(element.control, strSearch.length, element.control.value.length);
                      
                      scrollToSelectedRecord(element);
                      
                  } else {
                      clearSelection(element);
                      //selectRecordFromValue(element, strSearch, false);
                      //GS.setInputSelection(element.control, strSearch.length, element.control.value.length);
                  }
              }
              
              
          }
          
          if (element.attemptSearchOnNextKeyup === true) {
              element.attemptSearchOnNextKeyup = false;
          }
      }
      
      // handles fetching the data
      //      if bolInitalLoad === true then
      //          use: initialize query COALESCE TO source query
      //      else
      //          use: source query
      function getData(element, bolInitalLoad, bolClearPrevious, callback) {
          var strSrc     = GS.templateWithQuerystring(
                              (bolInitalLoad && element.getAttribute('initialize')
                                  ? element.getAttribute('initialize')
                                  : element.getAttribute('src')
                              )
                          )
            , srcParts   = strSrc[0] === '(' ? [strSrc, ''] : strSrc.split('.')
            , strSchema  = srcParts[0]
            , strObject  = srcParts[1]
            , strColumns = GS.templateWithQuerystring(element.getAttribute('cols') || '*').split(',').join('\t')
            , strWhere   = GS.templateWithQuerystring(element.getAttribute('where') || '')
            , strOrd     = GS.templateWithQuerystring(element.getAttribute('ord') || '')
            , strLimit   = GS.templateWithQuerystring(element.getAttribute('limit') || '')
            , strOffset  = GS.templateWithQuerystring(element.getAttribute('offset') || '')
            , response_i = 0, response_len = 0, arrTotalRecords = [];
          
          
          //GS.addLoader(element, 'Loading...');
          GS.requestCachingSelect(GS.envSocket, strSchema, strObject, strColumns
                                   , strWhere, strOrd, strLimit, strOffset
                                   , function (data, error) {
              var arrRecords, arrCells, envData
                , i, len, cell_i, cell_len;
              
              if (!error) {
                  if (data.strMessage !== 'TRANSACTION COMPLETED') {
                      arrRecords = GS.trim(data.strMessage, '\n').split('\n');
                      
                      for (i = 0, len = arrRecords.length; i < len; i += 1) {
                          arrCells = arrRecords[i].split('\t');
                          
                          for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                              arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                          }
                          
                          arrTotalRecords.push(arrCells);
                      }
                  } else {
                      //GS.removeLoader(element);
                      element.arrColumnNames = data.arrColumnNames;
                      
                      envData = {'arr_column': element.arrColumnNames, 'dat': arrTotalRecords};
                      
                      handleData(element, bolInitalLoad, envData);
                      if (typeof callback === 'function') {
                          callback();
                      }
                  }
              } else {
                  handleData(element, bolInitalLoad, data, error);
                  //GS.removeLoader(element);
              }
          }, bolClearPrevious);
      }
      
      // handles data result from method function: getData 
      //      success:  template
      //      error:    add error classes
      function handleData(element, bolInitalLoad, data, error) {
          var divElement, tableElement, theadElement, theadCellElements, tbodyElement, tbodyCellElements, lastRecordElement,
              currentCellLabelElement, template, i, len, arrHeaders = [], strTemplate, arrHide, strHeaderCells, strRecordCells,
              tableTemplateElement, recordElements, recordElement, jsnTemplate, strHTML;
          
          //GS.triggerEvent(this, 'after_select'); <== caused a MAJOR issue where code that was supposed to
          //                                              run after an envelope after_select caught all of
          //                                              the after selects of the comboboxes in the envelope
          
          // clear any old error status
          element.classList.remove('error');
          element.dropDownButton.setAttribute('title', '');
          element.dropDownButton.setAttribute('icon', 'angle-down');
          
          // if there was no error
          if (!error) {
              element.error = false;
              
              //console.log(this, this.tableTemplate);
              
              if (element.tableTemplate) {
                  //tableTemplateElement = document.createElement('template');
                  //tableTemplateElement.innerHTML = this.tableTemplate;
                  //
                  //theadElement = xtag.query(tableTemplateElement.content, 'thead')[0];
                  //tbodyElement = xtag.query(tableTemplateElement.content, 'tbody')[0];
                  //
                  //console.log(theadElement, tbodyElement);
                  
                  strTemplate = element.tableTemplate; //this.initalHTML;
                  
              } else { // if (data.arr_column)
                  // create an array of hidden column numbers
                  arrHide = (element.getAttribute('hide') || '').split(/[\s]*,[\s]*/);
                  
                  // build up the header cells variable and the record cells variable
                  for (i = 0, len = data.arr_column.length, strHeaderCells = '', strRecordCells = ''; i < len; i += 1) {
                      // if this column is not hidden
                      if (arrHide.indexOf((i + 1) + '') === -1 && arrHide.indexOf(data.arr_column[i]) === -1) {
                          // append a new cell to each of the header cells and record cells variables
                          strHeaderCells += '<th gs-dynamic>' + encodeHTML(data.arr_column[i]) + '</th> ';
                          strRecordCells += '<td gs-dynamic>{{! row[\'' + data.arr_column[i] + '\'] }}</td> ';
                      }
                  }
                  
                  // put everything together
                  strTemplate =   '<table gs-dynamic>' +
                                      '<thead gs-dynamic>' +
                                          '<tr gs-dynamic>' +
                                              strHeaderCells +
                                          '</tr>' +
                                      '</thead>' +
                                      '<tbody gs-dynamic>' +
                                          '<tr value="{{! row[\'' + data.arr_column[0] + '\'] }}" gs-dynamic>' +
                                              strRecordCells +
                                          '</tr>' +
                                      '</tbody>' +
                                  '<table>';
              }
              
              divElement = document.createElement('div');
              
              divElement.innerHTML = strTemplate;
              
              tableElement = xtag.queryChildren(divElement, 'table')[0];
              theadElement = xtag.queryChildren(tableElement, 'thead')[0];
              tbodyElement = xtag.queryChildren(tableElement, 'tbody')[0];
              
              // if there is a tbody
              if (tbodyElement) {
                  recordElement = xtag.queryChildren(tbodyElement, 'tr')[0];
                  
                  // if there is a record: template
                  if (recordElement) {
                      
                      // if there is a thead element: add reflow cell headers to the tds
                      if (theadElement) {
                          theadCellElements = xtag.query(theadElement, 'td, th');
                          tbodyCellElements = xtag.query(tbodyElement, 'td, th');
                          
                          for (i = 0, len = theadCellElements.length; i < len; i += 1) {
                              currentCellLabelElement = document.createElement('b');
                              currentCellLabelElement.classList.add('cell-label');
                              currentCellLabelElement.setAttribute('data-text', (theadCellElements[i].textContent || '') + ':');
                              currentCellLabelElement.setAttribute('gs-dynamic', '');
                              
                              if (tbodyCellElements[i].childNodes) {
                                  tbodyCellElements[i].insertBefore(currentCellLabelElement, tbodyCellElements[i].childNodes[0]);
                              } else {
                                  tbodyCellElements[i].insertChild(currentCellLabelElement);
                              }
                          }
                      }
                      
                      // template
                      jsnTemplate = GS.templateHideSubTemplates(tbodyElement.innerHTML, true);
                      strHTML = GS.templateWithEnvelopeData(tbodyElement.innerHTML, data);
                      tbodyElement.innerHTML = GS.templateShowSubTemplates(strHTML, jsnTemplate);
                      
                      element.dropDownTable = tableElement;
                      element.ready = true;
                  }
              }
              
              //if (data.arr_column) {
              if (bolInitalLoad && element.getAttribute('value')) {
                  selectRecordFromValue(element, element.getAttribute('value'), false);
                  
              } else if (element.value) {
                  selectRecordFromValue(element, element.value, false);
              }
              //}
              
          // else there was an error: add error class, title attribute
          } else {
              console.error(data);
              element.error = true;
              element.ready = false;
              element.classList.add('error');
              element.dropDownButton.setAttribute('title', 'This combobox has failed to load.');
              element.dropDownButton.setAttribute('icon', 'exclamation-circle');
              
              if (element.hasAttribute('limit-to-list')) {
                  element.setAttribute('disabled', '');
              }
          }
      }
      
      function refreshControl(element) {
          var i, len, divElement, arrPassThroughAttributes = [
                  'placeholder',
                  'name',
                  'maxlength',
                  'autocorrect',
                  'autocapitalize',
                  'autocomplete',
                  'autofocus',
                  'spellcheck',
                  'readonly'
              ];
          
          // if the gs-text element has a tabindex: save the tabindex and remov the attribute
          if (element.hasAttribute('tabindex')) {
              element.savedTabIndex = element.getAttribute('tabindex');
              element.removeAttribute('tabindex');
          }
          
          // clear out the combobox HTML
          element.innerHTML = '';
          
          // creating/setting root
          divElement = document.createElement('div');
          divElement.setAttribute('gs-dynamic', '');
          divElement.classList.add('root');
          
          element.appendChild(divElement);
          element.root = divElement;
          
          element.root.innerHTML = '<input gs-dynamic class="control" type="text" />' +
                                   '<gs-button gs-dynamic class="drop_down_button" icononly icon="angle-down" no-focus></gs-button>';
          
          element.control = xtag.query(element, '.control')[0];
          element.dropDownButton = xtag.query(element, '.drop_down_button')[0];
          
          // copy passthrough attrbutes to control
          for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
              if (element.hasAttribute(arrPassThroughAttributes[i])) {
                  element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
              }
          }
          
          // if we saved a tabindex: apply the tabindex to the control
          if (element.savedTabIndex !== undefined && element.savedTabIndex !== null) {
              element.control.setAttribute('tabindex', element.savedTabIndex);
          }
          
          // bind change event to control
          //console.log('change bound');
          element.control.addEventListener('change', function (event) {
              event.preventDefault();
              event.stopPropagation();
              
              //console.log('change detected');
              if (!element.ignoreChange) {
                  selectRecordFromValue(element, this.value, true);
              }
              element.ignoreChange = false;
          });
          
          
          //  on safari the change event doesn't occur if you click out while the autocomplete has
          //      completed the value (because the user technically didn't change after the javascript changed the value)
          //  to solve this the code below will mimic a change event if one does not occur at the right time
          
          // there are two ways that user's cause change events:
          //      1) after making a change to the value: taking the focus out of the field
          //      2) after making a change to the value: hitting return
          
          // this code counts on the fact that a browser will always emit a change event before a 'blur' or 'keyup'
          // the execution is as follows
          
          // this is the basic plan:
          //  change:
          //          // changeOccured tells the event code to not do anything because a change event did fire
          //          element.changeOccured to true
          //  focus:
          //          // element.lastValue allows us to compare the value to the old value, and if there's a difference: we need a change event
          //          set element.lastValue to current value of the control 
          //  blur:
          //          if element.changeOccured === true:
          //              set element.changeOccured = false
          //          else:
          //              if control.value !== lastValue: // if the value has been changed
          //                  trigger artificial change event on control
          //  keyup (on return key):
          //          if element.changeOccured === true:
          //              set element.changeOccured = false
          //          else:
          //              if control.value !== lastValue: // if the value has been changed
          //                  trigger artificial change event on control
          
          
          element.control.addEventListener('change', function (event) {
              element.changeOccured = true;
          });
          
          element.control.addEventListener('focus', function (event) {
              element.lastValue = element.control.value;
              
              event.target.parentNode.parentNode.classList.add('focus');
          });
          
          element.control.addEventListener('blur', function (event) {
              if (element.changeOccured === true) {
                  element.changeOccured = false;
              } else if (element.control.value !== element.lastValue) {
                  GS.triggerEvent(element.control, 'change');
              }
              
              event.target.parentNode.parentNode.classList.remove('focus');
          });
          
          element.control.addEventListener(evt.mouseout, function (event) {
              event.target.parentNode.parentNode.classList.remove('hover');
          });
          
          element.control.addEventListener(evt.mouseover, function (event) {
              event.target.parentNode.parentNode.classList.add('hover');
          });
          
          element.control.addEventListener('keyup', function (event) {
              // if the key was return
              if ((event.keyCode || event.which) === 13 && !element.hasAttribute('readonly')) {
                  if (element.changeOccured === true) {
                      element.changeOccured = false;
                  } else if (element.control.value !== element.lastValue) {
                      GS.triggerEvent(element.control, 'change');
                  }
              }
          });
      }
      
      //function pushReplacePopHandler(element) {
      //    var i, len, arrPopKeys, currentValue, bolRefresh = false, strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
      //    
      //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.value = GS.qryGetVal(strQueryString, strQSCol);
      //    }
      //    
      //    if (element.hasAttribute('refresh-on-querystring-values')) {
      //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
      //        
      //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
      //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
      //            
      //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
      //                bolRefresh = true;
      //            }
      //            
      //            element.popValues[arrPopKeys[i]] = currentValue;
      //        }
      //        
      //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
      //        bolRefresh = true;
      //    }
      //    
      //    if (bolRefresh) {
      //        getData(element);
      //    }
      //}
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          i = 0;
          len = element.attributes.length;
          arrAttr = element.attributes;
          while (i < len) {
              jsnAttr = element.attributes[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var arrPopKeys;
          var currentValue;
          var bolRefresh;
          var strOperator;
  
          if (strQSCol) {
              if (strQSCol.indexOf('=') !== -1) {
                  arrAttrParts = strQSCol.split(',');
                  i = 0;
                  len = arrAttrParts.length;
                  while (i < len) {
                      strQSCol = arrAttrParts[i];
      
                      if (strQSCol.indexOf('!=') !== -1) {
                          strOperator = '!=';
                          arrQSParts = strQSCol.split('!=');
                      } else {
                          strOperator = '=';
                          arrQSParts = strQSCol.split('=');
                      }
      
                      strQSCol = arrQSParts[0];
                      strQSAttr = arrQSParts[1] || arrQSParts[0];
      
                      // if the key is not present or we've got the negator: go to the attribute's default or remove it
                      if (strOperator === '!=') {
                          // if the key is not present: add the attribute
                          if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                              element.setAttribute(strQSAttr, '');
                          // else: remove the attribute
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      } else {
                          // if the key is not present: go to the attribute's default or remove it
                          if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                              if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                  element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                              } else {
                                  element.removeAttribute(strQSAttr);
                              }
                          // else: set attribute to exact text from QS
                          } else {
                              element.setAttribute(strQSAttr, (
                                  GS.qryGetVal(strQS, strQSCol) ||
                                  element.internal.defaultAttributes[strQSAttr] ||
                                  ''
                              ));
                          }
                      }
                      i += 1;
                  }
              } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                  strQSValue = GS.qryGetVal(strQS, strQSCol);
      
                  if (element.internal.bolQSFirstRun !== true) {
                      if (strQSValue !== '' || !element.getAttribute('value')) {
                          element.setAttribute('value', strQSValue);
                      }
                  } else {
                      element.value = strQSValue;
                  }
              }
          }
          
          // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
          if (element.internal.bolQSFirstRun === true) {
              if (element.hasAttribute('refresh-on-querystring-values')) {
                  arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                  
                  for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                      currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);
                      
                      if (element.popValues[arrPopKeys[i]] !== currentValue) {
                          bolRefresh = true;
                      }
                      
                      element.popValues[arrPopKeys[i]] = currentValue;
                  }
              } else if (element.hasAttribute('refresh-on-querystring-change')) {
                  bolRefresh = true;
              }
              
              if (bolRefresh && element.hasAttribute('src')) {
                  getData(element);
              } else if (bolRefresh && !element.hasAttribute('src')) {
                  console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
              }
          } else {
              if (element.hasAttribute('refresh-on-querystring-values')) {
                  arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                  
                  for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                      element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                  }
              }
          }
          
          element.internal.bolQSFirstRun = true;
      }
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              
          }
      }
      
      //
      function elementInserted(element) {
          var tableTemplateElement, tableTemplateElementCopy, oldRootElement, i, len,
              recordElement, strQueryString = GS.getQueryString(), arrElement, currentElement, strQSValue;
          
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
                  
                  element.open = false;
                  element.error = false;
                  element.ready = false;
                  
                  // handle "qs" attribute
                  if (element.getAttribute('qs') ||
                          element.getAttribute('refresh-on-querystring-values') ||
                          element.hasAttribute('refresh-on-querystring-change')) {
                      //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                      //
                      //if (strQSValue !== '' || !element.getAttribute('value')) {
                      //    element.setAttribute('value', strQSValue);
                      //}
                      
                      element.popValues = {};
                      pushReplacePopHandler(element);
                      window.addEventListener('pushstate', function () {    pushReplacePopHandler(element); });
                      window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                      window.addEventListener('popstate', function () {     pushReplacePopHandler(element); });
                  }
                  
                  //
                  tableTemplateElement = xtag.queryChildren(element, 'template')[0];
                  
                  if (tableTemplateElement) {
                      if (tableTemplateElement.innerHTML.indexOf('&gt;') > -1 || tableTemplateElement.innerHTML.indexOf('&lt;') > -1) {
                          console.warn('GS-COMBO WARNING: &gt; or &lt; detected in table template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                      }
                      
                      tableTemplateElementCopy = document.createElement('template');
                      tableTemplateElementCopy.innerHTML = tableTemplateElement.innerHTML;
                      
                      recordElement = xtag.query(xtag.query(tableTemplateElementCopy.content, 'tbody')[0], 'tr')[0];
                      
                      if (recordElement) {
                          arrElement = xtag.query(recordElement, '[column]');
                          
                          for (i = 0, len = arrElement.length; i < len; i += 1) {
                              currentElement = arrElement[i];
                              
                              if ((!currentElement.getAttribute('value')) && currentElement.getAttribute('column')) {
                                  currentElement.setAttribute('value', '{{! row.' + currentElement.getAttribute('column') + ' }}');
                              }
                          }
                          
                          element.tableTemplate = tableTemplateElementCopy.innerHTML;
                          
                          if (!element.getAttribute('src') && !element.getAttribute('source') && !element.getAttribute('initalize')) {
                              //element.staticDropDownTable = GS.cloneElement(tableTemplateElementCopy.content.children[0]);
                              //element.dropDownTable = GS.cloneElement(tableTemplateElementCopy.content.children[0]); //element.staticDropDownTable;
                              
                              element.dropDownTable = GS.cloneElement(xtag.query(tableTemplateElementCopy.content, 'table')[0]);
                          }
                      }
                  }
                  
                  // filling root
                  refreshControl(element);
                  
                  //
                  element.addEventListener('click', function (event) {
                      var clickHandler;
                      
                      if (event.target.classList.contains('drop_down_button')) {
                          //console.log(element.open, element.error);
                          if (!element.open && !element.error) {
                              clickHandler = function () {
                                  openDropDown(element);
                                  window.removeEventListener('click', clickHandler);
                              };
                              
                              window.addEventListener('click', clickHandler);
                          } else {
                              //closeDropDown(element);
                          }
                      }
                  });
                  
                  element.addEventListener('keydown', function (event) {
                      if (event.target.classList.contains('control')) {
                          handleKeyDown(element, event);
                      }
                  });
                  
                  element.addEventListener('keyup', function (event) {
                      if (event.target.classList.contains('control')) {
                          handleKeyUp(element, event);
                      }
                  });
                  
                  if (xtag.queryChildren(element, '.root').length < 1) {
                      refreshControl(element);
                  }
                  
                  if (element.getAttribute('src') || element.getAttribute('source') || element.getAttribute('initalize')) {
                      getData(element, true);
                  } else {
                      element.ready = true;
                      
                      if (element.getAttribute('value')) {
                          selectRecordFromValue(element, element.getAttribute('value'), false);
                          
                      } else if (element.value) {
                          selectRecordFromValue(element, element.value, false);
                      }
                  }
              }
          }
      }
      
      xtag.register('gs-combo', {
          lifecycle: {
              created: function () {
                  // if the value was set before the "created" lifecycle code runs: set attribute
                  //      (discovered when trying to set a value of a date control in the after_open of a dialog)
                  //      ("delete" keyword added because of firefox)
                  if (this.value && !this.hasAttribute('value')) {
                      this.setAttribute('value', this.value);
                      delete this.value;
                  }
                  
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      if (strAttrName === 'value' && oldValue !== newValue) {
                          this.value = newValue;
                      }
                  }
              }
          },
          events: {},
          accessors: {
              value: {
                  get: function () {
                      if (this.control || this.innerValue) {
                          return this.innerValue || this.control.value;
                      } else if (this.getAttribute('value')) {
                          return this.getAttribute('value');
                      }
                      return undefined;
                  },
                  
                  // set the value of the input and set the value attribute
                  set: function (newValue) {
                      
                      // if we have not yet templated: just stick the value in an attribute
                      if (this.ready === false) {
                          if (newValue !== this.getAttribute('value')) {
                              this.setAttribute('value', newValue);
                          }
                          
                      // else if the value is empty and allow-empty is present
                      } else if (newValue === '' && this.hasAttribute('allow-empty')) {
                          this.innerValue = '';
                          this.control.value = '';
                          
                      // else select the record using the string that was sent
                      } else {
                          selectRecordFromValue(this, newValue, false);
                      }
                  }
              },
              textValue: {
                  // get value straight from the input
                  get: function () {
                      return this.control.value;
                  },
                  
                  // set the value of the input and set the value attribute
                  set: function (newValue) {
                      
                      // if we have not yet templated: just stick the value in an attribute
                      if (this.ready === false) {
                          this.setAttribute('value', newValue);
                          
                      // else select the record using the string that was sent
                      } else {
                          selectRecordFromValue(this, newValue, false);
                      }
                  }
              }
          },
          methods: {
              focus: function () {
                  this.control.focus();
              },
              
              'getData': function () {
                  getData(this, undefined, true);
              },
              
              'refresh': function () {
                  getData(this, undefined, true);
              }
          }
      });
  });
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('<gs-container>', '<gs-container>', 'gs-container min-width="${1:sml;med;lrg;}" ${2:padded}>\n' +
                                                                  '    ${0}\n' +
                                                                  '</gs-container>');
      
      designRegisterElement('gs-container', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-container-jumbo.html');
      
      window.designElementProperty_GSCONTAINER = function(selectedElement) {
          var strVisibilityAttribute;
          
          addProp('Min-Width Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('min-width') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'min-width', this.value);
          });
          
          addProp('Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('media') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'media', this.value);
          });
          
          addProp('Padded', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('padded')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'padded', (this.value === 'true'), true);
          });
          
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
          
          // visibility attributes
          strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
          
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      var arrTakenContainers = [], intScrollBarWidth;
      
      function getScrollBarWidth() {
          var inner = document.createElement('div'),
              outer = document.createElement('div'),
              intWidth;
          
          inner.style.height = '200px';
          
          outer.style.position = 'absolute';
          outer.style.top = '0';
          outer.style.left = '0';
          outer.style.visibility = 'hidden';
          outer.style.overflow = 'scroll';
          
          outer.style.width = '50px';
          outer.style.height = '100px';
          
          outer.appendChild(inner);
          document.body.appendChild(outer);
          
          intWidth = (outer.offsetWidth - inner.offsetWidth);
          
          document.body.removeChild(outer);
          
          return intWidth;
      };
      
      intScrollBarWidth = getScrollBarWidth();
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              
          }
      }
      
      //
      function elementInserted(element) {
          var styleElement;
          
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  
                  // if the style element for the container CSS doesn't exist: create it
                  if (!document.getElementById('gs-dynamic-css')) {
                      styleElement = document.createElement('style');
                      styleElement.setAttribute('id', 'gs-dynamic-css');
                      styleElement.setAttribute('gs-dynamic', '');
                      document.head.appendChild(styleElement);
                  }
                  
                  if (element.getAttribute('min-width')) {
                      element.handleMinWidthCSS();
                  } else if (element.getAttribute('media')) {
                      element.handleMediaCSS();
                  }
              }
          }
      }
      
      xtag.register('gs-container', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      // if the "min-width" attribute changed
                      if (strAttrName === 'min-width') {
                          this.handleMinWidthCSS();
                          
                      // if the "media" attribute changed
                      } else if (strAttrName === 'media') {
                          this.handleMediaCSS();
                      }
                  }
              }
          },
          events: {},
          accessors: {},
          methods: {
              handleMinWidthCSS: function () {
                  var strMinWidth = this.getAttribute('min-width'), arrMinWidths, strCSS, i, len,
                      arrClassesToRemove, intContainerID, intWidthNumber, strWidthOperator, strNewWidth;
                  
                  // remove old classes
                  arrClassesToRemove = String(this.classList).match(/container-id-[0-9]*/g) || [];
                  
                  for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                      this.classList.remove(arrClassesToRemove[i]);
                  }
                  
                  // sml;med;lrg
                  // medium
                  // 100;200;300;400;500;600;700;800;900;1000;1100;1200
                  
                  // remove all whitespace, lowercase, trim off semicolons
                  strMinWidth = GS.trim(strMinWidth.replace(/\s+/g, '').toLowerCase(), ';');
                  
                  // replace shortcuts (lrg => 1200px)
                  strMinWidth = strMinWidth.replace(/small|sml/g, '768px').replace(/medium|med/g, '992px').replace(/large|lrg/g, '1200px');
                  
                  arrMinWidths = strMinWidth.split(';'); // seperate out layouts
                  
                  //console.log(strMinWidth, arrMinWidths);
                  
                  if (arrTakenContainers.indexOf(strMinWidth) === -1) {
                      arrTakenContainers.push(strMinWidth);
                      intContainerID = arrTakenContainers.length - 1;
                      strCSS = '';
                      
                      for (i = 0, len = arrMinWidths.length; i < len; i += 1) {
                          intWidthNumber = parseInt(arrMinWidths[i]);
                          strWidthOperator = arrMinWidths[i].replace(/[0-9]/g, '');
                          
                          if (strWidthOperator === 'px') {
                              intWidthNumber -= intScrollBarWidth;
                          } else if (strWidthOperator === 'em') {
                              intWidthNumber -= GS.pxToEm(this.parentNode, intScrollBarWidth);
                          }
                          
                          strNewWidth = intWidthNumber + strWidthOperator;
                          
                          strCSS +=   '\n@media (min-width:' + arrMinWidths[i] + ') {\n' +
                                      '    gs-container.container-id-' + intContainerID +
                                                  ' { width:' + strNewWidth + '; margin-left:auto; margin-right:auto; }\n' +
                                      '}\n';
                      }
                      
                      //console.log(strCSS);
                      
                      // append the column CSS
                      document.getElementById('gs-dynamic-css').innerHTML +=
                              '\n/* container #' + intContainerID + ' */\n' + strCSS;
                      
                  } else {
                      intContainerID = arrTakenContainers.indexOf(strMinWidth);
                  }
                  
                  this.classList.add('container-id-' + intContainerID);
              },
              
              handleMediaCSS: function () {
                  var strMedia = this.getAttribute('media'), arrMedias, strCSS, i, len,
                      arrClassesToRemove, arrParts, strCurrentMedia, strWidth, intContainerID;
                  
                  // remove old classes
                  arrClassesToRemove = String(this.classList).match(/container-id-[0-9]*/g) || [];
                  
                  for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                      this.classList.remove(arrClassesToRemove[i]);
                  }
                  
                  // (min-width: 500) {small}; (max-width: 500) {50}
                  // (max-width: small) {small}; (min-width: small) {small}
                  // (max-width: small) {50}; (min-width: small) {500}
                  
                  // trim, remove all close curly braces, lowercase, trim off semicolons
                  strMedia = GS.trim(strMedia.trim().replace(/\}/g, '').toLowerCase(), ';');
                  
                  // replace shortcuts (lrg => 1200px)
                  strMedia = strMedia.replace(/small|sml/g, '768px').replace(/medium|med/g, '992px').replace(/large|lrg/g, '1200px');
                  
                  arrMedias = strMedia.split(';'); // seperate out layouts
                  
                  //console.log(strMedia, arrMedias);
                  
                  if (arrTakenContainers.indexOf(strMedia) === -1) {
                      arrTakenContainers.push(strMedia);
                      intContainerID = arrTakenContainers.length - 1;
                      strCSS = '';
                      
                      
                      for (i = 0, len = arrMedias.length; i < len; i += 1) {
                          arrParts = arrMedias[i].split('{');
                          strCurrentMedia = arrParts[0].trim() || 'all';
                          strWidth = arrParts[1].trim() || '900px';
                          
                          strCSS +=   '\n@media ' + strCurrentMedia + ' {\n' +
                                      '    gs-container.container-id-' + intContainerID + ' ' +
                                                  '{ width:' + strWidth + '; margin-left:auto; margin-right:auto; }\n' +
                                      '}\n';
                      }
                      
                      //console.log(strCSS);
                      
                      // append the column CSS
                      document.getElementById('gs-dynamic-css').innerHTML += '\n/* container #' + intContainerID + ' */\n' + strCSS;
                      
                  } else {
                      intContainerID = arrTakenContainers.indexOf(strMinWidth);
                  }
                  
                  this.classList.add('container-id-' + intContainerID);
              }
          }
      });
  });window.addEventListener('design-register-element', function () {
      registerDesignSnippet('<gs-current-record>', '<gs-current-record>', 'gs-current-record for="${1:for}"></gs-current-record>');
      window.designElementProperty_GSCURRENT_RECORD = function (selectedElement) {
          addProp('For', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('for') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'for', this.value);
          });
  
          addProp('Inline', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('inline') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'inline', this.value === 'true', true);
          });
      };
  });
  
  //global xtag
  //jslint browser:true
  document.addEventListener("DOMContentLoaded", function () {
      "use strict";
      function buildElement(element) {
          
          element.forTable = document.getElementById(element.getAttribute('for'));
  
          element.forTable.addEventListener('selection_change', function () {
              element.refresh(element);
          });
          element.forTable.addEventListener('after_select', function () {
              element.refresh(element);
          });
          element.forTable.addEventListener('after_selection', function () {
              element.refresh(element);
          });
  
          element.firstChild.addEventListener('change', function (event) {
              var tableElem = element.forTable;
              var strValue = event.target.value;
              var intValue = parseInt(strValue.substring(0, strValue.indexOf(' ')), 10);
              var intMaxRecord = tableElem.internalData.records.length;
      
              var intMinColumn = (
                  tableElem.internalDisplay.recordSelectorVisible
                      ? -1
                      : 0
              );
      
              // if we couldn't extract a record number from the
              //      user's value, go to the first record
              if (isNaN(intValue)) {
                  intValue = 1;
              }
      
              if (intMaxRecord === 0) {
                  intValue = undefined;
              }
      
              // prevent intValue from being greater than the number
              //      of records
              if (intValue > intMaxRecord) {
                  intValue = intMaxRecord;
              }
      
              // intValue is from a user and therefore one-based
              if (!isNaN(intValue)) {
                  // correct one-based by subtracting one
                  intValue -= 1;
              }
              
              // override all current ranges to select the new record
              if (intValue !== undefined) {
                  tableElem.internalSelection.ranges = [
                      {
                          "start": {
                              "row": intValue,
                              "column": intMinColumn
                          },
                          "end": {
                              "row": intValue,
                              "column": intMinColumn
                          },
                          "negator": false
                      }
                  ];
              } else {
                  tableElem.internalSelection.ranges = [];
              }
  
              // render selection and scroll into view
              tableElem.goToLine(intValue + 1);
              event.target.parentNode.refresh(event.target.parentNode);
          });
      }
  
      function elementInserted(element) {
          if (element.children.length === 0) {
              var gsText = document.createElement("gs-text");
              element.appendChild(gsText);
          }
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute("suspend-created") && !element.hasAttribute("suspend-inserted")) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
  
                  if (!element.children[0].classList.contains('root')) {
                      buildElement(element);
                  }
              }
          }
      }
  
      xtag.register("gs-current-record", {
          lifecycle: {
              inserted: function () {
                  elementInserted(this);
              },
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  var element = this;
  
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === "suspend-created" && newValue === null) {
                      elementInserted(element);
  
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === "suspend-inserted" && newValue === null) {
                      elementInserted(element);
                  }
              }
          },
          events: {},
          accessors: {},
          methods: {
              'refresh': function (element) {
                  element.bolRefreshing = true;
                  var tableElem = element.forTable;
                  var intOriginRecord = (
                      tableElem.internalSelection.originRecord
                  );
                  // we need the element that contains the selection status
                  var statusElement = element.firstChild;
                  // if the element that is supposed to contain the status is
                  //      in the DOM
                  if (statusElement) {
                      // if we know the origin record
                      if (intOriginRecord !== undefined) {
                          statusElement.value = (
                              // origin record number is zero-based
                              (intOriginRecord + 1) +
                              ' of ' +
                              tableElem.internalData.records.length
                          );
                      // else, we don't know the origin record
                      } else {
                          statusElement.value = (
                              'nothing selected'
                          );
                      }
                  }
                  element.bolRefreshing = false;
              }
          }
      });
  });//jslint browser:true, white:true, multivar:true, for:true
  window.addEventListener('design-register-element', function (event) {
      'use strict';
      
      registerDesignSnippet('<gs-datasheet>', '<gs-datasheet>',
              'gs-datasheet src="${1:test.tpeople}">\n' +
              '    <template for="hud"></template>\n' +
              '    <template for="table">\n' +
              '        <table>\n' +
              '            <tbody>\n' +
              '                <tr>\n' +
              '                    <th heading="#"><gs-static column="row_number"></gs-static></th>\n' +
              '                    <td heading="">$0</td>\n' +
              '                </tr>\n' +
              '            </tbody>\n' +
              '        </table>\n' +
              '    </template>\n' +
              '    <template for="insert"></template>\n' +
              '</gs-datasheet>');
      
      designRegisterElement('gs-datasheet', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-datasheet.html');
      
      window.designElementProperty_GSDATASHEET = function (selectedElement) {
          addProp('Source', true,
                  '<gs-memo class="target" autoresize rows="1" value="' +
                          encodeHTML(decodeURIComponent(selectedElement.getAttribute('src'))) + '" mini></gs-memo>',
                  function () {
              return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
          });
          
          addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                  function () {
              return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
          });
          
          addProp('Lock Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('lock') || '') + '" mini></gs-text>',
                  function () {
              return setOrRemoveTextAttribute(selectedElement, 'lock', this.value);
          });
          
          addProp('Primary Keys', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('pk') || '') + '" mini></gs-text>',
                  function () {
              return setOrRemoveTextAttribute(selectedElement, 'pk', this.value);
          });
          
          addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('where') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'where', (this.value));
          });
          
          addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
          });
          
          addProp('Limit', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
          });
          
          addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
          });
          
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
          
          addProp('Parent&nbsp;Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
          
          addProp('Line Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('child-column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'child-column', this.value);
          });
          
          addProp('Reflow At', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('reflow-at') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'reflow-at', this.value);
          });
          
          addProp('Scroll To Bottom', true, '<gs-checkbox class="target" value="' + encodeHTML(selectedElement.hasAttribute('scroll-to-bottom') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'scroll-to-bottom', (this.value === 'true'), true);
          });
          
          addProp('HUD Paginate', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudpaginate')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-hudpaginate', (this.value === 'true'), false);
          });
          
          addProp('HUD Refresh', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudrefresh')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-hudrefresh', (this.value === 'true'), false);
          });
          
          addProp('HUD Delete', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-huddelete')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-huddelete', (this.value === 'true'), false);
          });
          
          addProp('Expand&nbsp;To&nbsp;Content', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('expand-to-content')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'expand-to-content', (this.value === 'true'), true);
          });
          
          addProp('Null String', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('null-string') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'null-string', this.value);
          });
          
          addProp('Filter Popup', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-filter')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-filter', (this.value === 'true'), false);
          });
          
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
          
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
              this.removeAttribute('refresh-on-querystring-change');
              return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
          });
          
          addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
              this.removeAttribute('refresh-on-querystring-values');
              return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
          });
          
          //// SUSPEND-CREATED attribute
          //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
          //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          //});
          
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      var KEY_RETURN = 13, KEY_TAB = 9, KEY_BACKSPACE = 8, KEY_DELETE = 46
        , KEY_UP = 38, KEY_RIGHT = 39, KEY_DOWN = 40, KEY_LEFT = 37;
      
      function deleteSelection(element) {
          var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'))
            , strObject = GS.templateWithQuerystring(element.getAttribute('object'))
            , arrSelectRecords = element.selectedRecords, deleteRecord, deleteRecordData
            , arrPk, arrLock, strHashColumns, strRoles, strColumns, strRecord
            , strRecordToHash, strDeleteData, strTemp, i, len, col_i, col_len;
          
          // if the first record is the header: remove it from the selection
          if (arrSelectRecords[0] && arrSelectRecords[0].parentNode.nodeName === 'THEAD') {
              arrSelectRecords.splice(0, 1);
          }
          
          if (element.numberOfSelections === 1
                  && arrSelectRecords.length > 0
                  && arrSelectRecords[0].children[0].hasAttribute('selected')
                  && !element.deleteButton.hasAttribute('disabled')) {
              
              // generate the information to send to the websocket
              arrPk = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
              arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);
              
              for (i = 0, len = arrPk.length, strRoles = '', strColumns = ''; i < len; i += 1) {
                  strRoles += (strRoles ? '\t' : '') + 'pk';
                  strColumns += (strColumns ? '\t' : '') + arrPk[i];
              }
              
              for (i = 0, len = arrLock.length, strHashColumns = ''; i < len; i += 1) {
                  strHashColumns += (strHashColumns ? '\t' : '') + arrLock[i];
              }
              
              strRoles += (strRoles ? '\t' : '') + 'hash';
              strColumns += (strColumns ? '\t' : '') + 'hash';
              
              for (i = 0, len = arrSelectRecords.length, strDeleteData = ''; i < len; i += 1) {
                  strRecord = '';
                  deleteRecord = arrSelectRecords[i];
                  deleteRecordData = element.internalData.arrRecords[parseInt(deleteRecord.getAttribute('data-index'), 10)];
                  //console.log(deleteRecordData);
                  
                  // get 'pk' columns
                  for (col_i = 0, col_len = arrPk.length; col_i < col_len; col_i += 1) {
                      strRecord += (strRecord ? '\t' : '');
                      strRecord += GS.encodeForTabDelimited(deleteRecordData[element.internalData.arrColumnNames.indexOf(arrPk[col_i])], element.nullString);
                  }
                  
                  // get 'hash' columns
                  strRecordToHash = '';
                  for (col_i = 0, col_len = arrLock.length; col_i < col_len; col_i += 1) {
                      strRecordToHash += (strRecordToHash ? '\t' : '');
                      strTemp = deleteRecordData[element.internalData.arrColumnNames.indexOf(arrLock[col_i])];
                      
                      // I believe that this needs to use the null-string instead of 'NULL'
                      strRecordToHash += (strTemp === 'NULL' ? '' : strTemp);
                  }
                  
                  strDeleteData += (strRecord + (strRecord ? '\t' : '') + GS.utfSafeMD5(strRecordToHash).toString() + '\n');
                  arrSelectRecords[i].classList.add('bg-red');
              }
              
              strDeleteData = (strRoles + '\n' + strColumns + '\n' + strDeleteData);
              
              // create delete transaction
              GS.addLoader(element, 'Creating Delete Transaction...');
              GS.requestDeleteFromSocket(
                  getSocket(element), strSchema, strObject, strHashColumns, strDeleteData
                  , function (data, error, transactionID) {
                      if (error) {
                          getData(element);
                          GS.removeLoader(element);
                          GS.webSocketErrorDialog(data);
                      }
                  }
                  , function (data, error, transactionID, commitFunction, rollbackFunction) {
                      var arrElements, i, len, templateElement;
                      GS.removeLoader(element);
                      
                      if (!error) {
                          if (data !== 'TRANSACTION COMPLETED') {
                              arrElements = xtag.query(element, '.bg-red');
                              
                              for (i = 0, len = arrElements.length; i < len; i += 1) {
                                  arrElements[i].classList.remove('bg-red');
                                  arrElements[i].classList.add('bg-amber');
                              }
                              
                          // open confirm message box
                          } else {
                              templateElement = document.createElement('template');
                              templateElement.innerHTML = ml(function () {/*
                                  <gs-page>
                                      <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                      <gs-body padded>
                                          <center>Are you sure you want to delete {{numberofrecords}} records?</center>
                                      </gs-body>
                                      <gs-footer>
                                          <gs-grid>
                                              <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                              <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                          </gs-grid>
                                      </gs-footer>
                                  </gs-page>
                              */}).replace(/\{\{numberofrecords\}\}/gi, xtag.query(element, '.bg-amber').length);
                              
                              GS.openDialog(templateElement, function () {
                                  document.getElementById('datasheet-focus-me').focus();
                                  
                              }, function (event, strAnswer) {
                                  if (strAnswer === 'Yes') {
                                      commitFunction();
                                      GS.addLoader(element, 'Commiting Delete Transaction...');
                                  } else {
                                      rollbackFunction();
                                      GS.addLoader(element, 'Rolling Back Delete Transaction...');
                                  }
                              });
                          }
                          
                      } else {
                          rollbackFunction();
                          getData(element);
                          GS.webSocketErrorDialog(data);
                      }
                  }
                  // final result callback, because we need to handle the commit/rollback response
                  , function (strAnswer, data, error) {
                      var arrElements, i, len;
                      GS.removeLoader(element);
                      
                      if (!error) {
                          if (strAnswer === 'COMMIT') {
                              // remove amber records, because the amber records have now been deleted
                              removeRecords(element, 'bg-amber');
                              
                              // clear internal variables for selection now that the selected records have been deleted,
                              //      because if you try to shift-select to extend the selection and the origin cell has
                              //      been deleted this may cause an error
                              clearSelection(element);
                              
                              // trigger after_delete so that developers can react to a successful delete
                              GS.triggerEvent(element, 'after_delete');
                              
                          } else {
                              // clear bg-amber class and don't add a green fade
                              clearRecordColor(element, 'bg-amber', false);
                          }
                          
                          // update record selector numbers to reflect current record numbers
                          //      because after you delete records there may be a gap in the numbers and that is not acceptable
                          arrElements = xtag.query(element, 'tbody > tr');
                          
                          for (i = 0, len = arrElements.length; i < len; i += 1) {
                              if (!arrElements[i].classList.contains('insert-record')) {
                                  arrElements[i].children[0].textContent = (i + 1);
                              }
                          }
                          
                      // if an error occurred
                      } else {
                          // get new data, because after an error we don't know the current state
                          //      of the data so a re-fetch will help mitigate inaccurate data errors
                          getData(element);
                          
                          // open an error dialog so that the user knows there was an error
                          GS.webSocketErrorDialog(data);
                      }
                  }
              );
          }
      }
      
      function insertDialog(element) {
          var templateElement = document.createElement('template'), strAddin;
          
          // if there is a column attribute on this element: append child column (or column) and
          //      the value to the insert string so that we can have parent-child relationships
          if (element.getAttribute('column') || element.getAttribute('qs')) {
              strAddin =  (
                              element.getAttribute('child-column')
                           || element.getAttribute('column')
                           || element.getAttribute('qs')
                          ) +
                          '=' +
                          element.value;
          }
          
          templateElement.innerHTML = ml(function () {/*
              <gs-page gs-dynamic>
                  <gs-header>
                      <center><h3>Insert</h3></center>
                  </gs-header>
                  <gs-body padded>
                      <gs-insert id="insert-dialog-content-container" src="{{SRC}}" addin="{{ADDIN}}">{{HTML}}</gs-insert>
                  </gs-body>
                  <gs-footer>
                      <gs-grid widths="1,1" class="width-2">
                          <gs-block width="1">
                              <gs-button dialogclose>Cancel</gs-button>
                          </gs-block>
                          <gs-block width="1">
                              <gs-button class="dialog-envelope-insert" listen-for-return bg-primary>Ok</gs-button>
                          </gs-block>
                      </gs-grid>
                  </gs-footer>
              </gs-page>
          */}).replace('{{HTML}}', element.insertTemplate)
              .replace('{{SRC}}', encodeHTML(element.getAttribute('src')))
              .replace('{{ADDIN}}', encodeHTML(strAddin || ''));
          
          GS.openDialog(templateElement, function () {
              var dialog = this;
              
              // if gs-datasheet has sequence attribute: add sequence attribute to gs-insert
              if (element.getAttribute('seq')) {
                  document.getElementById('insert-dialog-content-container').setAttribute('seq', element.getAttribute('seq'));
              }
              
              GS.triggerEvent(element, 'insert_dialog_open');
              
              xtag.query(dialog, '.dialog-envelope-insert')[0].addEventListener('click', function () {
                  var insertContainer = document.getElementById('insert-dialog-content-container');
                  
                  insertContainer.submit(function (lastval, jsnRow) {
                      getData(element);
                      GS.triggerEvent(element, 'after_insert');
                      GS.closeDialog(dialog, 'Ok');
                  });
              });
          });
      }
      
      function clearSelection(element) {
          element.savedSelection = [];
          element.savedSelectionCopy = [];
          element.dragOrigin = null;
          element.dragCurrentCell = null;
          element.selectionPreviousOrigin = null;
          element.numberOfSelections = 0;
          element.selectedCells = [];
      }
      
      function templateRecordsForInsert(element, strRecords, strClasses) {
          var arrRecords, arrCells, i, len, cell_i, cell_len, col_len, strHTML, intRowNumberAdd;
          
          // calculate the number of cells across
          if (element.getAttribute('cols')) {
              col_len = (element.getAttribute('cols') || '').split(/[\s]*,[\s]*/).length;
          }
          
          arrRecords = strRecords.split('\n');
          
          // calculate how much to add to the row numbers
          intRowNumberAdd = xtag.query(element, 'tr:not(.bg-red):not(.insert-record)').length - 1;
          
          for (i = 1, len = arrRecords.length - 1, strHTML = ''; i < len; i += 1) {
              arrCells = arrRecords[i].split('\t');
              
              strHTML += '<tr ' + (strClasses ? ' class="' + strClasses + '"' : '');
              
              for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                  strHTML += 'data-' + element.internalData.arrColumnNames[cell_i] +
                                  '="' + encodeHTML(GS.decodeFromTabDelimited(arrCells[cell_i], element.nullString)) + '"';
              }
              
              strHTML += '><th>' + (intRowNumberAdd + (i)) + '</th>';
              
              for (cell_i = 0, cell_len = (col_len || arrCells.length); cell_i < cell_len; cell_i += 1) {
                  strHTML += '<td><textarea rows="1" column="' + element.internalData.arrColumnNames[cell_i] + '">' +
                                  encodeHTML(GS.decodeFromTabDelimited(arrCells[cell_i], element.nullString) || '') +
                              '</textarea></td>';
              }
              
              strHTML += '</tr>';
          }
          
          
          //    strHTML = GS.templateWithEnvelopeData(element.tableTemplate.templateHTML, {
          //                        'arr_column': data.arrColumnNames
          //                      , 'dat': element.internalData.arrRecords
          //              }, intStart, element.internalData.arrRecords.length);
          //    
          //    strHTML = GS.templateShowSubTemplates(strHTML, element.tableTemplate);
          //
          //trMaker.children[0].classList.add('insert-record');
          
          return strHTML;
      }
      
      function handleData(element, data, bolFirstLoad, bolManualRefresh) {
          var strHTML, i, len, cell_i, cell_len, col_len, arrRecords
            , arrCells, disabled, arrColumns, arrElements, tbodyElement
            , trMaker, intStart, bolHeader, strWidth, numberOffset;
          
          // calculate the number of cells across
          if (element.getAttribute('cols')) {
              //col_len = (element.getAttribute('cols') || '').split(/[\s]*,[\s]*/).length;
              
              arrColumns = (element.getAttribute('cols') || '').split(/[\s]*,[\s]*/);
              
              for (i = 0, len = arrColumns.length; i < len; i += 1) {
                  arrColumns[i] = data.arrColumnNames.indexOf(arrColumns[i]);
              }
          }
          
          disabled = element.hasAttribute('disabled') || !element.hasAttribute('pk');
          
          // if first callback: table and header
          if (data.intCallback === 0) {
              if (!element.hasAttribute('lock')) {
                  element.setAttribute('lock', data.arrColumnNames.join(','));
              }
              if (!element.hasAttribute('cols')) {
                  element.setAttribute('cols', data.arrColumnNames.join(','));
              }
              if (disabled) {
                  element.deleteButton.setAttribute('disabled', '');
              } else {
                  element.deleteButton.removeAttribute('disabled');
              }
              
              element.internalData = {
                  'arrColumnNames': data.arrColumnNames || []
                , 'arrColumnTypes': data.arrColumnTypes || []
                , 'arrRecords': []
              };
              
              if (element.headerTemplateRecord) {
                  strHTML = GS.templateWithQuerystring(element.headerTemplateRecord);
                  element.scrollContainer.innerHTML = '<table><thead>' + strHTML + '</thead><tbody></tbody></table>';
                  
              } else {
                  arrElements = xtag.queryChildren(element.tableTemplateRecord, 'td, th');
                  for (i = 0, len = arrElements.length, strHTML = ''; i < len; i += 1) {
                      strHTML += '<th>' + encodeHTML(arrElements[i].getAttribute('heading') || '') + '</th>';
                      
                      bolHeader = Boolean(arrElements[i].hasAttribute('heading') || '') || bolHeader;
                  }
                  strHTML = '<tr>' + strHTML + '</tr>';
                  
                  if (bolHeader) {
                      element.scrollContainer.innerHTML = '<table><thead>' + strHTML + '</thead><tbody></tbody></table>';
                  } else {
                      element.scrollContainer.innerHTML = '<table><thead hidden>' + strHTML + '</thead><tbody></tbody></table>';
                  }
              }
          }
          
          // if not last callback: append data to end of table
          if (data.strMessage !== 'TRANSACTION COMPLETED') {
              arrRecords = data.strMessage.split('\n');
              
              intStart = element.internalData.arrRecords.length;
              
              for (i = 0, len = arrRecords.length - 1, strHTML = ''; i < len; i += 1) {
                  arrCells = arrRecords[i].split('\t');
                  
                  for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                      arrCells[cell_i] = GS.decodeFromTabDelimited(arrCells[cell_i], element.nullString);
                  }
                  
                  element.internalData.arrRecords.push(arrCells);
              }
              
              if (element.paginated === true && !isNaN(element.getAttribute('offset'))) {
                  numberOffset = parseInt(element.getAttribute('offset'), 10);
              } else {
                  numberOffset = 0
              }
              
              strHTML = GS.templateWithEnvelopeData(
                          element.tableTemplate.templateHTML
                        , {
                              'arr_column': data.arrColumnNames
                            , 'dat': element.internalData.arrRecords
                          }
                        , intStart
                        , element.internalData.arrRecords.length
                        , numberOffset);
              
              strHTML = GS.templateShowSubTemplates(strHTML, element.tableTemplate);
              
              trMaker = document.createElement('tbody');
              trMaker.innerHTML = strHTML;
              tbodyElement = xtag.query(element.scrollContainer, 'tbody')[0];
              
              arrElements = xtag.toArray(trMaker.children);
              for (i = 0, len = arrElements.length; i < len; i += 1) {
                  tbodyElement.appendChild(arrElements[i]);
              }
              //xtag.query(element.scrollContainer, 'tbody')[0].innerHTML += strHTML;
              
          // if last callback: insert record
          } else {
              arrElements = xtag.query(element.scrollContainer, 'tbody tr');
              
              if (arrElements[0] && arrElements[0].children[0].nodeName === 'TH' && !isNaN(arrElements[0].children[0].textContent)) {
                  
                  strWidth = (
                                  GS.pxToEm(element.hudContainer,
                                      GS.getTextWidth(element.hudContainer,
                                          String(element.internalData.arrRecords.length + 1)
                                      )
                                  ) + 1
                              ) + 'em';
                  
                  xtag.query(element.scrollContainer, 'thead th')[0].style.width = strWidth;
                  xtag.query(element.scrollContainer, 'tbody th')[0].style.width = strWidth;
              }
              
              if (parseInt((element.getAttribute('limit') || '0'), 10) > arrElements.length) {
                  element.pageRightButton.setAttribute('disabled', '');
              } else {
                  element.pageRightButton.removeAttribute('disabled');
              }
              
              //if (element.insertRecordElement) {
              //    trMaker = document.createElement('tbody');
              //    trMaker.innerHTML = element.insertRecordElement.outerHTML;
              //    trMaker.children[0].classList.add('insert-record');
              //    tbodyElement = xtag.query(element.scrollContainer, 'tbody')[0];
              //    
              //    //if (tbodyElement.children[0]) {
              //    //    tbodyElement.insertBefore(trMaker.children[0], tbodyElement.children[0]);
              //    //} else {
              //    tbodyElement.appendChild(trMaker.children[0]);
              //    //}
              //}
              
              arrElements = xtag.query(element.scrollContainer, 'tr');
              
              if (arrElements[0].parentNode.hasAttribute('hidden')) {
                  element.headerContainer.innerHTML = '<table><thead hidden>' + arrElements[0].outerHTML + '</thead></table>';
              } else {
                  element.headerContainer.innerHTML = '<table><thead>' + arrElements[0].outerHTML + '</thead></table>';
              }
              
              element.headerTR = element.headerContainer.children[0].children[0].children[0];
              
              refreshReflow(element);
              refreshHeight(element);
              synchronize(element, undefined, true, bolManualRefresh);
              synchronizeHeaderWidths(element);
              synchronizeHeaderScroll(element);
              
              if (bolFirstLoad && element.hasAttribute('scroll-to-bottom')) {
                  element.scrollContainer.scrollTop = element.scrollContainer.scrollHeight;
              }
              
              GS.triggerEvent(element, 'after_select');
          }
      }
      
      function synchronizeHeaderWidths(element) {
          'use strict';
          var guideTR, targetTR, arrChildren, i, len, subtractPadding;
          
          targetTR = element.headerTR;
          if (element.scrollContainer) {
              guideTR = xtag.query(element.scrollContainer, 'tr')[0];
              
              if (guideTR) {
                  arrChildren = xtag.toArray(guideTR.children);
                  subtractPadding = 0; //GS.emToPx(element.headerContainer, 0.2);
                  
                  if (element.scrollContainer.scrollHeight > element.scrollContainer.clientHeight) {
                      element.headerContainer.classList.add('scroll');
                  } else {
                      element.headerContainer.classList.remove('scroll');
                  }
                  
                  for (i = 0, len = arrChildren.length; i < len; i += 1) {
                      targetTR.children[i].style.width = (arrChildren[i].clientWidth - subtractPadding) + 'px';
                  }
              }
          }
      }
      function synchronizeHeaderScroll(element) {
          'use strict';
          if (element.headerContainer && element.scrollContainer) {
              if (element.scrollContainer.scrollTop > 0) {
                  element.headerContainer.classList.add('shadow');
              } else {
                  element.headerContainer.classList.remove('shadow');
              }
              element.headerContainer.scrollLeft = element.scrollContainer.scrollLeft;
          }
      }
      
      
      // get return column list
      function getReturn(element) {
          var arrColumns = [], arrSupplementalColumns = [], arrColsAttr, strColumns, arrPK, arrLock, i, len;
          
          // pk
          arrPK = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
          
          for (i = 0, len = arrPK.length; i < len; i += 1) {
              if (arrPK[i]) {
                  GS.listAdd(arrSupplementalColumns, arrPK[i]);
              }
          }
          
          // lock
          arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);
          
          for (i = 0, len = arrLock.length; i < len; i += 1) {
              if (arrLock[i]) {
                  GS.listAdd(arrSupplementalColumns, arrLock[i]);
              }
          }
          
          if (element.internalData && element.internalData.arrColumnNames) {
              for (i = 0, len = element.internalData.arrColumnNames.length; i < len; i += 1) {
                  GS.listAdd(arrColumns, element.internalData.arrColumnNames[i]);
              }
          } else if (element.getAttribute('cols')) {
              arrColsAttr = element.getAttribute('cols').split(/[\s]*,[\s]*/);
              
              for (i = 0, len = arrColsAttr.length; i < len; i += 1) {
                  GS.listAdd(arrColumns, arrColsAttr[i]);
              }
          }
          
          if (arrColumns.length === 0 || (arrColumns.length === 1 && arrColumns[0] === '*')) {
              strColumns = '*';
              
          } else {
              for (i = 0, len = arrSupplementalColumns.length; i < len; i += 1) {
                  GS.listAdd(arrColumns, arrSupplementalColumns[i]);
              }
              
              strColumns = arrColumns.join('\t');
          }
          
          return strColumns;
      }
      
      function valueListToHTML(valueText, fieldDelimiter, recordDelimiter, bolFirstContainsHeadings, quoteCharacter, decodeFunction) {
          var i = 0, len = valueText.length, col_i, col_len,
              arrHeadings = [], arrRecords = [], arrRecord = [],
              bolInQuote = false,
              strCell = '',
              strRecord,
              strHTML = '', strPreviousChar;
          
          // if there is a recordDelimiter at the beginning: add 1 to "i" to skip over it
          if (valueText[0] === recordDelimiter) {
              i += 1;
          }
          
          // make sure there is a recordDelimiter at the end
          if (valueText[len - 1] !== recordDelimiter) {
              valueText += recordDelimiter;
              len = valueText.length;
          }
          
          // looper
          for (; i < len; i += 1) {
              if (valueText[i] === quoteCharacter && bolInQuote === false
                  && (
                      strPreviousChar === fieldDelimiter ||
                      strPreviousChar === recordDelimiter ||
                      strPreviousChar === undefined
                  )) {
                  bolInQuote = true;
                  
              } else if (valueText[i] === quoteCharacter && bolInQuote === true) {
                  bolInQuote = false;
                  
              } else if (valueText[i] === fieldDelimiter && bolInQuote === false) {
                  arrRecord.push(decodeFunction(strCell, element.nullString));
                  strCell = '';
                  
              } else if (valueText[i] === recordDelimiter && bolInQuote === false) {
                  arrRecord.push(decodeFunction(strCell, element.nullString));
                  strCell = '';
                  
                  arrRecords.push(arrRecord);
                  arrRecord = [];
                  
              } else {
                  strCell += valueText[i];
              }
              
              strPreviousChar = valueText[i];
          }
          
          // data structure to html
          for (i = 0, len = arrRecords.length; i < len; i += 1) {
              for (col_i = 0, col_len = arrRecords[i].length, strRecord = ''; col_i < col_len; col_i += 1) {
                  strRecord += '<td>' + encodeHTML(arrRecords[i][col_i]) + '</td>';
              }
              
              strHTML += '<tr>' + strRecord + '</tr>';
          }
          
          return '<table>' + strHTML + '</table>';
      }
      
      function quoteIdent(strValue) {
          strValue = strValue || '';
          
          // if first char is not a lowercase letter or there is a character that is not a lowercase letter, underscore or number
          if (!(/[a-z]/).test(strValue[0]) || (/[^a-z_]/).test(strValue)) {
              strValue = '"' + strValue.replace(/\"/gim, '""') + '"';
          }
          
          return strValue;
      }
      
      // disfated's answer at: http://stackoverflow.com/questions/202605/repeat-string-javascript
      function stringRepeat(pattern, count) {
          if (count < 1) return '';
          var result = '';
          while (count > 1) {
              if (count & 1) result += pattern;
              count >>= 1, pattern += pattern;
          }
          return result + pattern;
      }
      
      function getSocket(element) {
          if (element.getAttribute('socket')) {
              return GS[element.getAttribute('socket')];
          }
          return GS.envSocket;
      }
      
      function getData(element, refocusSelector, refocusSelection, bolFirstLoad, bolManualRefresh) {
          var strSchema = GS.templateWithQuerystring(element.getAttribute('schema') || '')
            , strObject = GS.templateWithQuerystring(element.getAttribute('object') || '')
            , strReturn = getReturn(element) || ''
            , strWhere  = GS.templateWithQuerystring(element.getAttribute('where')  || '1=1')
            , strOrd    = GS.templateWithQuerystring(element.getAttribute('ord')    || '')
            , strLimit  = GS.templateWithQuerystring(element.getAttribute('limit')  || '')
            , strOffset = GS.templateWithQuerystring(element.getAttribute('offset') || '0')
            , strWhereColumn;
          
          // add in user where, if any
          if (element.getAttribute('user-where')) {
              strWhere = '(' + element.getAttribute('user-where') + ')' + (strWhere ? ' AND ' + strWhere : '');
          }
          
          // add in a column or qs where, if any
          
          // if there is a column attribute on element element: combine the where attribute with a where generated by value
          if ((element.getAttribute('column') || element.getAttribute('qs')) && element.value) {
              strWhereColumn = element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs');
              
              if (isNaN(element.value)) {
                  strWhere =
                      'CAST(' + strWhereColumn + ' AS ' + GS.database.type.text + ') = ' +
                      'CAST($WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')' +
                      (strWhere !== '' ? ' AND (' + strWhere + ')' : '');
              } else {
                  strWhere = strWhereColumn + '=' + (element.value) + (strWhere !== '' ? ' AND (' + strWhere + ')' : '');
              }
          }
          
          // disabled, hide or not the pageinate buttons
          if (strLimit === '') {
              element.pageLeftButton.setAttribute('hidden', '');
              element.pageRightButton.setAttribute('hidden', '');
          } else if (strOffset === '' || strOffset === '0') {
              element.pageLeftButton.setAttribute('disabled', '');
          }
          
          GS.addLoader(element, 'Loading...');
          GS.requestSelectFromSocket(
                          getSocket(element), strSchema, strObject, strReturn
                        , strWhere, strOrd, strLimit, strOffset
            , function (data, error) {
                  var refocusElement;
                  
                  if (!error) {
                      handleData(element, data, bolFirstLoad, bolManualRefresh);
                      
                      if (data.strMessage === 'TRANSACTION COMPLETED') {
                          GS.removeLoader(element);
                      }
                      
                      if (data.strMessage === 'TRANSACTION COMPLETED' && refocusSelector) {
                          refocusElement = xtag.query(element, refocusSelector)[0];
                          
                          if (refocusElement) {
                              refocusElement.focus();
                              
                              if (refocusSelection) {
                                  GS.setInputSelection(refocusElement, refocusSelection.start, refocusSelection.end);
                              }
                          }
                      }
                      
                  } else {
                      GS.removeLoader(element);
                      if (!element.scrollContainer.innerHTML) {
                          element.scrollContainer.innerHTML = '<' + 'center><h2>Couldn\'t Load Data.</h2></' + 'center>';
                      }
                      GS.webSocketErrorDialog(data);
                  }
              }
          );
      }
      
      
      function getSelectedCopyHTML(element) {
          var strHTMLCopyString, intFromRecord, intToRecord, intFromCell = 9999999, intToCell = 0
            , i, len, cell_i, cell_len, arrSelected, strCellHTML, arrRecords, arrCells
            , strHTMLRecordString;
          
          arrSelected = element.selectedCells;
          
          // loop through the selected cells and create an html string using the text of the cell
          if (arrSelected.length > 0) {
              intFromRecord = arrSelected[0].parentNode.rowIndex;
              intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;
              
              for (i = 0, len = arrSelected.length; i < len; i += 1) {
                  if (arrSelected[i].cellIndex < intFromCell) {
                      intFromCell = arrSelected[i].cellIndex;
                      intFromCell = (intFromCell === 0 ? 1 : intFromCell);
                  }
                  if (arrSelected[i].cellIndex + 1 > intToCell) {
                      intToCell = arrSelected[i].cellIndex + 1;
                  }
              }
              
              arrRecords = xtag.query(element, 'tr');
              strHTMLCopyString = '';
              
              for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                  arrCells = arrRecords[i].children;
                  strHTMLRecordString = '';
                  
                  if (!arrRecords[i].classList.contains('insert-record')) {
                      for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                          strCellHTML = '';
                          
                          if (arrCells[cell_i].hasAttribute('selected')) {
                              if (arrCells[cell_i].lastElementChild) { 
                                  strCellHTML = arrCells[cell_i].lastElementChild.textValue ||
                                                arrCells[cell_i].lastElementChild.value ||
                                                (arrCells[cell_i].lastElementChild.checked || '').toString();
                              } else {
                                  strCellHTML = arrCells[cell_i].textContent.trim();
                              }
                              
                              strCellHTML = encodeHTML(strCellHTML).replace(/\n/gim, '<br />');
                          }
                          
                          strCellHTML = '<' + 'td rowspan="1" colspan="1">' + (strCellHTML || '') + '</td>'
                          
                          strHTMLRecordString += (cell_i === intFromCell ? '<' + 'tr>' : '');
                          strHTMLRecordString += (strCellHTML || '');
                          strHTMLRecordString += (cell_i === (intToCell - 1) ? '<' + '/tr>' : '');
                      }
                  }
                  if (strHTMLRecordString.trim()) {
                      strHTMLCopyString += strHTMLRecordString;
                  }
              }
              
              if (strHTMLCopyString) {
                  strHTMLCopyString = '<' + 'style>' +
                                          'br { mso-data-placement:same-cell; } ' +
                                          'th, td { white-space: pre-wrap; }' +
                                      '<' + '/style>' +
                                      '<' + 'table border="0" cellpadding="0" cellspacing="0">' + strHTMLCopyString + '<' + '/table>';
              }
          }
          
          return strHTMLCopyString || '';
      }
      
      function getSelectedCopyText(element) {
          var strTextCopyString, intFromRecord, intToRecord, intFromCell = 9999999, intToCell = 0,
              i, len, cell_i, cell_len, arrSelected, strCellText, arrRecords, arrCells, arrCellIndexes, strTextRecordString;
          
          arrSelected = element.selectedCells;
          
          // loop through the selected cells and create a tsv string using the text of the cell
          if (arrSelected.length > 0) {
              intFromRecord = arrSelected[0].parentNode.rowIndex;
              intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;
              
              for (i = 0, len = arrSelected.length; i < len; i += 1) {
                  if (arrSelected[i].cellIndex < intFromCell) {
                      intFromCell = arrSelected[i].cellIndex;
                      intFromCell = (intFromCell === 0 ? 1 : intFromCell);
                  }
                  if (arrSelected[i].cellIndex + 1 > intToCell) {
                      intToCell = arrSelected[i].cellIndex + 1;
                  }
              }
              
              arrRecords = xtag.query(element, 'tr');
              strTextCopyString = '';
              
              for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                  arrCells = arrRecords[i].children;
                  strTextRecordString = '';
                  
                  for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                      if (!arrCells[cell_i].parentNode.classList.contains('insert-record')) {
                          strCellText = '';
                          
                          if (arrCells[cell_i].hasAttribute('selected')) {
                              if (arrCells[cell_i].lastElementChild) { 
                                  strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                                arrCells[cell_i].lastElementChild.value ||
                                                (arrCells[cell_i].lastElementChild.checked || '').toString();
                              } else {
                                  strCellText = arrCells[cell_i].textContent.trim();
                              }
                              
                              strCellText = strCellText.replace(/\"/gim, '""');
                          }
                          
                          strTextRecordString += (cell_i !== intFromCell ? '\t' : '');
                          strTextRecordString += (strCellText || '');
                      }
                  }
                  //if (strTextRecordString.trim()) {
                  strTextCopyString += strTextRecordString;
                  //}
                  if (i + 1 !== len) { //&& strTextRecordString.trim()
                      strTextCopyString += '\n';
                  }
              }
          }
          
          return strTextCopyString || '';
      }
      
      function handleClipboardData(event, strCopyString, strType) {
          var clipboardData = event.clipboardData || window.clipboardData, strMime;
          
          if (!clipboardData) { return; }
          if (!clipboardData.setData) { return; }
          
          if (strType === 'text') {
              if (window.clipboardData && window.clipboardData.getData) { // IE
                  strMime = 'Text';
              } else if (event.clipboardData && event.clipboardData.getData) {
                  strMime = 'text/plain';
              }
              
          } else if (strType === 'html') {
              if (window.clipboardData && window.clipboardData.getData) { // IE
                  strMime = '';
              } else if (event.clipboardData && event.clipboardData.getData) {
                  strMime = 'text/html';
              }
              
          } else {
              throw 'handleClipboardData Error: Type "' + strType + '" not recognized, recognized types are "text" and "html".';
          }
          
          if (strMime) {
              if (strCopyString && strMime) {
                  return clipboardData.setData(strMime, strCopyString) !== false;
              } else {
                  return clipboardData.getData(strMime);
              }
          }
      }
      
      
      function selectHandler(element, dragOriginCell, dragCurrentCell, dragMode) {
          var arrRecords = xtag.query(element, 'tr'), arrCells = xtag.query(element, 'td, th'),
              dragOriginRecord = dragOriginCell.parentNode,
              dragCurrentRecord = dragCurrentCell.parentNode,
              intStartRecordIndex, intStartCellIndex, intEndRecordIndex, intEndCellIndex,
              i, len, col_i, col_len, selectionIndex;
          
          // if origin & currentCell are both the top-left cell and the cell is a heading: select all cells
          if (dragOriginRecord.rowIndex === 0 && dragCurrentRecord.rowIndex === 0 &&
              dragOriginCell.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
              intStartRecordIndex = 0;
              intStartCellIndex = 0;
              intEndRecordIndex = arrRecords.length - 1;
              intEndCellIndex = arrRecords[0].children.length - 1;
              
          // else if origin is a first th: select the records from origin to currentCell
          } else if (dragOriginCell.cellIndex === 0) {
              intStartRecordIndex = Math.min(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
              intStartCellIndex = 0;
              intEndRecordIndex = Math.max(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
              intEndCellIndex = arrRecords[0].children.length - 1;
              
          // else if origin is a heading: select the columns from origin to currentCell
          } else if (dragOriginRecord.rowIndex === 0) {
              intStartRecordIndex = 0;
              intStartCellIndex = Math.min(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);
              intEndRecordIndex = arrRecords.length - 1;
              intEndCellIndex = Math.max(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);
              
          // else select cells from origin to currentCell
          } else {
              intStartRecordIndex = Math.min(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
              intStartCellIndex = Math.min(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);
              intEndRecordIndex = Math.max(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
              intEndCellIndex = Math.max(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);
          }
          
          element.savedSelection = element.savedSelectionCopy.slice(0);
          
          if (dragMode === 'select') {
              for (i = intStartRecordIndex, len = intEndRecordIndex + 1; i < len; i += 1) {
                  for (col_i = intStartCellIndex, col_len = intEndCellIndex + 1; col_i < col_len; col_i += 1) {
                      if (element.savedSelection.indexOf(i + ',' + col_i) === -1) {
                          element.savedSelection.push(i + ',' + col_i);
                      }
                  }
              }
              
          } else { // implied if: dragMode === 'deselect'
              for (i = intStartRecordIndex, len = intEndRecordIndex + 1; i < len; i += 1) {
                  for (col_i = intStartCellIndex, col_len = intEndCellIndex + 1; col_i < col_len; col_i += 1) {
                      selectionIndex = element.savedSelection.indexOf(i + ',' + col_i);
                      
                      if (selectionIndex > -1) {
                          element.savedSelection.splice(selectionIndex, 1);
                      }
                  }
              }
          }
          
          synchronize(element);
      }
      
      function synchronize(element, bolScroll, bolOnLoad, bolManualRefresh) {
          var arrRecords = xtag.query(element, 'tr'), selectCells = [], i, len,
              arrParts, arrTextareas, focusedElement, recordIndex, cellIndex;
          
          // selection
          if (element.savedSelection) {
              // loop through savedSelection
              for (i = 0, len = element.savedSelection.length; i < len; i += 1) {
                  // any cell position that is in saved selection gets added to the selectCells
                  arrParts = element.savedSelection[i].split(',');
                  recordIndex = parseInt(arrParts[0], 10);
                  cellIndex = parseInt(arrParts[1], 10);
                  
                  if (recordIndex < arrRecords.length && cellIndex < arrRecords[0].children.length) {
                      selectCells.push(arrRecords[recordIndex].children[cellIndex]);
                  }
              }
              
              // select cells
              element.selectedCells = selectCells;
          }
          
          // focus
          if (element.lastFocusedControl) {
              element.lastFocusedControl.focus();
              focusedElement = element.lastFocusedControl;
          } else if (!bolOnLoad || bolManualRefresh) {
              focusedElement = element.copyControl;
              element.copyControl.focus();
          }
          
          // if there was no control to focus and
          //      there is a selection and
          //      bolScroll is true: scroll to selected
          if (!element.lastFocusedControl && element.selectedCells.length > 0 && bolScroll) {
              GS.scrollIntoView(element.selectedCells[0].parentNode);
          }
          
          // if there was a control and bolScroll is true: scroll to focused record
          if (focusedElement && bolScroll) {
              GS.scrollIntoView(GS.findParentElement(document.activeElement, 'tr'));
          }
          
          if (focusedElement && element.lastTextSelection) {
              GS.setInputSelection(focusedElement, element.lastTextSelection.start, element.lastTextSelection.end);
          }
      }
      
      function clearRecordColor(element, strClass, bolGreenFade) {
          var arrElements = xtag.query(element, 'tr.' + strClass), i, len;
          
          if (bolGreenFade) {
              for (i = 0, len = arrElements.length; i < len; i += 1) {
                  arrElements[i].classList.remove(strClass);
                  arrElements[i].classList.add('bg-green-fade');
              }
              
              setTimeout(function () {
                  for (i = 0, len = arrElements.length; i < len; i += 1) {
                      arrElements[i].classList.remove('bg-green-fade');
                  }
              }, 1000);
              
          } else {
              for (i = 0, len = arrElements.length; i < len; i += 1) {
                  arrElements[i].classList.remove(strClass);
              }
          }
      }
      
      function removeRecords(element, strClass) {
          var arrElements = xtag.query(element, 'tr.' + strClass), i, len;
          
          for (i = 0, len = arrElements.length; i < len; i += 1) {
              arrElements[i].parentNode.removeChild(arrElements[i]);
          }
      }
      
      function insertRecords(element, strColumns, strInsertData, strLocalData, bolDialog) {
          var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'))
            , strObject = GS.templateWithQuerystring(element.getAttribute('object'))
            , templateElement, strSeq, arrSeq, strPk, arrPk
            , strColumn, arrColumns, i, len, col_i, col_len
            , tbodyElement, arrElements, insertRecord;
          
          arrSeq = (GS.templateWithQuerystring(element.getAttribute('seq') || '')).split(/[\s]*,[\s]*/);
          arrPk = (GS.templateWithQuerystring(element.getAttribute('pk') || '')).split(/[\s]*,[\s]*/);
          
          arrColumns = strColumns.split('\t');
          for (i = 0, len = arrColumns.length; i < len; i += 1) {
              strColumn = GS.decodeFromTabDelimited(arrColumns[i], element.nullString);
              
              if (arrSeq.indexOf(strColumn) > -1) {
                  arrSeq[arrSeq.indexOf(strColumn)] = '';
              }
          }
          
          //console.log(getReturn(element) + '\n' + strLocalData);
          
          // template local record data
          tbodyElement = document.createElement('tbody');
          tbodyElement.innerHTML = templateRecordsForInsert(element, strColumns + '\n' + strLocalData, 'bg-red');
          
          // add local records to the table before the insert record
          arrElements = xtag.toArray(tbodyElement.children);
          insertRecord = xtag.query(element, 'tr.insert-record')[0];
          
          for (i = 0, len = arrElements.length; i < len; i += 1) {
              insertRecord.parentNode.insertBefore(arrElements[i], insertRecord);
          }
          
          // scroll all the way down
          element.scrollContainer.scrollTop = element.scrollContainer.scrollHeight;
          
          // get pk and sequence values
          for (i = 0, len = arrPk.length, strPk = ''; i < len; i += 1) {
              strPk += (strPk ? '\t' : '') + GS.encodeForTabDelimited(arrPk[i], element.nullString);
          }
          
          for (i = 0, len = arrSeq.length, strSeq = ''; i < len; i += 1) {
              if (arrColumns.indexOf(arrPk[i]) > -1) {
                  strSeq += (i === 0 ? '' : '\t') + '';
              } else {
                  strSeq += (i === 0 ? '' : '\t') + GS.encodeForTabDelimited(arrSeq[i], element.nullString);
              }
          }
          
          strInsertData = strColumns + '\n' + strInsertData;
          
          GS.addLoader(element, 'Creating Insert Transaction...');
          GS.requestInsertFromSocket(
              getSocket(element), strSchema, strObject, getReturn(element), strPk, strSeq, strInsertData
              , function (data, error) {
                  if (error) {
                      removeRecords(element, 'bg-red');
                      GS.removeLoader(element);
                      GS.webSocketErrorDialog(data);
                  }
              }
              , function (data, error, transactionID, commitFunction, rollbackFunction) {
                  var tbodyElement, arrElements, arrReplaceElements, i, len, templateElement;
                  
                  GS.removeLoader(element);
                  
                  if (!error) {
                      if (data !== 'TRANSACTION COMPLETED') {
                          data = getReturn(element) + '\n' + data;
                          
                          // replace red records with amber records
                          tbodyElement = document.createElement('tbody');
                          tbodyElement.innerHTML = templateRecordsForInsert(element, data, 'bg-amber');
                          arrElements = xtag.toArray(tbodyElement.children);
                          arrReplaceElements = xtag.query(element, 'tr.bg-red');
                          
                          for (i = 0, len = arrElements.length; i < len; i += 1) {
                              arrReplaceElements[i].parentNode.replaceChild(arrElements[i], arrReplaceElements[i]);
                          }
                          
                      // open confirm message box
                      } else {
                          if (bolDialog) {
                              templateElement = document.createElement('template');
                              templateElement.innerHTML = ml(function () {/*
                                  <gs-page>
                                      <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                      <gs-body padded>
                                          <center>Are you sure you want create {{numberofrecords}} records?</center>
                                      </gs-body>
                                      <gs-footer>
                                          <gs-grid>
                                              <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                              <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                          </gs-grid>
                                      </gs-footer>
                                  </gs-page>
                              */}).replace(/\{\{numberofrecords\}\}/gi, xtag.query(element, '.bg-amber').length);
                              
                              GS.openDialog(templateElement, function () {
                                  document.getElementById('datasheet-focus-me').focus();
                                  
                              }, function (event, strAnswer) {
                                  if (strAnswer === 'Yes') {
                                      commitFunction();
                                      GS.addLoader(element, 'Commiting Insert...');
                                  } else {
                                      rollbackFunction();
                                      GS.addLoader(element, 'Rolling Back Insert...');
                                  }
                              });
                          } else {
                              commitFunction();
                          }
                      }
                      
                  } else {
                      removeRecords(element, 'bg-red');
                      rollbackFunction();
                      GS.webSocketErrorDialog(data);
                  }
              }
              , function (strAnswer, data, error) {
                  GS.removeLoader(element);
                  
                  if (!error) {
                      if (strAnswer === 'COMMIT') {
                          clearRecordColor(element, 'bg-amber', true);
                          GS.triggerEvent(element, 'after_insert');
                      } else {
                          removeRecords(element, 'bg-amber');
                      }
                  } else {
                      removeRecords(element, 'bg-red');
                      GS.webSocketErrorDialog(data);
                  }
              }
          );
      }
      
      
      function refreshRecordsAfterUpdate(element, arrRecordsToUpdate, data) {
          var arrColumns, arrRecords, arrValues, arrElements, arrColumnTypes,
              i, len, record_i, record_len, col_i, col_len, controlElement;
          
          // if last character is a \n: remove it
          if (data[data.length - 1] === '\n') {
              data = data.substring(0, data.length - 1);
          }
          
          // split records
          arrRecords = data.split('\n');
          
          // seperate first record (for column names)
          arrColumns = arrRecords[0].split('\t');
          arrRecords.splice(0, 1);
          
          // loop through each record
          len = arrRecordsToUpdate.length;
          record_len = arrRecords.length;
          i = 0;
          record_i = 0;
          while (i < len && record_i < record_len) {
              if (arrRecordsToUpdate[i].classList.contains('bg-red') && arrRecords[record_i]) {
                  arrRecordsToUpdate[i].classList.remove('bg-red');
                  arrRecordsToUpdate[i].classList.add('bg-amber');
                  
                  // build json row
                  arrValues = arrRecords[record_i].split('\t');
                  for (col_i = 0, col_len = arrValues.length; col_i < col_len; col_i += 1) {
                      arrRecordsToUpdate[i].setAttribute('data-' + arrColumns[col_i], GS.decodeFromTabDelimited(arrValues[col_i], element.nullString));
                      
                      controlElement = xtag.query(arrRecordsToUpdate[i], '[column="' + arrColumns[col_i] + '"]')[0];
                      if (controlElement) {
                          controlElement.value = GS.decodeFromTabDelimited(arrValues[col_i], element.nullString);
                      }
                  }
                  
                  record_i += 1;
              }
              i += 1;
          }
      }
      
      function updateRecords(element, strHashColumns, strUpdateData, arrUpdateRecords, bolDialog) {
          var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'))
            , strObject = GS.templateWithQuerystring(element.getAttribute('object'))
            , templateElement, i, len, refreshData;
          
          for (i = 0, len = arrUpdateRecords.length; i < len; i += 1) {
              arrUpdateRecords[i].classList.add('bg-red');
          }
          
          // create transaction
          GS.addLoader(element, 'Creating Update Transaction...');
          GS.requestUpdateFromSocket(
              getSocket(element), strSchema, strObject, getReturn(element), strHashColumns, strUpdateData
              , function (data, error, transactionID) {
                  if (error) {
                      getData(element);
                      GS.removeLoader(element);
                      GS.webSocketErrorDialog(data);
                  }
              }
              , function (data, error, transactionID, commitFunction, rollbackFunction) {
                  GS.removeLoader(element);
                  if (!error) {
                      if (data !== 'TRANSACTION COMPLETED') {
                          refreshData = data;
                          data = getReturn(element) + '\n' + data;
                          
                          // make the records amber and refresh their data
                          refreshRecordsAfterUpdate(element, arrUpdateRecords, data);
                          
                      // open confirm message box
                      } else {
                          if (bolDialog) {
                              templateElement = document.createElement('template');
                              templateElement.innerHTML = ml(function () {/*
                                  <gs-page>
                                      <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                      <gs-body padded>
                                          <center>Are you sure you want to update {{numberofrecords}} records?</center>
                                      </gs-body>
                                      <gs-footer>
                                          <gs-grid>
                                              <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                              <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                          </gs-grid>
                                      </gs-footer>
                                  </gs-page>
                              */}).replace(/\{\{numberofrecords\}\}/gi, xtag.query(element, '.bg-amber').length);
                              
                              GS.openDialog(templateElement, function () {
                                  document.getElementById('datasheet-focus-me').focus();
                                  
                              }, function (event, strAnswer) {
                                  if (strAnswer === 'Yes') {
                                      commitFunction();
                                      GS.addLoader(element, 'Commiting Update...');
                                  } else {
                                      rollbackFunction();
                                      GS.addLoader(element, 'Rolling Back Update...');
                                  }
                              });
                          } else {
                              commitFunction();
                          }
                      }
                      
                  } else {
                      rollbackFunction();
                      getData(element);
                      GS.webSocketErrorDialog(data);
                  }
              }
              , function (strAnswer, data, error) {
                  var arrRecords, arrCells, recordData, recordIndex, i, len, col_i, col_len;
                  
                  GS.removeLoader(element);
                  
                  if (!error) {
                      if (strAnswer === 'COMMIT') {
                          clearRecordColor(element, 'bg-amber', true);
                          
                          // refresh internal data
                          arrRecords = refreshData.split('\n');
                          
                          for (i = 0, len = arrUpdateRecords.length; i < len; i += 1) {
                              arrCells = arrRecords[i].split('\t');
                              recordIndex = parseInt(arrUpdateRecords[i].getAttribute('data-index'), 10);
                              
                              for (col_i = 0, col_len = arrCells.length; col_i < col_len; col_i += 1) {
                                  element.internalData.arrRecords[recordIndex][col_i] = GS.decodeFromTabDelimited(arrCells[col_i], element.nullString)
                              }
                          }
                          GS.triggerEvent(element, 'after_update');
                          
                      } else {
                          getData(element);
                      }
                  } else {
                      getData(element);
                      GS.webSocketErrorDialog(data);
                  }
              }
          );
      }
      
      function pasteHandler(element, event) {
          var clipboardData = (event.clipboardData || window.clipboardData)
            , templateElement = document.createElement('template')
            , pasteHTML, pastePlain, arrPasteRecords, arrSelectRecords, arrSetColumns
            , strColumn, strColumns, i, len, col_i, col_len, cell, arrPk, arrLock
            , strRecord, strInsertData, strLocalData, strLeftPad, strRightPad
            , strTemp, strRecordToHash, strHashColumns, strRoles, strUpdateData
            , arrRecords, arrUpdateRecords, arrUpdateColumns, updateRecord
            , updateRecordData, pasteElement;
          
          if (window.clipboardData) {
              pastePlain = clipboardData.getData('Text');
          } else {
              pasteHTML = clipboardData.getData('text/html');
              pastePlain = clipboardData.getData('Text');
          }
          
          // if no html: build HTML using plain
          if (!pasteHTML || (pasteHTML.indexOf('<' + 'table') === -1 && pasteHTML.indexOf('<' + 'tr') === -1)) {
              pasteHTML = valueListToHTML(pastePlain, '\t', '\n', false, '"', GS.decodeFromTabDelimited);
          }
          
          //console.log('HTML:', pasteHTML);
          //console.log('PLAIN:', pastePlain);
          
          // put HTML into a template element for traversal
          templateElement.innerHTML = pasteHTML;
          
          arrPasteRecords = xtag.query(xtag.query(templateElement.content, 'table')[0], 'tr');
          arrSelectRecords = element.selectedRecords;
          
          // if the first record is the header: remove it from the selection
          if (arrSelectRecords[0] && arrSelectRecords[0].parentNode.nodeName === 'THEAD') {
              arrSelectRecords.splice(0, 1);
          }
          
          if (element.numberOfSelections === 1) {
              arrSetColumns = xtag.query(arrSelectRecords[0], 'td[selected]');
              
              // if the selection starts on the insert record
              if (arrSelectRecords[0].classList.contains('insert-record')) {
                  strColumns = '';
                  for (i = 0, len = Math.min(arrSetColumns.length, arrPasteRecords[0].children.length); i < len; i += 1) {
                      strColumn = arrSetColumns[i].children[0].getAttribute('column');
                      strColumns += (strColumns ? '\t' : '') + strColumn;
                  }
                  
                  // extract data from paste HTML
                  strLeftPad = stringRepeat('\t', arrSetColumns[0].cellIndex - 1);
                  strRightPad = stringRepeat('\t', (element.internalData.arrColumnNames.length - ((arrSetColumns[0].cellIndex - 1) + arrSetColumns.length)));
                  
                  for (i = 0, len = arrPasteRecords.length, strInsertData = '', strLocalData = ''; i < len; i += 1) {
                      for (col_i = 0, col_len = arrSetColumns.length, strRecord = ''; col_i < col_len; col_i += 1) {
                          cell = arrPasteRecords[i].children[col_i];
                          strRecord += (strRecord ? '\t' : '') + GS.encodeForTabDelimited(cell.innerText || cell.textContent, element.nullString);
                      }
                      
                      strInsertData += strRecord + '\n';
                      strLocalData += strLeftPad + strRecord + strRightPad + '\n';
                  }
                  
                  insertRecords(element, strColumns, strInsertData, strLocalData, (arrPasteRecords.length > 1));
                  
              // else (if the selection starts on an update record)
              } else {
                  // if the last record is the insert: remove it from the selection
                  if (arrSelectRecords[arrSelectRecords.length - 1].parentNode.nodeName === 'THEAD') {
                      arrSelectRecords.pop();
                  }
                  
                  arrPk = (GS.templateWithQuerystring(element.getAttribute('pk') || '')).split(/[\s]*,[\s]*/);
                  arrLock = (GS.templateWithQuerystring(element.getAttribute('lock') || '')).split(/[\s]*,[\s]*/);
                  
                  // gathering update headers
                  for (i = 0, len = arrPk.length, strRoles = '', strColumns = ''; i < len; i += 1) {
                      strRoles += (strRoles ? '\t' : '') + 'pk';
                      strColumns += (strColumns ? '\t' : '') + arrPk[i];
                  }
                  
                  for (i = 0, len = arrLock.length, strHashColumns = ''; i < len; i += 1) {
                      strHashColumns += (strHashColumns ? '\t' : '') + arrLock[i];
                  }
                  strRoles += (strRoles ? '\t' : '') + 'hash';
                  strColumns += (strColumns ? '\t' : '') + 'hash';
                  
                  arrUpdateColumns = [];
                  for (i = 0, len = Math.min(arrSetColumns.length, arrPasteRecords[0].children.length); i < len; i += 1) {
                      pasteElement = xtag.query(arrSetColumns[i], '[column]')[0];//arrSetColumns[i].children[0];
                      
                      if (pasteElement) {
                          strColumn = pasteElement.getAttribute('column');
                          
                          strRoles += (strRoles ? '\t' : '') + 'set';
                          strColumns += (strColumns ? '\t' : '') + strColumn;
                          
                          arrUpdateColumns.push(strColumn);
                      }
                  }
                  
                  arrUpdateRecords = [];
                  for (i = 0, len = Math.min(arrSelectRecords.length, arrPasteRecords.length), strUpdateData = ''; i < len; i += 1) {
                      strRecord = '';
                      updateRecord = arrSelectRecords[i];
                      updateRecordData = element.internalData.arrRecords[parseInt(updateRecord.getAttribute('data-index'), 10)];
                      
                      // get 'pk' columns
                      for (col_i = 0, col_len = arrPk.length; col_i < col_len; col_i += 1) {
                          strRecord += (strRecord ? '\t' : '');
                          strRecord += GS.encodeForTabDelimited(updateRecordData[element.internalData.arrColumnNames.indexOf(arrPk[col_i])], element.nullString);
                      }
                      
                      // get 'hash' columns
                      strRecordToHash = '';
                      for (col_i = 0, col_len = arrLock.length; col_i < col_len; col_i += 1) {
                          strRecordToHash += (strRecordToHash ? '\t' : '');
                          strTemp = updateRecordData[element.internalData.arrColumnNames.indexOf(arrLock[col_i])];
                          strRecordToHash += (strTemp === 'NULL' ? '' : strTemp);
                      }
                      
                      strRecord += (strRecord ? '\t' : '') + GS.utfSafeMD5(strRecordToHash).toString();
                      
                      // get 'set' columns
                      for (col_i = 0, col_len = arrSetColumns.length; col_i < col_len; col_i += 1) {
                          pasteElement = xtag.query(arrSetColumns[col_i], '[column]')[0];
                          
                          if (pasteElement) {
                              cell = arrPasteRecords[i].children[col_i];
                              strRecord += (strRecord ? '\t' : '') + GS.encodeForTabDelimited(cell.innerText || cell.textContent, element.nullString);
                          }
                      }
                      
                      strUpdateData += strRecord + '\n';
                      arrUpdateRecords.push(arrSelectRecords[i]);
                  }
                  
                  strUpdateData = (strRoles + '\n' + strColumns + '\n' + strUpdateData);
                  updateRecords(element, strHashColumns, strUpdateData, arrUpdateRecords, (arrPasteRecords.length > 1));
              }
          }
      }
      
      function refreshHeight(element) {
          var intHeight;
          
          if (element.hasAttribute('expand-to-content') &&
                  element.hudContainer &&
                  element.scrollContainer &&
                  element.scrollContainer.children[0]) {
              element.style.height = '';
              
              intHeight = (
                              element.hudContainer.scrollHeight +
                              element.scrollContainer.children[0].scrollHeight
                          );
              
              element.style.height = intHeight + 'px';
              element.style.height = (intHeight + (element.scrollContainer.scrollHeight - element.scrollContainer.clientHeight)) + 'px';
          }
      }
      
      function refreshReflow(element) {
          var strReflowAt = GS.templateWithQuerystring(element.getAttribute('reflow-at') || ''), intReflowAt, intElementWidth;
          
          if (strReflowAt) {
              intElementWidth = element.offsetWidth;
              intReflowAt = parseInt(strReflowAt, 10);
              
              if (intElementWidth < intReflowAt) {
                  element.dataContainer.classList.add('grid-reflow');
              } else {
                  element.dataContainer.classList.remove('grid-reflow');
              }
          } else {
              element.dataContainer.classList.remove('grid-reflow');
          }
      }
      
      
      // clean the slate and set initial html
      function prepareElement(element) {
          var tableTemplateElement, HUDTemplateElement, strHTML, recordElement, insertTemplateElement, arrParts
            , headerRecordElement;
          var i, len, arrElements, arrHeaderElements;
          var tempTemplateElement;
          
          // default pk and lock
          if (!element.hasAttribute('pk'))   { element.setAttribute('pk',   'id'); }
          if (!element.hasAttribute('lock')) { element.setAttribute('lock', 'change_stamp'); }
          
          // harvest the templates, error if problems
          tableTemplateElement = xtag.query(element, 'template[for="table"]')[0];
          HUDTemplateElement = xtag.query(element, 'template[for="hud"]')[0];
          insertTemplateElement = xtag.query(element, 'template[for="insert"]')[0];
          
          if (
              HUDTemplateElement &&
              (
                  HUDTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                  HUDTemplateElement.innerHTML.indexOf('&lt;') > -1
              )
          ) {
              console.warn('GS-DATASHEET WARNING: &gt; or &lt; detected in HUD template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
          }
          if (
              tableTemplateElement &&
              (
                  tableTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                  tableTemplateElement.innerHTML.indexOf('&lt;') > -1
              )
          ) {
              console.warn('GS-DATASHEET WARNING: &gt; or &lt; detected in table template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
          }
          if (
              insertTemplateElement &&
              (
                  insertTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                  insertTemplateElement.innerHTML.indexOf('&lt;') > -1
              )
          ) {
              console.warn('GS-DATASHEET WARNING: &gt; or &lt; detected in insert template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
          }
          
          if (!tableTemplateElement || tableTemplateElement.nodeName !== 'TEMPLATE') {
              throw 'gs-datasheet error: No table template provided.';
          }
          
          // V----- cannot do .children on template.content
          //if (tableTemplateElement.content.children[0].nodeName !== 'TABLE') {
          //    throw 'gs-datasheet error: Table is not the first element in the provided table template.';
          //}
          
          // make header template
          headerRecordElement = xtag.query(tableTemplateElement.content, 'thead tr')[0];
          if (headerRecordElement) {
              
              arrHeaderElements = xtag.query(headerRecordElement, 'td, th');
              arrElements = xtag.query(tableTemplateElement.content, 'tbody td, tbody th');
              
              for (i = 0, len = arrHeaderElements.length; i < len; i += 1) {
                  if (!arrElements[i].hasAttribute('heading')) {
                      arrElements[i].setAttribute('heading', arrHeaderElements[i].textContent);
                  }
              }
              
              element.headerTemplateRecord = headerRecordElement.outerHTML;
          }
          
          // make table template
          recordElement = xtag.query(tableTemplateElement.content, 'tbody tr')[0];
          recordElement.setAttribute('data-index', '{{= i }}');
          strHTML = GS.templateColumnToValue(tableTemplateElement.innerHTML);
          tempTemplateElement = document.createElement('template');
          tempTemplateElement.innerHTML = strHTML;
          recordElement = xtag.query(tempTemplateElement.content, 'tbody tr')[0];
          
          element.tableTemplate = GS.templateHideSubTemplates(recordElement.outerHTML, true);
          element.tableTemplateRecord = recordElement;
          
          if (insertTemplateElement && insertTemplateElement.innerHTML) {
              element.insertTemplate = insertTemplateElement.innerHTML;
          }
          
          // split schema and object
          arrParts = GS.templateWithQuerystring(element.getAttribute('src')).split('.');
          
          element.setAttribute('schema', arrParts[0]);
          element.setAttribute('object', arrParts[1]);
          
          // replace element inner html and create element variables
          strHTML = ml(function () {/*
              <div class="root" flex-vertical flex-fill>
                  <div class="hud-container">
                      <gs-button icon="refresh" remove-right icononly no-focus title="Refresh Data." class="refresh-button"></gs-button>
                      <gs-button icon="times" remove-left icononly no-focus title="Delete Selected Records." class="delete-button"></gs-button>
                      
                      <gs-button icon="plus" icononly no-focus title="Create Record." class="insert-button"></gs-button>
                      
                      <gs-button icon="backward" remove-right icononly no-focus title="Go to previous page." class="paginate-left"></gs-button>
                      <gs-button icon="forward" remove-left icononly no-focus title="Go to next page." class="paginate-right"></gs-button>
                      
                      {{HUDHTML}}
                      
                      <gs-button icon="filter" icononly no-focus title="Edit Filters." class="filter-button" hidden></gs-button>
                      <textarea class="hidden-focus-control">Focus Control</textarea>
                  </div>
                  <div class="data-container" flex>
                      <div class="data-flex-reset">
                          <div class="scroll-container"></div>
                          <div class="header-container"></div>
                          <div class="insert-container"></div>
                      </div>
                  </div>
              </div>
          */});
          
          if (HUDTemplateElement) {
              strHTML = strHTML.replace(/\{\{HUDHTML\}\}/gi, HUDTemplateElement.innerHTML);
          } else {
              strHTML = strHTML.replace(/\{\{HUDHTML\}\}/gi, '');
          }
          
          element.innerHTML = strHTML;
          
          element.root = element.children[0];
          
          element.hudContainer    = element.root.children[0];
          element.dataContainer   = element.root.children[1];
          
          element.dataFlexReset   = element.dataContainer.children[0];
          
          element.scrollContainer = element.dataFlexReset.children[0];
          element.headerContainer = element.dataFlexReset.children[1];
          element.insertContainer = element.dataFlexReset.children[2];
          
          element.refreshButton   = xtag.queryChildren(element.hudContainer, '.refresh-button')[0];
          element.deleteButton    = xtag.queryChildren(element.hudContainer, '.delete-button')[0];
          element.insertButton    = xtag.queryChildren(element.hudContainer, '.insert-button')[0];
          element.pageLeftButton  = xtag.queryChildren(element.hudContainer, '.paginate-left')[0];
          element.pageRightButton = xtag.queryChildren(element.hudContainer, '.paginate-right')[0];
          element.copyControl     = xtag.queryChildren(element.hudContainer, '.hidden-focus-control')[0];
          element.filterButton    = xtag.queryChildren(element.hudContainer, '.filter-button')[0];
          
          if (element.hasAttribute('no-huddelete') && element.hasAttribute('no-hudrefresh')) {
              element.hudContainer.removeChild(element.refreshButton);//.setAttribute('hidden', '');
              element.hudContainer.removeChild(element.deleteButton);//.setAttribute('hidden', '');
              
          } else if (element.hasAttribute('no-huddelete')) {
              element.hudContainer.removeChild(element.deleteButton);//.setAttribute('hidden', '');
              element.refreshButton.removeAttribute('remove-right');
              
          } else if (element.hasAttribute('no-hudrefresh')) {
              element.hudContainer.removeChild(element.refreshButton);//.setAttribute('hidden', '');
              element.deleteButton.removeAttribute('remove-left');
          }
          
          if (element.hasAttribute('no-hudpaginate')) {
              element.hudContainer.removeChild(element.pageLeftButton);//.setAttribute('hidden', '');
              element.hudContainer.removeChild(element.pageRightButton);//.setAttribute('hidden', '');
          }
          
          if (!element.insertTemplate) {
              element.insertButton.setAttribute('hidden', '');
          }
      }
      
      //function pushReplacePopHandler(element) {
      //    var i, len, arrPopKeys, currentValue, bolRefresh = false, strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
      //    
      //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.value = GS.qryGetVal(strQueryString, strQSCol);
      //    }
      //    
      //    if (element.hasAttribute('refresh-on-querystring-values')) {
      //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
      //        
      //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
      //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
      //            
      //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
      //                bolRefresh = true;
      //            }
      //            
      //            element.popValues[arrPopKeys[i]] = currentValue;
      //        }
      //        
      //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
      //        bolRefresh = true;
      //    }
      //    
      //    if (bolRefresh) {
      //        getData(element);
      //    }
      //}
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          i = 0;
          len = element.attributes.length;
          arrAttr = element.attributes;
          while (i < len) {
              jsnAttr = element.attributes[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var arrPopKeys;
          var currentValue;
          var bolRefresh;
          var strOperator;
  
          if (strQSCol) {
              if (strQSCol.indexOf('=') !== -1) {
                  arrAttrParts = strQSCol.split(',');
                  i = 0;
                  len = arrAttrParts.length;
                  while (i < len) {
                      strQSCol = arrAttrParts[i];
      
                      if (strQSCol.indexOf('!=') !== -1) {
                          strOperator = '!=';
                          arrQSParts = strQSCol.split('!=');
                      } else {
                          strOperator = '=';
                          arrQSParts = strQSCol.split('=');
                      }
      
                      strQSCol = arrQSParts[0];
                      strQSAttr = arrQSParts[1] || arrQSParts[0];
      
                      // if the key is not present or we've got the negator: go to the attribute's default or remove it
                      if (strOperator === '!=') {
                          // if the key is not present: add the attribute
                          if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                              element.setAttribute(strQSAttr, '');
                          // else: remove the attribute
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      } else {
                          // if the key is not present: go to the attribute's default or remove it
                          if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                              if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                  element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                              } else {
                                  element.removeAttribute(strQSAttr);
                              }
                          // else: set attribute to exact text from QS
                          } else {
                              element.setAttribute(strQSAttr, (
                                  GS.qryGetVal(strQS, strQSCol) ||
                                  element.internal.defaultAttributes[strQSAttr] ||
                                  ''
                              ));
                          }
                      }
                      i += 1;
                  }
              } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                  strQSValue = GS.qryGetVal(strQS, strQSCol);
      
                  if (element.internal.bolQSFirstRun !== true) {
                      if (strQSValue !== '' || !element.getAttribute('value')) {
                          element.setAttribute('value', strQSValue);
                      }
                  } else {
                      element.value = strQSValue;
                  }
              }
          }
          
          // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
          if (element.internal.bolQSFirstRun === true) {
              if (element.hasAttribute('refresh-on-querystring-values')) {
                  arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                  
                  for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                      currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);
                      
                      if (element.popValues[arrPopKeys[i]] !== currentValue) {
                          bolRefresh = true;
                      }
                      
                      element.popValues[arrPopKeys[i]] = currentValue;
                  }
              } else if (element.hasAttribute('refresh-on-querystring-change')) {
                  bolRefresh = true;
              }
              
              if (bolRefresh && element.hasAttribute('src')) {
                  getData(element);
              } else if (bolRefresh && !element.hasAttribute('src')) {
                  console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
              }
          } else {
              if (element.hasAttribute('refresh-on-querystring-values')) {
                  arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                  
                  for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                      element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                  }
              }
          }
          
          element.internal.bolQSFirstRun = true;
      }
      
      
      // bind delegating events
      function bindElement(element) {
          var strQSValue;
          
          // handle "qs" attribute
          if (element.getAttribute('qs') ||
                  element.getAttribute('refresh-on-querystring-values') ||
                  element.hasAttribute('refresh-on-querystring-change')) {
              //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
              //
              //if (strQSValue !== '' || !element.getAttribute('value')) {
              //    element.setAttribute('value', strQSValue);
              //}
              
              element.popValues = {};
              pushReplacePopHandler(element);
              window.addEventListener('pushstate', function () {    pushReplacePopHandler(element); });
              window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
              window.addEventListener('popstate', function () {     pushReplacePopHandler(element); });
          }
          
          // on focus control: set oldvalue for update
          element.addEventListener('focus', function (event) {
              if (event.target.hasAttribute('column')) {
                  event.target.strOldValue = event.target.value;
              }
          }, true);
          
          if (!evt.touchDevice) {
              // focus copy control
              element.addEventListener('mousedown', function (event) {
                  var parentDatasheet = GS.findParentTag(event.target, 'gs-datasheet');
  
                  // we dont want to override the focus if the currently focused
                  //      element is inside the gs-datasheet and is capable of being focus
                  if (
                      !GS.isElementFocusable(event.target) ||
                      !parentDatasheet ||
                      parentDatasheet.nodeName !== 'GS-DATASHEET'
                  ) {
                      element.copyControl.focus();
                  }
              });
          }
          
          // copy
          element.copyControl.addEventListener('copy', function (event) {
              var strTextCopyString, strHTMLCopyString;
              
              if (document.activeElement.classList.contains('hidden-focus-control') ||
                  document.activeElement.selectionStart === document.activeElement.selectionEnd) {
                  
                  GS.setInputSelection(document.activeElement, document.activeElement.value.length,
                                              document.activeElement.value.length);
                  
                  strTextCopyString = getSelectedCopyText(element);
                  strHTMLCopyString = getSelectedCopyHTML(element);
                  
                  if (strTextCopyString && strHTMLCopyString) {
                      if (handleClipboardData(event, strTextCopyString, 'text')) {
                          event.preventDefault(event);
                      }
                      if (handleClipboardData(event, strHTMLCopyString, 'html')) {
                          event.preventDefault(event);
                      }
                  }
                  
                  GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
              }
          });
          
          // focus
          window.addEventListener('focus', function (event) {//element
              if (GS.findParentTag(document.activeElement, 'gs-datasheet') === element) {
                  element.lastFocusedControl = document.activeElement;
              } else {
                  element.lastFocusedControl = null;
              }
          });//, true
          
          // paste
          element.addEventListener('paste', function (event) {
              if (document.activeElement === element.copyControl) {
                  event.preventDefault();
                  pasteHandler(element, event);
              }
          });
          
          // selection
          if (!evt.touchDevice) {
              element.dragAllowed = false;
              element.numberOfSelections = 0;
              
              // on mousedown (event delagation style)
              element.addEventListener('mousedown', function (event) {
                  var target = GS.findParentElement(event.target, 'th,td'), originalTarget = event.target;
                  
                  // if target is a cell: begin selection
                  if (target && (target.nodeName === 'TH' || target.nodeName === 'TD')) {
                      if (GS.findParentElement(target, 'div').classList.contains('header-container')) {
                          target = xtag.query(element.scrollContainer, 'th, td')[target.cellIndex];
                          originalTarget = target;
                      }
                      
                      // if shift key is down and there is currently a selection to connect to
                      element.dragOrigin = target;
                      if (event.shiftKey && xtag.query(element, '[selected]').length > 0) {
                          element.dragOrigin = element.selectionPreviousOrigin;
                      }
                      
                      // if ctrl and cmd are not down: deselect all cells
                      if (!event.metaKey && !event.ctrlKey) {
                          element.selectedCells = [];
                          element.savedSelection = [];
                          element.numberOfSelections = 0;
                      }
                      
                      element.savedSelectionCopy = element.savedSelection.slice(0);
                      element.dragAllowed = true;
                      element.dragCurrentCell = target;
                      element.numberOfSelections += 1;
                      
                      element.dragMode = 'select';
                      if (target.hasAttribute('selected')) {
                          element.dragMode = 'deselect';
                      }
                      
                      // if the original target is a cell or if the dragOrigin isn't the target cell or
                      //      if there are already selected cells: blur focused element and prevent default
                      if (originalTarget.nodeName === 'TH' || originalTarget.nodeName === 'TD' ||
                          element.dragOrigin !== target || element.selectedCells.length > 0) {
                          element.lastFocusedControl = null;
                          element.copyControl.focus();
                          GS.triggerEvent(element.copyControl, 'focus');
                          event.preventDefault();
                      }
                      
                      selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                  }
              });
              
              element.addEventListener('mousemove', function (event) {
                  var cellFromTarget;
                  
                  // if mouse is down
                  if (event.which !== 0) {
                      cellFromTarget = GS.findParentElement(event.target, 'th,td');
                      
                      // if selection is allowed at this point and closestCell is different from element.dragCurrentCell
                      if (cellFromTarget && element.dragAllowed && element.dragCurrentCell !== cellFromTarget) {
                          element.lastFocusedControl = null;
                          element.copyControl.focus();
                          GS.triggerEvent(element.copyControl, 'focus');
                          
                          element.dragCurrentCell = cellFromTarget;
                          selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                          event.preventDefault();
                      }
                  } else {
                      element.dragAllowed = false;
                      element.selectionPreviousOrigin = element.dragOrigin;
                  }
              });
              
              element.addEventListener('mouseup', function (event) {
                  if (element.dragAllowed) {
                      if (document.activeElement === element || document.activeElement === document.body) {
                          element.copyControl.focus();
                          GS.triggerEvent(element.copyControl, 'focus');
                      }
                      element.dragAllowed = false;
                      element.selectionPreviousOrigin = element.dragOrigin;
                  }
              });
          }
          
          if (!element.hasAttribute('no-filter')) {
              // filter edit button
              element.filterButton.addEventListener('click', function () {
                  var templateElement = document.createElement('template');
                  
                  templateElement.setAttribute('data-max-width', '300px');
                  templateElement.setAttribute('data-overlay-close', 'true');
                  
                  templateElement.innerHTML = ml(function () {/*
                      <gs-body padded>
                          <label for="memo-datagrid-filters">Filters:</label>
                          <gs-memo id="memo-datagrid-filters" rows="6" no-resize-handle></gs-memo>
                          <br />
                          <gs-grid>
                              <gs-block><gs-button dialogclose remove-right>Cancel</gs-button></gs-block>
                              <gs-block><gs-button dialogclose remove-all style="border-left: 0 none;">Clear Filters</gs-button></gs-block>
                              <gs-block><gs-button dialogclose remove-left style="border-left: 0 none;">Update Filters</gs-button></gs-block>
                          </gs-grid>
                      </gs-body>
                  */});
                  
                  GS.openDialogToElement(element.filterButton, templateElement, 'down', function () {
                      document.getElementById('memo-datagrid-filters').value = element.getAttribute('user-where').replace(/\sAND\s/gi, '\nAND ');
                      
                  }, function (event, strAnswer) {
                      var strValue = document.getElementById('memo-datagrid-filters').value;
                      
                      if (strAnswer === 'Clear Filters' || (strAnswer === 'Update Filters' && strValue.trim() === '')) {
                          element.removeAttribute('user-where');
                          element.filterButton.setAttribute('hidden', '');
                          getData(element);
                          
                      } else if (strAnswer === 'Update Filters') {
                          element.setAttribute('user-where', strValue);
                          getData(element);
                      }
                  });
              });
              
              // filter popup
              var cellFloatingButtonFunction = function (targetCell) {
                  var jsnElementPosition = GS.getElementPositionData(targetCell), strHTML;
                  
                  // targetCell is a th or if targetCell doesn't have a child with the "column" attribute:
                  //      remove the floating button if it exists
                  if (targetCell.nodeName === 'TH' || xtag.query(targetCell, '[column]').length === 0) {
                      if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                          element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                          element.cellFloatingButtonContainer = null;
                      }
                      
                  // else: add the floating button
                  } else {
                      // if no floating button exists for this grid: create/append/bind one
                      if (!element.cellFloatingButtonContainer || !element.cellFloatingButtonContainer.parentNode) {
                          element.cellFloatingButtonContainer = document.createElement('div');
                          element.cellFloatingButtonContainer.classList.add('floating-button-container');
                          
                          element.cellFloatingButtonContainer.innerHTML =
                                          '<gs-button icononly icon="filter" inline bg-primary no-focus></gs-button>';
                          
                          //element.scrollContainer.appendChild(element.cellFloatingButtonContainer);
                          element.dataFlexReset.appendChild(element.cellFloatingButtonContainer);
                          
                          element.cellFloatingButtonContainer.addEventListener(evt.mousedown, function () {
                              element.cellFloatingButtonContainer.targetControl.bolSubstring =
                                  document.activeElement === element.cellFloatingButtonContainer.targetControl;
                          });
                          
                          element.cellFloatingButtonContainer.addEventListener('click', function () {
                              var targetControl = element.cellFloatingButtonContainer.targetControl
                                , jsnSelection, strMatchText = targetControl.value || targetControl.textContent
                                , templateElement = document.createElement('template');
                              
                              //console.log(targetControl, targetControl.value, strMatchText);
                              
                              if (targetControl.nodeName === 'INPUT' || targetControl.nodeName === 'TEXTAREA') {
                                  jsnSelection = GS.getInputSelection(element.cellFloatingButtonContainer.targetControl);
                              }
                              
                              if (targetControl.bolSubstring && jsnSelection && jsnSelection.start !== jsnSelection.end) {
                                  strMatchText = strMatchText.substring(jsnSelection.start, jsnSelection.end);
                              }
                              
                              templateElement.setAttribute('data-max-width', '250px');
                              templateElement.setAttribute('data-overlay-close', 'true');
                              
                              strHTML = '<gs-body padded>';
                              
                              if (evt.touchDevice) {
                                  strHTML += '<gs-button class="text-left" dialogclose>Select Range</gs-button>';
                                  strHTML += '<gs-button class="text-left" dialogclose>Select Records</gs-button><hr />';
                              }
                              
                              strHTML +=
                                  '<gs-button class="text-left" dialogclose>Equals "<u>{{VALUE}}</u>"</gs-button>' +
                                  '<gs-button class="text-left" dialogclose>Doesn\'t Equal "<u>{{VALUE}}</u>"</gs-button>' +
                                  '<gs-button class="text-left" dialogclose>Contains "<u>{{VALUE}}</u>"</gs-button>' +
                                  '<gs-button class="text-left" dialogclose>Doesn\'t Contain "<u>{{VALUE}}</u>"</gs-button>' +
                                  '<gs-button class="text-left" dialogclose>Starts With "<u>{{VALUE}}</u>"</gs-button>' +
                                  '<gs-button class="text-left" dialogclose>Ends With "<u>{{VALUE}}</u>"</gs-button>';
                              
                              strHTML += '</gs-body>';
                              
                              strHTML = strHTML.replace(/\{\{VALUE\}\}/gim, encodeHTML(strMatchText));
                              
                              templateElement.innerHTML = strHTML;
                              
                              GS.openDialogToElement(element.cellFloatingButtonContainer, templateElement, 'left', '',
                                                                                              function (event, strAnswer) {
                                  var clickFunction
                                    , addUserWhere = function (strNewWhere) {
                                          var strWhere = element.getAttribute('user-where');
                                          
                                          strWhere = (strWhere ? (strWhere + ' AND ' + strNewWhere) : strNewWhere);
                                          
                                          element.setAttribute('user-where', strWhere);
                                          element.filterButton.removeAttribute('hidden');
                                          getData(element);
                                      }
                                    , control = element.cellFloatingButtonContainer.targetCell.children[0];
                                  
                                  if (strAnswer === 'Select Range' || strAnswer === 'Select Records') {
                                      if (strAnswer === 'Select Records') {
                                          element.dragOrigin = element.cellFloatingButtonContainer.targetCell.parentNode.children[0];
                                      } else if (strAnswer === 'Select Range') {
                                          element.dragOrigin = element.cellFloatingButtonContainer.targetCell;
                                      }
                                      
                                      element.selectedCells = [];
                                      clickFunction = function (event) {
                                          var target;
                                          
                                          if (strAnswer === 'Select Records') {
                                              target = GS.findParentElement(event.target, 'tr');
                                              element.dragCurrentCell = target.children[0];
                                              
                                          } else if (strAnswer === 'Select Range') {
                                              target = GS.findParentElement(event.target, 'td,th');
                                              element.dragCurrentCell = target;
                                          }
                                          
                                          if (target) {
                                              element.selectionPreviousOrigin = element.dragOrigin;
                                              element.savedSelection = [];
                                              element.savedSelectionCopy = [];
                                              element.numberOfSelections = 1;
                                              element.dragMode = 'select';
                                              
                                              selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                                              
                                              document.activeElement.blur();
                                              event.preventDefault();
                                              element.removeEventListener('click', clickFunction, true);
                                          }
                                      };
                                      
                                      element.addEventListener('click', clickFunction, true);
                                      
                                  } else if (strAnswer.indexOf('Equals') === 0) {
                                      addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                          '= $$' + strMatchText + '$$');
                                      
                                  } else if (strAnswer.indexOf('Doesn\'t Equal') === 0) {
                                      addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                          '!= $$' + strMatchText + '$$');
                                      
                                  } else if (strAnswer.indexOf('Contains') === 0) {
                                      addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                          'LIKE $$%' + strMatchText + '%$$');
                                      
                                  } else if (strAnswer.indexOf('Doesn\'t Contain') === 0) {
                                      addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                          'NOT LIKE $$%' + strMatchText + '%$$');
                                      
                                  } else if (strAnswer.indexOf('Starts With') === 0) {
                                      addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                          'LIKE $$' + strMatchText + '%$$');
                                      
                                  } else if (strAnswer.indexOf('Ends With') === 0) {
                                      addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                          'LIKE $$%' + strMatchText + '$$');
                                  }
                              });
                          });
                      }
                      
                      // hover center next to the cell
                      element.cellFloatingButtonContainer.targetCell = targetCell;
                      element.cellFloatingButtonContainer.targetControl = xtag.query(targetCell, '[column]')[0];
                      element.cellFloatingButtonContainer.children[0].removeAttribute('remove-top-left');
                      element.cellFloatingButtonContainer.children[0].removeAttribute('remove-top-right');
                      element.cellFloatingButtonContainer.children[0].removeAttribute('remove-bottom-left');
                      element.cellFloatingButtonContainer.children[0].removeAttribute('remove-bottom-right');
                      
                      // top left
                      if (jsnElementPosition.intRoomAbove > element.cellFloatingButtonContainer.clientHeight &&
                          jsnElementPosition.intRoomLeft > element.cellFloatingButtonContainer.clientWidth) {
                          element.cellFloatingButtonContainer.setAttribute('style',
                                      'left: ' + ((jsnElementPosition.intElementLeft -
                                                      element.cellFloatingButtonContainer.clientWidth) + 4) + 'px;' +
                                      'top: ' + ((jsnElementPosition.intElementTop -
                                                      element.cellFloatingButtonContainer.clientHeight) + 4) + 'px;');
                          
                          element.cellFloatingButtonContainer.children[0].setAttribute('remove-bottom-right', '');
                          
                      // top right
                      } else if (jsnElementPosition.intRoomAbove > element.cellFloatingButtonContainer.clientHeight &&
                                 jsnElementPosition.intRoomRight > element.cellFloatingButtonContainer.clientWidth) {
                          element.cellFloatingButtonContainer.setAttribute('style',
                                      'left: ' + ((jsnElementPosition.intElementLeft +
                                                      jsnElementPosition.intElementWidth) - 4) + 'px;' +
                                      'top: ' + ((jsnElementPosition.intElementTop -
                                                      element.cellFloatingButtonContainer.clientHeight) + 4) + 'px;');
                          
                          element.cellFloatingButtonContainer.children[0].setAttribute('remove-bottom-left', '');
                          
                      // bottom left
                      } else if (jsnElementPosition.intRoomBelow > element.cellFloatingButtonContainer.clientHeight &&
                                 jsnElementPosition.intRoomLeft > element.cellFloatingButtonContainer.clientWidth) {
                          element.cellFloatingButtonContainer.setAttribute('style',
                                      'left: ' + ((jsnElementPosition.intElementLeft -
                                                      element.cellFloatingButtonContainer.clientWidth) + 4) + 'px;' +
                                      'top: ' + ((jsnElementPosition.intElementTop +
                                                      jsnElementPosition.intElementHeight) - 4) + 'px;');
                          
                          element.cellFloatingButtonContainer.children[0].setAttribute('remove-top-right', '');
                          
                      // bottom right
                      } else if (jsnElementPosition.intRoomBelow > element.cellFloatingButtonContainer.clientHeight &&
                                 jsnElementPosition.intRoomRight > element.cellFloatingButtonContainer.clientWidth) {
                          element.cellFloatingButtonContainer.setAttribute('style',
                                      'left: ' + ((jsnElementPosition.intElementLeft +
                                                      jsnElementPosition.intElementWidth) - 4) + 'px;' +
                                      'top: ' + ((jsnElementPosition.intElementTop +
                                                      jsnElementPosition.intElementHeight) - 4) + 'px;');
                          
                          element.cellFloatingButtonContainer.children[0].setAttribute('remove-top-left', '');
                      }
                  }
              };
              
              element.addEventListener('after_selection', function (event) {
                  var arrSelected = element.selectedCells;
                  
                  if (arrSelected.length === 1) {
                      cellFloatingButtonFunction(element.dragCurrentCell || arrSelected[arrSelected.length - 1]);
                      
                  } else if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                      element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                      element.cellFloatingButtonContainer = null;
                  }
              });
              
              element.addEventListener('focus', function (event) {
                  if (event.target.hasAttribute('column')) {
                      cellFloatingButtonFunction(event.target.parentNode);
                  }
              }, true);// this true is for making it so that the focus event (which doesn't bubble) gets captured
              
              // on mousewheel: remove floating button (scroll version of this is in the handleData function)
              element.addEventListener('mousewheel', function (event) {
                  if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                      element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                      element.cellFloatingButtonContainer = null;
                  }
              });
              element.scrollContainer.addEventListener('scroll', function (event) {
                  if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                      element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                      element.cellFloatingButtonContainer = null;
                  }
              });
          }
          
          // ################################################################
          // #################### TOUCH DEVICE CLIPBOARD ####################
          // ################################################################
          
          if (evt.touchDevice) {
              var rangeFloatingButtonFunction = function (arrSelected) {
                  var i, len, targetCell, arrSelectedRecords, bolCenter = true, jsnElementPosition,
                      intTopBoundry, intBottomBoundry, intLeftBoundry, intRightBoundry;
                  
                  // if no floating button exists for this grid: create/append/bind one
                  if (!element.rangeFloatingButtonContainer || !element.rangeFloatingButtonContainer.parentNode) {
                      element.rangeFloatingButtonContainer = document.createElement('div');
                      element.rangeFloatingButtonContainer.classList.add('floating-button-container');
                      
                      element.rangeFloatingButtonContainer.innerHTML =
                                      '<gs-button icononly icon="clipboard" inline bg-primary no-focus></gs-button>' +
                                      '<div contenteditable="true" style=" position: fixed;  border: 0 none;' +
                                                                          'margin: 0;        padding: 0;' +
                                                                          'z-index: -5000;   opacity: 0.00000001;' +
                                                                          '-webkit-appearance: none;' +
                                                                          '-moz-appearance: none;"></div>';
                      
                      element.scrollContainer.appendChild(element.rangeFloatingButtonContainer);
                      
                      element.rangeFloatingButtonContainer.control = element.rangeFloatingButtonContainer.children[1];
                      
                      element.rangeFloatingButtonContainer.addEventListener('click', function () {
                          element.rangeFloatingButtonContainer.control.innerHTML = getSelectedCopyHTML(element) || 'Nothing To Copy';
                          element.rangeFloatingButtonContainer.control.focus();
                          document.execCommand('selectAll', false, null);
                      });
                      
                      element.rangeFloatingButtonContainer.control.addEventListener('cut', function () {
                          var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'))
                            , strObject = GS.templateWithQuerystring(element.getAttribute('object'))
                            , strUpdateData = '', strRecord, arrSetColumnElements, strHashColumns
                            , arrSetColumns = [], arrPk, arrLock, arrLines, arrRecords, tbodyElement, arrElements
                            , tr_len, i, len, col_i, col_len, colIndex, arrRecordsToRefresh = [], updateFunction
                            , strColumns = '', strRoles = '', strColumn, strRecordToHash, strTemp;
                          
                          // gathering variables for select traversal
                          arrRecords = element.selectedRecords;
                          
                          // if the first record is the header: remove it
                          if (arrRecords[0] && arrRecords[0].parentNode.nodeName === 'THEAD') {
                              arrRecords[0].splice(0, 1);
                          }
                          
                          arrSetColumnElements = xtag.query(arrRecords[0], '[selected]:not(th)');
                          
                          arrPk = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
                          arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);
                          
                          // gathering update headers
                          for (i = 0, len = arrPk.length; i < len; i += 1) {
                              strRoles += (strRoles ? '\t' : '') + 'pk';
                              strColumns += (strColumns ? '\t' : '') + arrPk[i];
                          }
                          
                          for (i = 0, len = arrLock.length, strHashColumns = ''; i < len; i += 1) {
                              strHashColumns += (strHashColumns ? '\t' : '') + arrLock[i];
                          }
                          strRoles += (strRoles ? '\t' : '') + 'hash';
                          strColumns += (strColumns ? '\t' : '') + 'hash';
                          
                          for (i = 0, len = arrSetColumnElements.length; i < len; i += 1) {
                              strColumn = arrSetColumnElements[i].children[0].getAttribute('column');
                              
                              strRoles += (strRoles ? '\t' : '') + 'set';
                              strColumns += (strColumns ? '\t' : '') + strColumn;
                              arrSetColumns.push(strColumn);
                          }
                          
                          for (i = 0, len = arrRecords.length; i < len; i += 1) {
                              strRecord = '';
                              
                              // get 'pk' columns
                              for (col_i = 0, col_len = arrPk.length; col_i < col_len; col_i += 1) {
                                  strRecord += (strRecord ? '\t' : '');
                                  strRecord += GS.encodeForTabDelimited(arrRecords[i].getAttribute('data-' + arrPk[col_i]), element.nullString);
                              }
                              
                              // get 'hash' columns
                              strRecordToHash = '';
                              for (col_i = 0, col_len = arrLock.length; col_i < col_len; col_i += 1) {
                                  strRecordToHash += (strRecordToHash ? '\t' : '');
                                  strTemp = arrRecords[i].getAttribute('data-' + arrLock[col_i]);
                                  strRecordToHash += (strTemp === 'NULL' ? '' : strTemp);
                              }
                              
                              strRecord += (strRecord ? '\t' : '') + GS.utfSafeMD5(strRecordToHash).toString();
                              
                              // get 'set' columns
                              for (col_i = 0, col_len = arrSetColumns.length; col_i < col_len; col_i += 1) {
                                  strRecord += (strRecord ? '\t' : '');
                              }
                              
                              strRecord += '\n';
                              strUpdateData += strRecord;
                              arrRecordsToRefresh.push(arrRecords[i]);
                              
                              // make the records red
                              arrRecords[i].classList.add('bg-red');
                          }
                          
                          strUpdateData = (strRoles + '\n' + strColumns + '\n' + strUpdateData);
                          
                          // create update transaction
                          GS.addLoader(element, 'Creating Update Transaction...');
                          GS.requestUpdateFromSocket(
                              getSocket(element), strSchema, strObject, getReturn(element), strHashColumns, strUpdateData,
                              function (data, error, transactionID) {
                                  if (error) {
                                      getData(element);
                                      GS.removeLoader(element);
                                      GS.webSocketErrorDialog(data);
                                  }
                              }, function (data, error, transactionID, commitFunction, rollbackFunction) {
                                  GS.removeLoader(element);
                                  
                                  if (!error) {
                                      if (data !== 'TRANSACTION COMPLETED') {
                                          data = getReturn(element) + '\n' + data;
                                          
                                          // make the records amber and refresh their data
                                          refreshRecordsAfterUpdate(element, arrRecordsToRefresh, data);////
                                      } else {
                                          commitFunction();
                                      }
                                      
                                  } else {
                                      rollbackFunction();
                                      getData(element);
                                      GS.webSocketErrorDialog(data);
                                  }
                              }, function (strAnswer, data, error) {
                                  GS.removeLoader(element);
                                  
                                  if (!error) {
                                      if (strAnswer === 'COMMIT') {
                                          clearRecordColor(element, 'bg-amber', true);
                                          GS.triggerEvent(element, 'after_update');
                                      } else {
                                          getData(element);
                                      }
                                  } else {
                                      getData(element);
                                      GS.webSocketErrorDialog(data);
                                  }
                              }
                          );
                      });
                      element.rangeFloatingButtonContainer.control.addEventListener('copy', function (event) {
                          setTimeout(function () {
                              element.rangeFloatingButtonContainer.control.blur();
                              element.rangeFloatingButtonContainer.control.innerHTML = '';
                          }, 1);
                      });
                      element.rangeFloatingButtonContainer.control.addEventListener('paste', function (event) {
                          pasteHandler(element, event);
                          setTimeout(function () {
                              element.rangeFloatingButtonContainer.control.blur();
                              element.rangeFloatingButtonContainer.control.innerHTML = '';
                          }, 1);
                      });
                  }
                  
                  // position button
                  intTopBoundry = 99999999;
                  intBottomBoundry = 99999999;
                  intLeftBoundry = 99999999;
                  intRightBoundry = 99999999;
                  
                  for (i = 0, len = arrSelected.length; i < len; i += 1) {
                      jsnElementPosition = GS.getElementPositionData(arrSelected[i]);
                      
                      if (jsnElementPosition.intElementTop < intTopBoundry) {
                          intTopBoundry = jsnElementPosition.intElementTop;
                      }
                      if (jsnElementPosition.intElementBottom < intBottomBoundry) {
                          intBottomBoundry = jsnElementPosition.intElementBottom;
                      }
                      if (jsnElementPosition.intElementLeft < intLeftBoundry) {
                          intLeftBoundry = jsnElementPosition.intElementLeft;
                      }
                      if (jsnElementPosition.intElementRight < intRightBoundry) {
                          intRightBoundry = jsnElementPosition.intElementRight;
                      }
                  }
                  
                  // top right
                  if (intTopBoundry >= 0 && intRightBoundry >= 0) {
                      element.rangeFloatingButtonContainer.style.top = (intTopBoundry + 4) + 'px';
                      element.rangeFloatingButtonContainer.style.right = (intRightBoundry + 4) + 'px';
                      
                  // top left
                  } else if (intTopBoundry >= 0 && intLeftBoundry >= 0) {
                      element.rangeFloatingButtonContainer.style.top = (intTopBoundry + 4) + 'px';
                      element.rangeFloatingButtonContainer.style.left = (intLeftBoundry + 4) + 'px';
                      
                  // bottom right
                  } else if (intBottomBoundry >= 0 && intRightBoundry >= 0) {
                      element.rangeFloatingButtonContainer.style.bottom = (intBottomBoundry + 4) + 'px';
                      element.rangeFloatingButtonContainer.style.right = (intRightBoundry + 4) + 'px';
                  
                  // bottom left
                  } else if (intBottomBoundry >= 0 && intLeftBoundry >= 0) {
                      element.rangeFloatingButtonContainer.style.bottom = (intBottomBoundry + 4) + 'px';
                      element.rangeFloatingButtonContainer.style.left = (intLeftBoundry + 4) + 'px';
                  }
              };
              
              element.addEventListener('after_selection', function (event) {
                  var arrSelected = element.selectedCells;
                  
                  if (arrSelected.length > 0 && element.numberOfSelections === 1) {
                      rangeFloatingButtonFunction(arrSelected);
                      
                  } else if (element.rangeFloatingButtonContainer && element.rangeFloatingButtonContainer.parentNode) {
                      element.rangeFloatingButtonContainer.parentNode.removeChild(element.rangeFloatingButtonContainer);
                      element.rangeFloatingButtonContainer = null;
                  }
              });
              
              element.scrollContainer.addEventListener('scroll', function (event) {
                  if (element.rangeFloatingButtonContainer && element.rangeFloatingButtonContainer.parentNode) {
                      element.rangeFloatingButtonContainer.parentNode.removeChild(element.rangeFloatingButtonContainer);
                      element.rangeFloatingButtonContainer = null;
                  }
              });
          }
          
          // ######################################################################################################
          // ######################################################################################################
          // ######################################################################################################
          
          // delete, refresh, page left and page right buttons
          element.addEventListener('click', function (event) {
              var target = event.target, intOffset, intLimit
              
              // delete button
              if (target.classList.contains('delete-button')) {
                  deleteSelection(element);
                  
              // refresh button
              } else if (target.classList.contains('refresh-button')) {
                  getData(element, undefined, undefined, undefined, true);
                  
              // refresh button
              } else if (target.classList.contains('insert-button')) {
                  insertDialog(element);
                  
              } else if (target.classList.contains('paginate-left') || target.classList.contains('paginate-right')) {
                  intLimit = parseInt(element.getAttribute('limit'), 10);
                  intOffset = parseInt(element.getAttribute('offset') || '0', 10);
                  
                  if (target.classList.contains('paginate-left')) {
                      intOffset -= intLimit;
                  } else {
                      intOffset += intLimit;
                  }
                  
                  if (intOffset <= 0) {
                      intOffset = 0;
                      element.pageLeftButton.setAttribute('disabled', '');
                  } else {
                      element.pageLeftButton.removeAttribute('disabled');
                  }
                  
                  element.setAttribute('offset', intOffset);
                  element.paginated = true;
                  getData(element);
              }
          });
          
          if (!evt.touchDevice) {
              element.addEventListener('keydown', function (event) {
                  var intKeyCode = (event.which || event.keyCode);
                  
                  if (!element.hasAttribute('no-huddelete')) {
                      if (event.target === element.copyControl && (intKeyCode === KEY_BACKSPACE || intKeyCode === KEY_DELETE)) {
                          deleteSelection(element);
                          event.preventDefault();
                      }
                  }
              });
          }
          
          // manuel update
          var updateFromEntry = function (target) {
              
              var updateRecord = GS.findParentElement(target, 'tr')
                , updateRecordData = element.internalData.arrRecords[parseInt(updateRecord.getAttribute('data-index'), 10)]
                , arrPk, arrLock, i, len, col_i, col_len, strRoles, strColumns
                , strHashColumns, strRecordToHash, strTemp, strRecord, strUpdateData;
              
              arrPk = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
              arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);
              
              // gathering update headers
              for (i = 0, len = arrPk.length, strRoles = '', strColumns = ''; i < len; i += 1) {
                  strRoles += (strRoles ? '\t' : '') + 'pk';
                  strColumns += (strColumns ? '\t' : '') + arrPk[i];
              }
              
              for (i = 0, len = arrLock.length, strHashColumns = ''; i < len; i += 1) {
                  strHashColumns += (strHashColumns ? '\t' : '') + arrLock[i];
              }
              strRoles += (strRoles ? '\t' : '') + 'hash';
              strColumns += (strColumns ? '\t' : '') + 'hash';
              
              strRoles += (strRoles ? '\t' : '') + 'set';
              strColumns += (strColumns ? '\t' : '') + target.getAttribute('column');
              
              // get update data
              strRecord = '';
              
              // get 'pk' columns
              for (col_i = 0, col_len = arrPk.length; col_i < col_len; col_i += 1) {
                  strRecord += (strRecord ? '\t' : '');
                  strRecord += GS.encodeForTabDelimited(updateRecordData[element.internalData.arrColumnNames.indexOf(arrPk[col_i])], element.nullString);
              }
              
              // get 'hash' columns
              strRecordToHash = '';
              for (col_i = 0, col_len = arrLock.length; col_i < col_len; col_i += 1) {
                  strRecordToHash += (strRecordToHash ? '\t' : '');
                  strTemp = updateRecordData[element.internalData.arrColumnNames.indexOf(arrLock[col_i])];
                  strRecordToHash += (strTemp === 'NULL' ? '' : strTemp);
              }
              
              strRecord += (strRecord ? '\t' : '') + GS.utfSafeMD5(strRecordToHash).toString();
              
              // get 'set' column
              strRecord += (strRecord ? '\t' : '') + GS.encodeForTabDelimited(target.value, element.nullString);
              
              strUpdateData = (strRoles + '\n' + strColumns + '\n' + strRecord + '\n');
              updateRecords(element, strHashColumns, strUpdateData, [updateRecord], false);
          };
          
          element.addEventListener('change', function (event) {
              var target = event.target;
  
              if (
                  target.hasAttribute('column') &&
                  !GS.findParentElement(target, 'tr').classList.contains('insert-record') &&
                  !event.shiftKey
              ) {
                  updateFromEntry(target);
              }
          });
          
          // manuel insert
          var insertFromInsertRecord = function () {
              var arrElements = xtag.query(element, 'tr.insert-record > td > [column]')
                , i, len, strColumns, strInsertData, strLocalData;
              
              for (i = 0, len = arrElements.length, strColumns = '', strInsertData = '', strLocalData = ''; i < len; i += 1) {
                  strColumns += (strColumns ? '\t' : '') + arrElements[i].getAttribute('column');
                  strInsertData += (strInsertData ? '\t' : '') + GS.encodeForTabDelimited(arrElements[i].value || 'NULL', element.nullString);
                  strLocalData += (strLocalData ? '\t' : '') + GS.encodeForTabDelimited(arrElements[i].value || '', element.nullString);
                  arrElements[i].value = '';
              }
              
              //console.log('strColumns:    ', strColumns);
              //console.log('strInsertData: ', strInsertData);
              //console.log('strLocalData:  ', strLocalData);
              
              insertRecords(element, strColumns, strInsertData + '\n', strLocalData + '\n', false);
          };
          
          element.addEventListener('keydown', function (event) {
              var intKeyCode = (event.which || event.keyCode), target = event.target;
              
              if (target.hasAttribute('column') && GS.findParentElement(target, 'tr').classList.contains('insert-record') && !event.shiftKey) {
                  if (intKeyCode === KEY_RETURN) {
                      insertFromInsertRecord();
                      event.preventDefault();
                  }
              }
          });
          
          // arrow navigation, key selection
          if (!evt.touchDevice) {
              element.addEventListener('keydown', function (event) {
                  var intKeyCode = (event.which || event.keyCode)
                    , target = event.target, targetValue = target.value || '', bolNavigateMode = false
                    , parentCell, parentRecord, parentTBody, jsnCursorPos, intCursorPosition, bolSelect
                    , bolFullSelection, bolCursorAtFirst, bolCursorAtTop, bolCursorAtLast, bolCursorAtBottom
                    , arrSelected, arrRecords, focusElement;
                  
                  // find out if we are in focus mode
                  // if we are in a cell control: we might be in focus mode (we need to check further)
                  if ((event.target.nodeName === 'INPUT' || event.target.nodeName === 'TEXTAREA') &&
                      !target.classList.contains('hidden-focus-control')) {
                      jsnCursorPos = GS.getInputSelection(event.target);
                      
                      // if fill text selection and shift is down: not focus mode
                      if (!(jsnCursorPos.start === 0 && jsnCursorPos.end === event.target.value.length && event.shiftKey)) {
                          bolNavigateMode = true;
                      }
                  } else if (target.hasAttribute('column')) {
                      jsnCursorPos = {'start': 0, 'end': targetValue.length};
                      if (!event.shiftKey) {
                          bolNavigateMode = true;
                      }
                  }
                  
                  // if we're in navigate mode: change focused cell
                  if (bolNavigateMode) {
                      if (target.nodeName === 'INPUT' || target.nodeName === 'TEXTAREA') {
                          jsnCursorPos = GS.getInputSelection(target);
                      } else {
                          jsnCursorPos = {'start': 0, 'end': targetValue.length};
                      }
                      
                      parentCell = GS.findParentElement(target, 'th,td');
                      parentRecord = parentCell.parentNode;
                      parentTBody = parentRecord.parentNode;
                      
                      bolFullSelection = (jsnCursorPos.start === 0 && jsnCursorPos.end === targetValue.length);
                      
                      // if we don't have a full selection and the selection is one character position
                      if (!bolFullSelection && jsnCursorPos.start === jsnCursorPos.end) {
                          // find out where the cursor is
                          intCursorPosition = jsnCursorPos.start;
                          bolCursorAtFirst = (intCursorPosition === 0);
                          bolCursorAtTop = (intCursorPosition < (targetValue.indexOf('\n') === -1 ?
                                                                      targetValue.length + 1 :
                                                                      targetValue.indexOf('\n') + 1)) ||
                                           (intCursorPosition === 0);
                          bolCursorAtLast = (intCursorPosition === targetValue.length);
                          bolCursorAtBottom = (intCursorPosition > targetValue.lastIndexOf('\n'));
                      }
                      
                      // if left arrow and (full selection or the cursor is at the first character)
                      if (intKeyCode === KEY_LEFT && (bolFullSelection || bolCursorAtFirst)) {
                          if (parentCell.previousElementSibling && parentCell.previousElementSibling.nodeName !== 'TH') {
                              focusElement = parentCell.previousElementSibling;
                              bolSelect = true;
                              
                          } else if (parentRecord.previousElementSibling) {
                              focusElement = parentRecord.previousElementSibling.lastElementChild;
                              bolSelect = true;
                          }
                          
                      // if up arrow and (full selection or the cursor is in the top line)
                      } else if (intKeyCode === KEY_UP && (bolFullSelection || bolCursorAtTop)) {
                          if (parentRecord.previousElementSibling) {
                              focusElement = parentRecord.previousElementSibling.children[parentCell.cellIndex];
                              bolSelect = true;
                              
                          } else if (parentCell.previousElementSibling && parentCell.previousElementSibling.nodeName !== 'TH') {
                              focusElement = parentTBody.lastElementChild.children[parentCell.cellIndex - 1];
                              bolSelect = true;
                          }
                          
                      // if right arrow and (full selection or the cursor is at the last character)
                      } else if (intKeyCode === KEY_RIGHT && (bolFullSelection || bolCursorAtLast)) {
                          if (parentCell.nextElementSibling && parentCell.nextElementSibling.nodeName !== 'TH') {
                              focusElement = parentCell.nextElementSibling;
                              parentCell.nextElementSibling.children[0].focus();
                              bolSelect = true;
                              
                          } else if (parentRecord.nextElementSibling) {
                              focusElement = parentRecord.nextElementSibling.children[1];
                              bolSelect = true;
                          }
                          
                      // if down arrow  and (full selection or the cursor is in the last line)
                      } else if (intKeyCode === KEY_DOWN && (bolFullSelection || bolCursorAtBottom)) {
                          if (parentRecord.nextElementSibling) {
                              focusElement = parentRecord.nextElementSibling.children[parentCell.cellIndex];
                              bolSelect = true;
                              
                          } else if (parentCell.nextElementSibling && parentCell.nextElementSibling.nodeName !== 'TH') {
                              focusElement = parentTBody.firstElementChild.children[parentCell.cellIndex + 1];
                              bolSelect = true;
                          }
                      }
                      
                      // if something was selected
                      if (bolSelect) {
                          // set selected cells
                          element.savedSelection = [];
                          element.savedSelectionCopy = [];
                          element.dragOrigin = GS.findParentElement(focusElement, 'td, th');
                          element.dragCurrentCell = element.dragOrigin;
                          element.selectionPreviousOrigin = element.dragOrigin;
                          element.numberOfSelections = 1;
                          element.dragMode = 'select';
                          
                          selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                          
                          // this makes it so that the keyup doesn't happen,
                          //      allowing the new text selection to stay
                          event.preventDefault();
                          event.stopPropagation();
                      }
                      
                      if (focusElement) {
                          focusElement = xtag.query(focusElement, 'input, textarea, select, [tabindex]')[0];
                          if (focusElement) {
                              focusElement.focus();
                              
                              // select all the text and scroll into view
                              if (focusElement !== window) {
                                  if (focusElement.nodeName === 'INPUT' || focusElement.nodeName === 'TEXTAREA') {
                                      GS.setInputSelection(focusElement, 0, focusElement.value.length);
                                  }
                                  parentRecord = GS.findParentTag(focusElement, 'tr');
                                  
                                  if (parentRecord && parentRecord.nodeName === 'TR') {
                                      GS.scrollIntoView(parentRecord);
                                  }
                              }
                          }
                      }
                      
                  // else: change selection
                  } else if (event.target === element ||
                             event.target.hasAttribute('column') ||
                             event.target.classList.contains('hidden-focus-control')) {
                                 
                      // if mouse selection is not happening right now
                      if (!element.dragAllowed) {
                          arrSelected = element.selectedCells;
                          
                          // if the key was tab
                          if (intKeyCode === KEY_TAB) {
                              // if is a selection origin: focus the inner control
                              if (element.dragOrigin) {
                                  element.dragOrigin.children[0].focus();
                                  
                                  // this makes it so that the keyup doesn't happen,
                                  //      allowing the new text selection to stay
                                  event.preventDefault();
                              }
                              
                          // else if the key was return
                          } else if (intKeyCode === KEY_RETURN) {
                              // if there is only one cell selected: go into the cell control
                              if (arrSelected.length === 1) {
                                  arrSelected[0].children[0].focus();
                              } else {
                                  element.dragOrigin.children[0].focus();
                              }
                              
                              GS.setInputSelection(document.activeElement, document.activeElement.value.length);
                              GS.scrollIntoView(GS.findParentTag(document.activeElement, 'tr'));
                              
                              // this makes it so that the keyup doesn't happen,
                              //      allowing the new text selection to stay
                              event.preventDefault();
                              
                          // else if an arrow key was pressed
                          } else if (intKeyCode === KEY_UP || intKeyCode === KEY_DOWN || intKeyCode === KEY_LEFT || intKeyCode === KEY_RIGHT) {
                              arrRecords = xtag.query(element, 'tr');
                              element.dragMode = 'select';
                              
                              // if no selection: select first editable cell
                              if (arrSelected.length === 0) {
                                  //console.log('2***');
                                  element.savedSelection = [];
                                  element.savedSelectionCopy = [];
                                  element.dragOrigin = xtag.query(element, 'tbody td')[0];
                                  element.dragCurrentCell = element.dragOrigin;
                                  element.selectionPreviousOrigin = element.dragOrigin;
                                  element.numberOfSelections = 1;
                                  
                                  bolSelect = true;
                                  
                              // if shift: expand current selection
                              } else if (event.shiftKey) {
                                  //console.log('3***', element.dragCurrentCell);
                                  element.dragOrigin = element.selectionPreviousOrigin;
                                  parentRecord = element.dragCurrentCell.parentNode;
                                  
                                  // if left arrow
                                  if (intKeyCode === 37 && element.dragCurrentCell.previousElementSibling) {
                                      element.dragCurrentCell = element.dragCurrentCell.previousElementSibling;
                                      
                                  // if up arrow
                                  } else if (intKeyCode === 38 && arrRecords[parentRecord.rowIndex - 1]) {
                                      element.dragCurrentCell = arrRecords[parentRecord.rowIndex - 1]
                                                                      .children[element.dragCurrentCell.cellIndex];
                                      
                                  // if right arrow
                                  } else if (intKeyCode === 39 && element.dragCurrentCell.nextElementSibling) {
                                      element.dragCurrentCell = element.dragCurrentCell.nextElementSibling;
                                      
                                  // if down arrow
                                  } else if (intKeyCode === 40 && arrRecords[parentRecord.rowIndex + 1]) {
                                      element.dragCurrentCell = arrRecords[parentRecord.rowIndex + 1]
                                                                      .children[element.dragCurrentCell.cellIndex];
                                  }
                                  
                                  bolSelect = true;
                                  
                              // else: move selected cell based on origin cell
                              } else {
                                  //console.log('4***', arrSelected.length);
                                  if (arrSelected.length > 1) {
                                      element.dragCurrentCell = element.selectionPreviousOrigin;
                                  }
                                  
                                  parentRecord = element.dragCurrentCell.parentNode;
                                  
                                  // if left arrow
                                  if (intKeyCode === 37 && element.dragCurrentCell.previousElementSibling) {
                                      element.dragCurrentCell = element.dragCurrentCell.previousElementSibling;
                                      
                                  // if up arrow
                                  } else if (intKeyCode === 38 && arrRecords[parentRecord.rowIndex - 1]) {
                                      element.dragCurrentCell = arrRecords[parentRecord.rowIndex - 1]
                                                                      .children[element.dragCurrentCell.cellIndex];
                                      
                                  // if right arrow
                                  } else if (intKeyCode === 39 && element.dragCurrentCell.nextElementSibling) {
                                      element.dragCurrentCell = element.dragCurrentCell.nextElementSibling;
                                      
                                  // if down arrow
                                  } else if (intKeyCode === 40 && arrRecords[parentRecord.rowIndex + 1]) {
                                      element.dragCurrentCell = arrRecords[parentRecord.rowIndex + 1]
                                                                      .children[element.dragCurrentCell.cellIndex];
                                  }
                                  
                                  element.savedSelection = [];
                                  element.savedSelectionCopy = [];
                                  element.dragOrigin = element.dragCurrentCell;
                                  element.selectionPreviousOrigin = element.dragCurrentCell;
                                  element.numberOfSelections = 1;
                                  
                                  bolSelect = true;
                              }
                              
                              // if the above code has produced the info for a selection: call the select handler
                              if (bolSelect) {
                                  //console.log('5***', element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                                  
                                  element.lastFocusedControl = null;
                                  element.copyControl.focus();
                                  
                                  selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                                  GS.scrollIntoView(element.dragCurrentCell.parentNode);
                                  event.preventDefault();
                              }
                          }
                      }
                  }
              });
          }
          
          
          element.addEventListener('mousewheel', function (event) {
              synchronizeHeaderScroll(element);
          });
          element.scrollContainer.addEventListener('scroll', function (event) {
              synchronizeHeaderScroll(element);
          });
          window.addEventListener('resize', function (event) {
              refreshReflow(element);
              refreshHeight(element);
              synchronizeHeaderWidths(element);
          });
      }
      
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
                  
                  if (element.hasAttribute('null-string')) {
                      element.nullString = element.getAttribute('null-string') || '';
                  } else {
                      element.nullString = 'NULL';
                  }
                  
                  prepareElement(element);
                  bindElement(element);
                  getData(element, '', '', true);
              }
          }
      }
      
      xtag.register('gs-datasheet', {
          lifecycle: {
              created: function () {},
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  var element = this;
                  
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementInserted(element);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(element);
                      
                  } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                      if (strAttrName === 'value' && this.root) {
                          this.refresh();
                      }
                  }
              }
          },
          events: {},
          accessors: {
              selectedCells: {
                  
                  /*
                      function synchronize(element, bolScroll) {
                          var arrRecords = xtag.query(element, 'tr'), selectCells = [], i, len,
                              arrParts, arrTextareas, focusedElement, recordIndex, cellIndex;
                          
                          // selection
                          if (element.savedSelection) {
                              // loop through savedSelection
                              for (i = 0, len = element.savedSelection.length; i < len; i += 1) {
                                  // any cell position that is in saved selection gets added to the selectCells
                                  arrParts = element.savedSelection[i].split(',');
                                  recordIndex = parseInt(arrParts[0], 10);
                                  cellIndex = parseInt(arrParts[1], 10);
                                  
                                  if (recordIndex < arrRecords.length && cellIndex < arrRecords[0].children.length) {
                                      selectCells.push(arrRecords[recordIndex].children[cellIndex]);
                                  }
                              }
                              
                              // select cells
                              element.selectedCells = selectCells;
                          }
                          
                          // focus
                          if (element.lastFocusedControl) {
                              element.lastFocusedControl.focus();
                              focusedElement = element.lastFocusedControl;
                          } else {
                              focusedElement = element.copyControl;
                              focusedElement.focus();
                          }
                          
                          // if there was no control to focus and
                          //      there is a selection and
                          //      bolScroll is true: scroll to selected
                          if (!element.lastFocusedControl && element.selectedCells.length > 0 && bolScroll) {
                              GS.scrollIntoView(element.selectedCells[0].parentNode);
                          }
                          
                          // if there was a control and bolScroll is true: scroll to focused record
                          if (focusedElement && bolScroll) {
                              GS.scrollIntoView(GS.findParentElement(document.activeElement, 'tr'));
                          }
                          
                          if (focusedElement && element.lastTextSelection) {
                              GS.setInputSelection(focusedElement, element.lastTextSelection.start, element.lastTextSelection.end);
                          }
                      }
                      function clearSelection(element) {
                          element.savedSelection = [];
                          element.savedSelectionCopy = [];
                          element.dragOrigin = null;
                          element.dragCurrentCell = null;
                          element.selectionPreviousOrigin = null;
                          element.numberOfSelections = 0;
                          element.selectedCells = [];
                      }
                  */
                  
                  get: function () {
                      return xtag.query(this.scrollContainer, '[selected]');
                  },
                  
                  set: function (newValue) {
                      var i, len, intIdIndex, arrCells = xtag.query(this, '[selected]'),
                          cell_i, cell_len, arrRowIndexes = [], arrHeaderIndexes = [],
                          arrRecordSelectors, arrHeaders;
                      
                      // clear old selection
                      for (i = 0, len = arrCells.length; i < len; i += 1) {
                          arrCells[i].removeAttribute('selected');
                      }
                      
                      arrCells = xtag.query(this, '[selected-secondary]');
                      for (i = 0, len = arrCells.length; i < len; i += 1) {
                          arrCells[i].removeAttribute('selected-secondary');
                      }
                      
                      // if newValue is not an array: make it an array
                      if (typeof newValue === 'object' && newValue.length === undefined) {
                          arrCells = [newValue];
                      } else {
                          arrCells = newValue;
                      }
                      
                      // if this call is the result of a javascript ".selectedCells = ARRAY" call and there are more than zero cells to set
                      if (!this.dragAllowed && arrCells.length > 0) {
                          this.dragOrigin = arrCells[0];
                          this.dragCurrentCell = arrCells[arrCells.length - 1];
                      }
                      if (!this.savedSelection) { this.savedSelection = []; }
                      
                      // set new selection
                      for (i = 0, len = arrCells.length; i < len; i += 1) {
                          GS.listAdd(arrRowIndexes, arrCells[i].parentNode.rowIndex);
                          GS.listAdd(arrHeaderIndexes, arrCells[i].cellIndex);
                          
                          this.savedSelection.push(arrCells[i].parentNode.rowIndex + ',' + arrCells[i].cellIndex);
                          
                          arrCells[i].setAttribute('selected', '');
                      }
                      
                      // highlight non-selected headers and row selectors
                      
                      arrRecordSelectors = xtag.query(this, 'tbody th, thead th:first-child');
                      for (i = 0, len = arrRecordSelectors.length; i < len; i += 1) {
                          if (arrRowIndexes.indexOf(i) !== -1 && !arrRecordSelectors[i].hasAttribute('selected')) {
                              arrRecordSelectors[i].setAttribute('selected-secondary', '');
                          }
                      }
                      
                      arrHeaders = xtag.query(this, 'thead th');
                      for (i = 0, len = arrHeaders.length; i < len; i += 1) {
                          if (arrHeaderIndexes.indexOf(i) !== -1 && !arrHeaders[i].hasAttribute('selected')) {
                              arrHeaders[i].setAttribute('selected-secondary', '');
                          }
                      }
                      
                      //console.log(arrRecordSelectors, arrHeaders, arrRowIndexes, arrHeaderIndexes);
                      
                      GS.triggerEvent(this, 'after_selection');
                  }
              },
              
              selectedRecords: {
                  get: function () {
                      var i, len, intRecordIndex = -1, arrRecord = [], selected = this.selectedCells;
                      
                      // loop through the selected cells and create an array of trs
                      for (i = 0, len = selected.length; i < len; i += 1) {
                          if (selected[i].parentNode.rowIndex > intRecordIndex && selected[i].parentNode.parentNode.nodeName !== 'THEAD') {
                              intRecordIndex = selected[i].parentNode.rowIndex;
                              
                              arrRecord.push(selected[i].parentNode);
                          }
                      }
                      
                      return arrRecord;
                  },
                  
                  set: function (newValue) {
                      var i, len, cell_i, cell_len, intIdIndex, arrCells = this.selectedCells, arrRecords, arrCellChildren;
                      
                      // clear old selection
                      for (i = 0, len = arrCells.length; i < len; i += 1) {
                          arrCells[i].removeAttribute('selected');
                      }
                      
                      arrCells = xtag.query(this, '[selected-secondary]');
                      for (i = 0, len = arrCells.length; i < len; i += 1) {
                          arrCells[i].removeAttribute('selected-secondary');
                      }
                      
                      // if newValue is not an array: make it an array
                      if (typeof newValue === 'object' && newValue.length === undefined) {
                          arrRecords = [newValue];
                      } else {
                          arrRecords = newValue;
                      }
                      
                      // set new selection
                      for (i = 0, len = arrRecords.length, arrCells = []; i < len; i += 1) {
                          arrCellChildren = arrRecords[i].children;
                          
                          for (cell_i = 0, cell_len = arrCellChildren.length; cell_i < cell_len; cell_i += 1) {
                              arrCells.push(arrCellChildren[cell_i]);
                          }
                      }
                      
                      this.selectedCells = arrCells;
                  }
              },
              
              value: {
                  get: function () {
                      return this.getAttribute('value');
                  },
                  
                  set: function (newValue) {
                      return this.setAttribute('value', newValue);
                  }
              }
          },
          methods: {
              'refresh': function () {
                  getData(this);
              }
              
            , 'refreshFixedHeader': function () {
                  synchronizeHeaderScroll(this);
                  synchronizeHeaderWidths(this);
              }
              
            , 'refreshReflow': function () {
                  refreshReflow(this);
              }
          }
      });
  });window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('<gs-date>', '<gs-date>', 'gs-date column="${1:name}"></gs-date>');
      registerDesignSnippet('<gs-date> With Label', '<gs-date>', 'label for="${1:date-insert-start_date}">${2:Start Date}:</label>\n' +
                                                                 '<gs-date id="${1:date-insert-start_date}" column="${3:start_date}"></gs-date>');
      
      designRegisterElement('gs-date', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-date.html');
      
      window.designElementProperty_GSDATE = function(selectedElement) {
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
          
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
          
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
          
          addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
          });
          
          //console.log(selectedElement.hasAttribute('mini'));
          
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
          
          addProp('Date Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-picker')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-picker', (this.value === 'true'), false);
          });
          
          addProp('Format', true, '<gs-combo class="target" value="' + encodeHTML(selectedElement.getAttribute('format') || '') + '" mini>' + 
                          ml(function () {/*<template>
                                              <table>
                                                  <tbody>
                                                      <tr value="">
                                                          <td hidden>Default</td>
                                                          <td><center>Default<br /> (01/01/2015)</center></td>
                                                      </tr>
                                                      <tr value="shortdate">
                                                          <td hidden>shortdate</td>
                                                          <td><center>shortdate<br /> (1/1/15)</center></td>
                                                      </tr>
                                                      <tr value="mediumdate">
                                                          <td hidden>mediumdate</td>
                                                          <td><center>mediumdate<br /> (Jan 1, 2015)</center></td>
                                                      </tr>
                                                      <tr value="longdate">
                                                          <td hidden>longdate</td>
                                                          <td><center>longdate<br /> (January 1, 2015)</center></td>
                                                      </tr>
                                                      <tr value="fulldate">
                                                          <td hidden>fulldate</td>
                                                          <td><center>fulldate<br /> (Thursday, January 1, 2015)</center></td>
                                                      </tr>
                                                      <tr value="isodate">
                                                          <td hidden>isodate</td>
                                                          <td><center>isodate<br /> (2015-01-01)</center></td>
                                                      </tr>
                                                      <tr value="isodatetime">
                                                          <td hidden>isodatetime</td>
                                                          <td><center>isodatetime<br /> (2015-01-01T00:00:00)</center></td>
                                                      </tr>
                                                  </tbody>
                                              </table>
                                          </template>
                                      </gs-combo>
                                  */}), function () {
              return setOrRemoveTextAttribute(selectedElement, 'format', this.value);
          });
          
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          // TABINDEX attribute
          addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
          });
          
          addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
          });
          
          addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
          });
          
          addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
          });
          
          addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
          });
          
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
          
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          // DISABLED attribute
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
          
          // READONLY attribute
          addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
          });
          
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
          
          //// SUSPEND-CREATED attribute
          //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
          //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          //});
          
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      var singleLineTemplateElement = document.createElement('template'),
          singleLineTemplate;
  
      singleLineTemplateElement.innerHTML = '<input class="control" gs-dynamic type="text" />' +
                               '<gs-button class="date-picker-button" gs-dynamic inline icononly icon="calendar" no-focus></gs-button>';
  
      singleLineTemplate = singleLineTemplateElement.content;
  
      // re-target change event from control to element
      function changeFunction(event) {
          event.preventDefault();
          event.stopPropagation();
  
          //console.log('change event triggered');
  
          GS.triggerEvent(event.target.parentNode, 'change');
  
          handleFormat(event.target.parentNode, event);
      }
  
      // re-target focus event from control to element
      function focusFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'focus');
          event.target.parentNode.classList.add('focus');
      }
  
      // re-target blur event from control to element
      function blurFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'blur');
          event.target.parentNode.classList.remove('focus');
      }
  
      // mouseout, remove hover class
      function mouseoutFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseout);
          event.target.parentNode.classList.remove('hover');
      }
  
      // mouseover, add hover class
      function mouseoverFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseover);
          event.target.parentNode.classList.add('hover');
      }
  
  
      function buttonClickFunction(event) {
          openDatePicker(event.target.parentNode);
      }
  
      //function pushReplacePopHandler(element) {
      //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
      //
      //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
      //    }
      //}
  
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          i = 0;
          len = element.attributes.length;
          arrAttr = element.attributes;
          while (i < len) {
              jsnAttr = element.attributes[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  if (strQSValue !== '' || !element.getAttribute('value')) {
                      element.setAttribute('value', strQSValue);
                  }
              } else {
                  element.value = strQSValue;
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
  
      // sync control value and resize to text
      function syncView(element) {
          if (element.control) {
              element.setAttribute('value', element.control.value);
          }
      }
  
      function openDatePicker(element, dteDate) {
          var divElement = document.createElement('div')
            , jsnOffset = GS.getElementOffset(element.datePickerButton)
            , jsnControlOffset = GS.getElementOffset(element)
            , datePickerContainer, datePicker, strHTML = '', intTop, bolSelectOrigin
            , i, len, dateClickHandler, arrDateButtons, dteCurrent, strInputValue = element.control.value;
  
          // if there is a day of the week in the value: remove it
          if (strInputValue.match(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim)) {
              strInputValue = strInputValue.replace(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim, '')
                                           .replace(/  /gim, ' ')
                                           .trim();
          }
  
          // fix date being off by one day by replacing the dashes with slashes
          strInputValue = strInputValue.replace(/-/, '/')  // replace first dash with forward slash
                                       .replace(/-/, '/'); // replace second dash with forward slash
          
          dteCurrent = new Date(strInputValue);
          
          if (isNaN(dteCurrent.getTime())) {
              dteCurrent = new Date();
          }
          
          element.datePickerButton.setAttribute('selected', '');
          
          // if no date was sent
          if (!dteDate) {
              // try using the value from the input
              if (element.control.value) {
                  dteDate = dteCurrent;
                  bolSelectOrigin = true;
                  
              // else just use now
              } else {
                  dteDate = new Date();
              }
          }
          
          //if we are in the current month and year, Highlight the day we are on
          if (dteDate.getMonth() === dteCurrent.getMonth() && dteDate.getFullYear() === dteCurrent.getFullYear()) {
              bolSelectOrigin = true;
          }
          
          // set html using date
          strHTML = getContentForDatePicker(dteDate, bolSelectOrigin);
          
          divElement.innerHTML =  '<div class="gs-date-date-picker-container" gs-dynamic>' +
                                      '<div class="gs-date-date-picker" gs-dynamic>' + strHTML + '</div>' +
                                  '</div>';
          
          datePickerContainer = divElement.children[0];
          element.datePickerContainer = datePickerContainer;
          
          datePicker = datePickerContainer.children[0];
          
          document.body.appendChild(datePickerContainer);
          
          // position datePickerContainer
          intTop = jsnOffset.top + element.offsetHeight;
          
          if (intTop + datePicker.offsetHeight > window.innerHeight) {
              intTop -= datePicker.offsetHeight;
              intTop -= element.offsetHeight;
              
              if (intTop < 0) {
                  intTop = 0;
              }
          }
          
          datePicker.style.top = intTop + 'px';
          
          // if window width is wider than 450 pixels width AND the date picker will not fall off of the screen:
          if (window.innerWidth > 450 && jsnOffset.left > 450) {
              // datepicker width: 450px; right: calculated;
              datePicker.style.width = '450px';
              datePicker.style.right = window.innerWidth - (jsnOffset.left + element.datePickerButton.offsetWidth) + 'px';
              
          // if window width is wider than 450 pixels width AND the date picker will not fall off of the screen:
          } else if (window.innerWidth > 450 && jsnOffset.left <= 450) {
              // datepicker width: 450px; right: calculated;
              datePicker.style.width = '450px';
              datePicker.style.left = jsnControlOffset.left + 'px';
              
          // else:
          } else {
              // datepicker width: 96%; right: 2%;
              datePicker.style.width = '96%';
              datePicker.style.right = '2%';
          }
          
          // next month, previous month, next year, previous year click events
          datePickerContainer.getElementsByClassName('prev-month')[0].addEventListener('click', function () {
              dteDate.setMonth((dteDate.getMonth() - 1 < 0 ? 11 : dteDate.getMonth() - 1));
              closeDatePicker(element);
              openDatePicker(element, dteDate);
          });
          datePickerContainer.getElementsByClassName('next-month')[0].addEventListener('click', function () {
              var i, oldMonth;
              
              oldMonth = dteDate.getMonth();
              dteDate.setMonth((oldMonth + 1 > 11 ? 0 : oldMonth + 1));
              
              // if a month is skipped (no need to worry about the loop back to january because december and january both seem to have 31 days)
              if (dteDate.getMonth() === oldMonth + 2) {
                  // loop backwards until we reach the correct month
                  i = 0;
                  while (dteDate.getMonth() === oldMonth + 2 && i < 20) {
                      dteDate.setDate(dteDate.getDate() - 1);
                      i += 1;
                  }
              }
              
              closeDatePicker(element);
              openDatePicker(element, dteDate);
          });
          datePickerContainer.getElementsByClassName('prev-year')[0].addEventListener('click', function () {
              dteDate.setFullYear(dteDate.getFullYear() - 1);
              closeDatePicker(element);
              openDatePicker(element, dteDate);
          });
          datePickerContainer.getElementsByClassName('next-year')[0].addEventListener('click', function () {
              dteDate.setFullYear(dteDate.getFullYear() + 1);
              closeDatePicker(element);
              openDatePicker(element, dteDate);
          });
          
          // background click event
          datePickerContainer.addEventListener('click', function (event) {
              if (event.target.classList.contains('gs-date-date-picker-container')) {
                  closeDatePicker(element);
              }
          });
          
          // date click events
          dateClickHandler = function () {
              var dteNewDate = new Date(this.getAttribute('data-date'));
              
              closeDatePicker(element);
              
              element.value = (dteNewDate.getMonth() + 1) + '/' + dteNewDate.getDate() + '/' + dteNewDate.getFullYear();
              //console.trace('test', element.value);
              handleFormat(element);
              xtag.fireEvent(element, 'change', { bubbles: true, cancelable: true });
          };
          
          arrDateButtons = datePickerContainer.getElementsByClassName('day-marker');
          
          for (i = 0, len = arrDateButtons.length; i < len; i += 1) {
              arrDateButtons[i].addEventListener('click', dateClickHandler);
          }
      }
      
      function closeDatePicker(element) {
          element.datePickerButton.removeAttribute('selected');
          document.body.removeChild(element.datePickerContainer);
      }
      
      function getContentForDatePicker(originDate, bolSelectOrigin) {
          var strHTML = '', i, looperDate, lookaheadDate, intFirstDayOfWeek = 0, dteToday = new Date(),
              arrDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
              arrShortDays = ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
              arrMonths = [
                  'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
              ];
          
          looperDate = new Date(originDate);
          looperDate.setDate(1);
          
          strHTML =   '<div class="month-marker" flex-horizontal gs-dynamic>' +
                          '<gs-button class="prev-month" inline icononly icon="arrow-left" gs-dynamic>Prev</gs-button>' +
                          '<span flex gs-dynamic>' + arrMonths[originDate.getMonth()] + '</span>' +
                          '<gs-button class="next-month" inline icononly icon="arrow-right" gs-dynamic>Next</gs-button>' +
                      '</div>' +
                      '<div class="year-marker" flex-horizontal gs-dynamic>' +
                          '<gs-button class="prev-year" inline icononly icon="arrow-left" gs-dynamic>Prev</gs-button>' +
                          '<span flex gs-dynamic>' + originDate.getFullYear() + '</span>' +
                          '<gs-button class="next-year" inline icononly icon="arrow-right" gs-dynamic>Next</gs-button>' +
                      '</div>';
          
          if (!isNaN(looperDate.getTime())) {
              
              // reverse back to the previous intFirstDayOfWeek
              i = 0;
              while (looperDate.getDay() !== intFirstDayOfWeek && i < 20) {
                  looperDate.setDate(looperDate.getDate() - 1);
                  
                  i += 1;
              }
              //console.log(looperDate);
              
              // add day of week markers
              strHTML += '<div class="date-picker-divider" gs-dynamic></div><div class="day-of-week-markers-container" gs-dynamic>';
              for (i = 0; i < 7; i += 1) {
                  strHTML += '<div class="day-of-week-marker" gs-dynamic>' + arrShortDays[i] + '</div>';
              }
              strHTML += '</div>';
              
              // loop through till at least the end of the month (or further to find the day that is before the next intFirstDayOfWeek)
              i = 0;
              
              lookaheadDate = new Date(looperDate);
              lookaheadDate.setDate(lookaheadDate.getDate() + 1);
              
              while (!(looperDate.getDay()         === intFirstDayOfWeek &&
                      (looperDate.getMonth()       !== originDate.getMonth() && i > 0) &&
                       lookaheadDate.getFullYear() >=  originDate.getFullYear()) &&
                     i < 50) {
                  
                  strHTML +=  '<gs-button inline class="day-marker';
                  
                  if (looperDate.getMonth() !== originDate.getMonth()) {
                      strHTML += ' other-month';
                  }
                  if (looperDate.getFullYear() === dteToday.getFullYear() &&
                      looperDate.getMonth() === dteToday.getMonth() &&
                      looperDate.getDate() === dteToday.getDate()) {
                      strHTML += ' today';
                  }
                  strHTML += '"';
                  
                  if (looperDate.getTime() === originDate.getTime() && bolSelectOrigin) {
                      strHTML += ' selected ';
                  }
                  
                  strHTML +=  'data-date="' + looperDate + '" gs-dynamic>';
                  if (looperDate.getFullYear() === dteToday.getFullYear() &&
                      looperDate.getMonth() === dteToday.getMonth() &&
                      looperDate.getDate() === dteToday.getDate()) {
                      strHTML += 'T';
                  } else {
                      strHTML += looperDate.getDate();
                  }
                  strHTML += '</gs-button>';
                  
                  //console.log(looperDate, lookaheadDate);
                  
                  lookaheadDate.setDate(lookaheadDate.getDate() + 1);
                  looperDate.setDate(looperDate.getDate() + 1);
                  i += 1;
              }
          }
  
          return strHTML;
      }
  
      function handleFormat(element, event, bolAlertOnError) {
          ///console.log(element.value);
          if (element.value) {
              var dteValue, strValueToFormat = element.value, tempSelection = GS.getInputSelection(element.control);
      
              // if there is a day of the week in the value: remove it
              if (strValueToFormat.match(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim)) {
                  strValueToFormat = strValueToFormat.replace(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim, '')
                                                     .replace(/  /gim, ' ')
                                                     .trim();
              }
      
              if (strValueToFormat.indexOf(':') !== -1) {
                  strValueToFormat = strValueToFormat.substring(0, strValueToFormat.indexOf(':'));
                  strValueToFormat = strValueToFormat.substring(0, strValueToFormat.lastIndexOf(' '));
              }
      
              // if there are only six numbers in the field assume that
              //      the first  two are the month
              //      the second two are the day   and
              //      the third  two are the year  and make a date out of that
              if (strValueToFormat.length === 6 && strValueToFormat.match(/[0-9]/g).join('') === element.value) {
                  dteValue = new Date(strValueToFormat.substring(0, 2) + '/' +
                                      strValueToFormat.substring(2, 4) + '/' +
                                      strValueToFormat.substring(4, 6));
              } else {
                  //console.log(strValueToFormat.replace(/-/, '/').replace(/-/, '/').replace(/-.*/, ''));
                  dteValue = new Date(strValueToFormat.replace(/-/, '/').replace(/-/, '/').replace(/-.*/, ''));
                  //console.log(dteValue, dteValue.getFullYear());
              }
              
              //console.trace('test', element.value, strValueToFormat, dteValue);
              
              if (isNaN(dteValue.getTime())) {
                  if (bolAlertOnError !== undefined && bolAlertOnError !== false) {
                      alert('Invalid Date: ' + element.value);
                  }
                  
                  if (document.activeElement === element.control) {
                      GS.setInputSelection(element.control, tempSelection.start, tempSelection.end);
                      
                      if (event) {
                          if (event.keyCode === GS.keyCode('backspace')) {
                              GS.setInputSelection(element.control, tempSelection.start - 1, tempSelection.start - 1);
                          } else if (event.keyCode === GS.keyCode('delete')) {
                              GS.setInputSelection(element.control, tempSelection.start, tempSelection.start);
                          }
                          event.stopPropagation();
                          event.preventDefault();
                      }
                  }
                  
              } else {
                  if (element.control) {
                      element.control.value = formatDate(dteValue, getFormatString(element));
                      if (document.activeElement === element.control) {
                          GS.setInputSelection(element.control, tempSelection.start, tempSelection.end);
                      }
                  } else {
                      element.innerHTML = formatDate(dteValue, getFormatString(element));
                  }
              }
          } else {
              return 'NULL';
          }
      }
      
      function getFormatString(element) {
          var strFormat;
          
          if (element.hasAttribute('format')) {
              strFormat = element.getAttribute('format');
          }
          
          if (!strFormat) {
              strFormat = 'MM/dd/yyyy';
          } else if (strFormat.toLowerCase() === 'shortdate') {
              strFormat = 'M/d/yy';
          } else if (strFormat.toLowerCase() === 'mediumdate') {
              strFormat = 'MMM d, yyyy';
          } else if (strFormat.toLowerCase() === 'longdate') {
              strFormat = 'MMMM d, yyyy';
          } else if (strFormat.toLowerCase() === 'fulldate') {
              strFormat = 'EEEE, MMMM d, yyyy';
          } else if (strFormat.toLowerCase() === 'shorttime') {
              strFormat = 'h:mm a';
          } else if (strFormat.toLowerCase() === 'mediumtime') {
              strFormat = 'h:mm:ss a';
          } else if (strFormat.toLowerCase() === 'isodate') {
              strFormat = 'yyyy-MM-dd';
          } else if (strFormat.toLowerCase() === 'isotime') {
              strFormat = 'HH:mm:ss';
          } else if (strFormat.toLowerCase() === 'isodatetime') {
              strFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
          }
          
          return strFormat;
      }
      
      function formatDate(dteValue, strFormat) {
          /* (this function contains a (modified) substantial portion of code from another source
              here is the copyright for sake of legality) (Uses code by Matt Kruse)
          Copyright (c) 2006-2009 Rostislav Hristov, Asual DZZD
          
          Permission is hereby granted, free of charge, to any person obtaining a 
          copy of this software and associated documentation files 
          (the "Software"), to deal in the Software without restriction, 
          including without limitation the rights to use, copy, modify, merge, 
          publish, distribute, sublicense, and/or sell copies of the Software, 
          and to permit persons to whom the Software is furnished to do so, 
          subject to the following conditions:
          
          The above copyright notice and this permission notice shall be included 
          in all copies or substantial portions of the Software.
          
          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
          OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
          MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
          IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
          CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
          TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
          SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/
          var i = 0, j = 0, l = 0, c = '', token = '', x, y, yearLen,
              formatNumber = function (n, s) {
                  if (typeof s == 'undefined' || s == 2) {
                    return (n >= 0 && n < 10 ? '0' : '') + n;
                  } else {
                      if (n >= 0 && n < 10) {
                         return '00' + n; 
                      }
                      if (n >= 10 && n <100) {
                         return '0' + n;
                      }
                      return n;
                  }
              },
              locale = {
                  monthsFull:   ['January','February','March','April','May','June', 'July','August','September','October','November','December'],
                  monthsShort:  ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
                  daysFull:     ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
                  daysShort:    ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
                  shortDateFormat: 'M/d/yyyy h:mm a',
                  longDateFormat: 'EEEE, MMMM dd, yyyy h:mm:ss a'
              };
  
          y = dteValue.getFullYear();
          // Nunzio commented this out on Monday, October 19, 2015
          // It was causing an issue during typing in the year field
          /*if (y < 1000) {
              y = String(y + 1900);
          }*/
  
          var M = dteValue.getMonth() + 1,
              d = dteValue.getDate(),
              E = dteValue.getDay(),
              H = dteValue.getHours(),
              m = dteValue.getMinutes(),
              s = dteValue.getSeconds(),
              S = dteValue.getMilliseconds();
          
          //console.log(dteValue.getFullYear());
          
          yearLen = String(y).length;
          dteValue = {
              y: y,
              yyyy: y,
              yy: String(y).substring(yearLen - 2, yearLen),
              M: M,
              MM: formatNumber(M),
              MMM: locale.monthsShort[M-1],
              MMMM: locale.monthsFull[M-1],
              d: d,
              dd: formatNumber(d),
              EEE: locale.daysShort[E],
              EEEE: locale.daysFull[E],
              H: H,
              HH: formatNumber(H)
          };
          
          //console.log(dteValue);
  
          if (H === 0) {
              dteValue.h = 12;
          } else if (H > 12) {
              dteValue.h = H - 12;
          } else {
              dteValue.h = H;
          }
  
          dteValue.hh = formatNumber(dteValue.h);
          dteValue.k = H !== 0 ? H : 24;
          dteValue.kk = formatNumber(dteValue.k);
  
          if (H > 11) {
              dteValue.K = H - 12;
          } else {
              dteValue.K = H;
          }
  
          dteValue.KK = formatNumber(dteValue.K);
  
          if (H > 11) {
              dteValue.a = 'PM';
          } else {
              dteValue.a = 'AM';
          }
  
          dteValue.m = m;
          dteValue.mm = formatNumber(m);
          dteValue.s = s;
          dteValue.ss = formatNumber(s);
          dteValue.S = S;
          dteValue.SS = formatNumber(S);
          dteValue.SSS = formatNumber(S, 3);
  
          var result = '';
  
          i = 0;
          c = '';
          token = '';
          s = false;
  
          while (i < strFormat.length) {
              token = '';   
              c = strFormat.charAt(i);
              if (c == '\'') {
                  i++;
                  if (strFormat.charAt(i) == c) {
                      result = result + c;
                      i++;
                  } else {
                      s = !s;
                  }
              } else {
                  while (strFormat.charAt(i) == c) {
                      token += strFormat.charAt(i++);
                  }
                  if (token.indexOf('MMMM') != -1 && token.length > 4) {
                      token = 'MMMM';
                  }
                  if (token.indexOf('EEEE') != -1 && token.length > 4) {
                      token = 'EEEE';
                  }
                  if (typeof dteValue[token] != 'undefined' && !s) {
                      result = result + dteValue[token];
                  } else {
                      result = result + token;
                  }
              }
          }
          
          return result;
      }
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              // if the value was set before the "created" lifecycle code runs: set attribute
              //      (discovered when trying to set a value of a date control in the after_open of a dialog)
              //      ("delete" keyword added because of firefox)
              if (element.value && new Date(element.value).getTime()) {
                  element.setAttribute('value', element.value);
                  delete element.value;
                  //element.value = undefined;
                  //element.value = null;
              }
              
          }
      }
      
      //
      function elementInserted(element) {
          console.warn('GS-DATE WARNING: this element is deprecated, please use the gs-datetime instead.');
          var today, strQSValue;
          
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
                  
                  /*
                  element.addEventListener(evt.mouseout, function (event) {
                      element.classList.remove('hover');
                  });
                  
                  element.addEventListener(evt.mouseover, function (event) {
                      element.classList.add('hover');
                  });
                  */
                  
                  if (element.hasAttribute('tabindex')) {
                      element.oldTabIndex = element.getAttribute('tabindex');
                      element.removeAttribute('tabindex');
                  }
                  
                  if (element.hasAttribute('value') && element.getAttribute('value').trim().toLowerCase() === 'today') {
                      today = new Date();
                      element.setAttribute('value', GS.leftPad(today.getFullYear(), '0', 4) + '/' + GS.leftPad(today.getMonth() + 1, '0', 2) + '/' + GS.leftPad(today.getDate(), '0', 2));
                  }
                  
                  // handle "qs" attribute
                  if (element.getAttribute('qs')) {
                      //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                      //
                      //if (strQSValue !== '' || !element.getAttribute('value')) {
                      //    element.setAttribute('value', strQSValue);
                      //}
                      
                      pushReplacePopHandler(element);
                      window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                      window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                      window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                  }
                  
                  //if (element.hasAttribute('disabled')) {
                  //    element.innerHTML = element.getAttribute('value') || element.getAttribute('placeholder') || '';
                  //} else {
                  if (!element.hasAttribute('disabled')) {
                      element.innerHTML = '';
                      element.appendChild(singleLineTemplate.cloneNode(true));
                      if (element.oldTabIndex) {
                          xtag.query(element, '.control')[0].setAttribute('tabindex', element.oldTabIndex);
                      }
                  }
                  //}
                  
                  //if (element.innerHTML === '') {
                  //    element.appendChild(singleLineTemplate.cloneNode(true));
                  //    if (element.oldTabIndex) {
                  //        xtag.query(element, '.control')[0].setAttribute('tabindex', element.oldTabIndex);
                  //    }
                  //}
                  
                  element.refresh();
              }
          }
      }
      
      function getControlState(element) {
          var jsnTextSelection, intStart, intEnd, strFormat = getFormatString(element),
              strValue = element.control.value, delimiter1index, delimiter2index,
              intCurrentSection, strCurrentSection, arrParts, intCurrentSectionSize;
          
          jsnTextSelection = GS.getInputSelection(element.control);
          intStart = jsnTextSelection.start;
          intEnd = jsnTextSelection.end;
          delimiter1index = (strValue.indexOf('-') === -1 ? strValue.indexOf('/') : strValue.indexOf('-'));
          delimiter2index = (strValue.lastIndexOf('-') === -1 ? strValue.lastIndexOf('/') : strValue.lastIndexOf('-'));
          arrParts = strFormat.split(/[-|/]/g);
          
          // calculate current section number
          if (intStart > delimiter2index) {
              intCurrentSection = 2;
          } else if (intStart > delimiter1index && intStart <= delimiter2index) {
              intCurrentSection = 1;
          } else {
              intCurrentSection = 0;
          }
          
          // calculate current part type
          if (arrParts[intCurrentSection].indexOf('y') !== -1) {
              strCurrentSection = 'year';
          } else if (arrParts[intCurrentSection].indexOf('M') !== -1) {
              strCurrentSection = 'month';
          } else {
              strCurrentSection = 'day';
          }
          
          // calculate current section size
          if (intCurrentSection === 2) {
              intCurrentSectionSize = (strValue.length) - (delimiter2index + 1);
          } else if (intCurrentSection === 1) {
              intCurrentSectionSize = delimiter2index - (delimiter1index + 1);
          } else {
              intCurrentSectionSize = delimiter1index;
          }
          
          return {
              'jsnTextSelection': jsnTextSelection,
              'intStart': intStart,
              'intEnd': intEnd,
              'strFormat': strFormat,
              'strValue': strValue,
              'delimiter1index': delimiter1index,
              'delimiter2index': delimiter2index,
              'intCurrentSection': intCurrentSection,
              'strCurrentSection': strCurrentSection,
              'arrParts': arrParts,
              'intCurrentSectionSize': intCurrentSectionSize
          };
      }
      
      xtag.register('gs-date', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      if (strAttrName === 'disabled' && newValue !== null) {
                          this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder');
                      } else if (strAttrName === 'disabled' && newValue === null) {
                          this.innerHTML = '';
                          this.appendChild(singleLineTemplate.cloneNode(true));
                          if (this.oldTabIndex) {
                              xtag.query(this, '.control')[0].setAttribute('tabindex', this.oldTabIndex);
                          }
                          this.refresh();
                      } else if (strAttrName === 'value') {
                          this.value = newValue;
                      }
                  }
              }
          },
          events: {
              focus: function (event) {
                  if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      //console.log('1***', this.control, GS.getInputSelection(this.control));
                  }
              },
              click: function (event) {
                  var jsnTextSelection, intStart, strFormat, strValue, delimiter1index, delimiter2index;
                  
                  if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                      jsnTextSelection = GS.getInputSelection(this.control);
                      strFormat = getFormatString(this);
                      strValue = this.control.value;
                      
                      // if format is dash delimited or slash delimited and
                      //      we are not on a touch device
                      if ((/^[M|y]{1,}[/|-]{1}[M|d]{1,}[/|-]{1}[d|y]{1,}$/).test(strFormat) &&
                          (strValue.substring(jsnTextSelection.start, jsnTextSelection.end).match(/[-|/]/g) || []).length === 0 &&
                          !evt.touchDevice) {
                          
                          // if there is a date and it's dash or slash delimited: select date part
                          if ((/^[0-9]{1,}[-]{1}[0-9]{1,}[-]{1}[0-9]{1,}$/).test(strValue) ||
                              (/^[0-9]{1,}[/]{1}[0-9]{1,}[/]{1}[0-9]{1,}$/).test(strValue)) {
                              
                              intStart = jsnTextSelection.start;
                              delimiter1index = (strValue.indexOf('-') === -1 ? strValue.indexOf('/') : strValue.indexOf('-'));
                              delimiter2index = (strValue.lastIndexOf('-') === -1 ? strValue.lastIndexOf('/') : strValue.lastIndexOf('-'));
                              
                              // if greater than second delimeter
                              if (intStart > delimiter2index) {
                                  //console.log('Section 3');
                                  GS.setInputSelection(this.control, delimiter2index + 1, strValue.length);
                                  
                              // if in between than first and second delimeter
                              } else if (intStart > delimiter1index && intStart <= delimiter2index) {
                                  //console.log('Section 2');
                                  GS.setInputSelection(this.control, delimiter1index + 1, delimiter2index);
                                  
                              // else
                              } else {
                                  //console.log('Section 1');
                                  GS.setInputSelection(this.control, 0, delimiter1index);
                              }
                              
                              //console.log(intStart, delimiter1index, delimiter2index);
                          }
                      }
                  }
              },
              keydown: function (event) { // tried "input" event
                  var jsnTextSelection, intStart, intEnd, strFormat, strValue,
                      intKeyCode = (event.keyCode || event.which), delimiter1index, delimiter2index,
                      intCurrentSection, strCurrentSection, arrParts, dteDate, intCurrentSectionSize,
                      jsnState;
                  
                  if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                      jsnTextSelection = GS.getInputSelection(this.control);
                      strValue = this.control.value;
                      strFormat = getFormatString(this);
                      
                      // if format is dash delimited or slash delimited and
                      //      the selection doesn't encompass a delimeter and
                      //      we are not on a touch device
                      if ((/^[M|y]{1,}[/|-]{1}[M|d]{1,}[/|-]{1}[d|y]{1,}$/).test(strFormat) &&
                          (strValue.substring(jsnTextSelection.start, jsnTextSelection.end).match(/[-|/]/g) || []).length === 0 &&
                          !evt.touchDevice) {
                          
                          // if there is a date and it's dash or slash delimited
                          if ((/^[0-9]{1,}[-]{1}[0-9]{1,}[-]{1}[0-9]{1,}$/).test(strValue) ||
                              (/^[0-9]{1,}[/]{1}[0-9]{1,}[/]{1}[0-9]{1,}$/).test(strValue)) {
                              
                              // if shift, command and option keys are not down
                              if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
                                  event.stopPropagation();
                                  
                                  jsnState = getControlState(this)
                                  jsnTextSelection =      jsnState.jsnTextSelection
                                  intStart =              jsnState.intStart
                                  intEnd =                jsnState.intEnd
                                  strFormat =             jsnState.strFormat
                                  strValue =              jsnState.strValue
                                  delimiter1index =       jsnState.delimiter1index
                                  delimiter2index =       jsnState.delimiter2index
                                  intCurrentSection =     jsnState.intCurrentSection
                                  strCurrentSection =     jsnState.strCurrentSection
                                  arrParts =              jsnState.arrParts
                                  intCurrentSectionSize = jsnState.intCurrentSectionSize
                                  
                                  //// log
                                  //console.log('intCurrentSectionSize: ' + intCurrentSectionSize + '\n' +
                                  //            'intCurrentSection:     ' + intCurrentSection + '\n' +
                                  //            'delimiter1index:       ' + delimiter1index + '\n' +
                                  //            'delimiter2index:       ' + delimiter2index + '\n' +
                                  //            'strValue.length:       ' + strValue.length + '\n' +
                                  //            'strCurrentSection:     ' + strCurrentSection + '\n' +
                                  //            'strValue:              ' + strValue + '\n' +
                                  //            'Selection Start:       ' + jsnTextSelection.start + '\n' +
                                  //            'Selection End:         ' + jsnTextSelection.end);
                                  
                                  // if number: replace current date part
                                  if ((intKeyCode >= 96 && intKeyCode <= 105) || // numpad numbers
                                      (intKeyCode >= 48 && intKeyCode <= 57)) {  // other numbers
                                      this.keyupHandle = true;
                                      
                                  // if (/|-):
                                  } else if (intKeyCode === 111 || intKeyCode === 191 || // "/"
                                             intKeyCode === 109 || intKeyCode === 189) { // "-"
                                      // if first part: go to second part
                                      if (intCurrentSection === 0) {
                                          intCurrentSection = 1;
                                          
                                      // if second part: go to third part
                                      } else if (intCurrentSection === 1) {
                                          intCurrentSection = 2;
                                      }
                                      
                                  // if horizontal arrow: move to a different date part
                                  } else if (intKeyCode === 37 || // left arrow
                                             intKeyCode === 39) { // right arrow
                                      //console.log(intCurrentSection, intKeyCode);
                                      
                                      if (intCurrentSection === 2 && intKeyCode === 37) {
                                          intCurrentSection = 1;
                                          
                                      } else if (intCurrentSection === 1) {
                                          if (intKeyCode === 37) {
                                              intCurrentSection = 0;
                                          } else {
                                              intCurrentSection = 2;
                                          }
                                          
                                      } else if (intCurrentSection === 0 && intKeyCode === 39) {
                                          intCurrentSection = 1;
                                      }
                                      
                                  // if vertical arrow: update current date part
                                  } else if (intKeyCode === 38 || // up arrow
                                             intKeyCode === 40) { // down arrow
                                      // If the date is in ISO format, new Date() will create it in GMT then convert it to the local timezone
                                      dteDate = new Date(strValue + ' 00:00:00');
                                      
                                      // if current part is year
                                      if (strCurrentSection === 'year') {
                                          //console.log(dteDate, dteDate.getFullYear(), dteDate.getYear(), (intKeyCode === 38 ? 1 : -1),
                                          //                        dteDate.getYear() + (intKeyCode === 38 ? 1 : -1));
                                          
                                          // We're using "getFullYear" here instead of "getYear" because "getYear" for some unknown reason
                                          //      worked fine before the 29th of october 2015 (that's the date of discovery anyway) but now
                                          //      throws a number over a thousand years off instead of the actual number.
                                          // Upon looking at the docs, "getYear" is apparently subject to the demons of y2k and no longer
                                          //      supported. Wouldn't it have been better to just make "getYear" do the dame thing as
                                          //      "getFullYear"?
                                          // Still unexplained is why when I tested not more than a week ago it worked without a hitch.
                                          dteDate.setFullYear(dteDate.getFullYear() + (intKeyCode === 38 ? 1 : -1));
                                          
                                          //console.log(dteDate);
                                          
                                      // if current part is month
                                      } else if (strCurrentSection === 'month') {
                                          dteDate.setMonth(dteDate.getMonth() + (intKeyCode === 38 ? 1 : -1));
                                          
                                      // if current part is day
                                      } else if (strCurrentSection === 'day') {
                                          dteDate.setDate(dteDate.getDate() + (intKeyCode === 38 ? 1 : -1));
                                      }
                                      
                                      // set the value
                                      strValue = formatDate(dteDate, strFormat);
                                      this.control.value = strValue;
                                      this.triggerChangeManually = true;
                                  }
                                  
                                  if (this.keyupHandle !== true) {
                                      // reset the section selection in case something has changed it
                                      if (intCurrentSection === 2) {
                                          GS.setInputSelection(this.control, delimiter2index + 1, strValue.length);
                                          
                                      } else if (intCurrentSection === 1) {
                                          GS.setInputSelection(this.control, delimiter1index + 1, delimiter2index);
                                          
                                      } else {
                                          GS.setInputSelection(this.control, 0, delimiter1index);
                                      }
                                  }
                                  
                                  // if not return or tab or number: prevent
                                  if (!(intKeyCode >= 96 && intKeyCode <= 105) && // numpad numbers
                                      !(intKeyCode >= 48 && intKeyCode <= 57) &&
                                      intKeyCode !== 13 && // return/enter
                                      intKeyCode !== 9) {  // tab
                                      event.preventDefault();
                                  }
                              }
                          }
                      }
                  }
              },
              keyup: function (event) {
                  var jsnTextSelection, intStart, intEnd, strFormat, strValue,
                      intKeyCode = (event.keyCode || event.which),
                      delimiter1index, delimiter2index, intCurrentSection, strCurrentSection,
                      arrParts, dteDate, intCurrentSectionSize, jsnState;
                  
                  if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                      strFormat = getFormatString(this);
                      
                      // if format is dash delimited or slash delimited and
                      //      keyup has been allowed and
                      //      we are not on a touch device
                      if ((/^[M|y]{1,}[/|-]{1}[M|d]{1,}[/|-]{1}[d|y]{1,}$/).test(strFormat) && this.keyupHandle && !evt.touchDevice) {
                          
                          // if shift, command and option keys are not down
                          if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
                              jsnState = getControlState(this)
                              jsnTextSelection =      jsnState.jsnTextSelection
                              intStart =              jsnState.intStart
                              intEnd =                jsnState.intEnd
                              strFormat =             jsnState.strFormat
                              strValue =              jsnState.strValue
                              delimiter1index =       jsnState.delimiter1index
                              delimiter2index =       jsnState.delimiter2index
                              intCurrentSection =     jsnState.intCurrentSection
                              strCurrentSection =     jsnState.strCurrentSection
                              arrParts =              jsnState.arrParts
                              intCurrentSectionSize = jsnState.intCurrentSectionSize
                              
                              //// log
                              //console.log('intCurrentSectionSize: ' + intCurrentSectionSize + '\n' +
                              //            'intCurrentSection:     ' + intCurrentSection + '\n' +
                              //            'delimiter1index:       ' + delimiter1index + '\n' +
                              //            'delimiter2index:       ' + delimiter2index + '\n' +
                              //            'strValue.length:       ' + strValue.length + '\n' +
                              //            'strCurrentSection:     ' + strCurrentSection + '\n' +
                              //            'strValue:              ' + strValue + '\n' +
                              //            'strFormat:             ' + strFormat);
                              
                              if ((strCurrentSection === 'day' && intCurrentSectionSize === 2) ||
                                  (strCurrentSection === 'month' && intCurrentSectionSize === 2) ||
                                  (strCurrentSection === 'year' && intCurrentSectionSize === strFormat.match(/y/g).length)) {
                                  
                                  if (intCurrentSection === 2) {
                                      GS.setInputSelection(this.control, delimiter2index + 1, strValue.length);
                                      
                                  } else if (intCurrentSection === 1) {
                                      GS.setInputSelection(this.control, delimiter1index + 1, delimiter2index);
                                      
                                  } else {
                                      GS.setInputSelection(this.control, 0, delimiter1index);
                                  }
                              }
                          }
                      }
                      this.keyupHandle = false;
                      
                      //console.log(intKeyCode);
                      if (intKeyCode === 13 && this.triggerChangeManually) {
                          this.triggerChangeManually = false;
                          GS.triggerEvent(this, 'change');
                      }
                  }
              },
              focusout: function () {
                  if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      //console.log(this.triggerChangeManually);
                      if (this.triggerChangeManually) {
                          this.triggerChangeManually = false;
                          GS.triggerEvent(this, 'change');
                      }
                  }
              }
              
              
              /*// on keydown and keyup sync the value attribute and the control value
              keydown: function (event) {
                  var element = this, currentDate, currentSelectionRange, currentSelectionText, currentSelectionNumber, currentSelectionFormatText,
                      currentValue, newValue, strDateFormat, formatDivider, arrMatch, currentFieldRange, newCursorPos, newFieldValue,
                      daysOfTheWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                      monthsOfTheYear = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                      strKeyCode = event.keyCode.toString();
                  
                  currentSelectionRange = GS.getInputSelection(element.control);
                  
                  if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                      if (element.getAttribute('disabled') !== null && event.keyCode !== 9) {
                          event.preventDefault();
                          event.stopPropagation();
                      } else {
                          //console.log(strKeyCode === GS.keyCode('left arrow')  , GS.keyCode('left arrow') );
                          //console.log(strKeyCode === GS.keyCode('up arrow')    , GS.keyCode('up arrow'));
                          //console.log(strKeyCode === GS.keyCode('right arrow') , GS.keyCode('right arrow'));
                          //console.log(strKeyCode === GS.keyCode('down arrow')  , GS.keyCode('down arrow'));
                          
                          // When the user presses an arrow key:
                          // It finds the current number that the user has selected
                          //     If they pressed up or down
                          //         (inc/dec)rement the current number (handling day and month names of course)
                          //     If they pressed left or right
                          //         Move their selection to the left or right depending on what they pressed
                          // Then moves the selection to the current number (handling day/month name length differences)
                          
                          // Fix date format
                          strDateFormat = element.getAttribute('format');
                          //console.log(strDateFormat);
                          if (!strDateFormat) {
                              strDateFormat = 'MM/dd/yyyy';
                          } else if (strDateFormat.toLowerCase() === 'shortdate') {
                              strDateFormat = 'M/d/yy';
                          } else if (strDateFormat.toLowerCase() === 'mediumdate') {
                              strDateFormat = 'MMM d, yyyy';
                          } else if (strDateFormat.toLowerCase() === 'longdate') {
                              strDateFormat = 'MMMM d, yyyy';
                          } else if (strDateFormat.toLowerCase() === 'fulldate') {
                              strDateFormat = 'EEEE, MMMM d, yyyy';
                          } else if (strDateFormat.toLowerCase() === 'shorttime') {
                              strDateFormat = 'h:mm a';
                          } else if (strDateFormat.toLowerCase() === 'mediumtime') {
                              strDateFormat = 'h:mm:ss a';
                          } else if (strDateFormat.toLowerCase() === 'isodate') {
                              strDateFormat = 'yyyy-MM-dd';
                          } else if (strDateFormat.toLowerCase() === 'isotime') {
                              strDateFormat = 'HH:mm:ss';
                          } else if (strDateFormat.toLowerCase() === 'isodatetime') {
                              strDateFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
                          }
                          
                          formatDivider = strDateFormat.match(/[^mdyehmsa]/gi).join('');
                          
                          currentValue = element.control.value;
                          currentDate = new Date(currentValue.replace('\'T\'', ' ').replace(/-/g, '/'));
                          
                          if (strDateFormat.indexOf('M') === -1) {
                              currentDate = new Date('2015/6/15 ' + currentValue);
                          }
                          
                          arrMatch = strDateFormat.match(/(M|E)+/g);
                          if (arrMatch && arrMatch[0].length > 3) {
                              strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                              strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                          }
                          
                          // If it was an arrow that was pressed
                          if (strKeyCode === GS.keyCode('left arrow') ||
                              strKeyCode === GS.keyCode('up arrow') ||
                              strKeyCode === GS.keyCode('right arrow') ||
                              strKeyCode === GS.keyCode('down arrow')) {
                              
                              //console.log('test');
                              
                              // Prevent the browser from moving the cursor and prevent envelope from using arrows
                              event.preventDefault();
                              event.stopPropagation();
                              
                              //console.log(currentValue, formatDivider, currentSelectionRange.start, currentSelectionRange.end);
                              
                              // Encompass the field in which the cursor is inside
                              while (currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) {
                                  currentSelectionRange.start -= 1;
                              }
                              
                              currentSelectionRange.end = currentSelectionRange.start;
                              while ( currentSelectionRange.end < currentValue.length &&
                                      formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0) {
                                  currentSelectionRange.end += 1;
                              }
                              
                              //console.log(currentValue, currentSelectionRange.start, currentSelectionRange.end);
                              
                              GS.setInputSelection(element.control, currentSelectionRange.start, currentSelectionRange.end);
                              
                              currentSelectionText = currentValue.substring(currentSelectionRange.start, currentSelectionRange.end);
                              currentSelectionFormatText = strDateFormat.substring(currentSelectionRange.start, currentSelectionRange.end);
                              
                              // If it is up or down
                              if (strKeyCode === GS.keyCode('up arrow') ||
                                  strKeyCode === GS.keyCode('down arrow')) {
                                  var increment = strKeyCode === GS.keyCode('up arrow') ? 1 : -1;
                                  
                                  if (currentSelectionFormatText[0] === 'M') {
                                      currentDate.setMonth(currentDate.getMonth() +       increment);
                                      if ((currentSelectionRange.end - currentSelectionRange.start) > 2) {
                                          currentSelectionRange.end = currentSelectionRange.start + currentSelectionText.indexOf(' ');
                                      } else {
                                          currentSelectionRange.end = currentSelectionRange.start + currentDate.getMonth().toString().length;
                                      }
                                      
                                  } else if (currentSelectionFormatText[0] === 'd') {
                                      currentDate.setDate(currentDate.getDate() + increment);
                                      currentSelectionRange.end = currentSelectionRange.start + currentDate.getDate().toString().length;
                                      
                                  } else if (currentSelectionFormatText[0] === 'y') {
                                      currentDate.setFullYear(currentDate.getFullYear() + increment);
                                      currentSelectionRange.end = currentSelectionRange.start + currentDate.getFullYear().toString().length;
                                      
                                  } else if (currentSelectionFormatText[0] === 'E') {
                                      currentDate.setDate(currentDate.getDate() + increment);
                                      currentSelectionRange.start = 0;
                                      currentSelectionRange.end = daysOfTheWeek[currentDate.getDay()].length;
                                      
                                  } else if (currentSelectionFormatText[0] === 'h' || currentSelectionFormatText[0] === 'H') {
                                      currentDate.setHours(currentDate.getHours() + increment);
                                      currentSelectionRange.end = currentSelectionRange.start + currentDate.getHours().toString().length;
                                      
                                  } else if (currentSelectionFormatText[0] === 'm') {
                                      currentDate.setMinutes(currentDate.getMinutes() + increment);
                                      currentSelectionRange.end = currentSelectionRange.start + currentDate.getMinutes().toString().length;
                                      
                                  } else if (currentSelectionFormatText[0] === 's') {
                                      currentDate.setSeconds(currentDate.getSeconds() + increment);
                                      currentSelectionRange.end = currentSelectionRange.start + currentDate.getSeconds().toString().length;
                                      
                                  } else if (currentSelectionFormatText[0] === 'a') {
                                      currentDate.setHours(currentDate.getHours() + 12);
                                  }
                                  
                                  newValue = formatDate(currentDate, strDateFormat);
                                  this.control.value = newValue;
                                  currentValue = newValue;
                              } else if (strKeyCode === GS.keyCode('left arrow')) {
                                  currentSelectionRange.end = currentSelectionRange.start - 2;
                                  currentSelectionRange.start = currentSelectionRange.end;
                              } else if (strKeyCode === GS.keyCode('right arrow')) {
                                  currentSelectionRange.end = currentSelectionRange.end + 2;
                                  currentSelectionRange.start = currentSelectionRange.end;
                              }
                              
                              // Copied from above
                              arrMatch = strDateFormat.match(/(M|E)+/g);
                              if (arrMatch && arrMatch[0].length > 3) {
                                  strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                                  strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                              }
                              while (currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) {
                                  currentSelectionRange.start -= 1;
                              }
                              currentSelectionRange.end = currentSelectionRange.start;
                              while ( currentSelectionRange.end < currentValue.length &&
                                      formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0) {
                                  currentSelectionRange.end += 1;
                              }
                              
                              GS.setInputSelection(element.control, currentSelectionRange.start, currentSelectionRange.end);
                              
                          // All number keys
                          } else if (event.keyCode >= 96 && event.keyCode <= 105) {
                              //// HARK YE ONLOOKER:
                              //// This code caps the number that is inputed by the user to the length that the format allows,
                              //// this will dissallow anyone form entering a year that is > 4 characters unless the
                              //// page's developer allows it in a custom format.
                              //// 
                              //// This should be fixed around the year 9998 to have all default formats have 5 character years
                              
                              currentSelectionText = currentValue.substring(currentSelectionRange.start, currentSelectionRange.end);
                              currentSelectionFormatText = strDateFormat.substring(currentSelectionRange.start, currentSelectionRange.end);
                              
                              currentValue = element.value;
                              
                              // This is sort of copied from above
                              // There are only two differences:
                              //     the var name
                              //     the initialization on the next line
                              currentFieldRange = {
                                  start: currentSelectionRange.start
                              };
                              while (currentFieldRange.start >= 0 && formatDivider.indexOf(currentValue[currentFieldRange.start - 1]) < 0) {
                                  currentFieldRange.start -= 1;
                              }
                              currentFieldRange.end = currentFieldRange.start;
                              while ( currentFieldRange.end < currentValue.length &&
                                      formatDivider.indexOf(currentValue[currentFieldRange.end]) < 0) {
                                  currentFieldRange.end += 1;
                              }
                              
                              //console.log(currentFieldRange);
                              
                              //console.log(currentValue.substring(0, currentSelectionRange.start));
                              //console.log(GS.charFromKeyCode(event), currentSelectionText, currentSelectionFormatText, currentDate);
                              //console.log(currentValue.substring(currentSelectionRange.end));
                              
                              // This error checking is probably unneeded, but what the hey
                              currentFieldRange.start = Math.max(currentFieldRange.start, 0);
                              arrMatch = strDateFormat.match(strDateFormat[currentFieldRange.start] + '+', 'g');
                              if (arrMatch) {
                                  // Prevent the browser from putting the number in for us
                                  event.preventDefault();
                                  
                                  // Get the character that they pressed
                                  newFieldValue = GS.charFromKeyCode(event);
                                  console.log(newFieldValue);
                                  // Cap the length to the format field's length by using
                                  // all characters in the field except the first one
                                  newFieldValue = currentValue.substring(currentFieldRange.start + 1, currentFieldRange.start + arrMatch[0].length) + newFieldValue;
                                  console.log(newFieldValue, currentValue);
                                  
                                  console.log(currentFieldRange.start + 1, currentFieldRange.start + arrMatch[0].length);
                                  
                                  // Build the value using the current field range and the new field value we built above
                                  element.value = 
                                      currentValue.substring(0, currentFieldRange.start) +
                                      newFieldValue +
                                      currentValue.substring(currentFieldRange.end);
                                  
                                  
                                  console.log(currentValue.substring(0, currentFieldRange.start), newFieldValue, currentValue.substring(currentFieldRange.end));
                              
                                  // This is copied from above
                                  currentFieldRange = {
                                      start: currentSelectionRange.start
                                  };
                                  while (currentFieldRange.start >= 0 && formatDivider.indexOf(currentValue[currentFieldRange.start - 1]) < 0) {
                                      currentFieldRange.start -= 1;
                                  }
                                  currentFieldRange.end = currentFieldRange.start;
                                  while ( currentFieldRange.end < currentValue.length &&
                                          formatDivider.indexOf(currentValue[currentFieldRange.end]) < 0) {
                                      currentFieldRange.end += 1;
                                  }
                                  
                                  //                                                                          This indexOf does not need to be checked for -1
                                  //                                                                          Because we know for a fact that the match is in
                                  //                                                                          the string we are searching
                                  newCursorPos = Math.min(currentFieldRange.start + arrMatch[0].length, strDateFormat.indexOf(arrMatch[0]) + arrMatch[0].length);
                                  newCursorPos = Math.max(newCursorPos, currentFieldRange.end);
                                  //console.log(arrMatch[0].length, strDateFormat.indexOf(arrMatch[0]), newCursorPos, arrMatch[0]);
                                  GS.setInputSelection(element.control, newCursorPos, newCursorPos);
                              }
                              
                          }
                          
                          //// All visible keys
                          //} else if ( event.keyCode >= 48 && event.keyCode <= 90 ||
                          //            event.keyCode >= 96 && event.keyCode <= 109 ||
                          //            event.keyCode >= 186 && event.keyCode <= 222 ||
                          //            event.keyCode === 32) {
                          //    //console.log('test');
                          //    
                          //    //GS.triggerEvent(element, 'change');
                          //    
                          //    if ((currentSelectionRange.end - currentSelectionRange.start) > 0) {
                          //        element.control.addEventListener('keyup', function ______self() {
                          //            GS.setInputSelection(this, currentSelectionRange.start + 1, currentSelectionRange.start) + 1;
                          //            this.removeEventListener('keyup', ______self);
                          //        });
                          //    }
                          //}
                          
                          //console.log(event.keyCode);
                          
                          syncView(element);
                      }
                  }
              },
              keyup: function () {
                  var element = this;
                  if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                      syncView(element);
                  }
              },
              click: function () {
                  var element = this, currentSelectionRange = GS.getInputSelection(element.control),
                      daysOfTheWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                      monthsOfTheYear = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                      arrMatch, strDateFormat, formatDivider, currentValue, currentDate;
                  //console.log(currentSelectionRange.start, currentSelectionRange.end);
                  
                  ////// Copied from above until otherwise noted
                  
                  // Fix date format
                  strDateFormat = element.getAttribute('format');
                  //console.log(strDateFormat);
                  if (!strDateFormat) {
                      strDateFormat = 'MM/dd/yyyy';
                  } else if (strDateFormat.toLowerCase() === 'shortdate') {
                      strDateFormat = 'M/d/yy';
                  } else if (strDateFormat.toLowerCase() === 'mediumdate') {
                      strDateFormat = 'MMM d, yyyy';
                  } else if (strDateFormat.toLowerCase() === 'longdate') {
                      strDateFormat = 'MMMM d, yyyy';
                  } else if (strDateFormat.toLowerCase() === 'fulldate') {
                      strDateFormat = 'EEEE, MMMM d, yyyy';
                  } else if (strDateFormat.toLowerCase() === 'shorttime') {
                      strDateFormat = 'h:mm a';
                  } else if (strDateFormat.toLowerCase() === 'mediumtime') {
                      strDateFormat = 'h:mm:ss a';
                  } else if (strDateFormat.toLowerCase() === 'isodate') {
                      strDateFormat = 'yyyy-MM-dd';
                  } else if (strDateFormat.toLowerCase() === 'isotime') {
                      strDateFormat = 'HH:mm:ss';
                  } else if (strDateFormat.toLowerCase() === 'isodatetime') {
                      strDateFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
                  }
                  
                  formatDivider = strDateFormat.match(/[^mdyehmsa]/gi).join('');
                  
                  currentValue = element.control.value;
                  currentDate = new Date(currentValue.replace('\'T\'', ' ').replace(/-/g, '/'));
                  
                  if (strDateFormat.indexOf('M') === -1) {
                      currentDate = new Date('2015/6/15 ' + currentValue);
                  }
                  
                  arrMatch = strDateFormat.match(/(M|E)+/g);
                  if (arrMatch && arrMatch[0].length > 3) {
                      strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                      strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                  }
                  
                  while (currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) {
                      currentSelectionRange.start -= 1;
                  }
                  currentSelectionRange.end = currentSelectionRange.start;
                  while ( currentSelectionRange.end < currentValue.length &&
                          formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0) {
                      currentSelectionRange.end += 1;
                  }
                  //console.log(currentSelectionRange.start, currentSelectionRange.end);
                  
                  ////// Not copied
                  element.ignoreSelect = true;
                  GS.setInputSelection(element.control, currentSelectionRange.start, currentSelectionRange.end);
                  
                  //console.log('CLICK EVENT FIRED');
              },
              focus: function () {
                  GS.triggerEvent(this, 'click');
              },
              select: function () {
                  //if (!this.ignoreSelect) {
                  //    GS.triggerEvent(this, 'click');
                  //    this.ignoreSelect = false;
                  //}
                  //console.log('SELECT EVENT FIRED', GS.getInputSelection(this.control));
                  
                  // Copied from click handler until otherwise noted
                  var element = this, currentSelectionRange = GS.getInputSelection(element.control),
                      daysOfTheWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                      monthsOfTheYear = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                      arrMatch, strDateFormat, formatDivider, currentValue, currentDate;
                  //console.log(currentSelectionRange.start, currentSelectionRange.end);
                  
                  ////// Copied from above until otherwise noted
                  
                  // Fix date format
                  strDateFormat = element.getAttribute('format');
                  //console.log(strDateFormat);
                  if (!strDateFormat) {
                      strDateFormat = 'MM/dd/yyyy';
                  } else if (strDateFormat.toLowerCase() === 'shortdate') {
                      strDateFormat = 'M/d/yy';
                  } else if (strDateFormat.toLowerCase() === 'mediumdate') {
                      strDateFormat = 'MMM d, yyyy';
                  } else if (strDateFormat.toLowerCase() === 'longdate') {
                      strDateFormat = 'MMMM d, yyyy';
                  } else if (strDateFormat.toLowerCase() === 'fulldate') {
                      strDateFormat = 'EEEE, MMMM d, yyyy';
                  } else if (strDateFormat.toLowerCase() === 'shorttime') {
                      strDateFormat = 'h:mm a';
                  } else if (strDateFormat.toLowerCase() === 'mediumtime') {
                      strDateFormat = 'h:mm:ss a';
                  } else if (strDateFormat.toLowerCase() === 'isodate') {
                      strDateFormat = 'yyyy-MM-dd';
                  } else if (strDateFormat.toLowerCase() === 'isotime') {
                      strDateFormat = 'HH:mm:ss';
                  } else if (strDateFormat.toLowerCase() === 'isodatetime') {
                      strDateFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
                  }
                  
                  formatDivider = strDateFormat.match(/[^mdyehmsa]/gi).join('');
                  
                  currentValue = element.control.value;
                  currentDate = new Date(currentValue.replace('\'T\'', ' ').replace(/-/g, '/'));
                  
                  if (strDateFormat.indexOf('M') === -1) {
                      currentDate = new Date('2015/6/15 ' + currentValue);
                  }
                  
                  arrMatch = strDateFormat.match(/(M|E)+/g);
                  if (arrMatch && arrMatch[0].length > 3) {
                      strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                      strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                  }
                  
                  // Condition copied only
                  if ((currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) ||
                      (currentSelectionRange.end < currentValue.length && formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0)) {
                      GS.triggerEvent(this, 'click');
                      this.ignoreSelect = false;
                  }
              }*/
          },
          accessors: {
              value: {
                  // get value straight from the input
                  get: function () {
                      if (this.control) {
                          if (this.control.value.trim() === '') {
                              return 'NULL';
                          } else {
                              return this.control.value;
                          }
                      } else if (this.hasAttribute('disabled')) {
                          return this.innerHTML;
                      }
                      
                      return undefined;
                  },
                  
                  // set the value of the input and set the value attribute
                  set: function (newValue) {
                      var tempSelection = this.control ? GS.getInputSelection(this.control) : null;
                      
                      if (this.control) {
                          if (newValue && typeof newValue === 'object') {
                              this.control.value = newValue.toLocaleDateString();
                          } else {
                              this.control.value = newValue || '';
                          }
                          
                          if (document.activeElement === this.control) {
                             GS.setInputSelection(this.control, tempSelection.start, tempSelection.end);
                          }
                          
                      } else if (this.hasAttribute('disabled')) {                        
                          if (newValue && typeof newValue === 'object') {
                              this.innerHTML = formatDate(newValue, getFormatString(this));
                          } else {
                              this.innerHTML = newValue || '';
                          }
                          
                      } else {
                          this.setAttribute('value', newValue);
                      }
                      
                      if (this.control) {
                          handleFormat(this);
                      }
                      syncView(this);
                  }
              }
          },
          methods: {
              refresh: function () {
                  var element = this, arrPassThroughAttributes, i, len;
                  
                  // set a variable for the control element for convenience and speed
                  element.control = xtag.query(element, '.control')[0];
                  
                  // set a variable for the date picker button element for convenience and speed
                  element.datePickerButton = xtag.query(element, '.date-picker-button')[0];
                  
                  //console.log(element.control, element.getAttribute('value'), element.getAttribute('column'));
                  
                  if (element.control) {
                      element.control.removeEventListener('change', changeFunction);
                      element.control.addEventListener('change', changeFunction);
                      
                      element.control.removeEventListener('focus', focusFunction);
                      element.control.addEventListener('focus', focusFunction);
  
                      element.control.removeEventListener('blur', blurFunction);
                      element.control.addEventListener('blur', blurFunction);
  
                      element.control.removeEventListener(evt.mouseout, mouseoutFunction);
                      element.control.addEventListener(evt.mouseout, mouseoutFunction);
                      
                      element.control.removeEventListener(evt.mouseout, mouseoverFunction);
                      element.control.addEventListener(evt.mouseover, mouseoverFunction);
                  }
                  if (element.datePickerButton) {
                      element.datePickerButton.addEventListener('click', buttonClickFunction);
                  }
                  
                  // if there is a value already in the attributes of the element: set the control value
                  if (element.control && element.hasAttribute('value')) {
                      element.control.value = element.getAttribute('value');
                      handleFormat(element, undefined, false);
                  }
                  
                  if (element.control) {
                  // copy passthrough attributes to control
                      arrPassThroughAttributes = [
                          'placeholder',
                          'name',
                          'maxlength',
                          'autocorrect',
                          'autocapitalize',
                          'autocomplete',
                          'autofocus',
                          'spellcheck',
                          'readonly'
                      ];
                      for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                          if (element.hasAttribute(arrPassThroughAttributes[i])) {
                              element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
                          }
                      }
                  }
              },
              
              focus: function () {
                  GS.triggerEvent(this, 'focus');
                  this.control.focus();
              }
          }
      });
  });window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('<gs-datetime>', '<gs-datetime>', 'gs-datetime></gs-datetime>');
      
      designRegisterElement('gs-datetime', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-datetime.html');
      
      window.designElementProperty_GSDATETIME = function(selectedElement) {
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
  
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
  
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
  
          addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
          });
  
          //console.log(selectedElement.hasAttribute('mini'));
  
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
  
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // TABINDEX attribute
          addProp('Tabindex', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
          });
  
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility', true,
                  '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                  '    <option value="">Visible</option>' +
                  '    <option value="hidden">Invisible</option>' +
                  '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                  '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                  '    <option value="hide-on-phone">Invisible at phone size</option>' +
                  '    <option value="show-on-desktop">Visible at desktop size</option>' +
                  '    <option value="show-on-tablet">Visible at tablet size</option>' +
                  '    <option value="show-on-phone">Visible at phone size</option>' +
                  '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
  
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
  
              return selectedElement;
          });
  
          // DISABLED attribute
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
          
          addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
          });
  
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
  
      function transformCSS(css) {
          return  '-webkit-transform: ' + css + '; ' +
                  '-moz-transform: ' + css + '; ' +
                  '-ms-transform: ' + css + '; ' +
                  '-o-transform: ' + css + '; ' +
                  'transform: ' + css + ';';
      }
  
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  if (strQSValue !== '' || !element.getAttribute('value')) {
                      element.setAttribute('value', strQSValue);
                  }
              } else {
                  element.value = strQSValue;
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
  
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          i = 0;
          len = element.attributes.length;
          arrAttr = element.attributes;
          while (i < len) {
              jsnAttr = element.attributes[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      /***************** DATETIME WHEEL *****************/
  
      function datetimeOpenWheelDialog(element) {
          var i;
          var len;
          var arrFormat = element.getAttribute('format').split(/\b/);
          var arrDate = element.value.split(/\b/);
          if (arrFormat.indexOf('\'') > -1) {
              var arrTempDate = [];
              for (i = 0, len = arrDate.length; i < len; i += 1) {
                  if (arrDate[i].indexOf('T') > 1) {
                      var temp = arrDate[i].split('T');
                      arrTempDate.push(temp[0], '\'', 'T', '\'', temp[1]);
                  } else {
                      arrTempDate.push(arrDate[i]);
                  }
              }
              arrDate = arrTempDate;
          }
          var dialogHTML;
          var label = element.hasAttribute('id') ? xtag.query(document, '[for="' + element.id + '"]')[0] : null;
          var labelHTML = label ? '<center><h3>' + label.innerHTML.replace(/:$/, '') + '</h3></center>' : '';
          var dialogTemplate = document.createElement('template');
          var monthsFull   = ['January','February','March','April','May','June', 'July','August','September','October','November','December'];
          var monthsShort  = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  
          var wheelHTML = function () {
              var strRet = '';
              for (i = 0, len = arrFormat.length; i < len; i += 1) {
                  if (arrFormat[i] === '\'') {
                      i += 1;
                  }
  
                  if (arrFormat[i] === 'MMMM') {
                      arrFormat[i] = 'MM';
                      arrDate[i] = monthsFull.indexOf(arrDate[i]) + 1;
  
                  } else if (arrFormat[i] === 'MMM') {
                      arrFormat[i] = 'MM';
                      arrDate[i] = monthsShort.indexOf(arrDate[i]) + 1;
  
                  } else if (arrFormat[i] === 'a') {
                      arrFormat[i] = 'ampm';
  
                  } else if (arrFormat[i] === 'EEE' || arrFormat[i] === 'EEEE') {
                      i += 1;
                      continue;
                  }
                  strRet += '<gs-wheel values="' + arrFormat[i] + '" value="' + arrDate[i] + '"></gs-wheel>';
                  i += 1;
  
                  if (arrFormat[i] === '\'') {
                      i += 1;
                  }
  
                  if (i < len) {
                      strRet += '<span class="divider"' + (evt.touchDevice ? ' touch' : '') + '><span>' + arrFormat[i] + '</span></span>';
                  }
              }
              return strRet;
          };
  
          dialogHTML = ml(function () {/*
              <gs-page>
                  <gs-header>
                      {{LABELHTML}}
                      <gs-grid widths="1,1,1">
                          <gs-block>
                              <gs-button dialogclose>Cancel</gs-button>
                          </gs-block>
                          <gs-block>
                              <gs-button class="now-button">Now</gs-button>
                          </gs-block>
                          <gs-block>
                              <gs-button dialogclose bg-primary>Done</gs-button>
                          </gs-block>
                      </gs-grid>
                  </gs-header>
                  <gs-body class="gs-datetime-wheel-dialog">
                      <div class="root">
                          {{WHEELS}}
                      </div>
                  </gs-body>
              </gs-page>
          */}).replace('{{LABELHTML}}', labelHTML).replace('{{WHEELS}}', wheelHTML());
          dialogTemplate.innerHTML = dialogHTML;
          dialogTemplate.setAttribute('data-mode', 'full');
          GS.openDialog(dialogTemplate, function () {
              var dialog = xtag.query(document, 'gs-dialog')[0];
  
              xtag.query(dialog, '.now-button')[0].addEventListener('click', function () {
                  element.dteValue = new Date();
                  arrFormat = element.getAttribute('format').split(/\b/);
                  arrDate = element.value.split(/\b/);
                  xtag.query(dialog, '.gs-datetime-wheel-dialog > .root')[0].innerHTML = wheelHTML();
              });
  
              dialog.addEventListener('change', function (event) {
                  console.log(event.target);
                  if (event.target.getAttribute('values') === 'MM' || event.target.getAttribute('values')[0] === 'y') {
                      var year = xtag.query(dialog, 'gs-wheel[values^="y"]')[0].value;
                      var month = xtag.query(dialog, 'gs-wheel[values="MM"]')[0].value;
                      var dayElement = xtag.query(dialog, 'gs-wheel[values^="d"]')[0];
                      // month is zero based, but we pass a one based number
                      // 0 is the last day of the previous month
                      var days = new Date(year, month, 0).getDate();
                      console.log(days, dayElement);
  
                      var valuesPart = dayElement.getAttribute('values').match(/d*/)[0];
                      dayElement.parentNode.insertBefore(GS.stringToElement('<gs-wheel values="' + valuesPart + ',' + days + '" value="' + Math.min(dayElement.value, days) + '"></gs-wheel>'), dayElement);
                      dayElement.parentNode.removeChild(dayElement);
                  }
              });
              GS.triggerEvent(xtag.query(dialog, 'gs-wheel[values="MM"]')[0], 'change');
  
          }, function (event, strAnswer) {
              if (strAnswer === 'Done') {
                  for (i = 0, len = arrFormat.length; i < len; i += 1) {
                      if (arrFormat[i] === '\'') {
                          i += 1;
                      }
  
                      if (arrFormat[i] === 'MMMM') {
                          arrFormat[i] = 'MM';
                          arrDate[i] = monthsFull.indexOf(arrDate[i]);
  
                      } else if (arrFormat[i] === 'MMM') {
                          arrFormat[i] = 'MM';
                          arrDate[i] = monthsShort.indexOf(arrDate[i]);
  
                      } else if (arrFormat[i] === 'a') {
                          arrFormat[i] = 'ampm';
  
                      } else if (arrFormat[i] === 'EEE' || arrFormat[i] === 'EEEE') {
                          i += 1;
                          continue;
                      }
                      arrDate[i] = xtag.query(document, 'gs-dialog .gs-datetime-wheel-dialog gs-wheel[values="' + arrFormat[i] + '"]')[0].value;
                      i += 1;
  
                      if (arrFormat[i] === '\'') {
                          i += 1;
                      }
                  }
  
                  element.value = arrDate.join('').replace('\'T\'', 'T');
                  element.dteValue = new Date(element.value);
                  GS.triggerEvent(element, 'change');
              }
          });
      }
  
      /***************** DATETIME CALENDER *****************/
  
      function getFormatString(element) {
          var strFormat;
  
          if (element.hasAttribute('format')) {
              strFormat = element.getAttribute('format');
          }
  
          if (!strFormat) {
              strFormat = 'MM/dd/yyyy';
          } else if (strFormat.toLowerCase() === 'shortdate') {
              strFormat = 'M/d/yy';
          } else if (strFormat.toLowerCase() === 'mediumdate') {
              strFormat = 'MMM d, yyyy';
          } else if (strFormat.toLowerCase() === 'longdate') {
              strFormat = 'MMMM d, yyyy';
          } else if (strFormat.toLowerCase() === 'fulldate') {
              strFormat = 'EEEE, MMMM d, yyyy';
          } else if (strFormat.toLowerCase() === 'shorttime') {
              strFormat = 'h:mm a';
          } else if (strFormat.toLowerCase() === 'mediumtime') {
              strFormat = 'h:mm:ss a';
          } else if (strFormat.toLowerCase() === 'isodate') {
              strFormat = 'yyyy-MM-dd';
          } else if (strFormat.toLowerCase() === 'isotime') {
              strFormat = 'HH:mm:ss';
          } else if (strFormat.toLowerCase() === 'isodatetime') {
              strFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
          }
  
          return strFormat;
      }
  
      function formatDate(dteValue, strFormat) {
          /* (this function contains a (modified) substantial portion of code from another source
              here is the copyright for sake of legality) (Uses code by Matt Kruse)
          Copyright (c) 2006-2009 Rostislav Hristov, Asual DZZD
  
          Permission is hereby granted, free of charge, to any person obtaining a
          copy of this software and associated documentation files
          (the "Software"), to deal in the Software without restriction,
          including without limitation the rights to use, copy, modify, merge,
          publish, distribute, sublicense, and/or sell copies of the Software,
          and to permit persons to whom the Software is furnished to do so,
          subject to the following conditions:
  
          The above copyright notice and this permission notice shall be included
          in all copies or substantial portions of the Software.
  
          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
          IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
          CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
          TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
          SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/
          var i = 0, j = 0, l = 0, c = '', token = '', x, y, yearLen,
              formatNumber = function (n, s) {
                  if (typeof s == 'undefined' || s == 2) {
                    return (n >= 0 && n < 10 ? '0' : '') + n;
                  } else {
                      if (n >= 0 && n < 10) {
                         return '00' + n;
                      }
                      if (n >= 10 && n <100) {
                         return '0' + n;
                      }
                      return n;
                  }
              },
              locale = {
                  monthsFull:   ['January','February','March','April','May','June', 'July','August','September','October','November','December'],
                  monthsShort:  ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
                  daysFull:     ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
                  daysShort:    ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
                  shortDateFormat: 'M/d/yyyy h:mm a',
                  longDateFormat: 'EEEE, MMMM dd, yyyy h:mm:ss a'
              };
  
          y = dteValue.getFullYear();
          // Nunzio commented this out on Monday, October 19, 2015
          // It was causing an issue during typing in the year field
          /*if (y < 1000) {
              y = String(y + 1900);
          }*/
  
          var M = dteValue.getMonth() + 1,
              d = dteValue.getDate(),
              E = dteValue.getDay(),
              H = dteValue.getHours(),
              m = dteValue.getMinutes(),
              s = dteValue.getSeconds(),
              S = dteValue.getMilliseconds();
  
          //console.log(dteValue.getFullYear());
  
          yearLen = String(y).length;
          dteValue = {
              y: y,
              yyyy: y,
              yy: String(y).substring(yearLen - 2, yearLen),
              M: M,
              MM: formatNumber(M),
              MMM: locale.monthsShort[M-1],
              MMMM: locale.monthsFull[M-1],
              d: d,
              dd: formatNumber(d),
              EEE: locale.daysShort[E],
              EEEE: locale.daysFull[E],
              H: H,
              HH: formatNumber(H)
          };
  
          //console.log(dteValue);
  
          if (H === 0) {
              dteValue.h = 12;
          } else if (H > 12) {
              dteValue.h = H - 12;
          } else {
              dteValue.h = H;
          }
  
          dteValue.hh = formatNumber(dteValue.h);
          dteValue.k = H !== 0 ? H : 24;
          dteValue.kk = formatNumber(dteValue.k);
  
          if (H > 11) {
              dteValue.K = H - 12;
          } else {
              dteValue.K = H;
          }
  
          dteValue.KK = formatNumber(dteValue.K);
  
          if (H > 11) {
              dteValue.a = 'PM';
          } else {
              dteValue.a = 'AM';
          }
  
          dteValue.m = m;
          dteValue.mm = formatNumber(m);
          dteValue.s = s;
          dteValue.ss = formatNumber(s);
          dteValue.S = S;
          dteValue.SS = formatNumber(S);
          dteValue.SSS = formatNumber(S, 3);
  
          var result = '';
  
          i = 0;
          c = '';
          token = '';
          s = false;
  
          while (i < strFormat.length) {
              token = '';
              c = strFormat.charAt(i);
              if (c == '\'') {
                  i++;
                  if (strFormat.charAt(i) == c) {
                      result = result + c;
                      i++;
                  } else {
                      s = !s;
                  }
              } else {
                  while (strFormat.charAt(i) == c) {
                      token += strFormat.charAt(i++);
                  }
                  if (token.indexOf('MMMM') != -1 && token.length > 4) {
                      token = 'MMMM';
                  }
                  if (token.indexOf('EEEE') != -1 && token.length > 4) {
                      token = 'EEEE';
                  }
                  if (typeof dteValue[token] != 'undefined' && !s) {
                      result = result + dteValue[token];
                  } else {
                      result = result + token;
                  }
              }
          }
  
          return result;
      }
  
      function datetimeOpenCalenderDialog(element) {
          'use strict';
          var i, len, dateHTML, timeHTML, pickerHTML, dialogHTML, dialogTemplate = document.createElement('template');
          var dteToday = new Date(), dteValue = element.dteValue || new Date(dteToday);
  
          dateHTML = ml(function () {/*
              <div class="date-section">
                  <div class="adjust-section date-adjust-section centered">
                      <div class="date-today">&#xf017;</div>
                      <div class="date-input">
                          <input class="month" />
                          <span class="divider">/</span>
                          <input class="day" />
                          <span class="divider">/</span>
                          <input class="year" />
                      </div>
                      <div class="adjust-container">
                          <div class="date-adjust up">&#xf077;</div><div class="date-adjust down">&#xf078;</div>
                      </div>
                  </div>
                  <div class="calender centered">
                      <div flex-horizontal>
                          <gs-button icononly icon="chevron-left" class="month-adjust down"></gs-button>
  
                          <center flex class="month-label"></center>
  
                          <gs-button icononly icon="chevron-right" class="month-adjust up"></gs-button>
                      </div>
                      <div flex-horizontal>
                          <gs-button icononly icon="chevron-left" class="year-adjust down"></gs-button>
  
                          <center flex class="year-label"></center>
  
                          <gs-button icononly icon="chevron-right" class="year-adjust up"></gs-button>
                      </div>
                      <div>
                          <div class="day-letter">S</div><div class="day-letter">M</div><div class="day-letter">T</div><div class="day-letter">W</div><div class="day-letter">T</div><div class="day-letter">F</div><div class="day-letter">S</div>
                      </div>
                  </div>
              </div>
          */});
          timeHTML = ml(function () {/*
              <div class="time-section">
                  <div class="adjust-section time-adjust-section centered">
                      <div class="time-now">&#xf017;</div>
                      <div class="time-input">
                          <input class="hour" />
                          <span class="divider">:</span>
                          <input class="minute" />
                          <span class="divider">:</span>
                          <input class="second" />
                          <span class="divider"> </span>
                          <input class="ampm" />
                      </div>
                      <div class="adjust-container">
                          <div class="time-adjust up">&#xf077;</div><div class="time-adjust down">&#xf078;</div>
                      </div>
                  </div>
                  <div class="clock-parent">
                      <div class="clock"></div>
                  </div>
              </div>
          */});
  
          if (element.hasDate && element.hasTime) {
              pickerHTML = ml(function () {/*
                  <gs-grid widths="1,1">
                      <gs-block>
                          {{DATEHTML}}
                      </gs-block>
                      <gs-block>
                          {{TIMEHTML}}
                      </gs-block>
                  </gs-grid>
              */}).replace('{{DATEHTML}}', dateHTML).replace('{{TIMEHTML}}', timeHTML);
  
          } else if (element.hasDate) {
              pickerHTML = dateHTML;
  
          } else if (element.hasTime) {
              pickerHTML = timeHTML;
  
          }
  
          dialogHTML = ml(function () {/*
              <gs-page>
                  <gs-body class="gs-datetime-calender-dialog">
                      {{PICKERHTML}}
                      <gs-grid widths="1,1">
                          <gs-block>
                              <gs-button dialogclose>Cancel</gs-button>
                          </gs-block>
                          <gs-block>
                              <gs-button dialogclose bg-primary>Done</gs-button>
                          </gs-block>
                      </gs-grid>
                  </gs-body>
              </gs-page>
          */}).replace('{{PICKERHTML}}', pickerHTML);
          dialogTemplate.innerHTML = dialogHTML;
          dialogTemplate.setAttribute('no-background', '');
          dialogTemplate.setAttribute('data-overlay-close', '');
          GS.openDialogToElement(element, dialogTemplate, 'down', function () {
              var dteStart = new Date(dteValue);
  
              var refreshDateInputs = function () {};
              var refreshTimeInputs = function () {};
  
              var regenerateCalender = function () {};
              var resetClock = function () {};
  
              if (element.hasDate) {
                  var calender = xtag.query(document, 'gs-dialog .calender')[0];
                  var dateAdjustSection = xtag.query(document, 'gs-dialog .date-adjust-section')[0];
                  var dateInput = xtag.query(dateAdjustSection, '.date-input')[0];
  
                  var dayInput = xtag.query(dateInput, '.day')[0];
                  var monthInput = xtag.query(dateInput, '.month')[0];
                  var yearInput = xtag.query(dateInput, '.year')[0];
  
                  var monthLabel = xtag.query(calender, '.month-label')[0];
                  var yearLabel = xtag.query(calender, '.year-label')[0];
                  var arrMonth = [
                      'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
                  ];
  
                  refreshDateInputs = function () {
                      dayInput.value = GS.leftPad(dteValue.getDate(), '0', 2);
                      monthInput.value = GS.leftPad(dteValue.getMonth() + 1, '0', 2);
                      yearInput.value = dteValue.getFullYear();
  
                      if (dateInput.selectText) {
                          GS.setInputSelection(dateInput.selectText, 0, dateInput.selectText.value.length);
                          dateInput.selectText = null;
                      }
                  };
                  refreshDateInputs();
  
                  regenerateCalender = function (dteStart) {
                      var children = xtag.queryChildren(calender, '.day');
                      for (var i = 0, len = children.length; i < len; i += 1) {
                          calender.removeChild(children[i]);
                      }
  
                      var dteCurrent = new Date(dteStart), intCurrentMonth = dteCurrent.getMonth(), intNextMonth = intCurrentMonth + 1;
                      if (intNextMonth === 12) {
                          intNextMonth = 0;
                      }
  
                      monthLabel.innerText = arrMonth[dteStart.getMonth()];
                      yearLabel.innerText = dteStart.getFullYear();
  
                      dteCurrent.setDate(1);
                      dteCurrent.setDate(dteCurrent.getDate() - dteCurrent.getDay());
  
                      while (dteCurrent.getMonth() !== intNextMonth || dteCurrent.getDay() !== 0) {
                          var day = document.createElement('div');
                          day.classList.add('day');
                          day.innerText = dteCurrent.getDate();
                          if (dteCurrent.getMonth() !== intCurrentMonth) {
                              day.classList.add('grey');
                          }
                          if (dteCurrent.getMonth() === dteToday.getMonth() && dteCurrent.getFullYear() === dteToday.getFullYear() && dteCurrent.getDate() === dteToday.getDate()) {
                              day.classList.add('today');
                              day.innerText = 'T';
                          }
                          if (dteCurrent.getMonth() === dteValue.getMonth() && dteCurrent.getFullYear() === dteValue.getFullYear() && dteCurrent.getDate() === dteValue.getDate()) {
                              day.classList.add('selected');
                          }
                          day.value = new Date(dteCurrent);
                          calender.appendChild(day);
  
                          dteCurrent.setDate(dteCurrent.getDate() + 1);
                      }
                  };
                  regenerateCalender(dteStart);
  
                  dateInput.addEventListener('keydown', function (event) {
                      var code = event.which || event.keyCode || event.charCode;
                      var dtePreviousValue = new Date(dteValue);
                      // 38: up
                      // 40: down
                      if (code === 38 || code === 40) {
                          event.target.value = GS.leftPad((parseInt(event.target.value, 10) + (code === 38 ? 1 : -1)).toString(), '0', 2);
                          dateInput.selectText = event.target;
                          event.preventDefault();
                      }
  
                      if (event.target.classList.contains('year')) {
                          dteValue.setFullYear(event.target.value);
                          dteStart = new Date(dteValue);
  
                      } else if (event.target.classList.contains('month')) {
                          dteValue.setMonth(parseInt(event.target.value, 10) - 1);
                          dteStart = new Date(dteValue);
  
                      } else if (event.target.classList.contains('day')) {
                          dteValue.setDate(event.target.value);
                          dteStart = new Date(dteValue);
                      }
  
                      if (dtePreviousValue.getTime() !== dteValue.getTime()) {
                          refreshDateInputs();
                          regenerateCalender(dteStart);
                      }
                  });
  
                  dateAdjustSection.addEventListener('mousedown', function (event) {
                      if (event.target.nodeName.toUpperCase() !== 'INPUT') {
                          event.preventDefault();
                      }
                  });
  
                  dateAdjustSection.addEventListener('click', function (event) {
                      var dtePreviousValue = new Date(dteValue);
                      var activeElement = document.activeElement; // just to shorten things a bit
  
                      if (activeElement.parentNode.classList.contains('date-input') && event.target.classList.contains('date-adjust')) {
                          activeElement.value = GS.leftPad((parseInt(activeElement.value, 10) + (event.target.classList.contains('up') ? 1 : -1)).toString(), '0', 2);
                          dateInput.selectText = activeElement;
  
                          if (activeElement.classList.contains('year')) {
                              dteValue.setFullYear(activeElement.value);
  
                          } else if (activeElement.classList.contains('month')) {
                              dteValue.setMonth(parseInt(activeElement.value, 10) - 1);
  
                          } else if (activeElement.classList.contains('day')) {
                              dteValue.setDate(activeElement.value);
                          }
                          dteStart = new Date(dteValue);
  
                      } else if (event.target.classList.contains('date-today')) {
                          dteValue.setFullYear(dteToday.getFullYear());
                          dteValue.setMonth(dteToday.getMonth());
                          dteValue.setDate(dteToday.getDate());
  
                          dteStart = new Date(dteValue);
  
                      }
  
                      if (dtePreviousValue.getTime() !== dteValue.getTime()) {
                          refreshDateInputs();
                          regenerateCalender(dteStart);
                      }
                  });
  
                  calender.addEventListener('click', function (event) {
                      if (event.target.classList.contains('day')) {
                          var selected = xtag.query(calender, '.selected')[0];
                          if (selected) {
                              selected.classList.remove('selected');
                              event.target.classList.add('selected');
                          }
  
                          dteValue = event.target.value;
                          dteStart = new Date(dteValue);
  
                          refreshDateInputs();
                          if (event.target.classList.contains('grey')) {
                              regenerateCalender(dteStart);
                          }
                      } else if (event.target.classList.contains('month-adjust')) {
                          dteStart.setMonth(dteStart.getMonth() + (event.target.classList.contains('up') ? 1 : -1));
  
                          monthLabel.innerText = arrMonth[dteStart.getMonth()];
  
                          regenerateCalender(dteStart);
                      } else if (event.target.classList.contains('year-adjust')) {
                          dteStart.setFullYear(dteStart.getFullYear() + (event.target.classList.contains('up') ? 1 : -1));
  
                          yearLabel.innerText = dteStart.getFullYear();
  
                          regenerateCalender(dteStart);
                      }
                  });
              }
  
              if (element.hasTime) {
                  var clock = xtag.query(document, 'gs-dialog .clock')[0];
                  var timeAdjustSection = xtag.query(document, 'gs-dialog .time-adjust-section')[0];
                  var timeInput = xtag.query(timeAdjustSection, '.time-input')[0];
  
                  var hourInput = xtag.query(timeInput, '.hour')[0];
                  var minuteInput = xtag.query(timeInput, '.minute')[0];
                  var secondInput = xtag.query(timeInput, '.second')[0];
                  var ampmInput = xtag.query(timeInput, '.ampm')[0];
  
                  var hourHand;
                  var minuteHand;
                  var secondHand;
  
                  refreshTimeInputs = function () {
                      var hour = dteValue.getHours();
                      var ampm = hour >= 12 ? 'PM' : 'AM';
                      hour = hour === 0 ? 24 : hour;
                      hour = hour > 12 ? hour - 12 : hour;
                      hourInput.value = GS.leftPad(hour, '0', 2);
                      minuteInput.value = GS.leftPad(dteValue.getMinutes(), '0', 2);
                      secondInput.value = GS.leftPad(dteValue.getSeconds(), '0', 2);
                      ampmInput.value = ampm;
  
                      if (timeInput.selectText) {
                          GS.setInputSelection(timeInput.selectText, 0, timeInput.selectText.value.length);
                          timeInput.selectText = null;
                      }
                  };
                  refreshTimeInputs();
  
                  var i = 0, len = 60, clockHTML = '';
                  for (; i < len; i += 1) {
                      clockHTML += '<div class="marking' + ((i % 5) === 0 ? ' large' : '') + '" style="' + transformCSS('rotate(' + i * 6 + 'deg)') + '"></div>';
                  }
                  clockHTML += ml(function () {/*
                      <div class="position-reference"></div>
                      <div class="clock-hand hour-hand">
                          <div class="clock-hand-drag-handle"></div>
                      </div>
                      <div class="clock-hand minute-hand">
                          <div class="clock-hand-drag-handle"></div>
                      </div>
                      <div class="clock-hand second-hand">
                          <div class="clock-hand-drag-handle"></div>
                      </div>
                  */});
                  clock.innerHTML = clockHTML;
                  hourHand = xtag.query(clock, '.hour-hand')[0];
                  minuteHand = xtag.query(clock, '.minute-hand')[0];
                  secondHand = xtag.query(clock, '.second-hand')[0];
                  var resetClock = function () {
                      // the 180 is because the html is such that the hands point down
                      hourHand.setAttribute('style', transformCSS('rotate(' + (((dteValue.getHours() % 12) * 30) + 180) + 'deg)'));
                      minuteHand.setAttribute('style', transformCSS('rotate(' + ((dteValue.getMinutes() * 6) + 180) + 'deg)'));
                      secondHand.setAttribute('style', transformCSS('rotate(' + ((dteValue.getSeconds() * 6) + 180) + 'deg)'));
                  };
                  resetClock();
  
                  timeInput.addEventListener('keydown', function (event) {
                      var code = event.which || event.keyCode || event.charCode;
                      var dtePreviousValue = new Date(dteValue);
                      // 38: up
                      // 40: down
                      // 65: a
                      // 80: p
                      if (event.target.classList.contains('ampm')) {
                          timeInput.selectText = event.target;
                          event.preventDefault();
  
                          if (dteValue.getHours() >= 12 && (code === 65 || code === 38 || code === 40)) {
                              dteValue.setHours(dteValue.getHours() - 12);
  
                          } else if (dteValue.getHours() < 12 && (code === 80 || code === 38 || code === 40)) {
                              dteValue.setHours(dteValue.getHours() + 12);
  
                          }
  
                      } else if (code === 38 || code === 40) {
                          event.target.value = GS.leftPad((parseInt(event.target.value, 10) + (code === 38 ? 1 : -1)).toString(), '0', 2);
                          timeInput.selectText = event.target;
                          event.preventDefault();
                      }
  
                      if (event.target.classList.contains('hour')) {
                          dteValue.setHours(event.target.value + (dteValue.getHours() > 12 ? 12 : 0));
                          dteStart = new Date(dteValue);
  
                      } else if (event.target.classList.contains('minute')) {
                          dteValue.setMinutes(event.target.value);
                          dteStart = new Date(dteValue);
  
                      } else if (event.target.classList.contains('second')) {
                          dteValue.setSeconds(event.target.value);
                          dteStart = new Date(dteValue);
                      }
  
                      if (dtePreviousValue.getTime() !== dteValue.getTime()) {
                          refreshTimeInputs();
                          refreshDateInputs();
  
                          resetClock(dteStart);
                          regenerateCalender(dteStart);
                      }
                  });
  
                  timeAdjustSection.addEventListener('mousedown', function (event) {
                      if (event.target.nodeName.toUpperCase() !== 'INPUT') {
                          event.preventDefault();
                      }
                  });
  
                  timeAdjustSection.addEventListener('click', function (event) {
                      var dtePreviousValue = new Date(dteValue);
                      var activeElement = document.activeElement; // just to shorten things a bit
  
                      if (event.target.classList.contains('ampm')) {
                          GS.setInputSelection(event.target, 0, 2);
  
                      } else if (activeElement.parentNode.classList.contains('time-input') && event.target.classList.contains('time-adjust')) {
                          if (activeElement.classList.contains('ampm')) {
                              if (dteValue.getHours() < 12) {
                                  dteValue.setHours(dteValue.getHours() + 12);
  
                              } else {
                                  dteValue.setHours(dteValue.getHours() - 12);
                              }
  
                          } else {
                              activeElement.value = GS.leftPad((parseInt(activeElement.value, 10) + (event.target.classList.contains('up') ? 1 : -1)).toString(), '0', 2);
                          }
                          timeInput.selectText = activeElement;
  
                          if (activeElement.classList.contains('hour')) {
                              if (activeElement.value === '11' && dteValue.getHours() === 0) {
                                  dteValue.setHours(-1);
  
                                  dteStart = new Date(dteValue);
                                  regenerateCalender(dteStart);
                              } else {
                                  dteValue.setHours(parseInt(activeElement.value, 10) + (dteValue.getHours() > 12 ? 12 : 0));
                              }
  
                          } else if (activeElement.classList.contains('minute')) {
                              dteValue.setMinutes(activeElement.value);
  
                          } else if (activeElement.classList.contains('second')) {
                              dteValue.setSeconds(activeElement.value);
  
                          }
                          dteStart = new Date(dteValue);
  
                      } else if (event.target.classList.contains('time-now')) {
                          var dteNow = new Date();
                          dteValue.setHours(dteToday.getHours());
                          dteValue.setMinutes(dteToday.getMinutes());
                          dteValue.setSeconds(dteToday.getSeconds());
  
                          dteStart = new Date(dteValue);
  
                      }
  
                      if (dtePreviousValue.getTime() !== dteValue.getTime()) {
                          refreshTimeInputs();
                          refreshDateInputs();
  
                          resetClock(dteStart);
                          regenerateCalender(dteStart);
                      }
                  });
  
                  clock.addEventListener('mousedown', function (event) {
                      var target = event.target;
  
                      var clockRect = clock.getBoundingClientRect();
                      var refX = clockRect.left + (clockRect.width / 2);
                      var refY = clockRect.top + (clockRect.height / 2);
  
                      if (target.classList.contains('clock-hand-drag-handle')) {
                          target = target.parentNode;
                      }
  
                      if (target.classList.contains('clock-hand')) {
                          var dragHandler = function (event) {
                              var x = event.clientX - refX;
                              var y = event.clientY - refY;
                              var thetaRad = Math.atan2(y, x); // atan2 needs y first (?!?!?!?)
                              var thetaDeg = thetaRad * (180 / Math.PI);
                              if (target.classList.contains('hour-hand')) {
                                  var tMod30 = thetaDeg % 30;
                                  if (tMod30 <= 15) {
                                      thetaDeg -= tMod30;
                                  } else {
                                      thetaDeg += 30 - tMod30;
                                  }
                              } else {
                                  var tMod6 = thetaDeg % 6;
                                  if (tMod6 <= 3) {
                                      thetaDeg -= tMod6;
                                  } else {
                                      thetaDeg += 6 - tMod6;
                                  }
                              }
                              thetaDeg += 90;
                              if (thetaDeg <= 0) {
                                  thetaDeg += 360;
                              }
  
                              if (target.classList.contains('hour-hand')) {
                                  var newHours = thetaDeg / 30;
                                  // 11PM -> 12AM
                                  if (dteValue.getHours() === 23 && newHours === 12) {
                                      dteValue.setHours(24);
  
                                  // 1PM -> 12PM (because below we do 12 + newHours)
                                  } else if (dteValue.getHours() === 13 && newHours === 12) {
                                      dteValue.setHours(12);
  
                                  // 12AM -> 11PM
                                  } else if (dteValue.getHours() === 0 && newHours === 11) {
                                      dteValue.setHours(-1);
  
                                  // 12AM -> 12AM
                                  } else if (dteValue.getHours() === 0 && newHours === 12) {
                                      dteValue.setHours(0);
  
                                  // 11PM -> 10PM
                                  } else if (dteValue.getHours() === 23 && newHours < 11) {
                                      dteValue.setHours(12 + newHours);
  
                                  // 12PM -> 1PM
                                  } else if (dteValue.getHours() === 12 && newHours === 1) {
                                      dteValue.setHours(13);
  
                                  // 1AM -> 12AM
                                  } else if (dteValue.getHours() === 1 && newHours === 12) {
                                      dteValue.setHours(0);
  
                                  // *PM -> *PM
                                  } else if (dteValue.getHours() > 12) {
                                      dteValue.setHours(12 + newHours);
  
                                  // *AM -> *AM
                                  } else {
                                      dteValue.setHours(newHours);
                                  }
  
                              } else if (target.classList.contains('minute-hand')) {
                                  var newMinutes = thetaDeg / 6;
                                  newMinutes = newMinutes === 60 ? 0 : newMinutes;
                                  if (dteValue.getMinutes() === 59 && newMinutes === 0) {
                                      dteValue.setMinutes(60);
  
                                  } else if (dteValue.getMinutes() === 0 && newMinutes === 59) {
                                      dteValue.setMinutes(-1);
  
                                  } else {
                                      dteValue.setMinutes(newMinutes);
                                  }
  
                              } else if (target.classList.contains('second-hand')) {
                                  var newSeconds = thetaDeg / 6;
                                  newSeconds = newSeconds === 60 ? 0 : newSeconds;
                                  if (dteValue.getSeconds() === 59 && newSeconds === 0) {
                                      dteValue.setSeconds(60);
  
                                  } else if (dteValue.getSeconds() === 0 && newSeconds === 59) {
                                      dteValue.setSeconds(-1);
  
                                  } else {
                                      dteValue.setSeconds(newSeconds);
                                  }
  
                              }
  
                              if (dteStart.getTime() !== dteValue.getTime()) {
                                  dteStart = new Date(dteValue);
  
                                  refreshTimeInputs();
                                  refreshDateInputs();
  
                                  resetClock(dteStart);
                                  regenerateCalender(dteStart);
                              }
                          };
  
                          var dragStopHandler = function (event) {
                              window.removeEventListener('mousemove', dragHandler);
                              window.removeEventListener('mouseup', dragStopHandler);
                          };
  
                          window.addEventListener('mousemove', dragHandler);
                          window.addEventListener('mouseup', dragStopHandler);
                      }
                  });
              }
          }, function (event, strAnswer) {
              if (strAnswer === 'Done') {
                  element.dteValue = dteValue;
                  GS.triggerEvent(element, 'change');
              }
          });
      }
  
      // dont do anything that modifies the element here
      function datetimeElementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
  
          }
      }
  
      // re-target focus event from control to element
      function focusFunction(event) {
          event.target.classList.add('focus');
      }
  
      // re-target blur event from control to element
      function blurFunction(event) {
          event.target.classList.remove('focus');
      }
  
      // mouseout, remove hover class
      function mouseoutFunction(event) {
          event.target.classList.remove('hover');
      }
  
      // mouseover, add hover class
      function mouseoverFunction(event) {
          event.target.classList.add('hover');
      }
  
      function datetimeElementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
  
                  if (element.hasAttribute('format')) {
                      element.setAttribute('format', getFormatString(element));
  
                      var d1 = new Date(), d2 = new Date(formatDate(d1, element.getAttribute('format')));
                      if (d1.getTime() !== d2.getTime()) {
                          element.timezoneOffset = d2.getTime() - d1.getTime();
                      }
                  } else {
                      element.setAttribute('format', getFormatString(element));
                  }
  
                  element.hasDate = /\b(y|yyyy|yy|M|MM|MMM|MMMM|d|dd|EEE|EEEE)\b/g.test(element.getAttribute('format'));
                  element.hasTime = /\b(k|kk|hh|h|H|HH|m|mm|s|ss|S|SS|SSS)\b/g.test(element.getAttribute('format'));
  
                  if (element.getAttribute('value') === 'today' || element.getAttribute('value') === 'now') {
                      element.dteValue = new Date();
                  } else if (element.hasAttribute('value')) {
                      element.dteValue = new Date((element.hasDate ? '' : '1/1/1970 ') + element.getAttribute('value') + (element.hasTime ? '' : ' 00:00:00'));
                  } else if (!element.getAttribute('value') && element.hasAttribute('placeholder')) {
                      element.innerHTML = '<span gs-dynamic class="placeholder">' + element.getAttribute('placeholder') + '</span>';
                  }
  
                  // handle "qs" attribute
                  if (element.getAttribute('qs')) {
                      pushReplacePopHandler(element);
                      window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                      window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                      window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                  }
  
                  var label = element.hasAttribute('id') ? xtag.query(document, '[for="' + element.id + '"]')[0] : null;
                  if (label) {
                      label.addEventListener('click', function () {
                          GS.triggerEvent(element, 'click');
                      });
                  }
  
                  element.addEventListener('click', function () {
                      if (!element.hasAttribute('disabled') && !element.hasAttribute('readonly')) {
                          if (evt.touchDevice) {
                              datetimeOpenWheelDialog(element);
                          } else {
                              datetimeOpenCalenderDialog(element);
                          }
                      }
                  });
  
                  element.addEventListener('keydown', function (event) {
                      var code = event.which || event.keyCode || event.charCode;
  
                      if (code !== 9) { // tab
                          event.preventDefault();
                          GS.triggerEvent(element, 'click');
                      }
                  });
  
                  element.addEventListener('focus', focusFunction);
                  element.addEventListener('blur', blurFunction);
                  element.addEventListener(evt.mouseout, mouseoutFunction);
                  element.addEventListener(evt.mouseover, mouseoverFunction);
              }
          }
      }
  
      xtag.register('gs-datetime', {
          lifecycle: {
              created: function () {
                  datetimeElementCreated(this);
              },
  
              inserted: function () {
                  datetimeElementInserted(this);
              },
  
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
  
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
  
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
  
                  }
              }
          },
          events: {},
          accessors: {
              value: {
                  get: function () {
                      return this.getAttribute('value');
                  },
                  set: function (newValue) {
                      this.setAttribute('value', newValue);
                      this.innerText = newValue;
                  }
              },
              dteValue: {
                  get: function () {
                      var value = this.value;
                      var dteValue = value ? new Date((this.hasDate ? '' : '1/1/1970 ') + value + (this.hasTime ? '' : ' 00:00:00')) : null;
  
                      return dteValue;
                  },
                  set: function (newValue) {
                      this.value = formatDate(newValue, this.getAttribute('format'));
                  }
              }
          },
          methods: {}
      });
  
      /******************* WHEEL ******************/
  
      function wheelDragStartHandler(event) {
          var pageY = 0;
          if (event.touches && event.touches.length !== 1) {
              return;
          } else if (event.touches) {
              pageY = event.touches[0].pageY;
          } else if (event.pageY) {
              pageY = event.pageY;
          }
          var element = this;
          var fontSize = GS.emToPx(element, 1) / GS.emToPx(document.body, 1);
          var wheel = element.wheel;
          element.dragStart = pageY;
          element.rotationStart = element.rotation;
          element.numbersRotated = 1;
          if (element.kineticTimer) {
              clearTimeout(element.kineticTimer);
              element.kineticTimer = null;
          }
          // console.log(element.dragStart, pageY, element.velocity, element.rotation, event);
          // console.log('wheelDragStartHandler', element);
  
          var addNumberToStart = function () {
              wheel.removeChild(wheel.lastChild);
              var newRotation = parseFloat(wheel.firstChild.getAttribute('rotation')), newNumber = parseInt(wheel.firstChild.innerText, 10) - 1;
              newRotation += element.rotationInterval;
              if (newRotation > 0) {
                  newRotation -= 360;
              }
              if (newNumber < element.min) {
                  newNumber += (element.max + 1);
              }
              wheel.insertBefore(GS.stringToElement('<span class="value" rotation="' + newRotation + '" style="transform: rotateX(' + newRotation + 'deg) translateZ(' + element.radius + ');">' + GS.leftPad(newNumber, '0', 2) + '</span>'), wheel.firstChild);
          };
  
          var addNumberToEnd = function () {
              wheel.removeChild(wheel.firstChild);
              var newRotation = parseFloat(wheel.lastChild.getAttribute('rotation')), newNumber = parseInt(wheel.lastChild.innerText, 10) + 1;
              newRotation -= element.rotationInterval;
              if (newRotation < -360) {
                  newRotation += 360;
              }
              if (newNumber >= (element.max + 1)) {
                  newNumber -= (element.max + 1);
              }
              wheel.appendChild(GS.stringToElement('<span class="value" rotation="' + newRotation + '" style="transform: rotateX(' + newRotation + 'deg) translateZ(' + element.radius + ');">' + GS.leftPad(newNumber, '0', 2) + '</span>'));
          };
  
          var dragHandler = function (event) {
              var pageY = 0;
              if (event.touches && event.touches.length !== 1) {
                  return;
              } else if (event.touches) {
                  pageY = event.touches[0].pageY;
              } else if (event.pageY) {
                  pageY = event.pageY;
              }
              // console.log('dragHandler', element);
              element.velocity = element.dragStart - pageY;
              // console.log(element.dragStart, pageY, element.velocity, element.rotation, event);
  
              element.rotation += element.velocity / fontSize;
              wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');
  
              if (!element.ampm) {
                  while ((element.rotation - element.rotationStart) < ((element.numbersRotated - 1) * element.rotationInterval)) {
                      element.numbersRotated -= 1;
  
                      addNumberToStart();
                  }
  
                  while ((element.rotation - element.rotationStart) > (element.numbersRotated * element.rotationInterval)) {
                      element.numbersRotated += 1;
  
                      addNumberToEnd();
                  }
              }
  
              element.dragStart = pageY;
          };
  
          var dragStopHandler = function (event) {
              // console.log('dragStopHandler', element);
  
              if (element.ampm) {
                  while (element.rotation > 180) {
                      element.rotation -= 360;
                  }
                  while (element.rotation < -180) {
                      element.rotation += 360;
                  }
  
                  if (element.rotation < 11.25) {
                      element.rotation = 0;
                  } else if (element.rotation >= 11.25) {
                      element.rotation = 22.25;
                  }
  
                  wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');
  
                  var valueElement = xtag.query(wheel, '[rotation="' + (element.rotation * -1) + '"]')[0];
                  element.setAttribute('value', valueElement.innerText);
                  GS.triggerEvent(element, 'change');
  
              } else {
                  if (Math.abs(element.velocity) > 5) {
                      var drag = 0.01;
                      var interval = 10;
                      element.kineticTimer = setTimeout(function kinetic() {
                          dragHandler({
                              pageY: element.dragStart - (element.velocity * (1 - drag))
                          });
                          drag *= 1.05;
                          if (drag < 1) {
                              element.kineticTimer = setTimeout(kinetic, interval);
                          } else {
                              element.kineticTimer = null;
                              element.velocity = 0;
                              dragStopHandler();
                          }
                      }, interval);
  
                  } else {
                      var oldRotation = element.rotation;
                      element.rotation = Math.round(element.rotation / element.rotationInterval) * element.rotationInterval;
  
                      while (element.rotation > 360) {
                          element.rotation -= 360;
                      }
                      while (element.rotation < 0) {
                          element.rotation += 360;
                      }
  
                      var valueElement = xtag.query(wheel, '[rotation="' + (element.rotation * -1) + '"]')[0];
                      element.setAttribute('value', valueElement.innerText);
  
                      element.rotation = -180;
                      wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');
                      wheelGenerateHTML(element);
                      GS.triggerEvent(element, 'change');
                  }
              }
  
              window.removeEventListener(evt.mousemove, dragHandler);
              window.removeEventListener(evt.mouseup, dragStopHandler);
              window.addEventListener(evt.mouseout, dragStopHandler);
          };
  
          window.addEventListener(evt.mousemove, dragHandler);
          window.addEventListener(evt.mouseup, dragStopHandler);
          window.addEventListener(evt.mouseout, dragStopHandler);
      }
  
      function wheelGenerateHTML(element) {
          element.wheel.innerHTML = '';
          for (var rotation = 0, j = parseInt(element.value, 10) - 8; rotation > -360; rotation -= element.rotationInterval, j += 1) {
              if (element.ampm) {
                  element.wheel.appendChild(GS.stringToElement('<span class="value" rotation="' + rotation + '" style="transform: rotateX(' + rotation + 'deg) translateZ(' + element.radius + ');">' + (rotation === 0 ? 'AM' : 'PM') + '</span>'));
                  if (rotation == -22.5) {
                      break;
                  }
              } else {
                  if (j < element.min) {
                      if (j >= 0) {
                          j = element.max - j;
                      } else {
                          j = (element.max + (element.min === 0 ? 1 : 0)) + j;
                      }
                  }
                  element.wheel.appendChild(GS.stringToElement('<span class="value" rotation="' + rotation + '" style="transform: rotateX(' + rotation + 'deg) translateZ(' + element.radius + ');">' + GS.leftPad(j, '0', 2) + '</span>'));
                  if (j === element.max) {
                      j = element.min - 1;
                  }
              }
          }
      }
  
      // dont do anything that modifies the element here
      function wheelElementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
  
          }
      }
  
      //
      function wheelElementInserted(element) {
          var styleElement, i, len, wheelNames, wheelHTML;
  
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
  
                  if (evt.touchDevice) {
                      element.setAttribute('touch', '');
                  }
  
                  var maybePreventPullToRefresh = false;
                  var lastTouchY = 0;
                  var touchstartHandler = function(e) {
                      if (e.touches.length != 1) {
                          return;
                      }
                      lastTouchY = e.touches[0].clientY;
                      // Pull-to-refresh will only trigger if the scroll begins when the
                      // document's Y offset is zero.
                      maybePreventPullToRefresh = window.pageYOffset == 0;
                  };
  
                  var touchmoveHandler = function(e) {
                      var touchY = e.touches[0].clientY;
                      var touchYDelta = touchY - lastTouchY;
                      lastTouchY = touchY;
  
                      if (maybePreventPullToRefresh) {
                          // To suppress pull-to-refresh it is sufficient to preventDefault the
                          // first overscrolling touchmove.
                          maybePreventPullToRefresh = false;
                          if (touchYDelta > 0) {
                              e.preventDefault();
                              return;
                          }
                      }
  
                      e.preventDefault();
                      return;
  
                      if (window.pageYOffset == 0 && touchYDelta > 0) {
                          e.preventDefault();
                          return;
                      }
                  };
  
                  element.addEventListener('touchstart', touchstartHandler, { passive: false });
                  element.addEventListener('touchmove', touchmoveHandler, { passive: false });
  
                  element.radius = '4em'; //(element.clientHeight / 2) + 'px';
                  element.values = element.getAttribute('values');
                  element.innerHTML = ml(function () {/*
                      <div class="root">
                          <div class="transparent top"></div>
                          <div class="container">
                              <div class="wheel" style="transform: translateZ(-{{RADIUS}}) rotateX(-180deg);"></div>
                          </div>
                          <div class="transparent bottom"></div>
                      </div>
                  */}).replace('{{RADIUS}}', element.radius);
                  element.wheel = xtag.query(element, '.wheel')[0];
                  element.rotation = -180;
                  element.addEventListener(evt.mousedown, wheelDragStartHandler);
                  element.rotationInterval = 360 / 16;
                  //y|yyyy|yy|M|MM|d|dd|EEE|EEEE
                  //k|kk|hh|h|H|HH|m|mm|s|ss|S|SS|SSS
                  console.log(element.values, element.values.substring(0, 2) === 'dd', element.values.substring(0, 1) === 'd');
                  if (element.values === 'M' || element.values === 'MM' || element.values === 'H' || element.values === 'HH') {
                      element.min = 1;
                      element.max = 12;
                  } else if (element.values === 'h' || element.values === 'hh') {
                      element.min = 0;
                      element.max = 23;
                  } else if (element.values === 'k' || element.values === 'kk') {
                      element.min = 0;
                      element.max = 23;
                  } else if (element.values === 'm' || element.values === 'mm' || element.values === 'ss') {
                      element.min = 0;
                      element.max = 59;
                  } else if (element.values[0] === 'd') {
                      element.min = 1;
                      element.max = element.values.length > 2 ? parseInt(element.values.substring(element.values.length - 2, element.values.length), 10) : 31;
                  } else if (element.values === 'y') {
                      element.min = 0;
                      element.max = 99;
                  } else if (element.values === 'yyyy') {
                      element.min = 0;
                      element.max = 10000;
  
                  } else if (element.values === 'ampm') {
                      element.ampm = true;
                      element.rotation = 0;
                      element.wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');
                  } else {
                      var arrValue = element.values.split('-');
                      element.min = arrValue[0];
                      element.max = arrValue[1];
                  }
  
                  wheelGenerateHTML(element);
              }
          }
      }
  
      xtag.register('gs-wheel', {
          lifecycle: {
              created: function () {
                  wheelElementCreated(this);
              },
  
              inserted: function () {
                  wheelElementInserted(this);
              },
  
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
  
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
  
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
  
                  }
              }
          },
          events: {},
          accessors: {
              value: {
                  get: function () {
                      return this.getAttribute('value') || '0';
                  },
                  set: function (newValue) {
                      this.setAttribute('value', newValue);
                      wheelGenerateHTML(this);
                  }
              }
          },
          methods: {}
      });
  });
  
  
  window.addEventListener('design-register-element', function () {
      'use strict';
      registerDesignSnippet('Dialog From Template', 'Dialog From Template', 'GS.openDialog(\'${1:templateID}\', function () {\n' +
                                                                            '    // after dialog open \n' +
                                                                            '}, function (event, strAnswer) {\n' +
                                                                            '    if (strAnswer === \'${2:Ok}\') {\n' +
                                                                            '        // before dialog close\n' +
                                                                            '        $0\n' +
                                                                            '    }\n' +
                                                                            '});');
      
      registerDesignSnippet('GS.openDialog', 'GS.openDialog', 'GS.openDialog(\'${1:templateID}\', function () {\n' +
                                                              '    // after dialog open \n' +
                                                              '}, function (event, strAnswer) {\n' +
                                                              '    if (strAnswer === \'${2:Ok}\') {\n' +
                                                              '        // beforedialog close\n' +
                                                              '        $0\n' +
                                                              '    }\n' +
                                                              '});');
      
      
      registerDesignSnippet('GS.closeDialog', 'GS.closeDialog', 'GS.closeDialog(${1:dialog}, ${2:\'Ok\'});');
      registerDesignSnippet('Close Dialog', 'Close Dialog', 'GS.closeDialog(${1:dialog}, ${2:\'Ok\'});');
      
      registerDesignSnippet('GS.msgbox', 'GS.msgbox', 'GS.msgbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                              '${3:[\'Cancel\', \'Ok\']}, function (strAnswer) {\n' +
                                                      '    if (strAnswer === ${4:\'Ok\'}) {\n' +
                                                      '        // before dialog close\n' +
                                                      '        $0\n' +
                                                      '    }\n' +
                                                      '});');
      registerDesignSnippet('Message Box', 'Message Box', 'GS.msgbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                                  '${3:[\'Cancel\', \'Ok\']}, function (strAnswer) {\n' +
                                                          '    if (strAnswer === ${4:\'Ok\'}) {\n' +
                                                          '        // before dialog close\n' +
                                                          '        $0\n' +
                                                          '    }\n' +
                                                          '});');
      
      registerDesignSnippet('GS.inputbox', 'GS.inputbox', 'GS.inputbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                                  'function (strInputValue) {\n' +
                                                          '    // before dialog close\n' +
                                                          '    $0\n' +
                                                          '});');
      registerDesignSnippet('Input Box', 'Input Box', 'GS.inputbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                              'function (strInputValue) {\n' +
                                                      '    // before dialog close\n' +
                                                      '    $0\n' +
                                                      '});');
      
      registerDesignSnippet('GS.openDialogToElement', 'GS.openDialogToElement',
                                          'GS.openDialogToElement(${1:document.getElementById(\'target\')}, \'${2:templateID}\', ' +
                                                                              '\'${3:right}\', function () {\n' +
                                          '    // after dialog open \n' +
                                          '}, function (event, strAnswer) {\n' +
                                          '    if (strAnswer === \'${4:Ok}\') {\n' +
                                          '        // beforedialog close\n' +
                                          '        $0\n' +
                                          '    }\n' +
                                          '});');
      registerDesignSnippet('Dialog For Element', 'Dialog For Element',
                                          'GS.openDialogToElement(${1:document.getElementById(\'target\')}, \'${2:templateID}\', ' +
                                                                              '\'${3:right}\', function () {\n' +
                                          '    // after dialog open \n' +
                                          '}, function (event, strAnswer) {\n' +
                                          '    if (strAnswer === \'${4:Ok}\') {\n' +
                                          '        // beforedialog close\n' +
                                          '        $0\n' +
                                          '    }\n' +
                                          '});');
  });
  
  
  (function () {
      'use strict';
      
      function buttonHTML(buttons) {
          var strHTML, i, len;
          
          buttons = buttons || ['Ok'];
          
          // change button parameter to array format if it is string format (and the string is recognized)
          if (typeof buttons === 'string') {
              if (buttons === 'okcancel' || buttons === 'cancelok') {
                  buttons = ['Cancel', 'Ok'];
                  
              } else if (buttons === 'ok' || buttons === 'okonly') {
                  buttons = ['Ok'];
                  
              } else if (buttons === 'cancel' || buttons === 'cancelonly') {
                  buttons = ['Cancel'];
                  
              } else if (buttons === 'yesno' || buttons === 'noyes') {
                  buttons = ['No', 'Yes'];
                  
              } else if (buttons === 'Yes' || buttons === 'yesonly') {
                  buttons = ['Yes'];
                  
              } else if (buttons === 'No' || buttons === 'noonly') {
                  buttons = ['No'];
              }
          }
          
          if (typeof buttons === 'object') {
              if (buttons.length > 0) {
                  strHTML = '<gs-grid gs-dynamic>';
                  
                  for (i = 0, len = buttons.length; i < len; i += 1) {
                      strHTML +=
                          '<gs-block gs-dynamic>' +
                              '<gs-button dialogclose ' + (i === len - 1 ? 'bg-primary listen-for-return' : '') + ' gs-dynamic>' +
                                  encodeHTML(buttons[i]) +
                              '</gs-button>' +
                          '</gs-block>';
                  }
  
                  strHTML += '</gs-grid>';
  
              } else {
                  strHTML = '<gs-button dialogclose>Done</gs-button>';
              }
          } else {
              strHTML = buttons;
          }
  
          return strHTML;
      }
  
      // GS.msgbox('test1', 'test2', ['cancel', 'ok'], function (strAnswer) { console.log(strAnswer); });
      GS.msgbox = function (strTitle, strMessage, buttons, callback) {
          var templateElement = document.createElement('template');
  
          templateElement.innerHTML = '<gs-page>' +
                                      '    <gs-header><center><h3>' + strTitle + '</h3></center></gs-header>' +
                                      '    <gs-body padded>' +
                                      '        ' + strMessage +
                                      '    </gs-body>' +
                                      '    <gs-footer>' + buttonHTML(buttons) + '</gs-footer>' +
                                      '</gs-page>';
  
          GS.openDialog(templateElement, '', function (event, strAnswer) {
              if (typeof callback === 'function') {
                  callback(strAnswer);
              }
          });
      };
  
      // GS.inputbox('test1', 'test2', function (strAnswer) { console.log(strAnswer); });
      GS.inputbox = function (strTitle, strMessage, callback) {
          var templateElement = document.createElement('template');
  
          templateElement.innerHTML = '<gs-page>' +
                                      '    <gs-header><center><h3>' + strTitle + '</h3></center></gs-header>' +
                                      '    <gs-body padded>' +
                                      '        ' + strMessage +
                                      '        <gs-text id="dialog-inputbox-control"></gs-text>' +
                                      '    </gs-body>' +
                                      '    <gs-footer>' + buttonHTML(['Cancel', 'Ok']) + '</gs-footer>' +
                                      '</gs-page>';
  
          GS.openDialog(templateElement, '', function (event, strAnswer) {
              if (strAnswer === 'Ok') {
                  callback(document.getElementById('dialog-inputbox-control').value);
              } else {
                  callback('');
              }
          });
      };
  })();
  
  GS.dialogClose = function (dialog, strAnswer) {
      'use strict';
      console.warn('Please use "GS.closeDialog" instead of "GS.dialogClose".');
      dialog.destroy(strAnswer);
  };
  
  GS.closeDialog = function (dialog, strAnswer) {
      'use strict';
  
      if (typeof dialog === 'string') {
          dialog = document.getElementById('dialog-from-' + dialog);
      }
  
      if (dialog) {
          dialog.destroy(strAnswer);
      } else {
          console.warn('GS.closeDialog Warning: Dialog not found.');
      }
  };
  
  (function () {
      'use strict';
  
      // on focus: if the currently focus element is not in the frontmost dialog: focus first control of the frontmost dialog
      document.addEventListener('focus', function (event) {
          var arrDialog = xtag.queryChildren(document.body, 'gs-dialog[focus-lock]');
          var frontDialog;
          var parentFind;
          var arrElements;
          var i;
          var len;
  
          //console.log('1*** focus: ', document.activeElement, arrDialog);
          if (arrDialog.length > 0) {
              frontDialog = arrDialog[arrDialog.length - 1];
              parentFind = GS.findParentElement(document.activeElement, frontDialog);
  
              //console.log('2***', parentFind, frontDialog);
              if (parentFind !== frontDialog) {
                  arrElements = xtag.query(frontDialog, 'input, textarea, select, button, iframe, [tabindex], a');
  
                  for (i = 0, len = arrElements.length; i < len; i += 1) {
                      if (GS.isElementFocusable(arrElements[i])) {
                          arrElements[i].focus();
                          break;
                      }
                  }
                  //console.log('3***');
              }
          }
      }, true);
  
      // DEPRECATED
      GS.dialog = function (options) {
          var strHTML, dialogOverlay, dialog, strContent = '', strButtons = '', i, len, gridEach,
              arrElements, tapHandler, strHeader, sizingFunction, observer, returnTarget;
  
          // change button parameter to array format if it is string format (and the string is recognized)
          if (typeof options.buttons === 'string') {
              if (options.buttons === 'okcancel' || options.buttons === 'cancelok') {
                  options.buttons = ['Cancel', 'Ok'];
  
              } else if (options.buttons === 'ok' || options.buttons === 'okonly') {
                  options.buttons = ['Ok'];
  
              } else if (options.buttons === 'cancel' || options.buttons === 'cancelonly') {
                  options.buttons = ['Cancel'];
  
              } else if (options.buttons === 'yesno' || options.buttons === 'noyes') {
                  options.buttons = ['No', 'Yes'];
  
              } else if (options.buttons === 'Yes' || options.buttons === 'yesonly') {
                  options.buttons = ['Yes'];
  
              } else if (options.buttons === 'No' || options.buttons === 'noonly') {
                  options.buttons = ['No'];
              }
          }
  
          // option defaults
          options.theme      = options.theme        || 'regular';
          options.type       = options.type         || 'html';
          options.header     = options.header       || '';
          options.content    = options.content      || '';
          options.buttons    = options.buttons      || ['Ok']; // either array or string
          options.max_width  = options.max_width    || '700px';
          options.max_height = options.max_height   || '700px';
          options.mode       = options.mode         || 'detect'; // phone, touch, constrained, full, detect
          options.padded     = options.padded       || false;
          options.autofocus  = (options.autofocus === undefined ? true : false);
  
          // if type is html or, use content as is
          if (options.type === 'html') {
              strContent = options.content;
              strHeader = options.header;
  
          // if type is formatted-html, wrap content with a <pre>
          } else if (options.type === 'formatted-html') {
              strContent = '<pre gs-dynamic>' + options.content + '</pre>';
              strHeader = '<pre gs-dynamic>' + options.header + '</pre>';
  
          // if type is text, encode to be text only
          } else if (options.type === 'text') {
              strContent = encodeHTML(options.content);
              strHeader = encodeHTML(options.header);
  
          // if type is formatted-text, encode to be text only, and wrap with a <pre>
          } else if (options.type === 'formatted-text') {
              strContent = '<pre gs-dynamic>' + encodeHTML(options.content) + '</pre>';
              strHeader = '<pre gs-dynamic>' + encodeHTML(options.header) + '</pre>';
  
          // if type is unrecognized, use content as is
          } else {
              console.warn('Dialog type not recognized... Defaulting to \'html\'.');
              strContent = options.content;
              strHeader = options.header;
          }
  
          // if buttons is an array, build array into button html
          if (typeof options.buttons === 'object') {
              if (options.buttons.length > 0) {
                  strButtons = '<gs-grid gs-dynamic>';
  
                  for (i = 0, len = options.buttons.length; i < len; i += 1) {
                      strButtons +=
                          '<gs-block gs-dynamic>' +
                              '<gs-button dialogclose ' + (i === len - 1 ? 'bg-primary listen-for-return' : '') + ' gs-dynamic>' +
                                  encodeHTML(options.buttons[i]) +
                              '</gs-button>' +
                          '</gs-block>';
                  }
                  strButtons += '</gs-grid>';
              } else {
                  strButtons = '';
              }
  
          // if buttons is not an array, use as html
          } else {
              strButtons = options.buttons;
          }
  
          // append dialog overlay element
          dialogOverlay = GS.stringToElement('<gs-dialog-overlay gs-dynamic></gs-dialog-overlay>');
          document.body.appendChild(dialogOverlay);
  
          dialogOverlay.addEventListener(evt.mousedown, function (event) {
              event.preventDefault();
          });
          dialogOverlay.addEventListener(evt.mousemove, function (event) {
              event.preventDefault();
          });
  
          // build dialog html
          strHTML = '<gs-dialog class="' + encodeHTML(options.theme) + '" gs-dynamic focus-lock ';
  
          // if mode is set to phone or touch and we are not on those types of devices: change mode to detect
          if ((options.mode === 'touch' && !evt.touchDevice) || (options.mode === 'phone' && evt.deviceType !== 'phone')) {
              options.mode = 'detect';
          }
  
          // deal with full page mode
          if ((options.mode === 'touch' && evt.touchDevice) || (options.mode === 'phone' && evt.deviceType === 'phone') || options.mode === 'full') {
              strHTML += 'style="width: 100%; height: 100%; top: 0;">';
  
          } else if (options.mode === 'constrained') {
              strHTML += 'style="max-width: ' + options.max_width + '; max-height: ' + options.max_height + '; width: 94%; height: 90%;">';// auto
                               //width: ' + options.width + '; ' +
                               //'height: ' + options.height + '; ' +
                               //'top: ' + options.top + '; ' +
                               //'margin-left: -' + ((parseInt(options.width, 10) / 2) + options.width.replace(/[0-9]/g, '')) + ';">' +
  
          } else { // if (options.mode === 'constrained')
              strHTML += 'style="max-width: ' + options.max_width + '; width: 94%;">';
          }
  
          strHTML +=      '<gs-page gs-dynamic>' +
                              (options.header ? '<gs-header gs-dynamic>' + strHeader + '</gs-header>' : '') +
                              '<gs-body' + (options.padded ? ' padded' : '') + ' gs-dynamic>' + strContent + '</gs-body>' +
                             (strButtons ? '<gs-footer gs-dynamic>' + strButtons + '</gs-footer>' : '') +
                          '</gs-page>' +
                      '</gs-dialog>';
  
          // append dialog
          dialog = GS.stringToElement(strHTML);
          document.body.appendChild(dialog);
          document.body.parentNode.classList.add('no-scroll-except-for-dialog');
  
          // bind dialog
          dialog.addEventListener('beforeclose', function (event) {
              if (typeof options.before_close === 'function') {
                  options.before_close.apply(dialog, [event.originalEvent, event.data]);
              }
          });
          dialog.addEventListener('afterclose', function (event) {
              if (typeof options.after_close === 'function') {
                  options.after_close.apply(dialog, [event.originalEvent, event.data]);
              }
          });
  
          if (!template.hasAttribute('no-focus-lock')) {
              // focus autofocus element if there is one
              arrElements = xtag.query(dialog, '[autofocus]');
  
              if (arrElements.length > 0) {
                  arrElements[0].focus();
  
              // else if there is a listen-for-return: focus that
              } else {
                  arrElements = xtag.query(dialog, '[listen-for-return]');
  
                  if (arrElements.length > 0) {
                      arrElements[0].focus();
                  }
              }
          }
  
          // bind listening for return if there is an element with the "listen-for-return"
          arrElements = xtag.query(dialog, '[listen-for-return]');
  
          if (arrElements.length > 0) {
              returnTarget = arrElements[0];
  
              dialog.addEventListener('keydown', function (event) {
                  if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                      GS.triggerEvent(returnTarget, 'click');
                  }
              });
  
              if (arrElements.length > 1) {
                  console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
              }
          }
  
          // if mode is detect: do/bind detection
          if (options.mode === 'detect') {
              sizingFunction = function () {
                  if (dialog.parentNode !== document.body) {
                      window.removeEventListener('resize', sizingFunction);
                      window.removeEventListener('orientationchange', sizingFunction);
                      observer.disconnect();
  
                      return;
                  }
  
                  // if dialog is taller than 98% of the window: add max-height and height
                  if (dialog.offsetHeight > ((window.innerHeight / 100) * 98)) {
                      dialog.style.height = '98%';
                      dialog.style.maxHeight = options.max_height;
                  }
              };
  
              sizingFunction();
  
              window.addEventListener('resize', sizingFunction);
              window.addEventListener('orientationchange', sizingFunction);
  
              observer = new MutationObserver(sizingFunction);
              observer.observe(dialog, {childList: true, subtree: true, attributes: true});
          }
  
          // after open function call
          if (typeof options.after_open === 'function') {
              options.after_open.apply(dialog, []);
          }
  
          return dialog;
      };
  
  
      GS.openDialog = function (templateLink, afterOpenFunction, beforeCloseFunction, afterCloseFunction) {
          var template, templateID, strHTML, dialogOverlay, dialog, i, len, arrCloseButtons, clickHandler, sizingFunction,
              observer, arrElements, strTag, returnTarget, strTheme, strMaxWidth, strMaxHeight, strMode, refocusElement,
              scrollTarget, jsnInitalMousePos, scrollProtectorTouchStart, scrollProtectorTouchMove, scrollProtectorMouseWheel,
              strTag, xtagSelector, intervalID, intervalI;
  
          // get template
          if (typeof templateLink === 'string') {
              template = document.getElementById(templateLink);
          } else {
              template = templateLink;
          }
          if (template.innerHTML.indexOf('&gt;') > -1 || template.innerHTML.indexOf('&lt;') > -1) {
              console.warn('GS-DIALOG WARNING: &gt; or &lt; detected in dialog template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
          }
  
          // save and blur currently focused element
          refocusElement = document.activeElement;
          if (!template.hasAttribute('no-focus-lock')) {
              refocusElement.blur();
          }
  
          // save template ID
          templateID = template.getAttribute('id');
  
          // warn if a dialog already uses this ID
          if (templateID && document.getElementById('dialog-from-' + templateID)) {
              console.warn('GS.openDialog Warning: A dialog using the ID "' + templateID + '" is already open.');
          }
  
          // handle autofocus
          arrElements = xtag.query(template.content, '[autofocus]');
  
          // if there are not autofocus elements: add autofocus to first control in the template
          if (arrElements.length === 0) {
              arrElements = xtag.query(template.content, '*');
  
              if (arrElements.length > 0) {
                  for (i = 0, len = arrElements.length; i < len; i += 1) {
                      strTag = arrElements[i].nodeName.toLowerCase();
  
                      if (GS.isElementFocusable(arrElements[i]) ||
                          (
                              xtag.tags[strTag] &&
                              xtag.tags[strTag].methods &&
                              xtag.tags[strTag].methods.focus
                          )) {
                          arrElements[i].setAttribute('autofocus', '');
                          break;
                      }
                  }
              }
  
          // warn if there are too many autofocus elements
          } else if (arrElements.length > 1) {
              for (i = 1, len = arrElements.length; i < len; i += 1) {
                  arrElements[i].removeAttribute('autofocus');
              }
  
              console.warn('dialog Warning: Too many [autofocus] elements, defaulting to the first one. Please have only one [autofocus] element per dialog.');
          }
  
          // get and default parameters
          strTheme     = (template.getAttribute('data-theme') === 'error' ? 'error' : 'regular');
          strMaxWidth  = template.getAttribute('data-max-width')  || '700px';
          strMaxHeight = template.getAttribute('data-max-height') || '700px';
          strMode      = template.getAttribute('data-mode')       || 'detect'; // phone, touch, constrained, full, detect
  
          // build full dialog html
          strHTML = '<gs-dialog ' + (templateID ? 'id="dialog-from-' + templateID + '" ' : '') + 'class="' + strTheme + '" gs-dynamic ';
  
          if (!template.hasAttribute('no-focus-lock')) {
              strHTML += 'focus-lock ';
          }
  
          // if mode is set to phone or touch and we are not on those types of devices: change mode to detect
          if ((strMode === 'touch' && !evt.touchDevice) || (strMode === 'phone' && evt.deviceType !== 'phone')) {
              strMode = 'detect';
          }
  
          // deal with full page mode
          if ((strMode === 'touch' && evt.touchDevice) || (strMode === 'phone' && evt.deviceType === 'phone') || strMode === 'full') {
              strHTML += 'style="width: 100%; height: 100%; top: 0;">';
  
          } else if (strMode === 'constrained') {
              strHTML += 'style="max-width: ' + strMaxWidth + '; max-height: ' + strMaxHeight + '; width: 94%; height: 90%;">';
  
          } else {
              strHTML += 'style="max-width: ' + strMaxWidth + '; width: 94%;">';
          }
  
          strHTML +=      '<gs-page gs-dynamic>' +
                              template.innerHTML +
                          '</gs-page>' +
                      '</gs-dialog>';
  
          // get elements
          dialogOverlay = GS.stringToElement(
              '<gs-dialog-overlay gs-dynamic' +
              (
                  template.hasAttribute('no-background')
                      ? ' no-background '
                      : ''
              ) +
              '></gs-dialog-overlay>'
          );
          dialog = GS.stringToElement(strHTML);
  
          // append overlay element
          document.body.appendChild(dialogOverlay);
  
          // if the template has: data-overlay-close: bind overlay
          if (template.hasAttribute('data-overlay-close')) {
              dialogOverlay.addEventListener(evt.mousedown, function (event) {
                  GS.closeDialog(dialog, 'overlay');
              });
          }
  
          // bind overlay element
          dialogOverlay.addEventListener(evt.mousedown, function (event) {
              event.preventDefault();
          });
          dialogOverlay.addEventListener(evt.mousemove, function (event) {
              event.preventDefault();
          });
          dialogOverlay.addEventListener('mousewheel', function (event) {
              event.preventDefault();
          });
  
          // append dialog
          document.body.appendChild(dialog);
          //document.body.parentNode.classList.add('no-scroll-except-for-dialog');
  
          // bind dialog
          scrollProtectorTouchStart = function (event) {
              if (dialog.parentNode !== document.body) {
                  dialog.removeEventListener('touchstart', scrollProtectorTouchStart);
                  return true;
              }
  
              scrollTarget = GS.scrollParent(event.target);
  
              //console.log(scrollTarget);
  
              if (!scrollTarget || !GS.findParentTag(scrollTarget, 'gs-dialog')) {
                  scrollTarget = dialog;
              }
  
              //console.log(scrollTarget);
  
              jsnInitalMousePos = GS.mousePosition(event);
          };
  
          scrollProtectorTouchMove = function (event) {
              var jsnMousePos = GS.mousePosition(event), bolVertical, bolHorizontal;
  
              if (dialog.parentNode !== document.body) {
                  dialog.removeEventListener('touchmove', scrollProtectorTouchMove);
                  return true;
              }
  
              //console.log('2***', scrollTarget, jsnInitalMousePos, jsnMousePos);
  
              if (Math.abs(jsnInitalMousePos.top - jsnMousePos.top) > Math.abs(jsnInitalMousePos.left - jsnMousePos.left)) {
                  bolVertical = true;
              } else {
                  bolHorizontal = true;
              }
  
              //console.log(bolVertical, bolHorizontal);
  
              // if down  AND we are already at the top
              // if up    AND we are already at the bottom
              // if right AND we are already at the left
              // if left  AND we are already at the right
  
              if ((bolVertical && (
                      (jsnInitalMousePos.top < jsnMousePos.top && scrollTarget.scrollTop <= 0) ||
                      (jsnInitalMousePos.top > jsnMousePos.top &&
                          (scrollTarget.scrollTop + scrollTarget.clientHeight) >= scrollTarget.scrollHeight))) ||
                  (bolHorizontal && (
                      (jsnInitalMousePos.left < jsnMousePos.left && scrollTarget.scrollLeft <= 0) ||
                      (jsnInitalMousePos.left > jsnMousePos.left &&
                          (scrollTarget.scrollLeft + scrollTarget.clientWidth) >= scrollTarget.scrollWidth)))) {
                  event.preventDefault();
                  event.stopPropagation();
              }
          };
  
          scrollProtectorMouseWheel = function (event) {
              var target = GS.scrollParent(event.target); //event.target;
  
              //console.log(target);
  
              if (dialog.parentNode !== document.body) {
                  dialog.removeEventListener('mousewheel', scrollProtectorMouseWheel);
                  return true;
              }
  
              //console.log(event.deltaY, event.deltaX,
              //            target.scrollTop, target.scrollLeft,
              //            target.scrollHeight, target.scrollWidth,
              //            target.clientHeight, target.clientWidth);
  
              // if event.deltaY < 0 AND we are already at the top
              // if event.deltaY > 0 AND we are already at the bottom
              // if event.deltaX < 0 AND we are already at the left
              // if event.deltaX > 0 AND we are already at the right
  
              if ((event.deltaY < 0 && target.scrollTop <= 0) ||
                  (event.deltaY > 0 && (target.scrollTop + target.clientHeight) >= target.scrollHeight) ||
                  (event.deltaX < 0 && target.scrollLeft <= 0) ||
                  (event.deltaX > 0 && (target.scrollLeft + target.clientWidth) >= target.scrollWidth)) {
                  //console.log('prevented');
  
                  event.preventDefault();
                  event.stopPropagation();
              }
          };
  
          if (evt.touchDevice) {
              window.addEventListener('touchstart', scrollProtectorTouchStart);
              window.addEventListener('touchmove', scrollProtectorTouchMove);
          }
  
          dialog.addEventListener('mousewheel', scrollProtectorMouseWheel);
  
          dialog.addEventListener('beforeclose', function (event) {
              if (typeof beforeCloseFunction === 'function') {
                  beforeCloseFunction.apply(dialog, [event.originalEvent, event.data]);
              }
          });
  
          dialog.addEventListener('afterclose', function (event) {
              refocusElement.focus();
              if (typeof afterCloseFunction === 'function') {
                  afterCloseFunction.apply(dialog, [event.originalEvent, event.data]);
              }
          });
  
  
          // if mode equals 'detect'
          //console.log(strMode);
          if (strMode === 'detect') {
              // do/bind size detection
              sizingFunction = function () {
                  if (dialog.parentNode !== document.body) {
                      window.removeEventListener('resize', sizingFunction);
                      window.removeEventListener('orientationchange', sizingFunction);
                      observer.disconnect();
  
                      return;
                  }
  
                  // if dialog is taller than 98% of the window: add max-height and height
                  if (dialog.offsetHeight > ((window.innerHeight / 100) * 98)) {
                      dialog.style.height = '98%';
                      dialog.style.maxHeight = strMaxHeight;
                  }
              };
  
              sizingFunction();
  
              window.addEventListener('resize', sizingFunction);
              window.addEventListener('orientationchange', sizingFunction);
  
              observer = new MutationObserver(sizingFunction);
              observer.observe(dialog, {childList: true, subtree: true, attributes: true});
          }
  
  
          var elementReadyCallback = function () {
              if (!template.hasAttribute('no-focus-lock')) {
                  // focus autofocus element if there is one
                  arrElements = xtag.query(dialog, '[autofocus]');
  
                  if (arrElements.length > 0) {
                      arrElements[0].focus();
  
                  // else if there is a listen-for-return: focus that
                  } else {
                      arrElements = xtag.query(dialog, '[listen-for-return]');
  
                      if (arrElements.length > 0) {
                          arrElements[0].focus();
                      }
                  }
              }
  
              // bind listening for return if there is an element with the "listen-for-return"
              arrElements = xtag.query(dialog, '[listen-for-return]');
  
              if (arrElements.length > 0) {
                  returnTarget = arrElements[0];
  
                  dialog.addEventListener('keydown', function (event) { // keydown, keyup, keypress
                      if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                          //event.stopPropagation();
                          GS.triggerEvent(returnTarget, 'click');
                      }
                  });
  
                  if (arrElements.length > 1) {
                      console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
                  }
              }
  
              if (typeof afterOpenFunction === 'function') {
                  afterOpenFunction.apply(dialog, []);
              }
          };
  
  
          // get a list of all the xtag elements
          // if they are not all instantiated check: on an interval until they are all instantiated
  
  
          // if element registration is shimmed: we need to wait to run the callback
          //      until after the elements are ready. to do this we'll get a list of
          //      the current elements that are xtag-defined and on a 30ms loop we'll
          //      check their __upgraded__ property until they are all true
          if (shimmed.registerElement === true) {
              // build selector to get all xtag elements
              xtagSelector = '';
              for (strTag in xtag.tags) {
                  xtagSelector += (xtagSelector ? ',' : '');
                  xtagSelector += strTag;
              }
  
              // get all xtag elements
              var elem_wait = xtag.query(dialog, xtagSelector);
              var elem_i;
              var elem_len;
  
              // begin interval (max out at 1 second)
              intervalI = 0;
              intervalID = setInterval(function () {
                  if (elem_wait.length === 0 || intervalI >= 30) {
                      clearInterval(intervalID);
                      elementReadyCallback();
                  } else {
                      elem_i = 0;
                      elem_len = elem_wait.length;
                      while (elem_i < elem_len) {
                          if (elem_wait[elem_i].__upgraded__ === true) {
                              elem_wait.splice(elem_i, 1);
                              elem_i -= 1;
                              elem_len -= 1;
                          }
                          elem_i += 1;
                      }
                  }
                  intervalI += 1;
              }, 30);
  
          // else: element instantiation blocks JS execution until the elements
          //      are ready, so we don't need to wait to run the after open callback
          } else {
              elementReadyCallback();
          }
  
  
          //// after open function call
          //if (typeof afterOpenFunction === 'function') {
          //    if (dialog.inserted === true) {
          //        console.log('1***');
          //        afterOpenFunction.apply(dialog, []);
          //    } else {
          //        console.log('2***', new Date().getTime());
          //        dialog.addEventListener('dialog-inserted', function () {
          //            console.log('3***', new Date().getTime());
          //            afterOpenFunction.apply(dialog, []);
          //        });
          //    }
          //}
  
          return dialog;
      };
  
      GS.openDialogToElement = function (elementTarget, templateLink, strDirectionRequest, afterOpenFunction, beforeCloseFunction, afterCloseFunction) {
          'use strict';
          var positionHandlingFunction, jsnPositionData, divElement = document.createElement('div'), dialogElement, observer,
              intDialogResolvedWidth, intDialogResolvedHeight, strResolvedDirection, intMargin = 5, intElementMidPoint,
              intDialogMidPoint, i, len, arrTests, arrCloseButtons, clickHandler, arrElements, template, strTheme, strMaxWidth,
              strMaxHeight, strTag, dialogOverlay, refocusElement, jsnInitalMousePos, scrollTarget, returnTarget,
              scrollProtectorTouchStart, scrollProtectorTouchMove, scrollProtectorMouseWheel, templateID,
              strTag, xtagSelector, intervalID, intervalI;
  
          // get template
          if (typeof templateLink === 'string') {
              template = document.getElementById(templateLink);
          } else {
              template = templateLink;
          }
  
          // save and blur currently focused element
          refocusElement = document.activeElement;
          if (!template.hasAttribute('no-focus-lock')) {
              refocusElement.blur();
          }
  
          // save template ID
          templateID = template.getAttribute('id');
  
          // warn if a dialog already uses this ID
          if (templateID && document.getElementById('dialog-from-' + templateID)) {
              console.warn('GS.openDialog Warning: A dialog using the ID "' + templateID + '" is already open.');
          }
  
          // handle autofocus
          arrElements = xtag.query(template.content, '[autofocus]');
  
          // if there are not autofocus elements: add autofocus to first control in the template
          if (arrElements.length === 0) {
              arrElements = xtag.query(template.content, '*');
  
              if (arrElements.length > 0) {
                  for (i = 0, len = arrElements.length; i < len; i += 1) {
                      strTag = arrElements[i].nodeName.toLowerCase();
  
                      if (GS.isElementFocusable(arrElements[i]) ||
                          (
                              xtag.tags[strTag] &&
                              xtag.tags[strTag].methods &&
                              xtag.tags[strTag].methods.focus
                          )) {
                          arrElements[i].setAttribute('autofocus', '');
                          break;
                      }
                  }
              }
  
          // warn if there are too many autofocus elements
          } else if (arrElements.length > 1) {
              for (i = 1, len = arrElements.length; i < len; i += 1) {
                  arrElements[i].removeAttribute('autofocus');
              }
  
              console.warn('dialog Warning: Too many [autofocus] elements, defaulting to the first one. Please have only one [autofocus] element per dialog.');
          }
  
          // get and default parameters
          strTheme     = (template.getAttribute('data-theme') === 'error' ? 'error' : 'regular');
          strMaxWidth  = template.getAttribute('data-max-width')  || '700px';
          strMaxHeight = template.getAttribute('data-max-height') || '700px';
  
          // create dialog element
          divElement.innerHTML =
              '<gs-dialog ' +
                      (
                          templateID
                              ? 'id="dialog-from-' + templateID + '" '
                              : ''
                      ) +
                      'class="' + strTheme + '" ' +
                      'style="width: 94%; max-width: ' + strMaxWidth + ';" ' +
                      'no-window-listen ' +
                      (
                          template.hasAttribute('no-focus-lock')
                              ? ''
                              : 'focus-lock '
                      ) +
                      'gs-dynamic>' +
                  '<gs-page gs-dynamic>' +
                      template.innerHTML +
                  '</gs-page>' +
              '</gs-dialog>';
  
          dialogElement = divElement.children[0];
  
          // append dialog overlay element to the body
          dialogOverlay = GS.stringToElement(
              '<gs-dialog-overlay gs-dynamic' +
                      (
                          template.hasAttribute('no-background')
                              ? ' no-background '
                              : ''
                      ) +
                  '></gs-dialog-overlay>'
          );
          document.body.appendChild(dialogOverlay);
  
          // if the template has: data-overlay-close: bind overlay
          if (template.hasAttribute('data-overlay-close')) {
              dialogOverlay.addEventListener('click', function (event) {
                  GS.closeDialog(dialogElement, 'overlay');
              });
          }
  
          // bind dialog overlay
          dialogOverlay.addEventListener('mousewheel', function (event) {
              event.preventDefault();
          });
  
          // append dialog element to the body
          document.body.appendChild(dialogElement);
  
          // bind dialog
          scrollProtectorTouchStart = function (event) {
              if (dialogElement.parentNode !== document.body) {
                  dialogElement.removeEventListener('touchstart', scrollProtectorTouchStart);
                  return true;
              }
  
              scrollTarget = GS.scrollParent(event.target);
  
              //console.log(scrollTarget);
  
              if (!scrollTarget || !GS.findParentTag(scrollTarget, 'gs-dialog')) {
                  scrollTarget = dialogElement;
              }
  
              //console.log(scrollTarget);
  
              jsnInitalMousePos = GS.mousePosition(event);
          };
  
          scrollProtectorTouchMove = function (event) {
              var jsnMousePos = GS.mousePosition(event), bolVertical, bolHorizontal;
  
              if (dialogElement.parentNode !== document.body) {
                  dialogElement.removeEventListener('touchmove', scrollProtectorTouchMove);
                  return true;
              }
  
              //console.log('2***', scrollTarget, jsnInitalMousePos, jsnMousePos);
  
              if (Math.abs(jsnInitalMousePos.top - jsnMousePos.top) > Math.abs(jsnInitalMousePos.left - jsnMousePos.left)) {
                  bolVertical = true;
              } else {
                  bolHorizontal = true;
              }
  
              //console.log(bolVertical, bolHorizontal);
  
              // if down  AND we are already at the top
              // if up    AND we are already at the bottom
              // if right AND we are already at the left
              // if left  AND we are already at the right
  
              if ((bolVertical && (
                      (jsnInitalMousePos.top < jsnMousePos.top && scrollTarget.scrollTop <= 0) ||
                      (jsnInitalMousePos.top > jsnMousePos.top &&
                          (scrollTarget.scrollTop + scrollTarget.clientHeight) >= scrollTarget.scrollHeight))) ||
                  (bolHorizontal && (
                      (jsnInitalMousePos.left < jsnMousePos.left && scrollTarget.scrollLeft <= 0) ||
                      (jsnInitalMousePos.left > jsnMousePos.left &&
                          (scrollTarget.scrollLeft + scrollTarget.clientWidth) >= scrollTarget.scrollWidth)))) {
                  event.preventDefault();
                  event.stopPropagation();
              }
          };
  
          scrollProtectorMouseWheel = function (event) {
              var target = GS.scrollParent(event.target); //event.target;
              
              if (dialogElement.parentNode !== document.body) {
                  dialogElement.removeEventListener('mousewheel', scrollProtectorMouseWheel);
                  return true;
              }
              
              //console.log(event.deltaY, event.deltaX,
              //            target.scrollTop, target.scrollLeft,
              //            target.scrollHeight, target.scrollWidth,
              //            target.clientHeight, target.clientWidth);
              
              // if event.deltaY < 0 AND we are already at the top
              // if event.deltaY > 0 AND we are already at the bottom
              // if event.deltaX < 0 AND we are already at the left
              // if event.deltaX > 0 AND we are already at the right
              
              if ((event.deltaY < 0 && target.scrollTop <= 0) ||
                  (event.deltaY > 0 && (target.scrollTop + target.clientHeight) >= target.scrollHeight) ||
                  (event.deltaX < 0 && target.scrollLeft <= 0) ||
                  (event.deltaX > 0 && (target.scrollLeft + target.clientWidth) >= target.scrollWidth)) {
                  event.preventDefault();
                  event.stopPropagation();
              }
          };
          
          if (evt.touchDevice) {
              window.addEventListener('touchstart', scrollProtectorTouchStart);
              window.addEventListener('touchmove', scrollProtectorTouchMove);
          }
          
          dialogElement.addEventListener('mousewheel', scrollProtectorMouseWheel);
          
          dialogElement.addEventListener('beforeclose', function (event) {
              if (typeof beforeCloseFunction === 'function') {
                  beforeCloseFunction.apply(dialogElement, [event.originalEvent, event.data]);
              }
          });
          dialogElement.addEventListener('afterclose', function (event) {
              refocusElement.focus();
              if (typeof afterCloseFunction === 'function') {
                  afterCloseFunction.apply(dialogElement, [event.originalEvent, event.data]);
              }
          });
  
          if (!template.hasAttribute('no-focus-lock')) {
              // focus autofocus element if there is one
              arrElements = xtag.query(dialogElement, '[autofocus]');
  
              if (arrElements.length > 0) {
                  arrElements[0].focus();
  
              // else if there is a listen-for-return: focus that
              } else {
                  arrElements = xtag.query(dialogElement, '[listen-for-return]');
  
                  if (arrElements.length > 0) {
                      arrElements[0].focus();
                  }
              }
          }
  
          // bind listening for return if there is an element with the "listen-for-return"
          arrElements = xtag.query(dialogElement, '[listen-for-return]');
  
          if (arrElements.length > 0) {
              returnTarget = arrElements[0];
  
              dialogElement.addEventListener('keydown', function (event) {
                  if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                      GS.triggerEvent(returnTarget, 'click');
                  }
              });
  
              if (arrElements.length > 1) {
                  console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
              }
          }
          
          // if no direction was sent: set direction to down
          strDirectionRequest = strDirectionRequest || 'down';
          
          // make strDirectionRequest lowercase
          strDirectionRequest.toLowerCase();
          
          // if the direction does not match any valid direction: set direction to down and warn
          if (!strDirectionRequest.match(/^up$|^down$|^left$|^right$|^full$/)) {
              console.warn('GS.openDialogToElement Error: ' +
                                  'Direction \'' + strDirectionRequest + '\' not recognized. ' +
                                  'Please use \'up\', \'down\', \'left\', \'right\' or \'full\'.');
              strDirectionRequest = 'down';
          }
          
          positionHandlingFunction = function () {
              var intDialogTop = '', intDialogLeft = '', intDialogMarginTop = '', intDialogMarginLeft = '', strOldStyle,
                  arrElements, arrScrollingElements, i, len, strOverflow;
              
              // if the dialog is not in the DOM: unbind and skip the contents of the function using return
              if (dialogElement.parentNode !== document.body) {
                  window.removeEventListener('resize', positionHandlingFunction);
                  window.removeEventListener('orientationchange', positionHandlingFunction);
                  observer.disconnect();
                  return;
              }
              
              // save old style attribute
              strOldStyle = dialogElement.getAttribute('style');
              
              // save scroll numbers
              arrElements = xtag.query(dialogElement, '*');
              arrScrollingElements = [];
              
              for (i = 0, len = arrElements.length; i < len; i += 1) {
                  strOverflow = GS.getStyle(arrElements[i], 'overflow');
                  
                  if (strOverflow === 'scroll' ||
                      (strOverflow === 'auto' && arrElements[i].clientHeight < arrElements[i].scrollHeight)) {
                      arrScrollingElements.push(arrElements[i]);
                  }
              }
              
              for (i = 0, len = arrScrollingElements.length; i < len; i += 1) {
                  arrScrollingElements[i].oldScrollTop = arrScrollingElements[i].scrollTop;
                  arrScrollingElements[i].oldScrollLeft = arrScrollingElements[i].scrollLeft;
              }
              
              // clear dialog CSS
              dialogElement.style.top        = '';
              dialogElement.style.left       = '';
              dialogElement.style.marginTop  = '';
              dialogElement.style.marginLeft = '';
              dialogElement.style.width      = '94%';
              dialogElement.style.height     = '';
              dialogElement.style.maxHeight  = '';
              
              //console.log(dialogElement.oldHeight, dialogElement.offsetHeight);
              
              // if height hasn't changed: restore style
              if (dialogElement.oldHeight === dialogElement.offsetHeight) {
                  dialogElement.setAttribute('style', strOldStyle);
                  
                  for (i = 0, len = arrScrollingElements.length; i < len; i += 1) {
                      arrScrollingElements[i].scrollTop = arrScrollingElements[i].oldScrollTop;
                      arrScrollingElements[i].scrollLeft = arrScrollingElements[i].oldScrollLeft;
                  }
                  
              // else: recalculate style
              } else {
                  dialogElement.oldHeight = dialogElement.offsetHeight;
                  
                  // resolve dialog width and height
                  
                  // if dialog is taller than: window height - (intMargin * 2): add max-height and height
                  if (dialogElement.clientHeight > ((window.innerHeight / 100) * 94)) {
                      dialogElement.style.height = '94%';
                      dialogElement.style.maxHeight = strMaxHeight;
                  }
                  
                  intDialogResolvedWidth  = dialogElement.offsetWidth;
                  intDialogResolvedHeight = dialogElement.offsetHeight + 1; // + 1 added to fix occasional scrollbar issue
                  
                  // set dialog width and height to resolved width and height
                  dialogElement.style.width  = intDialogResolvedWidth  + 'px';
                  dialogElement.style.height = intDialogResolvedHeight + 'px';
                  
                  // get target position data
                  jsnPositionData = GS.getElementPositionData(elementTarget);
                  
                  // order of tests depending on direction
                  if (strDirectionRequest === 'up') { // up: up, down, left, right, full
                      arrTests = ['up', 'down', 'left', 'right'];
                      
                  } else if (strDirectionRequest === 'down') { // down: down, up, left, right, full
                      arrTests = ['down', 'up', 'left', 'right'];
                      
                  } else if (strDirectionRequest === 'left') { // left: left, right, down, up, full
                      arrTests = ['left', 'right', 'down', 'up'];
                      
                  } else if (strDirectionRequest === 'right') { // right: right, left, down, up, full
                      arrTests = ['right', 'left', 'down', 'up'];
                      
                  } else { // full: no tests (just go to full)
                      arrTests = [];
                  }
                  
                  // up: compare room above to dialog resolved height
                  //      pass: display
                  //      fail: next test
                  for (i = 0, len = arrTests.length; i < len; i += 1) {
                      if ((arrTests[i] ===    'up' && (intDialogResolvedHeight + intMargin) <= jsnPositionData.intRoomAbove) ||
                          (arrTests[i] ===  'down' && (intDialogResolvedHeight + intMargin) <= jsnPositionData.intRoomBelow) ||
                          (arrTests[i] ===  'left' && (intDialogResolvedWidth  + intMargin) <=  jsnPositionData.intRoomLeft) ||
                          (arrTests[i] === 'right' && (intDialogResolvedWidth  + intMargin) <= jsnPositionData.intRoomRight)) {
                          strResolvedDirection = arrTests[i];
                          break;
                      }
                  }
                  
                  // if we could not resolve to a particular direction: set direction to full screen
                  strResolvedDirection = strResolvedDirection || 'full';
                  //console.log(strResolvedDirection);
                  
                  // if up or down: get as close to horizontally centered on the element as possible
                  if (strResolvedDirection === 'up' || strResolvedDirection === 'down') {
                      intElementMidPoint = (jsnPositionData.intElementLeft + (jsnPositionData.intElementWidth / 2));
                      intDialogMidPoint = (intDialogResolvedWidth / 2);
                      //console.log(intElementMidPoint, jsnPositionData.left, jsnPositionData.intElementWidth);
                      
                      // if centered goes past intMargin of the left edge of the screen: go to intMargin from the bottom
                      if (intElementMidPoint - intDialogMidPoint < intMargin) {
                          intDialogLeft = intMargin;
                          //console.log('1***', intMargin);
                          
                      // else if centered goes past intMargin of the right edge of the screen: go to intMargin less than the width of the viewport
                      } else if (intElementMidPoint + intDialogMidPoint > window.innerWidth - intMargin) {
                          intDialogLeft = ((window.innerWidth - intDialogResolvedWidth) - intMargin);
                          //console.log('2***', window.innerWidth, intDialogResolvedWidth, intMargin);
                          
                      // else centered does not go past intMargin of either edge of the screen: center
                      } else {
                          intDialogLeft = (intElementMidPoint - intDialogMidPoint);
                          //console.log('3***', intElementMidPoint, intDialogMidPoint, (intElementMidPoint - intDialogMidPoint) + 'px');
                      }
                      
                  // else if left or right: get as close to vertically centered next to the element as possible
                  } else if (strResolvedDirection === 'left' || strResolvedDirection === 'right') {
                      intElementMidPoint = (jsnPositionData.intElementTop + (jsnPositionData.intElementHeight / 2));
                      intDialogMidPoint = (intDialogResolvedHeight / 2);
                      
                      //console.log('0***', intElementMidPoint, intDialogMidPoint, window.innerHeight, intMargin, intDialogResolvedHeight);
                      
                      // if centered goes past intMargin of the top edge of the screen: go to intMargin from the bottom
                      if (intElementMidPoint - intDialogMidPoint < intMargin) {
                          intDialogTop = intMargin;
                          //console.log('1***', intMargin);
                          
                      // else if centered goes past intMargin of the bottom edge of the screen: go to intMargin less than the height of the viewport
                      } else if (intElementMidPoint + intDialogMidPoint > window.innerHeight - intMargin) {
                          intDialogTop = ((window.innerHeight - intDialogResolvedHeight) - intMargin);
                          //console.log('2***', window.innerHeight, intDialogResolvedHeight, intMargin);
                          
                      // else centered does not go past intMargin of either edge of the screen: center
                      } else {
                          intDialogTop = (intElementMidPoint - intDialogMidPoint);
                          //console.log('3***', intElementMidPoint, intDialogMidPoint, (intElementMidPoint - intDialogMidPoint) + 'px');
                      }
                      
                  // else full: use dialog logic to get width and height and center both vertically and horizontally
                  } else {
                      intDialogTop        = '50%';
                      intDialogLeft       = '50%';
                      intDialogMarginTop  = '-' + (intDialogResolvedHeight / 2) + 'px';
                      intDialogMarginLeft = '-' + (intDialogResolvedWidth / 2) + 'px';
                  }
                  
                  // if direction is up: connect the bottom of the dialog to the top of the element
                  if (strResolvedDirection === 'up') {
                      intDialogTop = (jsnPositionData.intElementTop - intDialogResolvedHeight);
                      
                  // if direction is down: connect the top of the dialog to the bottom of the element
                  } else if (strResolvedDirection === 'down') {
                      intDialogTop = (jsnPositionData.intElementTop + jsnPositionData.intElementHeight);
                      
                  // if direction is left: connect the right of the dialog to the left of the element
                  } else if (strResolvedDirection === 'left') {
                      intDialogLeft = (jsnPositionData.intElementLeft - intDialogResolvedWidth);
                      
                  // if direction is right: connect the left of the dialog to the right of the element
                  } else if (strResolvedDirection === 'right') {
                      intDialogLeft = (jsnPositionData.intElementLeft + jsnPositionData.intElementWidth);
                  }
  
                  // prevent the dialog from vertically going outside the viewport
                  if (intDialogTop + intDialogResolvedHeight > window.innerHeight) {
                      intDialogTop -= (intDialogTop + intDialogResolvedHeight) - window.innerHeight;
                      
                  }
  
                  // prevent the dialog from horizontally going outside the viewport
                  if (intDialogLeft + intDialogResolvedWidth > window.innerWidth) {
                      intDialogLeft -= (intDialogLeft + intDialogResolvedWidth) - window.innerWidth;
                  }
  
                  // apply CSS to the dialog
                  dialogElement.style.top        = intDialogTop + 'px';
                  dialogElement.style.left       = intDialogLeft + 'px';
                  dialogElement.style.marginTop  = intDialogMarginTop + 'px';
                  dialogElement.style.marginLeft = intDialogMarginLeft + 'px';
              }
          };
  
          positionHandlingFunction();
          window.addEventListener('resize', positionHandlingFunction);
          window.addEventListener('orientationchange', positionHandlingFunction);
  
          // observer: on childlist update: recalculate positioning/sizing
          observer = new MutationObserver(positionHandlingFunction);
  
          // the observer is on "dialogElement.children[0]" because when we refresh the position of the dialog:
          //      the "style" attribute is changed which causes the observer to run again ergo: infinite loop
          observer.observe(dialogElement.children[0], {childList: true, subtree: true, attributes: true});
  
  
          var elementReadyCallback = function () {
              if (!template.hasAttribute('no-focus-lock')) {
                  // focus autofocus element if there is one
                  arrElements = xtag.query(dialogElement, '[autofocus]');
  
                  if (arrElements.length > 0) {
                      arrElements[0].focus();
  
                  // else if there is a listen-for-return: focus that
                  } else {
                      arrElements = xtag.query(dialogElement, '[listen-for-return]');
  
                      if (arrElements.length > 0) {
                          arrElements[0].focus();
                      }
                  }
              }
  
              // bind listening for return if there is an element with the "listen-for-return"
              arrElements = xtag.query(dialogElement, '[listen-for-return]');
  
              if (arrElements.length > 0) {
                  returnTarget = arrElements[0];
  
                  dialogElement.addEventListener('keydown', function (event) { // keydown, keyup, keypress
                      if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                          //event.stopPropagation();
                          GS.triggerEvent(returnTarget, 'click');
                      }
                  });
  
                  if (arrElements.length > 1) {
                      console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
                  }
              }
  
              if (typeof afterOpenFunction === 'function') {
                  afterOpenFunction.apply(dialogElement, []);
              }
          };
  
          // if element registration is shimmed: we need to wait to run the callback
          //      until after the elements are ready. to do this we'll get a list of
          //      the current elements that are xtag-defined and on a 30ms loop we'll
          //      check their __upgraded__ property until they are all true
          if (shimmed.registerElement === true) {
              // build selector to get all xtag elements
              xtagSelector = '';
              for (strTag in xtag.tags) {
                  xtagSelector += (xtagSelector ? ',' : '');
                  xtagSelector += strTag;
              }
              
              // get all xtag elements
              var elem_wait = xtag.query(dialogElement, xtagSelector);
              var elem_i;
              var elem_len;
              
              // begin interval (max out at 1 second)
              intervalI = 0;
              intervalID = setInterval(function () {
                  if (elem_wait.length === 0 || intervalI >= 30) {
                      clearInterval(intervalID);
                      elementReadyCallback();
                  } else {
                      elem_i = 0;
                      elem_len = elem_wait.length;
                      while (elem_i < elem_len) {
                          if (elem_wait[elem_i].__upgraded__ === true) {
                              elem_wait.splice(elem_i, 1);
                              elem_i -= 1;
                              elem_len -= 1;
                          }
                          elem_i += 1;
                      }
                  }
                  intervalI += 1;
              }, 30);
  
          // else: element instantiation blocks JS execution until the elements
          //      are ready, so we don't need to wait to run the after open callback
          } else {
              elementReadyCallback();
          }
  
          //// after open function call
          //if (typeof afterOpenFunction === 'function') {
          //    afterOpenFunction.apply(dialogElement, []);
          //}
  
          return dialogElement;
      };
  })();
  
  (function () {
      'use strict';
      xtag.register('gs-dialog', {
          lifecycle: {
              created: function () {
                  if (this.hasAttribute('focus-lock')) {
                      document.body.focus();
                  }
  
                  //document.body.parentNode.classList.add('no-scroll-except-for-dialog');
              },
  
              inserted: function () {
                  if (this.inserted !== true) {
                      this.inserted = true;
  
                      if (!this.hasAttribute('no-window-listen')) {
                          this.bind();
  
                          this.windowResizeHandler();
                      }
                      
                      this.addEventListener('click', function (event) {
                          var dialogcloseElement = GS.findParentElement(event.target, '[dialogclose]');
  
                          if (dialogcloseElement && event.target.hasAttribute('dialogclose')) {
                              GS.findParentTag(event.target, 'gs-dialog')
                                  .destroy(dialogcloseElement.textContent, event);
                          }
                      });
  
                      GS.triggerEvent(this, 'dialog-inserted');
                  }
              },
  
              removed: function () {
                  this.unbind();
              }
          },
          events: {
              //'click:delegate([dialogclose])': function (event) {
              //    var dialogcloseElement = GS.findParentElement(event.target, '[dialogclose]');
              //    console.log('running...');
              //    GS.findParentTag(event.target, 'gs-dialog')
              //            .destroy(dialogcloseElement.textContent, event);
              //}
          },
          accessors: {},
          methods: {
              bind: function () {
                  var element = this;
  
                  if (!element.hasAttribute('no-window-listen')) {
                      element.windowResizeHandler = function () {
                          element.style.left = (window.innerWidth / 2) - (element.offsetWidth / 2) + 'px';
                      };
                      
                      window.addEventListener('resize', element.windowResizeHandler);
                      window.addEventListener('orientationchange', element.windowResizeHandler);
                  }
              },
              
              unbind: function () {
                  window.removeEventListener('resize', this.windowResizeHandler);
                  window.removeEventListener('orientationchange', this.windowResizeHandler);
                  
                  GS.triggerEvent(window, 'resize');
              },
              
              destroy: function (strAnswer, originalEvent) {
                  var beforeCloseEvent;
                  
                  if (this.parentNode === document.body) {
                      beforeCloseEvent = GS.triggerEvent(this, 'beforeclose', {'data': strAnswer, 'originalEvent': originalEvent});
                      
                      if (!beforeCloseEvent.defaultPrevented && (!originalEvent || !originalEvent.defaultPrevented)) {
                          document.body.removeChild(this.previousElementSibling);
                          document.body.removeChild(this);
                          
                          GS.triggerEvent(this, 'afterclose', {'data': strAnswer, 'originalEvent': originalEvent});
                          
                          if (document.getElementsByTagName('gs-dialog').length === 0) {
                              document.body.parentNode.classList.remove('no-scroll-except-for-dialog');
                          }
                      }
                  }
              }
          }
      });
      
      xtag.register('gs-dialog-overlay', {
          lifecycle: {},
          events: {},
          accessors: {},
          methods: {}
      });
  })();window.addEventListener('design-register-element', function (event) {
      'use strict';
  
      registerDesignSnippet('<gs-envelope>', '<gs-envelope>', 'gs-envelope src="${1:test.tpeople}">\n' +
                                                              '    <template for="hud"></template>\n' +
                                                              '    <template for="table">\n' +
                                                              '        <table>\n' +
                                                              '            <tbody>\n' +
                                                              '                <tr>\n' +
                                                              '                    <th heading="#"><gs-static column="row_number"></gs-static></th>\n' +
                                                              '                    <td heading="">$0</td>\n' +
                                                              '                </tr>\n' +
                                                              '            </tbody>\n' +
                                                              '        </table>\n' +
                                                              '    </template>\n' +
                                                              '    <template for="insert"></template>\n' +
                                                              '</gs-envelope>');
  
      designRegisterElement('gs-envelope', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-envelope.html');
  
      window.designElementProperty_GSENVELOPE = function (selectedElement) {
          var intIdNumber = (Math.floor(Math.random() * 1000)) + (Math.floor(new Date().getTime() / (Math.random() * 100000)));
  
          addProp('Source', true,
                  '<gs-memo class="target" autoresize rows="1" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('src') ||
                                                                          selectedElement.getAttribute('source') || '')) + '" mini></gs-memo>',
                  function () {
              return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
          });
  
          addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                  function () {
              return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
          });
  
          addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('where') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'where', this.value);
          });
  
          addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
          });
  
          addProp('Limit', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
          });
  
          addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
          });
  
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
  
          addProp('Parent&nbsp;Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
  
          addProp('Line Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('child-column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'child-column', this.value);
          });
  
          addProp('Reflow At', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('reflow-at') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'reflow-at', this.value);
          });
  
          addProp('Scroll To Bottom', true, '<gs-checkbox class="target" value="' + encodeHTML(selectedElement.hasAttribute('scroll-to-bottom') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'scroll-to-bottom', (this.value === 'true'), true);
          });
  
          addProp('HUD Orderby', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudorderby')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-hudorderby', (this.value === 'true'), false);
          });
  
          addProp('HUD Limit', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudlimit')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-hudlimit', (this.value === 'true'), false);
          });
  
          addProp('HUD Refresh', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudrefresh')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-hudrefresh', (this.value === 'true'), false);
          });
  
          addProp('HUD Delete', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-huddelete')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-huddelete', (this.value === 'true'), false);
          });
  
          addProp('Expand&nbsp;To&nbsp;Content', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('expand-to-content')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'expand-to-content', (this.value === 'true'), true);
          });
  
          addProp('Primary Keys', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('primary-keys') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'primary-keys', this.value);
          });
  
          addProp('Select Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-select') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'action-select', this.value);
          });
  
          addProp('Insert Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-insert') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'action-insert', this.value);
          });
  
          addProp('Update Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-update') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'action-update', this.value);
          });
  
          addProp('Delete Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-delete') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'action-delete', this.value);
          });
  
          // Disable insert/update
          addProp('Disable Insert', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-insert') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-insert', this.value === 'true', true);
          });
  
          addProp('Disable Update', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-update') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-update', this.value === 'true', true);
          });
  
          // TEMPLATE attribute
          addProp('Record Template', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('template') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'template', this.value);
          });
  
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
  
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
  
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
  
              return selectedElement;
          });
  
          addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
              this.removeAttribute('refresh-on-querystring-change');
              return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
          });
  
          addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
              this.removeAttribute('refresh-on-querystring-values');
              return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
          });
  
          //// SUSPEND-CREATED attribute
          //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
          //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          //});
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
  
      // ####################################################################
      // ############################## LOADER ##############################
      // ####################################################################
  
      function addLoader(element, strText) {
          element.loaderContainer = GS.stringToElement('<div class="loader-container" style="top: ' + element.scrollContainerElement.scrollTop + 'px;"></div>');
          element.scrollContainerElement.appendChild(element.loaderContainer);
  
          GS.addLoader(element.loaderContainer, strText);
      }
  
      function removeLoader(element) {
          if (element.loaderContainer && element.loaderContainer.parentNode === element.scrollContainerElement) {
              element.scrollContainerElement.removeChild(element.loaderContainer);
          }
          GS.removeLoader(element.loaderContainer);
      }
  
      // ###################################################################
      // ########################## DRAG HANDLING ##########################
      // ###################################################################
  
      function selectHandler(element, dragOrigin, dragCurrentCell, dragMode) {
          var bolThead, bolFirstTh, arrRecords, arrCells, arrRecordsToAffect = [], arrCellsToAffect = [],
              arrNewSelection = [], arrCellsToRemoveFromSelection = [], i, len, intFrom, intTo;
  
          arrRecords = xtag.query(element.scrollContainerElement, 'tr');
          arrCells = xtag.query(element.scrollContainerElement, 'td, th');
  
          if (arrRecords.length > 0) {
              bolThead = Boolean(element.theadElement);
  
              if ((bolThead && arrRecords.length > 1) || (!bolThead && arrRecords > 0)) {
                  if (bolThead) {
                      bolFirstTh = arrRecords[1].children[0].nodeName === 'TH';
                  } else {
                      bolFirstTh = arrRecords[0].children[0].nodeName === 'TH';
                  }
              }
  
              // if origin & currentCell are both the top-left cell and the cell is a heading: select all cells
              if (bolThead && bolFirstTh &&
                  dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0 &&
                  dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                  arrCellsToAffect = arrCells;
  
              // else if origin & currentCell are both first ths: select the records from origin to currentCell
              } else if (bolFirstTh && dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                  arrRecordsToAffect =
                      arrRecords.slice(Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                                       Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1);
  
                  for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                      Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
                  }
  
              // else if origin & currentCell are both headings: select the columns from origin to currentCell
              } else if (bolThead && dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0) {
                  intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                  intTo   = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;
  
                  for (i = 0, len = arrRecords.length; i < len; i += 1) {
                      Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecords[i].children).slice(intFrom, intTo));
                  }
  
              //// else if origin & currentCell are the same cell: select the record
              //} else if (dragOrigin === dragCurrentCell) {
              //    arrRecordsToAffect = arrRecords.slice(dragOrigin.parentNode.rowIndex, dragOrigin.parentNode.rowIndex + 1);
              //
              //    for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
              //        Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
              //    }
  
              // else select cells from origin to currentCell
              } else {
                  arrRecordsToAffect =
                      arrRecords.slice(Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                                       Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1);
  
                  intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                  intTo   = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;
  
                  for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                      Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children).slice(intFrom, intTo));
                  }
              }
  
              if (dragOrigin !== dragCurrentCell) {
                  element.scrollContainerElement.removeAttribute('allow-text-selection');
                  element.copyFocusTargetElement.focus();
                  GS.setInputSelection(element.copyFocusTargetElement, 0, 'firefox...'.length);
              } else {
                  element.scrollContainerElement.setAttribute('allow-text-selection', '');
              }
  
              if (dragMode === 'select') {
  
                  // add new cells to element.selectionSelectedCells
                  for (i = 0, len = element.selectionSelectedCells.length; i < len; i += 1) {
                      if (arrCellsToAffect.indexOf(element.selectionSelectedCells[i]) === -1) {
                          arrCellsToRemoveFromSelection.push(element.selectionSelectedCells[i]);
                      }
                  }
                  element.selectionSelectedCells = arrCellsToAffect;
  
                  // add new cells to element.selectedCells
                  arrNewSelection = element.selectedCells;
                  for (i = 0, len = arrCellsToAffect.length; i < len; i += 1) {
                      GS.listAdd(arrNewSelection, arrCellsToAffect[i]);
                  }
                  for (i = 0, len = arrCellsToRemoveFromSelection.length; i < len; i += 1) {
                      arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToRemoveFromSelection[i]), 1);
                  }
                  element.selectedCells = arrNewSelection;
  
                  //element.selectionSelectedCells = arrCellsToAffect;
                  //element.selectedCells = arrCellsToAffect;
  
              } else { // implied if: dragMode === 'deselect'
                  // deselect cells from arrCellsToAffect
                  arrNewSelection = element.selectedCells;
  
                  for (i = 0, len = arrCellsToAffect.length; i < len; i += 1) {
                      if (arrNewSelection.indexOf(arrCellsToAffect[i]) > -1) {
                          arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToAffect[i]), 1);
                      }
                  }
                  element.selectedCells = arrNewSelection;
              }
          }
      }
  
      // #######################################################################
      // ############################ DATA HANDLING ############################
      // #######################################################################
  
  
      // get data and send it off to be templated
      function getData(element) {
          element.refreshing = true;
          var strSrc     = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') || element.getAttribute('source') || ''))
            , srcParts   = strSrc[0] === '(' ? [strSrc, ''] : strSrc.split('.')
            , strSchema  = srcParts[0]
            , strObject  = srcParts[1]
            , strWhere   = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('where') || ''))
            , strOrd     = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('ord') || ''))
            , strLimit   = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('limit') || ''))
            , strOffset  = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('offset') || ''))
            , response_i = 0, response_len = 0, arrTotalRecords = [], strWhereColumn
            , i, len;
  
          // if there is a column attribute on element: combine the where attribute with a where generated by value
          if ((element.getAttribute('column') || element.getAttribute('qs')) && element.value) {
              strWhereColumn = element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs');
  
              if (isNaN(element.value)) {
                  strWhere =  'CAST(' + strWhereColumn + ' AS ' + GS.database.type.text + ') = ' +
                              'CAST($WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')' +
                              (strWhere !== '' ? ' AND (' + strWhere + ')' : '');
              } else {
                  strWhere = strWhereColumn + '=' + (element.value) + (strWhere !== '' ? ' AND (' + strWhere + ')' : '');
              }
  
          // else: just use the where attribute
          }
  
          // if the user has set an order by: use the user order bys
          if (element.user_order_bys && element.user_order_bys.columns.length > 0) {
              for (i = 0, len = element.user_order_bys.columns.length, strOrd = ''; i < len; i += 1) {
                  strOrd += (strOrd !== '' ? ', ' : '') + element.user_order_bys.columns[i] + ' ' + element.user_order_bys.directions[i].toUpperCase();
              }
  
          // else: use the order by attribute
          }
  
          // save the old scrolltop (so that we can scroll back to it)
          element.oldScrollTop = element.scrollContainerElement.scrollTop;
  
          addLoader(element, 'Loading...');
          GS.requestCachingSelect(GS.envSocket, strSchema, strObject, '*'
                                   , strWhere, strOrd, strLimit, strOffset
                                   , function (data, error) {
              element.refreshing = false;
              var arrRecords, arrCells, envData
                , i, len, cell_i, cell_len;
  
              if (!error) {
                  if (data.strMessage !== 'TRANSACTION COMPLETED') {
                      arrRecords = GS.trim(data.strMessage, '\n').split('\n');
  
                      for (i = 0, len = arrRecords.length; i < len; i += 1) {
                          arrCells = arrRecords[i].split('\t');
  
                          for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                              arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                          }
  
                          arrTotalRecords.push(arrCells);
                      }
                  } else {
                      removeLoader(element);
                      element.arrColumnNames = data.arrColumnNames;
  
                      envData = {'arr_column': element.arrColumnNames, 'dat': arrTotalRecords};
  
                      handleData(element, envData);
                  }
              } else {
                  handleData(element, data, error);
                  //GS.removeLoader(element);
              }
          }, true);
      }
  
      function handleData(element, data, error) {
          var strHeaderHTML, strFixedHeaderHTML, tableElement, theadElement, tbodyElement,
              strBodyHTML, tableTemplateElement, arrCells, i, len,
              bolHeaderTextFound = false, strCurrentHeadingText, bolInitalSuccess;
  
          if (!error) {
              bolInitalSuccess = !element.lastSuccessData;
  
              // remove old error class
              element.classList.remove('error');
  
              // save data
              element.lastSuccessData = data;
  
              // create HTMl for header
              tableTemplateElement = document.createElement('template');
              tableTemplateElement.innerHTML = element.tableTemplate;
  
              tableElement = xtag.query(tableTemplateElement.content, 'table')[0];
              theadElement = xtag.queryChildren(tableElement, 'thead')[0];
              tbodyElement = xtag.queryChildren(tableElement, 'tbody')[0];
  
              // if there is a limit button
              if (element.limitButtonElement) {
                  element.limitButtonElement.textContent = data.dat.length + ' records';
                  element.limitButtonElement.setAttribute('class', 'row_count_btn');
              }
  
              //console.log(tableTemplateElement, element.tableTemplate, theadElement, tbodyElement);
  
              if (!theadElement) {
                  arrCells = tbodyElement.getElementsByTagName('tr')[0].children;
  
                  for (i = 0, len = arrCells.length, strHeaderHTML = '', strFixedHeaderHTML = ''; i < len; i += 1) {
                      strCurrentHeadingText = encodeHTML(GS.templateWithQuerystring(arrCells[i].getAttribute('heading') || ''));
  
                      if (strCurrentHeadingText) {
                          bolHeaderTextFound = true;
                      }
  
                      strHeaderHTML += '<th gs-dynamic>' + strCurrentHeadingText + '</th>';
                      strFixedHeaderHTML += '<div class="fixed-header-cell" gs-dynamic>' + strCurrentHeadingText + '</div>';
                  }
  
                  if (bolHeaderTextFound) {
                      strHeaderHTML = '<thead gs-dynamic><tr gs-dynamic>' + strHeaderHTML + '</tr></thead>';
  
                  } else {
                      strHeaderHTML = '';
                      strFixedHeaderHTML = '';
                  }
              } else {
                  strHeaderHTML = theadElement.outerHTML;
                  arrCells = theadElement.getElementsByTagName('tr')[0].children;
  
                  for (i = 0, len = arrCells.length, strFixedHeaderHTML = ''; i < len; i += 1) {
                      strFixedHeaderHTML += '<div class="fixed-header-cell" gs-dynamic>' + encodeHTML(arrCells[i].textContent || '') + '</div>';
                  }
              }
  
              element.fixedHeaderContainerElement.innerHTML = strFixedHeaderHTML;
  
              // create HTMl for body using the templated data
              strBodyHTML = '<tbody gs-dynamic>' + dataTemplateRecords(element, data) + '</tbody>';
  
  
  
              // this following observer code was added so that firefox would adjust it's headers at the right time
              //      I belive that the problem firefox had was that comboboxes were changing their width after
              //      refreshFixedHeader was being called, so this observer will call it after the childlist of the
              //      scrollcontainer changes
              // if there is already an observer: disconnect it
              if (element.headerRefreshObserver) {
                  element.headerRefreshObserver.disconnect();
                  element.headerRefreshObserver = undefined;
              }
  
              // fixed header mutation observer
              element.headerRefreshObserver = new MutationObserver(function(mutations) {
                  mutations.forEach(function(mutation) {
                      //console.log('1***');
                      element.refreshFixedHeader();
                  });
              });
  
              // pass in the target node, as well as the observer options
              element.headerRefreshObserver.observe(element.scrollContainerElement, {'childList': true});
  
  
              // set scroll container html
              element.scrollContainerElement.innerHTML = '<table gs-dynamic>' +
                                                          strHeaderHTML +
                                                          strBodyHTML +
                                                      '</table>';
  
              element.theadElement = xtag.query(element.scrollContainerElement, 'thead')[0];
              element.tbodyElement = xtag.query(element.scrollContainerElement, 'tbody')[0];
  
              element.refreshFixedHeader();
  
              // refresh height and reflow status
              element.refreshHeight();
              element.refreshReflow();
  
              // set scrolltop to the old scrolltop
              element.scrollContainerElement.scrollTop = element.oldScrollTop;
  
              if (element.hasAttribute('scroll-to-bottom')) {
                  element.scrollContainerElement.scrollTop = element.scrollContainerElement.scrollHeight;
              }
  
              // this is triggered after the scrolling is set so that if someone wants to scroll
              // to a record after select they aren't going to encounter a problem
              GS.triggerEvent(element, 'after_select');
  
          } else {
              // add error class
              element.classList.add('error');
  
              // error dialog
              GS.ajaxErrorDialog(data, function () {
                  getData(element);
              });
          }
      }
  
  
      function updateRecord(element, record, strColumn, newValue) {
          var srcParts   = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') || element.getAttribute('source') || '')).split('.')
            , strSchema  = srcParts[0]
            , strObject  = srcParts[1]
            , strHashCols = ''
            , strHashData = ''
            , strUpdateData =
              'pk\tset\thash\n' +
              'id\t' + GS.encodeForTabDelimited(strColumn) + '\thash\n' +
              GS.encodeForTabDelimited(record.getAttribute('data-id')) + '\t' + GS.encodeForTabDelimited(newValue) + '\t'
            , i, len, arrTotalRecords = [], callbackFunction;
  
          for (i = 0, len = element.arrWhereColumns.length; i < len; i += 1) {
              if (element.arrWhereColumns[i] != 'id') {
                  if (strHashCols.length > 0) {
                      strHashCols += '\t';
                      strHashData += '\t';
                  }
                  strHashCols += GS.encodeForTabDelimited(element.arrWhereColumns[i]);
  
                  strHashData += GS.encodeForTabDelimited(record.getAttribute('data-' + element.arrWhereColumns[i]));
              }
          }
  
          strUpdateData += CryptoJS.MD5(strHashData);
  
          addLoader(element, 'Updating Record...');
          GS.requestUpdateFromSocket(GS.envSocket, strSchema, strObject, '*', strHashCols, strUpdateData, function (data, error, transactionID) {
              if (error) {
                  removeLoader(element);
                  GS.webSocketErrorDialog(data);
              }
          }, function (data, error, transactionID, commitFunction, rollbackFunction) {
              var arrRecords, arrCells, envData
                , i, len, cell_i, cell_len;
  
              if (!error) {
                  if (data !== 'TRANSACTION COMPLETED') {
                      arrRecords = GS.trim(data, '\n').split('\n');
  
                      for (i = 0, len = arrRecords.length; i < len; i += 1) {
                          arrCells = arrRecords[i].split('\t');
  
                          for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                              arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                          }
  
                          arrTotalRecords.push(arrCells);
                      }
  
                  } else {
                      commitFunction();
                  }
  
              } else {
                  removeLoader(element);
                  rollbackFunction();
                  GS.webSocketErrorDialog(data);
              }
          }, function (strAnswer, data, error) {
              var arrElements, i, len;
  
              if (!error) {
                  if (strAnswer === 'COMMIT') {
                      callbackFunction({
                          detail: {
                              response: arrTotalRecords[0],
                              error: error
                          }
                      });
                  }
  
              } else {
                  getData(element);
                  GS.webSocketErrorDialog(data);
              }
          });
  
          callbackFunction = function (event) {
              var jsnData, i, len, idIndex, tbodyElement, recordIndex, focusElement = document.activeElement
                , focusElementTag, focusElementRecord, focusElementCell, focusElementRecordIndex, focusElementCellIndex
                , focusElementIndex, focusElementCell, elementWalkResult, arrElements, arrSelection, newRecord, jsnTextSelection
                , newRecordData;
              //console.log(event);
  
              removeLoader(element);
  
              focusElementCell = getCellFromTarget(focusElement);
  
              if (focusElementCell) {
                  focusElementTag = focusElement.nodeName.toLowerCase();
                  focusElementRecord = GS.findParentTag(focusElementCell, 'tr'); // getParentRecord(focusElementCell);
  
                  focusElementRecordIndex = focusElementRecord.rowIndex;
                  focusElementCellIndex = focusElementCell.cellIndex;
                  focusElementIndex = xtag.query(focusElementRecord, focusElement.nodeName.toLowerCase()).indexOf(focusElement);
  
                  //console.log(focusElementRecord,
                  //            xtag.query(focusElementRecord, '*'),
                  //            xtag.query(focusElementRecord, '*').indexOf(focusElement),
                  //            xtag.query(focusElementRecord, focusElement.nodeName.toLowerCase()).indexOf(focusElement));
              }
  
              // if no error: refresh just the updated record
              if (!event.detail.error) {
                  GS.triggerEvent(element, 'after_update');
                  newRecordData = JSON.parse(JSON.stringify(event.detail.response));
  
                  if (newRecordData.length > 0) {
                      // refresh record in lastSuccessData
                      idIndex = element.lastSuccessData.arr_column.indexOf('id');
  
                      for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                          if (String(element.lastSuccessData.dat[i][idIndex]) === String(record.getAttribute('data-id'))) {
                              recordIndex = i;
                              element.lastSuccessData.dat[i] = JSON.parse(JSON.stringify(event.detail.response));
  
                              break;
                          }
                      }
  
                      // save text selection status
                      if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                          jsnTextSelection = GS.getInputSelection(document.activeElement);
                      }
  
                      // save selection status of the cells in "record"
                      arrElements = xtag.query(record, 'td, th');
                      arrSelection = [];
  
                      for (i = 0, len = arrElements.length; i < len; i += 1) {
                          if (arrElements[i].hasAttribute('selected-secondary')) {
                              arrSelection.push('selected-secondary');
                          } else if (arrElements[i].hasAttribute('selected')) {
                              arrSelection.push('selected');
                          } else {
                              arrElements.push('');
                          }
                      }
  
                      // replace "record" with new templated record
                      tbodyElement = document.createElement('tbody');
                      tbodyElement.innerHTML = dataTemplateRecords(element, element.lastSuccessData, recordIndex, 1); // jsnData // dataTemplate
                      newRecord = xtag.queryChildren(tbodyElement, 'tr')[0];
                      record.parentNode.replaceChild(newRecord, record);
  
                      // use saved selection status to select the cells in the new record
                      arrElements = xtag.query(newRecord, 'td, th');
  
                      for (i = 0, len = arrElements.length; i < len; i += 1) {
                          if (arrSelection[i]) {
                              arrElements[i].setAttribute(arrSelection[i], '');
                          }
                      }
  
                      // refocus
                      if (focusElementCell) {
                          elementWalkResult = xtag.query(element.scrollContainerElement, 'tr')[focusElementRecordIndex];
  
                          if (elementWalkResult) {
                              elementWalkResult = xtag.query(elementWalkResult, focusElementTag)[focusElementIndex];
  
                              if (elementWalkResult) {
                                  elementWalkResult.focus();
                              }
  
                              //elementWalkResult = xtag.queryChildren(elementWalkResult, 'th, td')[focusElementCellIndex];
                              //
                              //if (elementWalkResult) {
                              //    elementWalkResult = xtag.query(elementWalkResult, '*')[1];
                              //
                              //    if (elementWalkResult) {
                              //        elementWalkResult.focus();
                              //    }
                              //}
                          }
                      }
  
                      // use saved text selection status to select active element
                      if (jsnTextSelection) {
                          GS.setInputSelection(document.activeElement, jsnTextSelection.start, jsnTextSelection.end);
                      }
                  } else {
                      element.selectedCells = [];
                      record.parentNode.removeChild(record);
                  }
  
                  element.refreshFixedHeader();
                  element.refreshHeight();
  
              // else: errorDialog
              } else {
                  // create addin to error response
                  event.detail.response.error_addin = '<b gs-dynamic>Your Unsaved Value:</b> "' + newValue + '"';
  
                  GS.ajaxErrorDialog(event.detail.response, function () {
                      updateRecord(element, record, strColumn, newValue);
                  }, function () {
                      // revert
                      idIndex = element.lastSuccessData.arr_column.indexOf('id');
  
                      for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                          if (String(element.lastSuccessData.dat[i][idIndex]) === String(record.getAttribute('data-id'))) {
                              recordIndex = i;
                              break;
                          }
                      }
  
                      tbodyElement = document.createElement('tbody');
                      tbodyElement.innerHTML = dataTemplateRecords(element, element.lastSuccessData, recordIndex, 1);
                      record.parentNode.replaceChild(xtag.queryChildren(tbodyElement, 'tr')[0], record);
                  });
              }
          };
      }
  
      function deleteRecords(element, arrID, arrRecord) {
          var srcParts   = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') || element.getAttribute('source') || '')).split('.')
            , strSchema  = srcParts[0]
            , strObject  = srcParts[1]
            , strHashCols = ''
            , strHashData = ''
            , strDeleteData =
              'pk\thash\n' +
              'id\thash\n'
            , i, len, j, len2, arrTotalRecords = [], callbackFunction;
  
          for (j = 0, len2 = element.arrWhereColumns.length; j < len2; j += 1) {
              if (element.arrWhereColumns[j] != 'id') {
                  if (strHashCols.length > 0) {
                      strHashCols += '\t';
                  }
                  strHashCols += GS.encodeForTabDelimited(element.arrWhereColumns[j]);
              }
          }
  
          for (i = 0, len = arrID.length; i < len; i += 1) {
              for (j = 0, len2 = element.arrWhereColumns.length; j < len2; j += 1) {
                  if (element.arrWhereColumns[j] != 'id') {
                      if (strHashData.length > 0) {
                          strHashData += '\t';
                      }
  
                      strHashData += GS.encodeForTabDelimited(arrRecord[i].getAttribute('data-' + element.arrWhereColumns[j]));
                  } else {
                      strDeleteData += GS.encodeForTabDelimited(arrRecord[i].getAttribute('data-id'));
                  }
              }
              //console.log(strHashData);
              strDeleteData += '\t' + CryptoJS.MD5(strHashData) + '\n';
              strHashData = '';
          }
  
          addLoader(element, 'Creating Delete Transaction...');
          GS.requestDeleteFromSocket(
              GS.envSocket, strSchema, strObject, strHashCols, strDeleteData
              , function (data, error, transactionID) {
                  if (error) {
                      removeLoader(element);
                      GS.webSocketErrorDialog(data);
                  }
              }
              , function (data, error, transactionID, commitFunction, rollbackFunction) {
                  var arrElements, i, len, templateElement;
                  if (!error) {
                      if (data === 'TRANSACTION COMPLETED') {
                          // We have already confimed with the user that we are going to delete
                          commitFunction();
                      }
  
                  } else {
                      rollbackFunction();
                      GS.webSocketErrorDialog(data);
                  }
              }
              , function (strAnswer, data, error) {
                  var i, len, idColIndex, deleteIndex;
                  removeLoader(element);
  
                  if (!error) {
                      if (strAnswer === 'COMMIT') {
                          GS.triggerEvent(element, 'after_delete');
  
                          for (i = 0, len = arrRecord.length; i < len; i += 1) {
                              arrRecord[i].parentNode.removeChild(arrRecord[i]);
                          }
  
                          idColIndex = element.lastSuccessData.arr_column.indexOf('id');
  
                          if (element.hasAttribute('limit') || element.lastSuccessData.dat.length === arrID.length) {
                              element.refresh();
  
                          } else {
                              // remove the record data from our stored data and
                              //      stop looping when we have deleted all the ones we are supposed to
                              for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                                  // (arrID should only have strings so we cast the current id to string)
                                  deleteIndex = arrID.indexOf(String(element.lastSuccessData.dat[i][idColIndex]));
  
                                  if (deleteIndex > -1) {
                                      element.lastSuccessData.dat.splice(i, 1);
                                      arrID.splice(deleteIndex, 1);
                                      len -= 1;
                                      i -= 1;
                                  }
  
                                  if (arrID.length === 0) {
                                      break;
                                  }
                              }
  
                              handleData(element, element.lastSuccessData);
                          }
                      }
  
                  } else {
                      getData(element);
                      GS.webSocketErrorDialog(data);
                  }
              }
          );
      }
  
      function insertRecord(element, dialog, strInsertString) {
          var srcParts   = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') || element.getAttribute('source') || '')).split('.')
            , strSchema  = srcParts[0]
            , strObject  = srcParts[1]
            , arrInsertKeys
            , arrInsertValues
            , strWSInsertColumns
            , strWSInsertData
            , i, len;
  
          // if there is a column attribute on this element: append child column (or column) and the value to the insert string
          if (element.getAttribute('column') || element.getAttribute('qs')) {
              strInsertString += (strInsertString ? '&' : '') + (element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs')) + '=' + (element.value);
          }
  
          //console.log(strInsertString);
  
          arrInsertKeys = GS.qryGetKeys(strInsertString);
          arrInsertValues = GS.qryGetVals(strInsertString);
  
          for (i = 0, len = arrInsertKeys.length, strWSInsertColumns = ''; i < len; i += 1) {
              strWSInsertColumns += arrInsertKeys[i] + ((i + 1) === len ? '\n' : '\t');
          }
          for (i = 0, len = arrInsertValues.length, strWSInsertData = ''; i < len; i += 1) {
              strWSInsertData += arrInsertValues[i] + ((i + 1) === len ? '\n' : '\t');
          }
  
          addLoader(element, 'Inserting Record...');
  
          GS.requestInsertFromSocket(GS.envSocket, strSchema, strObject, strWSInsertColumns, 'id', '', strWSInsertColumns + strWSInsertData, function (data, error, transactionID) {
              if (error) {
                  removeLoader(element);
                  GS.webSocketErrorDialog(data);
              }
          }, function (data, error, transactionID, commitFunction, rollbackFunction) {
              var arrElements, i, len, templateElement;
  
              if (!error) {
                  if (data === 'TRANSACTION COMPLETED') {
                      commitFunction();
                  }
  
              } else {
                  removeLoader(element);
                  rollbackFunction();
                  GS.webSocketErrorDialog(data);
              }
          }, function () {
              removeLoader(element);
              GS.triggerEvent(element, 'after_insert');
              GS.closeDialog(dialog, 'Ok');
              getData(element, true);
          });
      }
  
  
      // ##################################################################
      // ########################### UI REFRESH ###########################
      // ##################################################################
  
  
      function refreshHud(element) {
          var elementHudTopContainer, elementHudBottomContainer, divElement = document.createElement('div'),
              hudInsertButton, hudRefreshButton, hudDeleteButton, hudOrderbyButton, hudLimitButton, intOffset, intLimit,
              jsnOrderByCopy, i, len, customHudTemplate, customHudElements;
  
          elementHudTopContainer    = element.hudTopElement;
          elementHudBottomContainer = element.hudBottomElement;
  
          elementHudTopContainer.innerHTML = '';
          elementHudBottomContainer.innerHTML = '';
  
          // insert hud button
          if (element.insertTemplate && !element.hasAttribute('no-insert')) {
              divElement.innerHTML = '<gs-button inline icononly icon="plus" no-focus gs-dynamic>Insert</gs-button>';
  
              hudInsertButton = divElement.childNodes[0];
  
              elementHudTopContainer.appendChild(hudInsertButton);
          }
  
          // refresh hud button
          if (!element.hasAttribute('no-hudrefresh')) {
              divElement.innerHTML = '<gs-button inline icononly icon="refresh" no-focus gs-dynamic>Refresh</gs-button>';
  
              hudRefreshButton = divElement.childNodes[0];
  
              elementHudTopContainer.appendChild(hudRefreshButton);
          }
  
          // delete hud button
          if (!element.hasAttribute('no-huddelete')) {
              divElement.innerHTML = '<gs-button inline icononly icon="times" no-focus gs-dynamic>Delete</gs-button>';
  
              hudDeleteButton = divElement.childNodes[0];
  
              elementHudTopContainer.appendChild(hudDeleteButton);
          }
  
          // custom hud buttons (trim so that just whitespace doesn't count)
          if (element.hudTemplate && element.hudTemplate.trim()) {
              customHudTemplate = document.createElement('template');
              customHudTemplate.innerHTML = element.hudTemplate;
  
              elementHudTopContainer.appendChild(customHudTemplate.content.cloneNode(true));
  
              // V------ you can't use .children on a template.content
              //customHudElements = customHudTemplate.content.childNodes;
              //
              //for (i = 0, len = customHudElements.length; i < len; i += 1) {
              //    //customHudElements[i].setAttribute('inline', '');
              //    elementHudTopContainer.appendChild(customHudElements[0]);
              //}
              //elementHudTopContainer.innerHTML += element.hudTemplate; <-- this causes events to be lost in the hud-top container
          }
  
          // order by hud button
          if (!element.hasAttribute('no-hudorderby')) {
              divElement.innerHTML = '<gs-button inline icononly icon="sort-amount-asc" no-focus gs-dynamic>Order By</gs-button>';
  
              hudOrderbyButton = divElement.childNodes[0];
  
              elementHudBottomContainer.appendChild(hudOrderbyButton);
          }
  
          // limit hud button
          element.limitButtonElement = '';
          if (!element.hasAttribute('no-hudlimit')) {
              //console.log(element, element.lastSuccessData);
              divElement.innerHTML = '<span flex></span><gs-button inline no-focus>Limit</gs-button>';
  
              hudLimitButton = divElement.childNodes[1];
  
              element.limitButtonElement = hudLimitButton;
  
              elementHudBottomContainer.appendChild(divElement.childNodes[0]);
              elementHudBottomContainer.appendChild(divElement.childNodes[0]);
          }
  
          if (elementHudTopContainer.innerHTML === '') {
              elementHudTopContainer.style.display = 'none';
          } else {
              elementHudTopContainer.style.display = '';
          }
  
          if (elementHudBottomContainer.innerHTML === '') {
              elementHudBottomContainer.style.display = 'none';
          } else {
              elementHudBottomContainer.style.display = '';
          }
  
  
          // bind hud buttons
          if (hudInsertButton) {
              hudInsertButton.addEventListener('click', function (event) {
                  var templateElement = document.createElement('template');
  
                  templateElement.innerHTML = ml(function () {/*
                      <gs-page gs-dynamic>
                          <gs-header gs-dynamic><center gs-dynamic><h3 gs-dynamic>Insert</h3></center></gs-header>
                          <gs-body padded gs-dynamic>
                              <div id="insert-dialog-content-container" gs-dynamic>{{HTML}}</div>
                          </gs-body>
                          <gs-footer gs-dynamic>
                              <gs-grid gs-dynamic widths="1,1" class="width-2">
                                  <gs-block gs-dynamic width="1">
                                      <gs-button dialogclose gs-dynamic>Cancel</gs-button>
                                  </gs-block>
                                  <gs-block gs-dynamic width="1">
                                      <gs-button class="dialog-envelope-insert" listen-for-return bg-primary gs-dynamic>Ok</gs-button>
                                  </gs-block>
                              </gs-grid>
                          </gs-footer>
                      </gs-page>
                  */}).replace('{{HTML}}', element.insertTemplate);
  
                  GS.openDialog(templateElement, function () {
                      var dialog = this;
  
                      GS.triggerEvent(element, 'insert_dialog_open');
  
                      xtag.query(dialog, '.dialog-envelope-insert')[0].addEventListener('click', function () {
                          var insertContainer = document.getElementById('insert-dialog-content-container'),
                              controls, i, len, strInsertString, currentValue;
  
                          controls = xtag.query(insertContainer, '[column]');
  
                          for (i = 0, len = controls.length, strInsertString = ''; i < len; i += 1) {
                              currentValue = controls.checked !== undefined ? controls.checked : controls[i].value;
  
                              if (currentValue === undefined || currentValue === null) {
                                  currentValue = '';
                              }
  
                              currentValue = encodeURIComponent(currentValue);
  
                              if (currentValue !== undefined && currentValue !== null && currentValue !== '') {
                                  strInsertString += (strInsertString === '' ? '' : '&') +
                                                      controls[i].getAttribute('column') + '=' + currentValue;
                              }
                          }
  
                          insertRecord(element, dialog, strInsertString);
                      });
                  });
              });
          }
  
          if (hudRefreshButton) {
              element.hudRefreshButton = hudRefreshButton;
              hudRefreshButton.addEventListener('click', function (event) {
                  getData(element, true);
              });
          }
  
          if (hudDeleteButton) {
              element.hudDeleteButton = hudDeleteButton;
              //console.log('binding click on', hudDeleteButton);
              hudDeleteButton.addEventListener('click', function (event) {
                  var i, len, arrRecord = element.selectedRecords, arrID = [];
  
                  // loop through the selected cells and create an array of ids
                  for (i = 0, len = arrRecord.length; i < len; i += 1) {
                      arrID.push(String(arrRecord[i].dataset.id));
                  }
  
                  if (arrID.length > 0) {
                      GS.msgbox(  'Are you sure...',
                                      '<br gs-dynamic />' +
                                      '<center gs-dynamic>' +
                                          'Are you sure you want to delete ' + (arrID.length > 1 ? 'these records' : 'this record') + '?' +
                                      '</center>' +
                                      '<br gs-dynamic />',
                                  ['No', 'Yes'],
                                  function (strAnswer) {
                                      if (strAnswer === 'Yes') {
                                          deleteRecords(element, arrID, arrRecord);
                                      }
                                  });
  
                  } else {
                      GS.msgbox('Nothing Selected.',
                                '<br gs-dynamic /><center gs-dynamic>Nothing is selected. Please select something to delete.</center><br />',
                                ['Ok']);
                  }
              });
          }
  
          if (hudOrderbyButton) {
              element.hudOrderbyButton = hudOrderbyButton;
              hudOrderbyButton.addEventListener('click', function (event) {
                  var templateElement = document.createElement('template');
  
                  jsnOrderByCopy = JSON.parse(JSON.stringify(element.user_order_bys));
  
                  // TESTING LINE!!! COMMENT OUT WHEN NOT IN USE!!!
                  //jsnOrderByCopy = {'columns': ['billable', 'taxable', 'id', 'user_name'], 'directions': ['asc', 'desc', 'asc', 'asc']};
                  // TESTING LINE!!! COMMENT OUT WHEN NOT IN USE!!!
  
                  templateElement.setAttribute('data-mode', 'touch');
                  templateElement.innerHTML = ml(function () {/*
                      <gs-page gs-dynamic>
                          <gs-header gs-dynamic>
                              <center gs-dynamic><h3 gs-dynamic>Sorted Columns</h3></center>
                              <gs-button id="order-by-dialog-add-column" gs-dynamic>Add A Column To Sort</gs-button>
                          </gs-header>
                          <gs-body padded gs-dynamic>
                              <div id="order-by-dialog-ghost-container" gs-dynamic></div>
                              <div id="order-by-dialog-used-columns" gs-dynamic></div>
                          </gs-body>
                          <gs-footer gs-dynamic>
                              <gs-grid>
                                  <gs-block><gs-button gs-dynamic dialogclose>Cancel</gs-button></gs-block>
                                  <gs-block><gs-button gs-dynamic dialogclose>Ok</gs-button></gs-block>
                              </gs-grid>
                          </gs-footer>
                      </gs-page>
                  */});
  
                  GS.openDialog(templateElement, function () {
                      document.getElementById('order-by-dialog-add-column').addEventListener('click', function (event) {
                          var dialog, dialogButtons, templateElement = document.createElement('template');
  
                          templateElement.innerHTML = ml(function () {/*
                              <gs-page gs-dynamic>
                                  <gs-header gs-dynamic>
                                      <center gs-dynamic><h3 gs-dynamic>Unsorted Columns</h3></center>
                                  </gs-header>
                                  <gs-body padded gs-dynamic>
                                      <div id="order-by-dialog-unused-columns" gs-dynamic></div>
                                  </gs-body>
                                  <gs-footer gs-dynamic>
                                      <gs-button dialogclose gs-dynamic>Cancel</gs-button>
                                  </gs-footer>
                              </gs-page>
                          */});
  
                          dialog = GS.openDialog(templateElement, function () {
                                      var unusedColumnsContainer = document.getElementById('order-by-dialog-unused-columns'),
                                          unusedColumnTapHandler, columnElements, i, len, strHTML;
  
                                      for (i = 0, len = element.lastSuccessData.arr_column.length, strHTML = ''; i < len; i += 1) {
                                          if (jsnOrderByCopy.columns.indexOf(element.lastSuccessData.arr_column[i]) === -1) {
                                              strHTML +=  '<div class="order_by_column" dialogclose data-column="' + element.lastSuccessData.arr_column[i] + '" gs-dynamic>' +
                                                              '<div class="column_name" gs-dynamic>' + GS.strToTitle(element.lastSuccessData.arr_column[i]) + '</div>' +
                                                          '</div>';
                                          }
                                      }
  
                                      unusedColumnsContainer.innerHTML = strHTML;
  
                                      unusedColumnTapHandler = function (event) {
                                          if (event.target.classList.contains('column_name')) {
                                              jsnOrderByCopy.columns.push(event.target.parentNode.getAttribute('data-column'));
                                          } else {
                                              jsnOrderByCopy.columns.push(event.target.getAttribute('data-column'));
                                          }
                                          jsnOrderByCopy.directions.push('asc');
  
                                          // refresh the column list
                                          refreshOrderBys();
                                      };
  
                                      columnElements = unusedColumnsContainer.getElementsByClassName('order_by_column');
  
                                      for (i = 0, len = columnElements.length; i < len; i += 1) {
                                          columnElements[i].addEventListener('click', unusedColumnTapHandler);
                                      }
                                  });
  
                          dialogButtons = dialog.getElementsByTagName('gs-button');
                      });
  
                      var refreshOrderBys = function () {
                          var usedColumnsElement = document.getElementById('order-by-dialog-used-columns'),
                              ghostContainerElement = document.getElementById('order-by-dialog-ghost-container'),
                              strHTML, i, len, sortButtons, sortMousedownHandler, deleteButtons,
                              deleteTapHandler, directionButtons, directionTapHandler;
  
  
                          for (i = 0, len = jsnOrderByCopy.columns.length, strHTML = ''; i < len; i += 1) {
                              strHTML +=  '<div class="order_by_column" flex-horizontal data-column="' + jsnOrderByCopy.columns[i] + '" data-direction="' + jsnOrderByCopy.directions[i] + '" gs-dynamic>' +
                                              '<gs-button inline remove-all icononly icon="bars" class="sort" gs-dynamic></gs-button>' +
                                              '<div class="column_name" flex gs-dynamic>' + GS.strToTitle(jsnOrderByCopy.columns[i]) + '</div>' +
                                              '<gs-button inline remove-all icononly icon="times" class="delete" gs-dynamic></gs-button>' +
                                              '<gs-button inline remove-all icononly icon="sort-amount-' + jsnOrderByCopy.directions[i] + '" class="direction" gs-dynamic></gs-button>' +
                                          '</div>';
                          }
  
                          usedColumnsElement.innerHTML = strHTML;
  
                          // bind sort buttons
                          sortMousedownHandler = function () {
                              var columns = usedColumnsElement.getElementsByClassName('order_by_column'), offsetsCache = [], i, len,
                                  currentElement = this.parentNode, currentlyMarkedElement, markerElement, bolLast = false, intToIndex,
                                  currentElementClone, intCloneoffset, intFromIndex, sortMousemoveHandler, sortMouseupHandler, 
                                  strColumn = currentElement.getAttribute('data-column'),
                                  strDirection = currentElement.getAttribute('data-direction');
  
                              markerElement = document.createElement('div');
                              markerElement.classList.add('drop_marker');
                              markerElement.setAttribute('gs-dynamic', '');
  
                              currentElementClone = currentElement.cloneNode(true);
                              ghostContainerElement.appendChild(currentElementClone);
                              intCloneoffset = GS.getElementOffset(ghostContainerElement).top + (currentElementClone.offsetHeight / 2);
  
  
                              for (i = 0, len = columns.length; i < len; i += 1) {
                                  offsetsCache.push({
                                      'element': columns[i],
                                      'top': GS.getElementOffset(columns[i]).top,
                                      'height': columns[i].offsetHeight//, 'iscurrentelement': columns[i] === currentElement
                                  });
  
                                  if (columns[i] === currentElement) {
                                      intFromIndex = i;
                                  }
                              }
  
                              sortMousemoveHandler = function (event) {
                                  var i, len, matchedElement, bolNewLast, intTop;
  
                                  event.preventDefault();
                                  event.stopPropagation();
  
                                  if (event.which === 0 && !evt.touchDevice) {
                                      sortMouseupHandler();
  
                                  } else {
                                      intTop = GS.mousePosition(event).top + usedColumnsElement.parentNode.scrollTop;
  
                                      currentElementClone.style.top = (intTop - intCloneoffset) + 'px';
  
                                      //console.log('mousemove', GS.mousePosition(event).top, usedColumnsElement.parentNode.scrollTop);
  
                                      if (offsetsCache[0].top > intTop) {
                                          matchedElement = offsetsCache[0].element;
                                          bolNewLast = false;
  
                                      } else {
                                          for (i = 0, len = offsetsCache.length; i < len; i += 1) {
                                              if (offsetsCache[i + 1]) {
                                                  if (offsetsCache[i].top <= intTop &&
                                                      offsetsCache[i].top + ((offsetsCache[i + 1].top - offsetsCache[i].top) / 2) > intTop) {
  
                                                      matchedElement = offsetsCache[i].element;
                                                      bolNewLast = false;
                                                      intToIndex = i;
                                                      break;
  
                                                  } else if (offsetsCache[i].top <= intTop &&
                                                              offsetsCache[i].top + ((offsetsCache[i + 1].top - offsetsCache[i].top) / 2) <= intTop &&
                                                              offsetsCache[i + 1].top > intTop) {
  
                                                      matchedElement = offsetsCache[i + 1].element;
                                                      bolNewLast = false;
                                                      intToIndex = i + 1;
                                                      break;
                                                  }
                                              } else {
                                                  if (offsetsCache[i].top + (offsetsCache[i].height / 2) >= intTop) {
                                                      matchedElement = offsetsCache[i].element;
                                                      bolNewLast = false;
                                                      intToIndex = i;
                                                      break;
  
                                                  } else if (offsetsCache[i].top + (offsetsCache[i].height / 2) <= intTop) {
                                                      matchedElement = offsetsCache[i].element;
                                                      bolNewLast = true;
                                                      intToIndex = i;
                                                      break;
                                                  }
                                              }
                                          }
                                      }
  
                                      if (matchedElement !== currentlyMarkedElement || bolNewLast !== bolLast) {
                                          if (bolNewLast === true) {
                                              if (markerElement) {
                                                  markerElement.parentNode.removeChild(markerElement);
                                              }
                                              matchedElement.parentNode.appendChild(markerElement);
  
                                          } else {
                                              matchedElement.parentNode.insertBefore(markerElement, matchedElement);
                                          }
  
                                          currentlyMarkedElement = matchedElement;
                                          bolLast = bolNewLast;
  
                                          //console.log(currentlyMarkedElement, bolLast);
                                      }
  
                                      //console.log('mousemove', intTop);
                                  }
                              };
  
                              document.body.addEventListener(evt.mousemove, sortMousemoveHandler);
  
                              sortMouseupHandler = function (event) {
                                  intToIndex = (intToIndex > intFromIndex ? intToIndex - 1: intToIndex);
  
                                  // if we have valid to and from indexes:
                                  if (intFromIndex !== intToIndex && intToIndex !== undefined) {
  
                                      if (intFromIndex !== undefined && intFromIndex !== '') {
                                          jsnOrderByCopy.columns.splice(intFromIndex, 1);
                                          jsnOrderByCopy.directions.splice(intFromIndex, 1);
                                      }
  
                                      jsnOrderByCopy.columns.splice(intToIndex, 0, strColumn);
                                      jsnOrderByCopy.directions.splice(intToIndex, 0, strDirection);
  
                                      // refresh the column list
                                      refreshOrderBys();
                                  } else {
                                      markerElement.parentNode.removeChild(markerElement);
                                  }
  
                                  //console.log(intFromIndex, intToIndex);
                                  ghostContainerElement.innerHTML = '';
                                  document.body.removeEventListener(evt.mousemove, sortMousemoveHandler);
                                  document.body.removeEventListener(evt.mouseup, sortMouseupHandler);
                              };
  
                              document.body.addEventListener(evt.mouseup, sortMouseupHandler);
  
                              //console.log('sortMousedownHandler');
                          };
                          sortButtons = usedColumnsElement.getElementsByClassName('sort');
  
                          for (i = 0, len = sortButtons.length; i < len; i += 1) {
                              sortButtons[i].addEventListener(evt.mousedown, sortMousedownHandler);
                          }
                          //console.log(usedColumnsElement.getElementsByClassName('sort'));
  
                          // bind delete buttons
                          deleteTapHandler = function () {
                              var indexToDelete = jsnOrderByCopy.columns.indexOf(this.parentNode.getAttribute('data-column'));
  
                              jsnOrderByCopy.columns.splice(indexToDelete, 1);
                              jsnOrderByCopy.directions.splice(indexToDelete, 1);
  
                              refreshOrderBys();
                              //console.log('deleteTapHandler');
                          };
                          deleteButtons = usedColumnsElement.getElementsByClassName('delete');
  
                          for (i = 0, len = deleteButtons.length; i < len; i += 1) {
                              deleteButtons[i].addEventListener('click', deleteTapHandler);
                          }
                          //console.log(usedColumnsElement.getElementsByClassName('delete'));
  
  
                          // bind direction buttons
                          directionTapHandler = function () {
                              var indexToFlip = jsnOrderByCopy.columns.indexOf(this.parentNode.getAttribute('data-column'));
  
                              if (jsnOrderByCopy.directions[indexToFlip] === 'asc') {
                                  jsnOrderByCopy.directions[indexToFlip] = 'desc';
                              } else {
                                  jsnOrderByCopy.directions[indexToFlip] = 'asc';
                              }
  
                              refreshOrderBys();
                              //console.log('directionTapHandler');
                          };
                          directionButtons = usedColumnsElement.getElementsByClassName('direction');
  
                          for (i = 0, len = directionButtons.length; i < len; i += 1) {
                              directionButtons[i].addEventListener('click', directionTapHandler);
                          }
                          //console.log(usedColumnsElement.getElementsByClassName('direction'));
                      }
  
                      refreshOrderBys();
                  }, function (event, strAnswer) {
                      if (strAnswer === 'Ok') {
                          element.user_order_bys = JSON.parse(JSON.stringify(jsnOrderByCopy));
                          getData(element, true);
                      }
                  });
              });
          }
  
          if (hudLimitButton) {
              element.hudLimitButton = hudLimitButton;
              hudLimitButton.addEventListener('click', function (event) {
                  var intLimit, intOffset, bolShowAll, fromValue, toValue,
                      templateElement = document.createElement('template');
  
                  if (element.getAttribute('limit') && element.getAttribute('offset')) {
                      intOffset = parseInt(element.getAttribute('offset'), 10);
                      intLimit = parseInt(element.getAttribute('limit'), 10);
  
                      fromValue = intOffset;
                      toValue = intOffset + intLimit;
                      bolShowAll = false;
  
                  } else if (element.getAttribute('limit')) {
                      fromValue = '0';
                      toValue = element.getAttribute('limit');
                      bolShowAll = false;
  
                  } else if (element.old_offset && element.old_limit) {
                      intOffset = parseInt(element.old_offset, 10);
                      intLimit = parseInt(element.old_limit, 10);
  
                      fromValue = intOffset;
                      toValue = intOffset + intLimit;
                      bolShowAll = true;
  
                  } else if (element.old_limit) {
                      fromValue = '0';
                      toValue = element.old_limit;
                      bolShowAll = true;
  
                  } else {
                      fromValue = '0';
                      toValue = '';
                      bolShowAll = true;
                  }
  
                  templateElement.setAttribute('id', 'template-envelope-limit');
                  templateElement.innerHTML = ml(function () {/*
                      <gs-page gs-dynamic>
                          <gs-header><center><h3>Limit</h3></center></gs-header>
                          <gs-body padded>
                              <gs-optionbox id="limit-dialog-choice" value="{{OPTION}}">
                                  <gs-option value="range">
                                      Show Range:
                                      <gs-grid gutter>
                                          <gs-block>
                                              <b>From:</b>
                                              <gs-text id="limit-dialog-from" value="{{FROM}}" {{DISABLE}}></gs-text>
                                          </gs-block>
                                          <gs-block>
                                              <b>To:</b>
                                              <gs-text id="limit-dialog-to" value="{{TO}}" {{DISABLE}}></gs-text>
                                          </gs-block>
                                      </gs-grid>
                                  </gs-option>
                                  <gs-option value="all">Show All</gs-option>
                              </gs-optionbox>
                          </gs-body>
                          <gs-footer>
                              <gs-grid>
                                  <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                                  <gs-block><gs-button dialogclose listen-for-return bg-primary>Ok</gs-button></gs-block>
                              </gs-grid>
                          </gs-footer>
                      </gs-page>
                  */}).replace('{{OPTION}}', (bolShowAll === true ? 'all' : 'range'))
                      .replace(/\{\{DISABLE\}\}/gim, (bolShowAll === true ? 'disabled' : ''))
                      .replace('{{FROM}}', fromValue)
                      .replace('{{TO}}', toValue);
  
                  GS.openDialog(templateElement, function () {
                      var choiceElement, showAllElement, fromElement, toElement, intLimit, intOffset, bolShowAll, fromValue, toValue;
  
                      choiceElement = document.getElementById('limit-dialog-choice');
                      fromElement = document.getElementById('limit-dialog-from');
                      toElement = document.getElementById('limit-dialog-to');
  
                      choiceElement.addEventListener('change', function (event) {
                          if (this.value === 'all') {
                              fromElement.setAttribute('disabled', '');
                              toElement.setAttribute('disabled', '');
                              GS.closeDialog('template-envelope-limit', 'Ok');
                          } else {
                              fromElement.removeAttribute('disabled');
                              toElement.removeAttribute('disabled');
                          }
                      });
  
                  }, function (event, strAnswer) {
                      var dialog = this, choiceElement, showAllElement, fromElement, toElement, intLimit, intOffset;
  
                      if (strAnswer === 'Ok') {
                          choiceElement = document.getElementById('limit-dialog-choice');
                          showAllElement = document.getElementById('limit-dialog-show-all');
                          fromElement = document.getElementById('limit-dialog-from');
                          toElement = document.getElementById('limit-dialog-to');
  
                          if (choiceElement.value === 'all') {
                              if (element.getAttribute('limit')) {
                                  element.old_limit = element.getAttribute('limit');
                                  element.removeAttribute('limit');
                              }
                              if (element.getAttribute('offset')) {
                                  element.old_offset = element.getAttribute('offset');
                                  element.removeAttribute('offset');
                              }
  
                          } else {
                              if (fromElement.value) {
                                  element.setAttribute('offset', fromElement.value);
                              }
                              if (toElement.value) {
                                  element.setAttribute('limit', parseInt(toElement.value, 10) - parseInt(fromElement.value, 10));
                              }
                          }
  
                          getData(element);
                      }
                  });
              });
          }
      }
  
  
      // #################################################################
      // ########################### UTILITIES ###########################
      // #################################################################
  
      function handleClipboardData(event, strCopyString) {
          var clipboardData = event.clipboardData || window.clipboardData, strMime;
  
          if (!clipboardData) {
              return;
          }
          if (!clipboardData.setData) {
              return;
          }
  
          if (window.clipboardData && window.clipboardData.getData) { // IE
              strMime = 'Text';
          } else if (event.clipboardData && event.clipboardData.getData) {
              strMime = 'text/plain';
          }
  
          if (strCopyString) {
              return clipboardData.setData(strMime, strCopyString) !== false;
          } else {
              return clipboardData.getData(strMime);
          }
      }
  
      function dataTemplateRecords(element, data, intStartRecordNumber, intNumberOfRecords) {
          var tableTemplateElement = document.createElement('template'), jsnTemplate, strRet, strStart, strEnd;
  
          tableTemplateElement.innerHTML = element.tableTemplate;
  
          //strStart = '<table><tbody>';
          //strEnd = '</tbody></table>';
          //jsnTemplate = GS.templateHideSubTemplates(strStart + xtag.query(tableTemplateElement.content, 'tbody')[0].innerHTML + strEnd);
          jsnTemplate = GS.templateHideSubTemplates(xtag.query(tableTemplateElement.content, 'tbody')[0].innerHTML, true);
  
          //jsnTemplate.templateHTML = jsnTemplate.templateHTML.substring(strStart.length, jsnTemplate.templateHTML.length - strEnd.length);
          //console.log(jsnTemplate.templateHTML);
  
          strRet = GS.templateWithEnvelopeData(jsnTemplate.templateHTML, data, intStartRecordNumber, intStartRecordNumber + intNumberOfRecords);
  
          strRet = GS.templateShowSubTemplates(strRet, jsnTemplate);
  
          return strRet;
      }
  
  
  
      // ########################################################################################
      // ########################################################################################
      // ########################################################################################
      // ########################################################################################
      // ########################################################################################
      // ########################################################################################
      // ########################################################################################
      // ########################################################################################
      // ########################################################################################
  
      function getCellFromTarget(element) {
          var currentElement = element;
  
          while (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH' && currentElement.nodeName !== 'HTML') {
              currentElement = currentElement.parentNode;
          }
  
          if (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH') {
              return undefined;
          }
  
          return currentElement;
      }
  
      //function pushReplacePopHandler(element) {
      //    var i, len, arrPopKeys, bolRefresh = false, currentValue, strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
      //
      //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.value = GS.qryGetVal(strQueryString, strQSCol);
      //    }
      //
      //    if (element.hasAttribute('refresh-on-querystring-values')) {
      //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(',');
      //
      //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
      //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
      //
      //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
      //                bolRefresh = true;
      //            }
      //
      //            element.popValues[arrPopKeys[i]] = currentValue;
      //        }
      //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
      //        bolRefresh = true;
      //    }
      //
      //    if (bolRefresh) {
      //        element.refresh();
      //    }
      //}
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          i = 0;
          len = element.attributes.length;
          arrAttr = element.attributes;
          while (i < len) {
              jsnAttr = element.attributes[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var arrPopKeys;
          var currentValue;
          var bolRefresh;
          var strOperator;
  
          if (strQSCol) {
              if (strQSCol.indexOf('=') !== -1) {
                  arrAttrParts = strQSCol.split(',');
                  i = 0;
                  len = arrAttrParts.length;
                  while (i < len) {
                      strQSCol = arrAttrParts[i];
  
                      if (strQSCol.indexOf('!=') !== -1) {
                          strOperator = '!=';
                          arrQSParts = strQSCol.split('!=');
                      } else {
                          strOperator = '=';
                          arrQSParts = strQSCol.split('=');
                      }
  
                      strQSCol = arrQSParts[0];
                      strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                      // if the key is not present or we've got the negator: go to the attribute's default or remove it
                      if (strOperator === '!=') {
                          // if the key is not present: add the attribute
                          if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                              element.setAttribute(strQSAttr, '');
                          // else: remove the attribute
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      } else {
                          // if the key is not present: go to the attribute's default or remove it
                          if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                              if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                  element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                              } else {
                                  element.removeAttribute(strQSAttr);
                              }
                          // else: set attribute to exact text from QS
                          } else {
                              element.setAttribute(strQSAttr, (
                                  GS.qryGetVal(strQS, strQSCol) ||
                                  element.internal.defaultAttributes[strQSAttr] ||
                                  ''
                              ));
                          }
                      }
                      i += 1;
                  }
              } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                  strQSValue = GS.qryGetVal(strQS, strQSCol);
  
                  if (element.internal.bolQSFirstRun !== true) {
                      if (strQSValue !== '' || !element.getAttribute('value')) {
                          element.setAttribute('value', strQSValue);
                      }
                  } else {
                      element.value = strQSValue;
                  }
              }
          }
  
          // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
          if (element.internal.bolQSFirstRun === true) {
              if (element.hasAttribute('refresh-on-querystring-values')) {
                  arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
  
                  for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                      currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);
  
                      if (element.popValues[arrPopKeys[i]] !== currentValue) {
                          bolRefresh = true;
                      }
  
                      element.popValues[arrPopKeys[i]] = currentValue;
                  }
              } else if (element.hasAttribute('refresh-on-querystring-change')) {
                  bolRefresh = true;
              }
  
              if (bolRefresh && element.hasAttribute('src')) {
                  console.log('pushReplacePopHandler: getData', element);
                  getData(element);
              } else if (bolRefresh && !element.hasAttribute('src')) {
                  console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
              }
          } else {
              if (element.hasAttribute('refresh-on-querystring-values')) {
                  arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
  
                  for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                      element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                  }
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
  
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
  
          }
      }
  
      //
      function elementInserted(element) {
          var hudTemplateElement, tableTemplateElement, tableTemplateElementCopy, insertTemplateElement,
              recordElement, divElement, oldRootElement, i, len, arrElement, arrColumnElement, arrTemplates, arrWhereColumns,
              strQueryString = GS.getQueryString(), currentElement, strQSValue;
  
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
  
                  GS.addBeforeUnloadEvent(function () {
                      document.activeElement.blur();
                  });
  
                  // handle "qs" attribute
                  if (element.getAttribute('qs') ||
                          element.getAttribute('refresh-on-querystring-values') ||
                          element.hasAttribute('refresh-on-querystring-change')) {
                      element.popValues = {};
                      //strQSValue = GS.qryGetVal(strQueryString, element.getAttribute('qs'));
                      //
                      //if (strQSValue !== '' || !element.getAttribute('value')) {
                      //    element.setAttribute('value', strQSValue);
                      //}
                      pushReplacePopHandler(element);
                      window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                      window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                      window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                  }
  
                  // primary keys attribute and defaulting
                  if (element.getAttribute('primary-keys')) {
                      arrWhereColumns = element.getAttribute('primary-keys').split(/\s*,\s*/gim);
                      if (arrWhereColumns.length === 0) {
                          arrWhereColumns = ['id', 'change_stamp'];
                      }
                  } else {
                      arrWhereColumns = ['id', 'change_stamp'];
                  }
                  element.arrWhereColumns = arrWhereColumns;
  
                  // set user order bys to default to empty
                  element.user_order_bys = {
                      'columns': [],
                      'directions': []
                  };
  
                  // if there is an old root element: delete it
                  oldRootElement = xtag.queryChildren(element, '.root');
  
                  if (oldRootElement.length > 0) {
                      for (i = 0, len = oldRootElement.length; i < len; i += 1) {
                          element.removeChild(oldRootElement[i]);
                      }
                  }
  
                  // selecting for template elements
                  hudTemplateElement    = xtag.queryChildren(element, 'template[for="hud"]')[0];
                  tableTemplateElement  = xtag.queryChildren(element, 'template[for="table"]' + (element.hasAttribute('template') ? '[id="' + element.getAttribute('template') + '"': ''))[0];
                  if (!tableTemplateElement && element.hasAttribute('template')) {
                      console.warn('ENVELOPE WARNING: Hey! You used the name of a non-existant record template!');
                      tableTemplateElement  = xtag.queryChildren(element, 'template[for="table"]')[0];
                  }
                  insertTemplateElement = xtag.queryChildren(element, 'template[for="insert"]')[0];
                  
                  if (
                      hudTemplateElement &&
                      (
                          hudTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                          hudTemplateElement.innerHTML.indexOf('&lt;') > -1
                      )
                  ) {
                      console.warn('GS-ENVELOPE WARNING: &gt; or &lt; detected in HUD template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                  }
                  if (
                      tableTemplateElement &&
                      (
                          tableTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                          tableTemplateElement.innerHTML.indexOf('&lt;') > -1
                      )
                  ) {
                      console.warn('GS-ENVELOPE WARNING: &gt; or &lt; detected in table template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                  }
                  if (
                      insertTemplateElement &&
                      (
                          insertTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                          insertTemplateElement.innerHTML.indexOf('&lt;') > -1
                      )
                  ) {
                      console.warn('GS-ENVELOPE WARNING: &gt; or &lt; detected in insert template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                  }
  
                  element.templates = {};
                  xtag.queryChildren(element, 'template[for="table"]').forEach(function (cur, i) {
                      if (i === 0) {
                          element.templates['default'] = cur;
                      }
                      if (cur.hasAttribute('id')) {
                          element.templates[cur.getAttribute('id')] = cur;
                      }
                  });
  
                  // checking/saving template elements
                  if (hudTemplateElement) {
                      element.hudTemplate = hudTemplateElement.innerHTML;
                  }
  
                  if (tableTemplateElement) {
                      tableTemplateElementCopy = document.createElement('template');
                      tableTemplateElementCopy.innerHTML = tableTemplateElement.innerHTML;
  
                      recordElement = xtag.query(xtag.query(tableTemplateElementCopy.content, 'tbody')[0], 'tr')[0];
  
                      if (recordElement) {
                          // add a data- attribute for all where columns (most of the time: id and change_stamp)
                          for (i = 0, len = element.arrWhereColumns.length; i < len; i += 1) {
                              recordElement.setAttribute('data-' + element.arrWhereColumns[i], '{{! row.' + element.arrWhereColumns[i] + ' }}');
                          }
  
                          // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                          element.tableTemplate = GS.templateColumnToValue(tableTemplateElementCopy.innerHTML);
                      }
                  } else {
                      throw 'Envelope error: table template is required.';
                  }
                  if (insertTemplateElement) {
                      element.insertTemplate = insertTemplateElement.innerHTML;
                  }
  
                  // clear element content
                  element.innerHTML = '';
  
                  // creating/setting root
                  divElement = document.createElement('div');
                  divElement.classList.add('root');
                  divElement.setAttribute('flex-fill', '');
                  divElement.setAttribute('flex-vertical', '');
                  divElement.setAttribute('gs-dynamic', '');
  
                  element.appendChild(divElement);
                  element.root = divElement;
  
                  // filling root with containers
                  element.root.innerHTML = '<div class="hud-container-top" gs-dynamic></div>' +
                                           '<div class="fixed-header-container" gs-dynamic></div>' +
                                           '<div class="scroll-container" flex gs-dynamic></div>' +
                                           '<div class="hud-container-bottom" flex-horizontal gs-dynamic></div>' +
                                           '<input class="gs-envelope-copy-focus-target" value="Firefox compatibility input" gs-dynamic />';
  
                  element.hudTopElement =                 xtag.queryChildren(element.root, '.hud-container-top')[0];
                  element.fixedHeaderContainerElement =   xtag.queryChildren(element.root, '.fixed-header-container')[0];
                  element.scrollContainerElement =        xtag.queryChildren(element.root, '.scroll-container')[0];
                  element.hudBottomElement =              xtag.queryChildren(element.root, '.hud-container-bottom')[0];
                  element.copyFocusTargetElement =        xtag.queryChildren(element.root, '.gs-envelope-copy-focus-target')[0];
  
                  element.scrollContainerElement.setAttribute('allow-text-selection', '');
  
                  ////REFPOINT
                  //element.addEventListener('focus', function (event) {
                  //    //console.log(document.activeElement, element, event.target, element.copyFocusTargetElement);
                  //    if (document.activeElement === element) { // event.target
                  //        element.copyFocusTargetElement.focus();
                  //        GS.setInputSelection(element.copyFocusTargetElement, 0, 'firefox...'.length);
                  //    }
                  //});
  
                  // binding events
                  element.scrollContainerElement.addEventListener('change', function (event) {
                      var newValue, parentTr;
  
                      if (event.target.getAttribute('column')) {
                          if (event.target.value !== null) {
                              newValue = event.target.value;
                          } else {
                              newValue = event.target.checked;
                          }
  
                          parentTr = GS.findParentTag(event.target, 'tr');
  
                          // if the control is a direct child of this envelope (fixes sub envelope update)
                          if (
                              parentTr.parentNode.parentNode.parentNode === element.scrollContainerElement &&
                              !element.hasAttribute('no-update')
                          ) {
                              updateRecord(element, parentTr, event.target.getAttribute('column'), newValue);
                          }
                      }
                  });
  
                  // META-SHIFT-CLICK
                  if (!evt.touchDevice) {
                      element.addEventListener('click', function (event) {
                          var templateElement;
  
                          if (event.metaKey && event.shiftKey) {
                              templateElement = document.createElement('template');
  
  
                              var strOrderBy = '', strRelWhere = '', strElemWhere, strWhereColumn, strUserOrderBy = '', strLimit, strOffset,
                                  strSource = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') || '')),
                                  strCols = GS.templateWithQuerystring(element.getAttribute('cols') || ''), strElemOrderBy;
  
                              // if there is a column attribute on element element: combine the where attribute with a where generated by value
                              if ((element.getAttribute('column') || element.getAttribute('qs')) && element.value) {
                                  strWhereColumn = element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs');
  
                                  if (isNaN(element.value)) {
                                      strRelWhere =
                                          'CAST(' + strWhereColumn + ' AS ' + GS.database.type.text + ') = ' +
                                          'CAST($WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')';
                                  } else {
                                      strRelWhere = strWhereColumn + '=' + (element.value);
                                  }
                              }
  
                              strElemWhere = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('where') || ''));
                              strLimit = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('limit') || ''));
                              strOffset = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('offset') || ''));
  
                              // if the user has set an order by: use the user order bys
                              if (element.user_order_bys && element.user_order_bys.columns.length > 0) {
                                  for (i = 0, len = element.user_order_bys.columns.length, strUserOrderBy; i < len; i += 1) {
                                      strUserOrderBy += (strUserOrderBy !== '' ? ', ' : '') + element.user_order_bys.columns[i] + ' ' + element.user_order_bys.directions[i].toUpperCase();
                                  }
                              }
  
                              strElemOrderBy = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('ord') || ''));
  
  
                              templateElement.innerHTML = ml(function () {/*
                                  <gs-page>
                                      <gs-header><h3>GS-Envelope Details</h3></gs-header>
                                      <gs-body padded>
                                          <b>Source: </b>{{SOURCE}}<br />
                                          <b>Columns: </b>{{COLS}}<br />
                                          <b>Element Where: </b>{{ELEMWHERE}}<br />
                                          <b>Relationship Where: </b>{{RELWHERE}}<br />
                                          <b>Limit: </b>{{LIMIT}}<br />
                                          <b>Offset: </b>{{OFFSET}}<br />
                                          <b>Element Order By: </b>{{ELEMORD}}<br />
                                          <b>User Order By: </b>{{USERORD}}
                                      </gs-body>
                                      <gs-footer>
                                          <gs-button dialogclose>Done</gs-button>
                                      </gs-footer>
                                  </gs-page>
                              */}).replace(/\{\{SOURCE\}\}/gi, strSource)
                                  .replace(/\{\{COLS\}\}/gi, strCols)
                                  .replace(/\{\{ELEMWHERE\}\}/gi, strElemWhere)
                                  .replace(/\{\{RELWHERE\}\}/gi, strRelWhere)
                                  .replace(/\{\{LIMIT\}\}/gi, strLimit)
                                  .replace(/\{\{OFFSET\}\}/gi, strOffset)
                                  .replace(/\{\{ELEMORD\}\}/gi, strElemOrderBy)
                                  .replace(/\{\{USERORD\}\}/gi, strUserOrderBy);
  
                              GS.openDialog(templateElement);
                          }
                      });
                  }
  
                  // if we are not on a touch device: cell by cell selection
                  if (!evt.touchDevice) {
                      // mousedown (on selected and unselected) + drag
                      //      clear previous selection(s)
                      //      select cells from origin cell to current cell
                      //
                      // shift + mousedown (on selected and unselected) + drag
                      //      alter previous selection
                      //      select cells from previous origin cell to current cell
                      //
                      // command + mousedown (on unselected) + drag
                      //      maintain previous selection(s)
                      //      select cells from origin cell to current cell
                      //
                      // command + mousedown (on selected) + drag
                      //      maintain previous selection(s)
                      //      deselect cells from origin cell to current cell
                      //
                      // collision handling
                      //      when colliding with previous selections: dont treat them different
                      //
                      // copy handling
                      //      selection ("X" marks selected cells (imagine all cells contain the letter "a")):
                      //          1  2  3  4  5
                      //          -------------
                      //          a  a  a  a  a
                      //          a  X  X  a  a
                      //          a  a  X  X  a
                      //          a  a  a  a  a
                      //
                      //      yields ("'" marks an empty cell):
                      //          2  3  4
                      //          --------
                      //          a  a  '
                      //          '  a  a
  
                      element.addEventListener(evt.mousedown, function (event) {
                          var target = event.target, cellFromTarget = getCellFromTarget(target), closestCell, arrSelectedCells, i, len;
  
                          if (GS.findParentTag(event.target, 'table') || target.classList.contains('fixed-header-cell')) {
                              if (cellFromTarget) {
                                  closestCell = cellFromTarget;
                              } else if (target.classList.contains('fixed-header-cell')) {
                                  closestCell = element.theadElement.children[0].children[xtag.toArray(target.parentNode.children).indexOf(target)];
                              }
  
                              if (closestCell) {
                                  element.dragAllowed = true;
                                  element.dragCurrentCell = closestCell;
                                  element.selectionSelectedCells = [];
  
                                  // if shift is down and there is a previous origin: use previous origin for current origin
                                  if (event.shiftKey && element.selectionPreviousOrigin) {
  
                                      // if there are previously selected cells: deselect the previous selected cells
                                      if (element.selectionPreviousSelectedCells) {
                                          arrSelectedCells = element.selectedCells;
  
                                          for (i = 0, len = element.selectionPreviousSelectedCells.length; i < len; i += 1) {
                                              arrSelectedCells.splice(arrSelectedCells.indexOf(element.selectionPreviousSelectedCells[i]), 1);
                                          }
  
                                          element.selectedCells = arrSelectedCells;
                                      }
  
                                      element.dragOrigin = element.selectionPreviousOrigin;
                                      element.dragMode = 'select';
  
                                  // else if ctrl or cmd is down and the target cell is not selected: select cells from target cell to current cell
                                  } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && !closestCell.hasAttribute('selected')) {
                                      element.dragOrigin = closestCell;
                                      element.dragMode = 'select';
  
                                  // else if ctrl or cmd is down and the target cell is selected: deselect cells from target cell to current cell
                                  } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && closestCell.hasAttribute('selected')) {
                                      element.dragOrigin = closestCell;
                                      element.dragMode = 'deselect';
  
                                  // else: deselect all cells and start new selection
                                  } else {
                                      element.selectedCells = [];
                                      element.dragOrigin = closestCell;
                                      element.dragMode = 'select';
                                  }
  
                                  selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                              }
                          }
                      });
                      element.addEventListener(evt.mousemove, function (event) {
                          var target, closestCell, cellFromTarget;
  
                          // if mouse is down
                          if (event.which !== 0) {
                              target = event.target;
                              cellFromTarget = getCellFromTarget(target);
  
                              if (cellFromTarget) {
                                  closestCell = cellFromTarget;
                              } else if (target.classList.contains('fixed-header-cell')) {
                                  closestCell =
                                      element.theadElement.children[0].children[xtag.toArray(target.parentNode.children).indexOf(target)];
                              }
  
                              // if selection is allowed at this point and closestCell is different from element.dragCurrentCell
                              if (closestCell && element.dragAllowed && element.dragCurrentCell !== closestCell) {
                                  element.dragCurrentCell = getCellFromTarget(closestCell);
                                  selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                              }
                          } else {
                              element.dragAllowed = false;
                              element.selectionPreviousOrigin = element.dragOrigin;
                              element.selectionPreviousSelectedCells = element.selectionSelectedCells;
                          }
                      });
                      element.addEventListener(evt.mouseup, function (event) {
                          element.dragAllowed = false;
  
                          if (element.dragMode === 'select') {
                              element.selectionPreviousOrigin = element.dragOrigin;
                              element.selectionPreviousSelectedCells = element.selectionSelectedCells;
                          }
                      });
  
                  // else we are on a touch device: record selection
                  } else {
                      element.root.addEventListener(evt.mousedown, function (event) {
                          if (event.target.nodeName === 'TD' || event.target.nodeName === 'TH' || getCellFromTarget(event.target)) {
                              element.selectedCells = [];
  
                              // if there is a parent record to the target: select all of the cells in the record
                              if (GS.findParentTag(event.target, 'tr')) {
                                  element.selectedCells = GS.findParentTag(event.target, 'tr').children;
                              }
                          }
                      });
                  }
  
                  window.addEventListener('resize', function () {
                      element.refreshFixedHeader();
                      element.refreshHeight();
                      element.refreshReflow();
                  });
                  window.addEventListener('orientationchange', function () {
                      element.refreshFixedHeader();
                      element.refreshHeight();
                      element.refreshReflow();
                  });
                  element.addEventListener('size-changed', function (event) {
                      element.refreshFixedHeader();
                      element.refreshHeight();
                      //element.refreshReflow();
                  });
  
                  // key navigation
                  element.addEventListener('keydown', function (event) {
                      var target = event.target, intKeyCode = event.which || event.keyCode, jsnSelection, bolCursorElement, i, len,
                          focusElement, tbodyElement, recordElement, cellElement, cellElements, tempElement;
  
                      if (target !== element) {
                          bolCursorElement = target.nodeName === 'INPUT' || target.nodeName === 'TEXTAREA';
  
                          if (bolCursorElement) {
                              jsnSelection = GS.getInputSelection(target);
                          } else {
                              jsnSelection = {};
                          }
  
                          // up arrow
                          if (intKeyCode === 38) {
                              //console.log('if there is a record before this one: focus the same column in the previous record');
  
                              cellElement = getCellFromTarget(target);
                              recordElement = cellElement.parentNode;
                              tbodyElement = recordElement.parentNode;
  
                              if (recordElement.rowIndex > 1) { // recordIndex > 0
                                  recordElement = tbodyElement.children[recordElement.rowIndex - 2];
  
                                  focusElement = xtag.query(recordElement.children[cellElement.cellIndex], '[column]')[0];
                              }
  
                          // down arrow
                          } else if (intKeyCode === 40) {
                              //console.log('if there is another record after this one: focus the same column in the next record');
  
                              cellElement = getCellFromTarget(target);
                              recordElement = cellElement.parentNode;
                              tbodyElement = recordElement.parentNode;
  
                              if (recordElement.rowIndex < tbodyElement.children.length) {
                                  recordElement = tbodyElement.children[recordElement.rowIndex];
  
                                  //focusElement = recordElement.children[cellElement.cellIndex].children[0];
                                  focusElement = xtag.query(recordElement.children[cellElement.cellIndex], '[column]')[0];
                              }
  
                          // if left or right arrow
                          } else if (intKeyCode === 37 || intKeyCode === 39) {
                              // left arrow and (at the beginning of the target OR target has no selected)
                              if (intKeyCode === 37 && (bolCursorElement === false || jsnSelection.start === 0)) {
                                  //console.log('previous control if possible');
  
                                  cellElement = getCellFromTarget(target);
                                  recordElement = cellElement.parentNode;
                                  tbodyElement = recordElement.parentNode;
  
                                  cellElements = xtag.query(tbodyElement, 'tr > td, tr > th');
  
                                  // loop through previous cells looking for something focusable
                                  for (i = cellElements.indexOf(cellElement) - 1; i > -1; i -= 1) {
                                      //console.log(i);
  
                                      tempElement = xtag.query(cellElements[i], '[column]')[0];
  
                                      if (tempElement && GS.isElementFocusable(tempElement)) { // tempElement.control
                                          focusElement = tempElement; // tempElement.control
  
                                          break;
                                      }
                                  }
  
                              // right arrow and (at the end of the target OR target has no selected)
                              } else if (intKeyCode === 39 && (bolCursorElement === false || jsnSelection.end === target.value.length)) {
                                  cellElement = getCellFromTarget(target);
                                  recordElement = cellElement.parentNode;
                                  tbodyElement = recordElement.parentNode;
  
                                  cellElements = xtag.query(tbodyElement, 'tr > td, tr > th');
  
                                  // loop through previous cells looking for something focusable
                                  for (i = cellElements.indexOf(cellElement) + 1, len = cellElements.length; i < len; i += 1) { // - 1
                                      tempElement = xtag.query(cellElements[i], '[column]')[0];
  
                                      if (tempElement && GS.isElementFocusable(tempElement)) { // tempElement.control
                                          focusElement = tempElement; // tempElement.control
  
                                          break;
                                      }
                                  }
                              }
                          }
  
                          if (focusElement && GS.isElementFocusable(focusElement)) {
                              event.preventDefault();
  
                              focusElement.focus();
  
                              if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                                  GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
                              }
  
                              element.selectedRecords = GS.findParentTag(focusElement, 'TR');
                          }
                      }
                  });
  
                  // copy event
                  element.tabIndex = 0;
                  document.body.addEventListener('copy', function (event) {//console.log('test');
                      var elementClosestEnvelope = GS.findParentTag(document.activeElement, 'gs-envelope'), strCopyString,
                          i, len, cell_i, cell_len, arrSelected, intFromRecord = 9999999, intFromCell = 9999999, intToRecord = 0, intToCell = 0,
                          strCellText, arrRecords, arrCells, strRecordString;
  
                      if (elementClosestEnvelope === element &&
                          (
                              document.activeElement.classList.contains('gs-envelope-copy-focus-target') ||
                              document.activeElement.selectionStart === document.activeElement.selectionEnd
                          )) {
                          arrSelected = element.selectedCells;
  
                          // loop through the selected cells and create a tsv string using the text of the cell
                          if (arrSelected.length > 0) {
                              for (i = 0, len = arrSelected.length; i < len; i += 1) {
                                  if (arrSelected[i].parentNode.rowIndex < intFromRecord) {
                                      intFromRecord = arrSelected[i].parentNode.rowIndex;
                                  }
                                  if (arrSelected[i].cellIndex < intFromCell) {
                                      intFromCell = arrSelected[i].cellIndex;
                                  }
                                  if (arrSelected[i].parentNode.rowIndex + 1 > intToRecord) {
                                      intToRecord = arrSelected[i].parentNode.rowIndex + 1;
                                  }
                                  if (arrSelected[i].cellIndex + 1 > intToCell) {
                                      intToCell = arrSelected[i].cellIndex + 1;
                                  }
                              }
  
                              arrRecords = xtag.query(element.scrollContainerElement, 'tr');
                              strCopyString = '';
  
                              for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                                  arrCells = arrRecords[i].children;
  
                                  for (cell_i = intFromCell, cell_len = intToCell, strRecordString = ''; cell_i < cell_len; cell_i += 1) {
                                      if (arrCells[cell_i].hasAttribute('selected')) {
                                          if (arrCells[cell_i].lastElementChild) {
                                              strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                                            arrCells[cell_i].lastElementChild.value ||
                                                            (arrCells[cell_i].lastElementChild.checked || '').toString();
                                          } else {
                                              strCellText = arrCells[cell_i].textContent.trim();
                                          }
                                      } else {
                                          strCellText = '';
                                      }
  
                                      strRecordString += (cell_i !== intFromCell ? '\t' : '') + (strCellText || '');
                                  }
                                  if (strRecordString.trim()) {
                                      strCopyString += strRecordString;
                                  }
                                  if (i + 1 !== len && strRecordString.trim()) {
                                      strCopyString += '\n';
                                  }
                              }
                          }
  
                          if (strCopyString) {
                              if (handleClipboardData(event, strCopyString)) {
                                  event.preventDefault(event);
                              }
                          }
                      }
                  });
  
                  // getData
                  refreshHud(element);
                  getData(element);
              }
          }
      }
  
      xtag.register('gs-envelope', {
          lifecycle: {
              created: function () {
                  //console.log(this.outerHTML);
                  elementCreated(this);
              },
  
              inserted: function () {
                  elementInserted(this);
              },
  
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
  
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
  
                  } else if (strAttrName === 'template') {
                      var tableTemplateElement, tableTemplateElementCopy, recordElement, element = this, i, len;
                      tableTemplateElement  = element.templates[element.getAttribute('template') || 'default'];
                      //console.log(tableTemplateElement);
                      if (!tableTemplateElement && element.hasAttribute('template')) {
                          console.warn('ENVELOPE WARNING: Hey! You used the name of a non-existant record template!');
                          tableTemplateElement = element.templates['default'];
                      }
                      //console.log(tableTemplateElement);
  
                      if (tableTemplateElement) {
                          //console.log(tableTemplateElement);
                          tableTemplateElementCopy = document.createElement('template');
                          tableTemplateElementCopy.innerHTML = tableTemplateElement.innerHTML;
  
                          recordElement = xtag.query(xtag.query(tableTemplateElementCopy.content, 'tbody')[0], 'tr')[0];
  
                          if (recordElement) {
                              // add a data- attribute for all where columns (most of the time: id and change_stamp)
                              for (i = 0, len = element.arrWhereColumns.length; i < len; i += 1) {
                                  recordElement.setAttribute('data-' + element.arrWhereColumns[i], '{{! row.' + element.arrWhereColumns[i] + ' }}');
                              }
  
                              // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                              element.tableTemplate = GS.templateColumnToValue(tableTemplateElementCopy.innerHTML);
                          }
                      } else {
                          throw 'Envelope error: table template is required.';
                      }
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      if (strAttrName === 'no-hudlimit' ||
                          strAttrName === 'no-hudorderby' ||
                          strAttrName === 'no-huddelete' ||
                          strAttrName === 'no-hudrefresh') {
                          refreshHud(this);
  
                      // this.root is here becuase of an issue where refresh was called before the envelope was initialized
                      } else if (strAttrName === 'value' && this.root) {
                          this.refresh();
                      }
                  }
              }
          },
          events: {},
          accessors: {
              value: {
                  get: function () {
                      return this.getAttribute('value');
                  },
  
                  set: function (newValue) {
                      this.setAttribute('value', newValue);
                      getData(this);
                  }
              },
              selectedCells: {
                  get: function () {
                      return xtag.query(this.scrollContainerElement, '[selected]');
                  },
  
                  set: function (newValue) {
                      var i, len, intIdIndex, arrCells = xtag.query(this.scrollContainerElement, '[selected]'), arrRecords, cell_i, cell_len,
                          fixedHeaderCells = xtag.queryChildren(this.fixedHeaderContainerElement, '.fixed-header-cell');
  
                      //console.log(arrRecords);
  
                      // clear old selection
                      for (i = 0, len = fixedHeaderCells.length; i < len; i += 1) {
                          fixedHeaderCells[i].removeAttribute('selected');
                      }
                      for (i = 0, len = arrCells.length; i < len; i += 1) {
                          arrCells[i].removeAttribute('selected');
                      }
  
                      arrCells = xtag.query(this.scrollContainerElement, '[selected-secondary]');
                      for (i = 0, len = arrCells.length; i < len; i += 1) {
                          arrCells[i].removeAttribute('selected-secondary');
                      }
  
                      // if newValue is not an array: make it an array
                      if (typeof newValue === 'object' && newValue.length === undefined) {
                          arrCells = [newValue];
                      } else {
                          arrCells = newValue;
                      }
  
                      // set new selection
                      for (i = 0, len = arrCells.length; i < len; i += 1) {
                          arrCells[i].setAttribute('selected', '');
  
                          if (arrCells[i].parentNode.parentNode.nodeName === 'THEAD') {
                              fixedHeaderCells[arrCells[i].cellIndex].setAttribute('selected', '');
                          }
                      }
  
                      arrRecords = this.selectedRecords;
  
                      for (i = 0, len = arrRecords.length; i < len; i += 1) {
                          arrCells = arrRecords[i].children;
  
                          for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                              if (!arrCells[cell_i].hasAttribute('selected')) {
                                  arrCells[cell_i].setAttribute('selected-secondary', '');
                              }
                          }
                      }
  
                      GS.triggerEvent(this, 'after_selection');
                  }
              },
              selectedRecords: {
                  get: function () {
                      var i, len, intRecordIndex = -1, arrRecord = [], selected = this.selectedCells;
  
                      // loop through the selected cells and create an array of trs
                      for (i = 0, len = selected.length; i < len; i += 1) {
                          if (selected[i].parentNode.rowIndex > intRecordIndex && selected[i].parentNode.parentNode.nodeName !== 'THEAD') {
                              intRecordIndex = selected[i].parentNode.rowIndex;
  
                              arrRecord.push(selected[i].parentNode);
                          }
                      }
  
                      return arrRecord;
                  },
  
                  set: function (newValue) {
                      var i, len, cell_i, cell_len, intIdIndex, arrCells = this.selectedCells, arrRecords, arrCellChildren,
                          fixedHeaderCells = xtag.queryChildren(this.fixedHeaderContainerElement, '.fixed-header-cell');
  
                      // clear old selection
                      for (i = 0, len = arrCells.length; i < len; i += 1) {
                          arrCells[i].removeAttribute('selected');
  
                          if (arrCells[i].parentNode.parentNode.nodeName === 'THEAD') {
                              fixedHeaderCells[arrCells[i].cellIndex].removeAttribute('selected', '');
                          }
                      }
  
                      arrCells = xtag.query(this.scrollContainerElement, '[selected-secondary]');
                      for (i = 0, len = arrCells.length; i < len; i += 1) {
                          arrCells[i].removeAttribute('selected-secondary');
                      }
  
                      // if newValue is not an array: make it an array
                      if (typeof newValue === 'object' && newValue.length === undefined) {
                          arrRecords = [newValue];
                      } else {
                          arrRecords = newValue;
                      }
  
                      // set new selection
                      for (i = 0, len = arrRecords.length, arrCells = []; i < len; i += 1) {
                          arrCellChildren = arrRecords[i].children;
  
                          for (cell_i = 0, cell_len = arrCellChildren.length; cell_i < cell_len; cell_i += 1) {
                              arrCells.push(arrCellChildren[cell_i]);
                          }
                      }
  
                      this.selectedCells = arrCells;
  
                      GS.triggerEvent(this, 'after_selection');
                  }
              },
              selectedIds: {
                  get: function () {
                      var i, len, arrID = [], selected = this.selectedRecords;
  
                      // loop through the selected records and create an array of ids
                      for (i = 0, len = selected.length; i < len; i += 1) {
                          arrID.push(String(selected[i].dataset.id));
                          //arrID.push(String(selected[i].parentNode.dataset.id));
                      }
  
                      return arrID;
                  },
  
                  set: function (newValue) {
                      var i, len, cell_i, cell_len, arrCells = this.selectedCells, // intIdIndex,
                          arrRecords = xtag.query(this.scrollContainerElement, 'tbody > tr');
  
                      //console.log(arrRecords);
  
                      // clear old selection
                      for (i = 0, len = arrCells.length; i < len; i += 1) {
                          arrCells[i].removeAttribute('selected');
                      }
  
                      arrCells = xtag.query(this.scrollContainerElement, '[selected-secondary]');
                      for (i = 0, len = arrCells.length; i < len; i += 1) {
                          arrCells[i].removeAttribute('selected-secondary');
                      }
  
                      // if newValue is not an array: make it an array
                      if (typeof newValue !== 'object') {
                          newValue = [String(newValue)];
  
                      // else: cast all new values to strings
                      } else {
                          for (i = 0, len = newValue.length; i < len; i += 1) {
                              newValue[i] = String(newValue[i]);
                          }
                      }
  
                      // set new selection
                      for (i = 0, len = arrRecords.length; i < len; i += 1) {
  
                          if (newValue.indexOf(arrRecords[i].getAttribute('data-id')) > -1) {//String(.dataset.id) === String()
                              arrCells = arrRecords[i].children;
  
                              for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                                  arrCells[cell_i].setAttribute('selected', '');
                              }
                          }
                      }
  
                      GS.triggerEvent(this, 'after_selection');
                  }
              }
          },
          methods: {
              // just a semantic alias to the getData function
              refresh: function () {
                  getData(this);
              },
  
              refreshReflow: function () {
                  var intEnvelopeWidth = this.scrollContainerElement.clientWidth + 1,
                      bolCurrentlyReflowed,
                      intWindowWidth = window.innerWidth,
                      intReflowAt = parseInt(this.getAttribute('reflow-at'), 10);
  
                  if (this.reflowBreakPoint === undefined) {
                      this.reflowBreakPoint = 0;
                  }
  
                  //console.log('check for reflow', window.innerWidth, this.reflowBreakPoint,
                  // this.scrollContainerElement.clientWidth < this.scrollContainerElement.scrollWidth);
  
                  bolCurrentlyReflowed = this.classList.contains('reflow');
                  this.classList.remove('reflow');
  
                  //console.log(intEnvelopeWidth, this.scrollContainerElement.scrollWidth);
                  //console.log('envWidth    ', intEnvelopeWidth);
                  //console.log('scrollWidth ', this.scrollContainerElement.scrollWidth);
                  //console.log('reflowAt    ', this.hasAttribute('reflow-at'));
                  //console.log('intReflowAt ', intReflowAt);
  
                  //if (intWindowWidth > this.reflowBreakPoint) {
                  if ((
                          intEnvelopeWidth < this.scrollContainerElement.scrollWidth &&
                          !this.hasAttribute('reflow-at')
                      ) ||
                      (
                          !isNaN(intReflowAt) &&
                          intEnvelopeWidth < intReflowAt
                      )) {
                      if (!bolCurrentlyReflowed) {
                          this.selectedCells = [];
                      }
  
                      this.reflowBreakPoint = intWindowWidth;
                      this.classList.add('reflow');
  
                  } else {
                      if (bolCurrentlyReflowed) {
                          this.selectedCells = [];
                      }
  
                      this.reflowBreakPoint = 0;
                      this.classList.remove('reflow');
                  }
              },
  
              refreshFixedHeader: function () {
                  var elementFixedHeaderCells = xtag.queryChildren(this.fixedHeaderContainerElement, '.fixed-header-cell'),
                      theadCellElements, i, len, intLeft;
  
                  if (this.theadElement && GS.getStyle(this.theadElement, 'display') !== 'none') {
                      //Why isn't this after we set the widths of the fixed header? -Joseph 10-01-15
                      this.fixedHeaderContainerElement.removeAttribute('hidden');
                      theadCellElements = xtag.query(this.theadElement, 'th, td');
  
                      for (i = 0, len = theadCellElements.length, intLeft = 0; i < len; i += 1) {
                          elementFixedHeaderCells[i].style.height = (theadCellElements[i].offsetHeight + 1) + 'px';
                          elementFixedHeaderCells[i].style.width = theadCellElements[i].offsetWidth + 'px';
                          elementFixedHeaderCells[i].style.left = (intLeft - this.scrollContainerElement.scrollLeft) + 'px';
  
                          intLeft += theadCellElements[i].offsetWidth;
                      }
                  } else {
                      this.fixedHeaderContainerElement.setAttribute('hidden', '');
                  }
              },
  
              refreshHeight: function () {
                  var intHeight = 0;
  
                  //console.log('1*** refreshHeight');
  
                  // if this envelope is zero height: add expand to content automatically
                  if (this.clientHeight === 0) {
                      this.setAttribute('expand-to-content', '');
                  }
  
                  //console.log('1-1*', this);
                  //console.log('1-2*', this.hasAttribute('expand-to-content'));
                  if (this.hasAttribute('expand-to-content')) {
                      //console.log('2***');
                      this.style.height = '';
  
                      intHeight += this.hudTopElement.scrollHeight;
                      //console.log('3***');
                      //intHeight += this.fixedHeaderContainerElement.scrollHeight;
                      intHeight += this.scrollContainerElement.scrollHeight;
                      intHeight += this.hudBottomElement.scrollHeight;
                      //console.log('4***', intHeight);
  
                      this.style.height = (intHeight + 5) + 'px'; // used to add 2
                      //console.log('5***', this.style.height);
                  }
              }
          }
      });
  });//jslint white:true, multivar:true
  
  
  window.addEventListener('design-register-element', function () {
      window.designElementProperty_GSFOLDER = function(selectedElement) {
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
          
          addProp('Path', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('path') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'path', this.value);
          });
          
          addProp('Hide Folders', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-folders')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-folders', (this.value === 'true'), true);
          });
          
          addProp('Hide Files', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-files')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-files', (this.value === 'true'), true);
          });
          
          addProp('Side-By-Side', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('horizontal')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'horizontal', (this.value === 'true'), true);
          });
          
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
          
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', (this.value === 'true'), true);
          });
      };
      
      registerDesignSnippet('<gs-folder>', '<gs-folder>', 'gs-folder path="${0:/}" folder="${1:role}"></gs-folder>');
      
      designRegisterElement('gs-folder', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-folder.html');
  });
  
  (function () {
      'use strict';
      
      // #################################################################################################
      // ############################################ UTILITY ############################################
      // #################################################################################################
      
      function getPath(element) {
          var strAttributePath = GS.trim(GS.templateWithQuerystring(element.getAttribute('path') || ''), '/')
            , strInnerPath = element.arrPath.join('/'), strRet;
          
          if (strAttributePath && strInnerPath) {
              strRet = '/' + strAttributePath + '/' + strInnerPath + '/';
          } else if (strAttributePath) {
              strRet = '/' + strAttributePath + '/';
          } else if (strInnerPath) {
              strRet = '/' + strInnerPath + '/';
          }
          
          return strRet || '/';
      }
      
      function getRealPath(element) {
          var strAttributePath = GS.trim(GS.templateWithQuerystring(element.getAttribute('path') || ''), '/')
            , arrPath = element.arrPath, strInnerPath, strRet, strPrefix;
          
          if (element.arrPath[0] === 'app' || strAttributePath.indexOf('app') === 0) {
              strPrefix = '/env';
          } else if (element.arrPath[0] === 'role' || strAttributePath.indexOf('role') === 0) {
              strPrefix = '/env';
          } else if (element.arrPath[0] === 'web_root' || strAttributePath.indexOf('web_root') === 0) {
              strPrefix = '';
              arrPath.splice(0, 1);
          }
          
          strInnerPath = arrPath.join('/');
          
          if (strAttributePath && strInnerPath) {
              strRet = '/' + strAttributePath + '/' + strInnerPath + '/';
          } else if (strAttributePath) {
              strRet = '/' + strAttributePath + '/';
          } else if (strInnerPath) {
              strRet = '/' + strInnerPath + '/';
          }
          
          return (strPrefix || '') + (strRet || '/');
      }
      
      function getData(element) {
          var strPath = getPath(element)
            , bolFolders = !element.hasAttribute('no-folders')
            , bolFiles = !element.hasAttribute('no-files')
            , strHeader
            , intResponseNumber;
          
          element.folderList.innerHTML = '';
          element.fileList.innerHTML = '';
          
          strHeader = GS.trim('/' + element.arrPath.join('/'), '/');
          
          // if there is something in the header: wrap it with slashes
          if (strHeader) {
              strHeader = '/' + strHeader + '/';
          }
          
          element.pathTitle.textContent = strHeader;
          
          if (element.arrPath.length > 0) {
              element.backButton.removeAttribute('disabled');
          } else {
              element.backButton.setAttribute('disabled', '');
          }
          element.arrFile = [];
          element.arrFolder = [];
          intResponseNumber = 0;
          GS.requestFromSocket(GS.envSocket, 'FILE\tLIST\t' + GS.encodeForTabDelimited(strPath), function (data, error, errorData) {
              var arrPaths, strName, strType, arrCells, i, len, divElement
                , arrFiles = [], arrFolders = [];
              
              if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                  if (data !== 'TRANSACTION COMPLETED') {
                      arrPaths = GS.trim(data, '\n').split('\n');
                      if (intResponseNumber === 0) {
                          element.folderList.innerHTML = '';
                          element.fileList.innerHTML = '';
                      }
                      
                      for (i = 0, len = arrPaths.length; i < len; i += 1) {
                          arrCells = arrPaths[i].split('\t');
                          strType = GS.decodeFromTabDelimited(arrCells[1]);
                          strName = GS.trim(GS.decodeFromTabDelimited(arrCells[0]), '/');
                          
                          if ((strType === 'folder' && bolFolders) || (strType === 'file' && bolFiles)) {
                              divElement = document.createElement('div');
                              divElement.setAttribute('flex-horizontal', '');
                              divElement.setAttribute('flex-fill', '');
                              divElement.setAttribute('class', strType + '-line');
                              divElement.setAttribute('data-name', strName);
                              
                              if (strType === 'file') {
                                  arrFiles.push(element.arrPath.join('/') + '/' + strName);
                                  divElement.innerHTML =
                                      '<gs-button class="more-file" icononly icon="bars" remove-right></gs-button>'
                                    + '<gs-button class="open-file" flex remove-left>' + encodeHTML(strName) + '</gs-button>';
                                  
                                  element.fileList.appendChild(divElement);
                              }
                              
                              if (strType === 'folder') {
                                  arrFolders.push(element.arrPath.join('/') + '/' + strName);
                                  divElement.innerHTML =
                                      '<gs-button class="more-folder" icononly icon="bars" remove-right></gs-button>'
                                    + '<gs-button class="open-folder" flex remove-left>' + encodeHTML(strName) + '</gs-button>';
                                  
                                  element.folderList.appendChild(divElement);
                              }
                          }
                      }
                      
                      element.arrFile = arrFiles;
                      element.arrFolder = arrFolders;
                      GS.triggerEvent(element, 'change');
                      
                  } else {
                      if (element.folderList.innerHTML === '') {
                          element.folderList.innerHTML = '<center prevent-text-selection><h4><small>No Folders.</small></h4></center>';
                      }
                      
                      if (element.fileList.innerHTML === '') {
                          element.fileList.innerHTML = '<center prevent-text-selection><h4><small>No Files.</small></h4></center>';
                      }
                  }
              } else if (error) {
                  if (!element.hasAttribute('no-list-error')) {
                      GS.webSocketErrorDialog(errorData);
                  }
              }
              
              intResponseNumber += 1;
          });
      }
      
      function prepareElement(element) {
          var bolFolders = !element.hasAttribute('no-folders')
            , bolFiles = !element.hasAttribute('no-files');
          
          element.innerHTML = ml(function () {/*
              <div class="root" flex-vertical flex-fill gs-dynamic>
                  <span class="path-title"></span>
                  <div class="list-container" flex-fill>
                      <div class="folder-list-container" flex-vertical flex-fill flex>
                          <div class="folder-list-header" flex-horizontal>
                              <b flex prevent-text-selection>Folders:</b>
                              <gs-button class="button-back-folder" icon="long-arrow-left" icononly remove-bottom disabled no-focus></gs-button>
                              <gs-button class="button-new-folder" icon="plus" icononly remove-bottom no-focus></gs-button>
                          </div>
                          <div class="folder-list" flex></div>
                      </div>
                      <div class="file-list-container" flex-vertical flex-fill flex>
                          <div class="file-list-header" flex-horizontal>
                              <b flex prevent-text-selection>Files:</b>
                              <gs-button class="button-new-file" icon="plus" icononly remove-bottom no-focus></gs-button>
                              <gs-button class="button-upload-file" icon="upload" icononly remove-bottom no-focus></gs-button>
                          </div>
                          <div class="file-list" flex></div>
                      </div>
                  </div>
              </div>
          */});
          //remove-right
          //remove-left
          
          element.root             = xtag.queryChildren(element, '.root')[0];
          element.folderListHeader = xtag.query(element.root, '.folder-list-header')[0];
          element.fileListHeader   = xtag.query(element.root, '.file-list-header')[0];
          
          element.folderList       = xtag.query(element.root, '.folder-list')[0];
          element.fileList         = xtag.query(element.root, '.file-list')[0];
          
          element.newFolderButton  = xtag.query(element.root, '.button-new-folder')[0];
          element.newFileButton    = xtag.query(element.root, '.button-new-file')[0];
          element.uploadFileButton = xtag.query(element.root, '.button-upload-file')[0];
          element.backButton       = xtag.query(element.root, '.button-back-folder')[0];
          
          element.pathTitle        = xtag.query(element.root, '.path-title')[0];
          
          element.arrPath = [];
      }
      
      //function pushReplacePopHandler(element) {
      //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
      //    
      //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        getData(element);
      //    }
      //}
      
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          i = 0;
          len = element.attributes.length;
          arrAttr = element.attributes;
          while (i < len) {
              jsnAttr = element.attributes[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol && strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun === true && GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                  //console.trace(element, 'test');
                  getData(element);
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
      
      function bindElement(element) {
          if (element.hasAttribute('qs')) {
              pushReplacePopHandler(element);
              window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
              window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
              window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
          }
          
          element.addEventListener('click', function (event) {
              var target = event.target;
              
              if (target.classList.contains('button-new-folder')) {
                  newFolder(element, target);
                  
              } else if (target.classList.contains('button-new-file')) {
                  newFile(element, target);
                  
              } else if (target.classList.contains('open-file')) {
                  fileOpen(element, target);
                  
              } else if (target.classList.contains('open-folder')) {
                  folderOpen(element, target);
                  
              } else if (target.classList.contains('button-back-folder')) {
                  backFolder(element, target);
                  
              } else if (target.classList.contains('more-folder')) {
                  folderMenu(element, target);
                  
              } else if (target.classList.contains('more-file')) {
                  fileMenu(element, target);
                  
              } else if (target.classList.contains('button-upload-file')) {
                  fileUpload(element, target);
              }
          });
      }
      
      
      // ################################################################################################
      // ####################################### FOLDER FUNCTIONS #######################################
      // ################################################################################################
      
      function folderMenu(element, target) {
          'use strict';
          var lineElement = GS.findParentElement(target, '.folder-line')
            , strFolderName = lineElement.getAttribute('data-name')
            , strPath = (getPath(element) + strFolderName)
            , templateElement = document.createElement('template');
          
          templateElement.setAttribute('data-overlay-close', 'true');
          templateElement.setAttribute('data-max-width', '250px');
          templateElement.innerHTML = ml(function () {/*
              <gs-body padded>
                  <gs-button dialogclose remove-bottom style="border-bottom: 0 none;">Rename Folder</gs-button>
                  <gs-button dialogclose remove-top>Delete Folder</gs-button>
                  <hr />
                  <gs-button dialogclose>Cancel</gs-button>
              </gs-body>
          */});
          
          GS.openDialogToElement(target, templateElement, 'right', '', function (event, strAnswer) {
              if (strAnswer === 'Rename Folder') {
                  folderRename(element, target, strPath, strFolderName);
                  
              } else if (strAnswer === 'Delete Folder') {
                  folderDelete(element, target, strPath, strFolderName);
              }
          });
      }
      
      function folderRename(element, target, strOldPath, strFolderName) {
          'use strict';
          var templateElement = document.createElement('template');
          
          templateElement.setAttribute('data-overlay-close', 'true');
          templateElement.setAttribute('data-max-width', '250px');
          templateElement.innerHTML = ml(function () {/*
              <gs-body padded>
                  <label for="gs-file-manager-text-folder-name">Folder Name:</label>
                  <gs-text id="gs-file-manager-text-folder-name"></gs-text>
                  <hr />
                  <gs-grid>
                      <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                      <gs-block><gs-button dialogclose remove-left>Rename</gs-button></gs-block>
                  </gs-grid>
              </gs-body>
          */});
          
          GS.openDialogToElement(target, templateElement, 'right', function () {
              document.getElementById('gs-file-manager-text-folder-name').value = strFolderName;
              
          }, function (event, strAnswer) {
              var strNewPath;
              
              if (strAnswer === 'Rename') {
                  strNewPath = getPath(element) + document.getElementById('gs-file-manager-text-folder-name').value;
                  
                  //console.log('strOldPath:', strOldPath);
                  //console.log('strNewPath:', strNewPath);
                  
                  GS.requestFromSocket(GS.envSocket
                                     , 'FILE\tMOVE\t' + GS.encodeForTabDelimited(strOldPath) + '\t' +
                                                        GS.encodeForTabDelimited(strNewPath) + '\n'
                                     , function (data, error, errorData) {
                      if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                          if (data === 'TRANSACTION COMPLETED') {
                              getData(element);
                          }
                      } else if (error) {
                          GS.webSocketErrorDialog(errorData);
                      }
                  });
              }
          });
      }
      
      function folderDelete(element, target, strPath, strFolderName) {
          'use strict';
          var templateElement = document.createElement('template');
          
          templateElement.setAttribute('data-overlay-close', 'true');
          templateElement.setAttribute('data-max-width', '250px');
          templateElement.innerHTML = ml(function () {/*
              <gs-body padded>
                  Are you sure you want to delete the folder: "<b>{{STRPATH}}</b>"?
                  <hr />
                  <gs-grid>
                      <gs-block><gs-button dialogclose remove-right style="border-right: 0 none;">No</gs-button></gs-block>
                      <gs-block><gs-button dialogclose remove-left>Yes</gs-button></gs-block>
                  </gs-grid>
              </gs-body>
          */}).replace(/\{\{STRPATH\}\}/gi, strFolderName);
          
          GS.openDialogToElement(target, templateElement, 'right', '', function (event, strAnswer) {
              if (strAnswer === 'Yes') {
                  //console.log('Delete:', strPath);
                  
                  GS.requestFromSocket(GS.envSocket
                                     , 'FILE\tDELETE\t' + GS.encodeForTabDelimited(strPath) + '\n'
                                     , function (data, error, errorData) {
                      if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                          if (data === 'TRANSACTION COMPLETED') {
                              getData(element);
                          }
                      } else if (error) {
                          GS.webSocketErrorDialog(errorData);
                      }
                  });
              }
          });
      }
      
      function newFolder(element, target) {
          'use strict';
          var templateElement = document.createElement('template');
          
          templateElement.setAttribute('data-overlay-close', 'true');
          templateElement.setAttribute('data-max-width', '250px');
          templateElement.innerHTML = ml(function () {/*
              <gs-body padded>
                  <label for="gs-file-manager-text-folder-name">New Folder Name:</label>
                  <gs-text id="gs-file-manager-text-folder-name"></gs-text>
                  <hr />
                  <gs-grid>
                      <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                      <gs-block><gs-button dialogclose remove-left>Create</gs-button></gs-block>
                  </gs-grid>
              </gs-body>
          */});
          
          GS.openDialogToElement(target, templateElement, 'down', '', function (event, strAnswer) {
              var strPath;
              
              if (strAnswer === 'Create') {
                  strPath = getPath(element) + document.getElementById('gs-file-manager-text-folder-name').value;
                  //console.log('Create:', strPath);
                  
                  GS.requestFromSocket(GS.envSocket
                                     , 'FILE\tCREATE_FOLDER\t' + GS.encodeForTabDelimited(strPath) + '\n'
                                     , function (data, error, errorData) {
                      if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                          if (data === 'TRANSACTION COMPLETED') {
                              getData(element);
                          }
                      } else if (error) {
                          GS.webSocketErrorDialog(errorData);
                      }
                  });
              }
          });
      }
      
      function folderOpen(element, target) {
          'use strict';
          var lineElement = GS.findParentElement(target, '.folder-line');
          
          element.arrPath.push(lineElement.getAttribute('data-name'));
          getData(element);
      }
      
      function backFolder(element, target) {
          'use strict';
          element.arrPath.pop();
          getData(element);
      }
      
      // ################################################################################################
      // ######################################## FILE FUNCTIONS ########################################
      // ################################################################################################
      
      function fileMenu(element, target) {
          'use strict';
          var lineElement = GS.findParentElement(target, '.file-line')
            , strFileName = lineElement.getAttribute('data-name')
            //, intPeriodIndex = strFileName.indexOf('.')
            //, strFileExtension = strFileName.substring(intPeriodIndex)
            , strPath = getPath(element) + strFileName
            , templateElement = document.createElement('template');
          
          //console.log(strFileExtension);
          
          templateElement.setAttribute('data-overlay-close', 'true');
          templateElement.setAttribute('data-max-width', '250px');
          templateElement.innerHTML = ml(function () {/*
              <gs-body padded>
                  <gs-button dialogclose remove-bottom style="border-bottom: 0 none;">Rename File</gs-button>
                  <gs-button dialogclose remove-all style="border-bottom: 0 none;">Delete File</gs-button>
                  <gs-button dialogclose remove-top>Edit File</gs-button>
                  <hr />
                  <gs-button dialogclose>Cancel</gs-button>
              </gs-body>
          */});
          
          GS.openDialogToElement(target, templateElement, 'right', '', function (event, strAnswer) {
              if (strAnswer === 'Rename File') {
                  fileRename(element, target, strPath, strFileName);
                  
              } else if (strAnswer === 'Delete File') {
                  fileDelete(element, target, strPath, strFileName);
                  
              } else if (strAnswer === 'Edit File') {
                  fileEdit(element, target, strPath, strFileName);
              }
          });
      }
      
      function fileRename(element, target, strOldPath, strFileName) {
          'use strict';
          var templateElement = document.createElement('template');
          
          templateElement.setAttribute('data-overlay-close', 'true');
          templateElement.setAttribute('data-max-width', '250px');
          templateElement.innerHTML = ml(function () {/*
              <gs-body padded>
                  <label for="gs-file-manager-text-file-name">File Name:</label>
                  <gs-text id="gs-file-manager-text-file-name"></gs-text>
                  <hr />
                  <gs-grid>
                      <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                      <gs-block><gs-button dialogclose remove-left>Rename</gs-button></gs-block>
                  </gs-grid>
              </gs-body>
          */});
          
          GS.openDialogToElement(target, templateElement, 'right', function () {
              document.getElementById('gs-file-manager-text-file-name').value = strFileName;
              
          }, function (event, strAnswer) {
              var strNewPath;
              
              if (strAnswer === 'Rename') {
                  strNewPath = getPath(element) + document.getElementById('gs-file-manager-text-file-name').value;
                  
                  //console.log('strOldPath:', strOldPath);
                  //console.log('strNewPath:', strNewPath);
                  
                  GS.requestFromSocket(GS.envSocket
                                     , 'FILE\tMOVE\t' + GS.encodeForTabDelimited(strOldPath) + '\t' +
                                                        GS.encodeForTabDelimited(strNewPath) + '\n'
                                     , function (data, error, errorData) {
                      if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                          if (data === 'TRANSACTION COMPLETED') {
                              getData(element);
                          }
                      } else if (error) {
                          GS.webSocketErrorDialog(errorData);
                      }
                  });
              }
          });
      }
      
      function fileDelete(element, target, strPath, strFileName) {
          'use strict';
          var templateElement = document.createElement('template');
          
          templateElement.setAttribute('data-overlay-close', 'true');
          templateElement.setAttribute('data-max-width', '250px');
          templateElement.innerHTML = ml(function () {/*
              <gs-body padded>
                  Are you sure you want to delete the file: "<b>{{STRPATH}}</b>"?
                  <hr />
                  <gs-grid>
                      <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>No</gs-button></gs-block>
                      <gs-block><gs-button dialogclose remove-left>Yes</gs-button></gs-block>
                  </gs-grid>
              </gs-body>
          */}).replace(/\{\{STRPATH\}\}/gi, strFileName);
          
          GS.openDialogToElement(target, templateElement, 'right', '', function (event, strAnswer) {
              if (strAnswer === 'Yes') {
                  //console.log('Delete:', strPath);
                  
                  GS.requestFromSocket(GS.envSocket
                                     , 'FILE\tDELETE\t' + GS.encodeForTabDelimited(strPath) + '\n'
                                     , function (data, error, errorData) {
                      if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                          if (data === 'TRANSACTION COMPLETED') {
                              getData(element);
                          }
                      } else if (error) {
                          GS.webSocketErrorDialog(errorData);
                      }
                  });
              }
          });
      }
      
      function fileEdit(element, target, strPath, strFileName) {
          'use strict';
          window.open('/env/app/all/file_manager/file_edit.html?socket=true&link=' + encodeURIComponent(strPath));
      }
      
      function newFile(element, target) {
          'use strict';
          var templateElement = document.createElement('template');
          
          templateElement.setAttribute('data-overlay-close', 'true');
          templateElement.setAttribute('data-max-width', '250px');
          templateElement.innerHTML = ml(function () {/*
              <gs-body padded>
                  <label for="gs-file-manager-text-file-name">New File Name:</label>
                  <gs-text id="gs-file-manager-text-file-name"></gs-text>
                  <hr />
                  <gs-grid>
                      <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                      <gs-block><gs-button dialogclose remove-left>Create</gs-button></gs-block>
                  </gs-grid>
              </gs-body>
          */});
          
          GS.openDialogToElement(target, templateElement, 'down', '', function (event, strAnswer) {
              var strPath;
              var strName = document.getElementById('gs-file-manager-text-file-name').value || '';
              
              //console.log('Name:', strName);
              
              if (strAnswer === 'Create' && strName) {
                  strPath = getPath(element) + strName;
                  //console.log('Create:', strPath);
                  
                  if (document.getElementById('gs-file-manager-text-file-name').value.trim()) {
                      GS.requestFromSocket(GS.envSocket
                                         , 'FILE\tCREATE_FILE\t' + GS.encodeForTabDelimited(strPath) + '\n'
                                         , function (data, error, errorData) {
                          if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                              if (data === 'TRANSACTION COMPLETED') {
                                  getData(element);
                              }
                          } else if (error) {
                              GS.webSocketErrorDialog(errorData);
                          }
                      });
                  }
              }
          });
      }
      
      function fileOpen(element, target) {
          'use strict';
          var lineElement = GS.findParentElement(target, '.file-line');
          
          window.open(location.protocol + '//' + location.host + getRealPath(element) + '' + lineElement.getAttribute('data-name'));
      }
      
      
      // ################################################################################################
      // ############################################# XTAG #############################################
      // ################################################################################################
      
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
                  
                  prepareElement(element);
                  bindElement(element);
                  
                  //// if no "qs" set or "qs" key set in query string <- non-standard behaviour, you could want 
                  //if ((!element.hasAttribute('qs') || GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs')))) {
                  //    getData(element);
                  //}
                  
                  getData(element);
                  //pushReplacePopHandler(element);
              }
          }
      }
      
      xtag.register('gs-folder', {
          lifecycle: {
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      
                  }
              }
          },
          events: {},
          accessors: {},
          methods: {}
      });
  }());
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('<gs-font>', '<gs-font>', 'gs-font min-width="${1}">\n' +
                                                      '    ${0}\n' +
                                                      '</gs-font>');
      
      designRegisterElement('gs-font', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-font.html');
      
      window.designElementProperty_GSFONT = function (selectedElement) {
          addProp('Min-Width Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('min-width') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'min-width', this.value);
          });
          
          addProp('Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('media') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'media', this.value);
          });
          
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
          
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
          
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      var arrTakenFonts = [];
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              
          }
      }
      
      //
      function elementInserted(element) {
          var styleElement;
          
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  
                  // if the style element for the container CSS doesn't exist: create it
                  if (!document.getElementById('gs-dynamic-css')) {
                      styleElement = document.createElement('style');
                      styleElement.setAttribute('id', 'gs-dynamic-css');
                      styleElement.setAttribute('gs-dynamic', '');
                      document.head.appendChild(styleElement);
                  }
                  
                  if (element.getAttribute('min-width')) {
                      element.handleMinWidthCSS();
                  } else if (element.getAttribute('media')) {
                      element.handleMediaCSS();
                  }
              }
          }
      }
      
      xtag.register('gs-font', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      // if the "min-width" attribute changed
                      if (strAttrName === 'min-width') {
                          this.handleMinWidthCSS();
                          
                      // if the "media" attribute changed
                      } else if (strAttrName === 'media') {
                          this.handleMediaCSS();
                      }
                  }
              }
          },
          events: {},
          accessors: {},
          methods: {
              handleMinWidthCSS: function () {
                  var strMinWidth = this.getAttribute('min-width'), arrMinWidths, strCSS, i, len, arrClassesToRemove, intContainerID,
                      arrParts, strMedia, strResult;
                  
                  // remove old classes
                  arrClassesToRemove = String(this.classList).match(/font-id-[0-9]*/g) || [];
                  
                  for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                      this.classList.remove(arrClassesToRemove[i]);
                  }
                  
                  // all {15px}; lrg {25px};
                  // all {15px}; lrg {25px};
                  // all {20px}; sml {25px}; med {30px}; lrg {35px};
                  
                  // all close curly braces, remove all whitespace, lowercase, trim off semicolons
                  strMinWidth = GS.trim(strMinWidth.replace(/\}/g, '').replace(/\s+/g, '').toLowerCase(), ';');
                  
                  // replace shortcuts (lrg => 1200px)
                  strMinWidth = strMinWidth.replace(/all/g, '0px')
                                           .replace(/small|sml/g, '768px')
                                           .replace(/medium|med/g, '992px')
                                           .replace(/large|lrg/g, '1200px');
                  
                  arrMinWidths = strMinWidth.split(';'); // seperate out layouts
                  
                  //console.log(strMinWidth, arrMinWidths);
                  
                  if (arrTakenFonts.indexOf(strMinWidth) === -1) {
                      arrTakenFonts.push(strMinWidth);
                      intContainerID = arrTakenFonts.length - 1;
                      strCSS = '';
                      
                      for (i = 0, len = arrMinWidths.length; i < len; i += 1) {
                          arrParts = arrMinWidths[i].split('{');
                          strMedia = arrParts[0];
                          strResult = arrParts[1];
                          
                          strCSS +=   '\n@media (min-width:' + strMedia + ') {\n' +
                                      '    gs-font.font-id-' + intContainerID + ' { font-size:' + strResult + '; }\n' +
                                      '}\n';
                      }
                      
                      //console.log(strCSS);
                      
                      // append the column CSS
                      document.getElementById('gs-dynamic-css').innerHTML += '\n/* font #' + intContainerID + ' */\n' + strCSS;
                      
                  } else {
                      intContainerID = arrTakenFonts.indexOf(strMinWidth);
                  }
                  
                  this.classList.add('font-id-' + intContainerID);
              },
              
              handleMediaCSS: function () {
                  var strMedia = this.getAttribute('media'), arrMedias, strCSS, i, len,
                      arrClassesToRemove, arrParts, strCurrentMedia, strWidth, intContainerID;
                  
                  // remove old classes
                  arrClassesToRemove = String(this.classList).match(/font-id-[0-9]*/g) || [];
                  
                  for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                      this.classList.remove(arrClassesToRemove[i]);
                  }
                  
                  // print {20px}; all and (max-width: 500px) {20px}; (min-width: 500px) {25px};
                  
                  // trim, remove all close curly braces, lowercase, trim off semicolons
                  strMedia = GS.trim(strMedia.trim().replace(/\}/g, '').toLowerCase(), ';');
                  
                  // replace shortcuts (lrg => 1200px)
                  strMedia = strMedia.replace(/all/g, '0px')
                                     .replace(/small|sml/g, '768px')
                                     .replace(/medium|med/g, '992px')
                                     .replace(/large|lrg/g, '1200px');
                  
                  arrMedias = strMedia.split(';'); // seperate out layouts
                  
                  //console.log(strMedia, arrMedias);
                  
                  if (arrTakenFonts.indexOf(strMedia) === -1) {
                      arrTakenFonts.push(strMedia);
                      intContainerID = arrTakenFonts.length - 1;
                      strCSS = '';
                      
                      
                      for (i = 0, len = arrMedias.length; i < len; i += 1) {
                          arrParts = arrMedias[i].split('{');
                          strCurrentMedia = arrParts[0].trim() || 'all';
                          strWidth = arrParts[1].trim() || '900px';
                          
                          strCSS +=   '\n@media ' + strCurrentMedia + ' {\n' +
                                      '    gs-font.font-id-' + intContainerID + ' ' +
                                                  '{ font-size: ' + strWidth + '; }\n' +
                                      '}\n';
                      }
                      
                      //console.log(strCSS);
                      
                      // append the column CSS
                      document.getElementById('gs-dynamic-css').innerHTML += '\n/* font #' + intContainerID + ' */\n' + strCSS;
                      
                  } else {
                      intContainerID = arrTakenFonts.indexOf(strMinWidth);
                  }
                  
                  this.classList.add('font-id-' + intContainerID);
              }
          }
      });
  });//global registerDesignSnippet, designRegisterElement, window, addProp, addFlexContainerProps, addFlexProps, document, xtag
  
  window.addEventListener('design-register-element', function () {
      'use strict';
      registerDesignSnippet('<gs-footer>', '<gs-footer>', 'gs-footer>$0</gs-footer>');
  
      designRegisterElement('gs-footer', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-page.html');
  
      window.designElementProperty_GSFOOTER = function (selectedElement) {
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility', true,
                  '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                  '    <option value="">Visible</option>' +
                  '    <option value="hidden">Invisible</option>' +
                  '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                  '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                  '    <option value="hide-on-phone">Invisible at phone size</option>' +
                  '    <option value="show-on-desktop">Visible at desktop size</option>' +
                  '    <option value="show-on-tablet">Visible at tablet size</option>' +
                  '    <option value="show-on-phone">Visible at phone size</option>' +
                  '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
  
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
  
              return selectedElement;
          });
  
          addFlexContainerProps(selectedElement);
          //addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
  
      xtag.register('gs-footer', {
          lifecycle: {},
          events: {},
          accessors: {},
          methods: {}
      });
  });//jslint white:true miltivar:true
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('<gs-form>', '<gs-form>', 'gs-form src="${1:test.tpeople}">\n' +
                                                      '    <template>\n' +
                                                      '        ${2}\n' +
                                                      '    </template>\n' +
                                                      '</gs-form>');
      
      designRegisterElement('gs-form', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-form.html');
      
      window.designElementProperty_GSFORM = function (selectedElement) {
          addProp('Source', true, '<gs-memo class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('src') ||
                                                                                          selectedElement.getAttribute('source') || '')) + '" mini></gs-memo>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
          });
          
          addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                  function () {
              return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
          });
          
          addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('where') || '')) + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'where', encodeURIComponent(this.value));
          });
          
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
          
          addProp('Lock', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('lock') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'lock', this.value);
          });
          
          addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
          });
          
          addProp('Limit', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
          });
          
          addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
          });
          
          addProp('Save&nbsp;While&nbsp;Typing', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('save-while-typing')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'save-while-typing', (this.value === 'true'), true);
          });
          
          addProp('Suppress<br />"No&nbsp;Record&nbsp;Found"<br />Error', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suppress-no-record-found')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suppress-no-record-found', (this.value === 'true'), true);
          });
          
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
          
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
          
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
          
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
              this.removeAttribute('refresh-on-querystring-change');
              return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
          });
          
          addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
              this.removeAttribute('refresh-on-querystring-values');
              return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
          });
          
          addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      
      function triggerAfterUpdate(element) {
          GS.triggerEvent(element, 'after_update');
          if (element.hasAttribute('afterupdate')) {
              new Function(element.getAttribute('afterupdate')).apply(element);
          }
      }
      
      // ##################################################################
      // ######################## UPDATE FUNCTIONS ########################
      // ##################################################################
      
      function emergencyUpdate(element) {
          if (element.currentSaveAjax) {
              element.currentSaveAjax.abort();
          }
          element.bolCurrentlySaving = false;
          updateDataWithoutTemplate(element, false);
      }
      
      function updateData(element, updateElement, strColumn, newValue) {
          var data, parentRecord, strID, strHash
            , srcParts = GS.templateWithQuerystring(element.getAttribute('src')).split('.')
            , strSchema = srcParts[0]
            , strObject = srcParts[1]
            , strReturnCols = element.arrColumns.join('\t')
            , strHashCols = element.lockColumn
            , updateFrameData, strRoles, strColumns, arrTotalRecords = [];
          
          parentRecord = GS.findParentElement(updateElement, '.form-record');
          
          strID = parentRecord.getAttribute('data-id');
          strHash = CryptoJS.MD5(parentRecord.getAttribute('data-' + element.lockColumn)).toString();
          
          strRoles   = 'pk\thash\tset';
          strColumns = 'id\thash\t' + GS.encodeForTabDelimited(strColumn);
          updateFrameData = strID + '\t' + strHash + '\t' + GS.encodeForTabDelimited(newValue);
          
          updateFrameData = (strRoles + '\n' + strColumns + '\n' + updateFrameData);
          GS.triggerEvent(element, 'before_update');
          
          GS.requestUpdateFromSocket(
              GS.envSocket, strSchema, strObject
            , strReturnCols, strHashCols, updateFrameData
              
            , function (data, error, transactionID) {
                  if (error) {
                      getData(element);
                      GS.removeLoader(element);
                      GS.webSocketErrorDialog(data);
                  }
              }
            , function (data, error, transactionID, commitFunction, rollbackFunction) {
                  GS.removeLoader(element);
                  
                  if (!error) {
                      if (data === 'TRANSACTION COMPLETED') {
                          commitFunction();
                      } else {
                          var arrRecords, arrCells, i, len, cell_i, cell_len;
                          
                          arrRecords = GS.trim(data, '\n').split('\n');
                          
                          for (i = 0, len = arrRecords.length; i < len; i += 1) {
                              arrCells = arrRecords[i].split('\t');
                              
                              for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                                  arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                              }
                              
                              arrTotalRecords.push(arrCells);
                          }
                      }
                      
                  } else {
                      rollbackFunction();
                      getData(element);
                      GS.webSocketErrorDialog(data);
                  }
              }
            , function (strAnswer, data, error) {
                  GS.removeLoader(element);
                  
                  if (!error) {
                      if (strAnswer === 'COMMIT') {
                          var idIndex, i, len;
                          
                          idIndex = element.lastSuccessData.arr_column.indexOf('id');
                          
                          for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                              if (String(element.lastSuccessData.dat[i][idIndex]) === strID) {
                                  element.lastSuccessData.dat[i] = arrTotalRecords[0];
                                  break;
                              }
                          }
                          
                          triggerAfterUpdate(element);
                          handleData(element, element.lastSuccessData);
                          
                          GS.triggerEvent(element, 'after_update');
                      } else {
                          getData(element);
                      }
                  } else {
                      getData(element);
                      GS.webSocketErrorDialog(data);
                  }
              }
          );
      }
      
      function updateDataWithoutTemplate(element, bolErrorHandling) {
          if (element.bolCurrentlySaving === false && !element.bolErrorOpen) {
              var data, parentRecord, strID, strHash
                , srcParts = GS.templateWithQuerystring(element.getAttribute('src')).split('.')
                , strSchema = srcParts[0]
                , strObject = srcParts[1]
                , strReturnCols = element.arrColumns.join('\t')
                , strHashCols = element.lockColumn
                , updateFrameData, strRoles, strColumns, arrTotalRecords = [], functionUpdateRecord, col_key, key, strColumn, newValue, idIndex, i, len;
              
              functionUpdateRecord = function (strID, strColumn, recordIndex, strParameters) {
                  var strWhere, strChangeStamp, strValue;
                  
                  element.bolCurrentlySaving = true;
                  element.jsnUpdate[strID][strColumn] = undefined;
                  
                  // run ajax
                  removeMessage(element, 'waiting');
                  addMessage(element, 'saving');
                  element.state = 'saving';
                  
                  strWhere        = GS.qryGetVal(strParameters, 'where');
                  strColumn       = GS.qryGetVal(strParameters, 'column');
                  strValue        = GS.qryGetVal(strParameters, 'value');
                  
                  strID           = GS.qryGetVal(strWhere,      'id');
                  strChangeStamp  = GS.qryGetVal(strWhere,      element.lockColumn);
                  
                  strHash = CryptoJS.MD5(strChangeStamp).toString();
                  
                  //parentRecord = GS.findParentElement(updateElement, '.form-record');
                  
                  strRoles   = 'pk\thash\tset';
                  strColumns = 'id\thash\t' + GS.encodeForTabDelimited(strColumn);
                  updateFrameData = strID + '\t' + strHash + '\t' + GS.encodeForTabDelimited(strValue);
                  
                  updateFrameData = (strRoles + '\n' + strColumns + '\n' + updateFrameData);
                  
                  
                  
                  //console.log(strParameters);
                  //console.log(updateFrameData);
                  //console.log(strSchema, strObject, strReturnCols, strHashCols);
                  
                  GS.requestUpdateFromSocket(
                      GS.envSocket, strSchema, strObject
                    , strReturnCols, strHashCols, updateFrameData
                      
                    , function (data, error, transactionID) {
                          if (error) {
                              getData(element);
                              GS.webSocketErrorDialog(data);
                          }
                      }
                    , function (data, error, transactionID, commitFunction, rollbackFunction) {
                          if (!error) {
                              if (data === 'TRANSACTION COMPLETED') {
                                  commitFunction();
                              } else {
                                  var arrRecords, arrCells, i, len, cell_i, cell_len;
                                  
                                  arrRecords = GS.trim(data, '\n').split('\n');
                                  
                                  for (i = 0, len = arrRecords.length; i < len; i += 1) {
                                      arrCells = arrRecords[i].split('\t');
                                      
                                      for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                                          arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                                      }
                                      
                                      arrTotalRecords.push(arrCells);
                                  }
                              }
                              
                          } else {
                              rollbackFunction();
                              getData(element);
                              GS.webSocketErrorDialog(data);
                          }
                      }
                    , function (strAnswer, data, error) {
                          var col_key, key, bolSaveWaiting;
                          removeMessage(element, 'saving');
                          element.state = 'saved';
                          
                          GS.removeLoader(element);
                          
                          if (!error) {
                              if (strAnswer === 'COMMIT') {
                                  element.lastSuccessData.dat[recordIndex] = arrTotalRecords[0];
                                  element.bolCurrentlySaving = false;
                                  
                                  // if there is another save in the pipeline: bolSaveWaiting = true
                                  for (key in element.jsnUpdate) {
                                      for (col_key in element.jsnUpdate[key]) {
                                          if (element.jsnUpdate[key][col_key] !== undefined) {
                                              bolSaveWaiting = true;
                                              break;
                                          }
                                      }
                                  }
                                  
                                  // if there is a save waiting: update again
                                  if (bolSaveWaiting) {
                                      updateDataWithoutTemplate(element);
                                      
                                  } else {
                                      triggerAfterUpdate(element);
                                  }
                              } else {
                                  getData(element);
                              }
                          } else {
                              GS.webSocketErrorDialog(data);
                          }
                      }
                  );
              };
              
              // loop through the jsnUpdate variable and make one update for every record that needs an update
              console.log(JSON.stringify(element.jsnUpdate));
              
              for (key in element.jsnUpdate) {
                  for (col_key in element.jsnUpdate[key]) {
                      if (element.jsnUpdate[key][col_key] !== undefined) {
                          strID = key;
                          strColumn = col_key;
                          newValue = element.jsnUpdate[key][col_key];
                          idIndex = element.lastSuccessData.arr_column.indexOf('id');
                          
                          for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                              if (String(element.lastSuccessData.dat[i][idIndex]) === strID) {
                                  functionUpdateRecord(strID, strColumn, i,
                                              'where=' + encodeURIComponent(
                                                  'id=' + strID +
                                                  '&' + element.lockColumn + '=' + GS.envGetCell(element.lastSuccessData, i, element.lockColumn)
                                              ) +
                                              '&column=' + strColumn +
                                              '&value=' +  encodeURIComponent(newValue));
                                  
                                  break;
                              }
                          }
                          
                          break;
                      }
                  }
              }
          }
      }
      
      
      // #################################################################
      // ######################### DATA HANDLING #########################
      // #################################################################
      
      // handles fetching the data
      //      if bolInitalLoad === true then
      //          use: initialize query COALESCE TO source query
      //      else
      //          use: source query
      function getData(element) { //bolClearPrevious
          var strSrc     = GS.templateWithQuerystring(element.getAttribute('src'))
            , srcParts   = strSrc[0] === '(' ? [strSrc, ''] : strSrc.split('.')
            , strSchema  = srcParts[0]
            , strObject  = srcParts[1]
            , strColumns = GS.templateWithQuerystring(element.getAttribute('cols') || '*').split(',').join('\t')
            , strWhere   = GS.templateWithQuerystring(element.getAttribute('where') || '')
            , strOrd     = GS.templateWithQuerystring(element.getAttribute('ord') || '')
            , strLimit   = GS.templateWithQuerystring(element.getAttribute('limit') || '1')
            , strOffset  = GS.templateWithQuerystring(element.getAttribute('offset') || '')
            , response_i = 0, response_len = 0, arrTotalRecords = [];
          
          GS.triggerEvent(element, 'before_select');
          GS.requestSelectFromSocket(GS.envSocket, strSchema, strObject, strColumns
                                   , strWhere, strOrd, strLimit, strOffset
                                   , function (data, error) {
              var arrRecords, arrCells, i, len, cell_i, cell_len;
              
              if (!error) {
                  if (data.strMessage !== 'TRANSACTION COMPLETED') {
                      arrRecords = GS.trim(data.strMessage, '\n').split('\n');
                      
                      for (i = 0, len = arrRecords.length; i < len; i += 1) {
                          arrCells = arrRecords[i].split('\t');
                          
                          for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                              arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                          }
                          
                          arrTotalRecords.push(arrCells);
                      }
                  } else {
                      element.arrColumns = data.arrColumnNames;
                      
                      handleData(element, {
                          "arr_column": data.arrColumnNames
                        , "dat": arrTotalRecords
                        , "row_count": arrTotalRecords.length
                      }, '', 'load');
                  }
              } else {
                  GS.webSocketErrorDialog(data);
              }
          });
      }
      
      // handles data result from method function: getData 
      //      success:  template
      //      error:    add error classes
      function handleData(element, data, error, strAction, failCallback) {
          var arrElements, i, len, arrHeaders = [], intColumnElementFocusNumber, jsnSelection, matchElement,
              templateElement = document.createElement('template'), focusTimerID, focusToElement, timer_i;
          
          // clear any old error status
          element.classList.remove('error');
          
          if (!error && data.dat.length === 0 && !element.hasAttribute('limit') && !element.hasAttribute('suppress-no-record-found')) {
              templateElement.setAttribute('data-theme', 'error');
              templateElement.innerHTML = ml(function () {/*
                  <gs-page>
                      <gs-header><center><h3>Error</h3></center></gs-header>
                      <gs-body padded>
                          <center>No record found</center>
                      </gs-body>
                      <gs-footer>
                          <gs-grid>
                              <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                              <gs-block><gs-button dialogclose listen-for-return bg-primary>Try Again</gs-button></gs-block>
                          </gs-grid>
                      </gs-footer>
                  </gs-page>
              */});
              
              GS.openDialog(templateElement, '', function (event, strAnswer) {
                  if (strAnswer === 'Try Again') {
                      element.refresh();
                  }
              });
          }
          
          // if there was no error
          if (!error) {
              element.error = false;
              
              // save success data
              element.lastSuccessData = data;
              
              if (GS.findParentElement(document.activeElement, 'gs-form') === element) {
                  //console.log('Hey');
                  arrElements = xtag.query(element, '[column]');
                  matchElement = GS.findParentElement(document.activeElement, '[column]');
                  
                  if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                      jsnSelection = GS.getInputSelection(document.activeElement);
                  }
                  
                  if (matchElement) {
                      for (i = 0, len = arrElements.length; i < len; i += 1) {
                          if (arrElements[i] === matchElement) {
                              intColumnElementFocusNumber = i;
                              break;
                          }
                      }
                  }
              }
              
              element.innerHTML = dataTemplateRecords(element, data);
              
              // if template is not native: handle templates inside the form
              if (shimmed.HTMLTemplateElement) {
                  HTMLTemplateElement.bootstrap(element);
              }
              
              // handle autofocus
              arrElements = xtag.query(element, '[autofocus]');
              
              if (arrElements.length > 0 && !evt.touchDevice) {
                  arrElements[0].focus();
                  
                  if (arrElements.length > 1) {
                      console.warn('dialog Warning: Too many [autofocus] elements, defaulting to the first one. Please have only one [autofocus] element per form.');
                  }
              }
              
              // if there is a intColumnElementFocusNumber: restore focus
              if (intColumnElementFocusNumber) {
                  arrElements = xtag.query(element, '[column]');
                  
                  //console.log(intColumnElementFocusNumber, jsnSelection);
                  //
                  //console.log('arrElements: ', arrElements);
                  //console.log('intColumnElementFocusNumber: ', intColumnElementFocusNumber);
                  //console.log('element: ', arrElements[intColumnElementFocusNumber]);
                  //console.log('jsnSelection: ', jsnSelection);
                  //
                  //console.log('element upgrade: ', arrElements[intColumnElementFocusNumber].__upgraded__);
                  
                  //console.log('1***');
                  if (arrElements.length > intColumnElementFocusNumber) {
                      //console.log('2***', document.activeElement);
                      focusToElement = arrElements[intColumnElementFocusNumber];
                      
                      // if element registration is not shimmed, we can just focus into the target element
                      if (shimmed.registerElement === false) {
                          focusToElement.focus();
                          if (jsnSelection) {
                              GS.setInputSelection(document.activeElement, jsnSelection.start, jsnSelection.end);
                          }
                          
                      // else, we have to check on a loop to see if the element has been upgraded,
                      //      the reason I need to use a loop here is because there is no event for
                      //      when an element is upgraded (if there was then 1000 custom elements
                      //      would emit 1000 events, which is a lot and we don't want to bog the
                      //      browser down)
                      } else {
                          timer_i = 0;
                          focusTimerID = setInterval(function () {
                              if (focusToElement.__upgraded__ || timer_i >= 10) {
                                  clearTimeout(focusTimerID);
                              }
                              if (focusToElement.__upgraded__) {
                                  focusToElement.focus();
                                  if (jsnSelection) {
                                      GS.setInputSelection(document.activeElement, jsnSelection.start, jsnSelection.end);
                                  }
                              }
                              timer_i += 1;
                          }, 5);
                      }
                  }
              }
              
              //console.log('current element', document.activeElement);
              
              // trigger after_select
              GS.triggerEvent(element, 'after_select');
              //console.log(element, 'after_select');
              
          // else there was an error: add error class, title attribute
          } else {
              element.error = true;
              element.classList.add('error');
              
              element.innerHTML = 'This form encountered an error.'
              
              //GS.ajaxErrorDialog(event.detail.response);
              GS.ajaxErrorDialog(data);
          }
      }
      
      
      function dataTemplateRecords(element, data) {
          var jsnTemplate, strRet;
          
          jsnTemplate = GS.templateHideSubTemplates(element.templateHTML);
          
          //console.log(jsnTemplate.templateHTML);
          
          strRet = GS.templateWithEnvelopeData('<div class="form-record" ' + (data.dat.length === 1 ? 'style="height: 100%;" ' : '') +
                                                  'data-id="{{! row.id }}" data-' + element.lockColumn + '="{{! row.' + element.lockColumn + ' }}" gs-dynamic>' +
                                                  jsnTemplate.templateHTML +
                                              '</div>',
                                              data);
          
          strRet = GS.templateShowSubTemplates(strRet, jsnTemplate);
          
          //console.log(strRet);
          
          return strRet;
      }
      
      
      // #################################################################
      // ########################### UTILITIES ###########################
      // #################################################################
      
      function addMessage(element, strMessageName) {
          if (strMessageName === 'saving') {
              if (element.savingMessage) {
                  removeMessage(element, 'saving');
              }
              element.savingMessage = document.createElement('div');
              element.savingMessage.classList.add('message');
              element.savingMessage.innerHTML = 'Saving...';
              
              element.appendChild(element.savingMessage);
              
          } else if (strMessageName === 'waiting') {
              if (element.waitingMessage) {
                  removeMessage(element, 'waiting');
              }
              element.waitingMessage = document.createElement('div');
              element.waitingMessage.classList.add('message');
              element.waitingMessage.innerHTML = 'Waiting<br />to save...';
              
              element.appendChild(element.waitingMessage);
          }
      }
      
      function removeMessage(element, strMessageName) {
          if (strMessageName === 'saving' && element.savingMessage) {
              element.removeChild(element.savingMessage);
              element.savingMessage = undefined;
              
          } else if (strMessageName === 'waiting' && element.waitingMessage) {
              element.removeChild(element.waitingMessage);
              element.waitingMessage = undefined;
          }
      }
      
      function columnParentsUntilForm(form, element) {
          var intColumnParents = 0, currentElement = element, maxLoops = 50, i = 0;
          
          while (currentElement.parentNode !== form && currentElement.parentNode && i < maxLoops) {
              if (currentElement.parentNode.hasAttribute('column') === true //If something with a column attribute
                  || currentElement.parentNode.hasAttribute('src') === true) { //or something with a src attribute
                  intColumnParents += 1;
              }
              
              currentElement = currentElement.parentNode;
              i += 1;
          }
          
          return intColumnParents;
      }
      
      //function pushReplacePopHandler(element) {
      //    var i, len, arrPopKeys, bolRefresh = false, currentValue, strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
      //    
      //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.setAttribute('where', 'id=' + GS.qryGetVal(strQueryString, strQSCol));
      //        bolRefresh = true;
      //        
      //    } else if (element.hasAttribute('refresh-on-querystring-values')) {
      //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
      //        
      //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
      //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
      //            
      //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
      //                bolRefresh = true;
      //            }
      //            
      //            element.popValues[arrPopKeys[i]] = currentValue;
      //        }
      //        
      //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
      //        bolRefresh = true;
      //    }
      //    
      //    if (bolRefresh) {
      //        element.refresh();
      //    }
      //}
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          arrAttr = element.attributes;
          i = 0;
          len = arrAttr.length;
          while (i < len) {
              jsnAttr = arrAttr[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var arrPopKeys;
          var currentValue;
          var bolRefresh;
          var strOperator;
  
          if (strQSCol) {
              if (strQSCol.indexOf('=') !== -1) {
                  arrAttrParts = strQSCol.split(',');
                  i = 0;
                  len = arrAttrParts.length;
                  while (i < len) {
                      strQSCol = arrAttrParts[i];
      
                      if (strQSCol.indexOf('!=') !== -1) {
                          strOperator = '!=';
                          arrQSParts = strQSCol.split('!=');
                      } else {
                          strOperator = '=';
                          arrQSParts = strQSCol.split('=');
                      }
      
                      strQSCol = arrQSParts[0];
                      strQSAttr = arrQSParts[1] || arrQSParts[0];
      
                      // if the key is not present or we've got the negator: go to the attribute's default or remove it
                      if (strOperator === '!=') {
                          // if the key is not present: add the attribute
                          if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                              element.setAttribute(strQSAttr, '');
                          // else: remove the attribute
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      } else {
                          // if the key is not present: go to the attribute's default or remove it
                          if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                              if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                  element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                              } else {
                                  element.removeAttribute(strQSAttr);
                              }
                          // else: set attribute to exact text from QS
                          } else {
                              element.setAttribute(strQSAttr, (
                                  GS.qryGetVal(strQS, strQSCol) ||
                                  element.internal.defaultAttributes[strQSAttr] ||
                                  ''
                              ));
                          }
                      }
                      i += 1;
                  }
              } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                  strQSValue = GS.qryGetVal(strQS, strQSCol);
      
                  if (element.internal.bolQSFirstRun !== true) {
                      console.log(element.getAttribute('value'));
                      if (strQSValue !== '' || !element.getAttribute('value')) {
                          element.setAttribute('where', 'id=' + (isNaN(strQSValue) ? '$WHEREQuoTE$' + strQSValue + '$WHEREQuoTE$' : strQSValue));
                          bolRefresh = true;
                      }
                  } else {
                      element.setAttribute('where', 'id=' + (isNaN(strQSValue) ? '$WHEREQuoTE$' + strQSValue + '$WHEREQuoTE$' : strQSValue));
                      bolRefresh = true;
                  }
              }
          }
          
          // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
          if (element.internal.bolQSFirstRun === true) {
              if (element.hasAttribute('refresh-on-querystring-values')) {
                  arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                  
                  for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                      currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);
                      
                      if (element.popValues[arrPopKeys[i]] !== currentValue) {
                          bolRefresh = true;
                      }
                      
                      element.popValues[arrPopKeys[i]] = currentValue;
                  }
              } else if (element.hasAttribute('refresh-on-querystring-change')) {
                  bolRefresh = true;
              }
          } else {
              if (element.hasAttribute('refresh-on-querystring-values')) {
                  arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                  
                  for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                      element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                  }
              }
              
              if (GS.getQueryString() || element.hasAttribute('refresh-on-querystring-change') || element.hasAttribute('src')) {
                  bolRefresh = true;
              }
          }
          
          if (bolRefresh && element.hasAttribute('src')) {
              getData(element);
          } else if (bolRefresh && !element.hasAttribute('src')) {
              console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
          }
          
          element.internal.bolQSFirstRun = true;
      }
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              
          }
      }
      
      //
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              if (element.children.length === 0) {
                  throw 'GS-Form Error: No template provided';
              }
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
                  
                  var //templateElement = document.createElement('template'),
                      //templateElementSubTemplateSafe = document.createElement('template'),
                      firstChildElement = element.children[0],
                      //arrElements, i, len, arrColumnElement, arrTemplates,
                      strQueryString = GS.getQueryString(), changeHandler;
                  
                  // if this form has the "save-while-typing" attribute
                  if (element.hasAttribute('save-while-typing')) {
                      GS.addBeforeUnloadEvent(function () {
                          if (element.bolCurrentlySaving || element.saveTimerID) {
                              return 'The page has not finished saving.';
                          }
                      });
                  } else {
                      // this prevents the issue where you type in a change but then unload
                      //      the page without causing a change event to fire, which means you lose your change
                      GS.addBeforeUnloadEvent(function () {
                          document.activeElement.blur();
                      });
                  }
                  
                  // lock attribute and defaulting
                  element.lockColumn = element.getAttribute('lock') || 'change_stamp';
                  
                  // if the first child is a template element: save its HTML
                  if (firstChildElement.nodeName === 'TEMPLATE') {
                      element.templateHTML = firstChildElement.innerHTML;
                      
                  // else: save the innerHTML of the form and send a warning
                  } else {
                      console.warn('Warning: gs-form is now built to use a template element. ' +
                                   'Please use a template element to contain the template for this form. ' + // this warning was added: March 12th 2015
                                   'A fix has been included so that it is not necessary to use the template element, but that code may be removed at a future date.');
                      
                      element.templateHTML = element.innerHTML;
                  }
                  
                  // if there is no HTML: throw an error
                  if (!element.templateHTML.trim()) { throw 'GS-FORM error: no template HTML.'; }
                  
                  if (element.templateHTML.indexOf('&gt;') > -1 || element.templateHTML.indexOf('&lt;') > -1) {
                      console.warn('GS-FORM WARNING: &gt; or &lt; detected in record template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                  }
                  
                  // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                  element.templateHTML = GS.templateColumnToValue(element.templateHTML);
                  
                  // handle "qs" attribute
                  if (element.getAttribute('qs') ||
                          element.getAttribute('refresh-on-querystring-values') ||
                          element.hasAttribute('refresh-on-querystring-change')) {
                      element.popValues = {};
                      
                      //if (element.getAttribute('qs')) {
                      //    if (GS.qryGetVal(strQueryString, element.getAttribute('qs'))) {
                      //        element.setAttribute('where', 'id=' + GS.qryGetVal(strQueryString, element.getAttribute('qs')));
                      //    } else {
                      //        element.setAttribute('where', 'false');
                      //    }
                      //}
                      
                      //if (GS.getQueryString() || element.hasAttribute('refresh-on-querystring-change')) {
                      pushReplacePopHandler(element);
                      //}
                      
                      window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                      window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                      window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                  } else {
                      getData(element);
                  }
                  
                  element.addEventListener('keydown', function (event) {
                      var intKeyCode = event.which || event.keyCode, jsnSelection;
                      
                      if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                          jsnSelection = GS.getInputSelection(event.target);
                      }
                      
                      if ((intKeyCode === 37 && (!jsnSelection || jsnSelection.start === 0)) ||
                          (intKeyCode === 39 && (!jsnSelection || jsnSelection.end === event.target.value.length))) {
                          var focusToElement, i, len, arrElementsFocusable, currentElement;
                          //Left
                          if (intKeyCode === 37 && (!jsnSelection || jsnSelection.start === 0)) {
                              arrElementsFocusable = xtag.query(document, 'input:not([disabled]), ' +
                                  'select:not([disabled]), memo:not([disabled]), button:not([disabled]), ' +
                                  '[tabindex]:not([disabled]), [column]');
                              
                              for (i = 0,len = arrElementsFocusable.length;i < len;i++) {
                                  currentElement = arrElementsFocusable[i];
                                  //console.log(currentElement === event.target, currentElement, event.target);
                                  if (currentElement === event.target ||
                                      ((event.target.nodeName === 'INPUT' || event.target.nodeName === 'TEXTAREA') &&
                                      currentElement === event.target.parentNode)) {
                                      if (i === 0) {
                                          focusToElement = currentElement;
                                      } else {
                                          focusToElement = arrElementsFocusable[i - 1];
                                      }
                                      break;
                                  }
                              }
                              //console.log(focusToElement);
                          //Right
                          } else if (intKeyCode === 39 && (!jsnSelection || jsnSelection.end === event.target.value.length)) {
                              arrElementsFocusable = xtag.query(document, 'input:not([disabled]), ' +
                                  'select:not([disabled]), memo:not([disabled]), button:not([disabled]), ' +
                                  '[tabindex]:not([disabled]), [column]');
                              
                              for (i = 0,len = arrElementsFocusable.length;i < len;i++) {
                                  currentElement = arrElementsFocusable[i];
                                  if (currentElement === event.target) {
                                      if (i === len) {
                                          focusToElement = currentElement;
                                      } else {
                                          focusToElement = arrElementsFocusable[i + 1];
                                      }
                                      break;
                                  }
                              }
                          }
                          
                          //console.log('focusable', GS.isElementFocusable(focusToElement));
                          if (focusToElement && GS.isElementFocusable(focusToElement)) {
                              //console.log('focus');
                              event.preventDefault();
                              
                              focusToElement.focus();
                              
                              if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                                  GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
                              }
                          }
                      }
                  });
                  
                  // bind save code
                  if (element.hasAttribute('save-while-typing')) {
                      element.bolCurrentlySaving = false;
                      element.jsnUpdate = {};
                      element.state = 'saved';
                      //element.currentSaveAjax = false;
                      
                      // possible states:
                      //      'saved'
                      //      'waiting to save'
                      //      'saving'
                      
                      // JSON object for holding columns to update
                      // on keydown, keyup, change add to JSON object
                      // keep updating until all columns have been saved (undefined marks an empty column)
                      
                      changeHandler = function (event) {
                          var intKeyCode = event.which || event.keyCode, newValue,
                              targetColumnParent = GS.findParentElement(event.target, '[column]'),
                              parentRecordElement, strID;
                          
                          //console.log(event.target, targetColumnParent);
                          
                          if (targetColumnParent.getAttribute('column') && columnParentsUntilForm(element, targetColumnParent) === 0 &&
                              element.column(targetColumnParent.getAttribute('column')) !== targetColumnParent.value) {
                              
                              //event.stopPropagation();
                              if (element.saveTimerID) {
                                  clearTimeout(element.saveTimerID);
                                  element.saveTimerID = undefined;
                              }
                              
                              addMessage(element, 'waiting');
                              element.state = 'waiting to save';
                              
                              if (targetColumnParent.value !== null && targetColumnParent.value !== null) {
                                  newValue = targetColumnParent.value;
                              } else {
                                  newValue = targetColumnParent.checked;
                              }
                              
                              parentRecordElement = GS.findParentElement(targetColumnParent, '.form-record[data-id]');
                              strID = parentRecordElement.getAttribute('data-id');
                              
                              if (!element.jsnUpdate[strID]) {
                                  element.jsnUpdate[strID] = element.jsnUpdate[strID] = {};
                              }
                              element.jsnUpdate[strID][targetColumnParent.getAttribute('column')] = newValue;
                              
                              element.saveTimerID = setTimeout(function () {
                                  updateDataWithoutTemplate(element);
                                  element.saveTimerID = undefined;
                              }, 300);
                          }
                      };
                      
                      element.addEventListener('keydown', changeHandler);
                      element.addEventListener('keyup', changeHandler);
                      element.addEventListener('change', changeHandler);
                      
                  } else {
                      element.addEventListener('change', function (event) {
                          var newValue;
                          
                          if (event.target.getAttribute('column')
                                  && columnParentsUntilForm(element, event.target) === 0
                                  && GS.findParentTag(event.target, 'gs-form') === element) {
                              //event.stopPropagation();
                              
                              if (event.target.value !== null) {
                                  newValue = event.target.value;
                              } else {
                                  newValue = event.target.checked;
                              }
                              
                              updateData(element, event.target, event.target.getAttribute('column'), newValue);
                          }
                      });
                  }
              }
          }
      }
      
      xtag.register('gs-form', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      // attribute code
                  }
              },
              
              removed: function () {
                  if (this.hasAttribute('save-while-typing') && this.saveTimerID) {
                      clearTimeout(this.saveTimerID);
                      emergencyUpdate(this);
                  }
              }
          },
          events: {},
          accessors: {},
          methods: {
              refresh: function () {
                  getData(this);
              },
              
              column: function (strColumn) {
                  //console.log(this.lastSuccessData);
                  return GS.envGetCell(this.lastSuccessData, 0, strColumn);
              },
              
              addMessage: function (strMessageName) {
                  return addMessage(this, strMessageName);
              },
              removeMessage: function (strMessageName) {
                  return removeMessage(this, strMessageName);
              }
          }
      });
  });
  window.addEventListener('design-register-element', function () {
      'use strict';
      registerDesignSnippet('<gs-grid>', '<gs-grid>', 'gs-grid widths="${1}">\n' +
                                                      '    <gs-block>${2}</gs-block>\n' +
                                                      '</gs-grid>');
  
      designRegisterElement('gs-grid', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-grid.html');
  
      window.designElementProperty_GSGRID = function(selectedElement) {
          addProp('Min-Width Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('min-width') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'min-width', this.value);
          });
  
          addProp('Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('media') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'media', this.value);
          });
  
          addProp('Widths', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('widths') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'widths', this.value);
          });
  
          addProp('Padded', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('padded')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'padded', (this.value === 'true'), true);
          });
  
          addProp('Gutters', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('gutter')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'gutter', (this.value === 'true'), true);
          });
  
          addProp('Reflow At', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('reflow-at') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'reflow-at', this.value);
          });
  
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  window.addEventListener('design-register-element', function () {
      'use strict';
  
      registerDesignSnippet('<gs-block>', '<gs-block>', 'gs-block>${2}</gs-block>');
  
      designRegisterElement('gs-block', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-grid.html');
  
      window.designElementProperty_GSBLOCK = function(selectedElement) {
          addProp('Width:', true, '<gs-text class="target" value="' + (selectedElement.getAttribute('width') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'width', this.value);
          });
  
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + (selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          addFlexContainerProps(selectedElement);
          //addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      var arrTakenGrids = [];
      
      function handleObserver(element) {
          var observer = new MutationObserver(function(mutations) {
              element.handleBlocks();
          });
          
          observer.observe(element, {childList: true});
      }
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              handleObserver(element);
          }
      }
  
      //
      function elementInserted(element) {
          var styleElement;
  
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
  
                  // if the style element for the grid column CSS doesn't exist: create it
                  if (!document.getElementById('gs-dynamic-css')) {
                      styleElement = document.createElement('style');
                      styleElement.setAttribute('id', 'gs-dynamic-css');
                      styleElement.setAttribute('gs-dynamic', '');
                      document.head.appendChild(styleElement);
                  }
  
                  // if no width parameter is set: default
                  if (!element.getAttribute('widths') && !element.getAttribute('min-width') && !element.getAttribute('media')) {
                      element.bolIgnoreAttribute = true;
                      element.setAttribute('widths', new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                      .join('1').split('').join(','));
                      element.bolIgnoreAttribute = false;
                  }
  
                  element.handleCSS();
                  element.handleBlocks();
              }
          }
      }
      
      xtag.register('gs-grid', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      // if the "widths" attribute changed
                      if (strAttrName === 'widths' && this.bolIgnoreAttribute !== true) {
                          this.handleCSS();
                          this.handleBlocks();
                          
                      // if the "reflow-at" attribute changed
                      } else if (strAttrName === 'reflow-at') {
                          this.handleCSS();
                          
                      // if the "min-width" attribute changed
                      } else if (strAttrName === 'min-width') {
                          this.handleCSS();
                          this.handleBlocks();
                          
                      // if the "media" attribute changed
                      } else if (strAttrName === 'media') {
                          this.handleCSS();
                          this.handleBlocks();
                      }
                  }
              }
          },
          events: {},
          accessors: {},
          methods: {
              
              getWidthsParameters: function (strWidths) {
                  var arrWidths, intGridWidth, i, len;
                  
                  arrWidths = strWidths
                          .replace(/[^0-9,]/gim, '') // remove everything except commas and numbers
                          .replace(/,{1,}/gim, ',')  // replace multiple commas right next to each other with a single comma
                          .replace(/^,|,$/gim, '')   // remove commas at the end and the beginning of the line
                          .split(',');               // split on commas to make an array of numbers (which are currently type 'string')
                  
                  // if the array doesn't have content: error
                  if (arrWidths.length === 0) {
                      throw 'gs-grid Error: no valid widths found. Please put a comma seperated list of widths in the "widths" attribute.';
                  }
                  
                  // convert the array of strings to an array of integers
                  for (i = 0, len = arrWidths.length; i < len; i += 1) {
                      arrWidths[i] = parseInt(arrWidths[i], 10);
                  }
                  
                  // add up the array of integers to come up with a grid width
                  for (i = 0, len = arrWidths.length, intGridWidth = 0; i < len; i += 1) {
                      intGridWidth += arrWidths[i];
                  }
                  
                  return {
                      'arrWidths': arrWidths,
                      'intGridWidth': intGridWidth
                  };
              },
              
              handleCSS: function () {
                  var jsnWidthsParameters;
                  
                  if (this.getAttribute('widths')) {
                      jsnWidthsParameters = this.getWidthsParameters(this.getAttribute('widths'));
                      
                      this.handleWidthsCSS(jsnWidthsParameters.arrWidths, jsnWidthsParameters.intGridWidth);
                      
                  } else if (this.getAttribute('min-width')) {
                      this.handleMinWidthCSS();
                      
                  } else if (this.getAttribute('media')) {
                      this.handleMediaCSS();
                  }
              },
              
              handleBlocks: function () {
                  var jsnWidthsParameters;
                  
                  if (this.getAttribute('widths')) {
                      jsnWidthsParameters = this.getWidthsParameters(this.getAttribute('widths'));
                      
                      this.handleWidthsBlocks(jsnWidthsParameters.arrWidths, jsnWidthsParameters.intGridWidth);
                      
                  } else if (this.getAttribute('min-width')) {
                      this.handleMinWidthBlocks();
                      
                  } else if (this.getAttribute('media')) {
                      this.handleMediaBlocks();
                  }
              },
              
              
              
              
              handleWidthsCSS: function (arrWidths, intGridWidth) {
                  var styleElement = document.getElementById('gs-dynamic-css'),
                      i, len, strCurrentWidth, intCurrentWidth, widthIncreaseAmount, strCSS,
                      strReflowAt = this.getAttribute('reflow-at') || '', arrClassesToRemove;
                  
                  // reflow-at shortcuts
                  strReflowAt = strReflowAt.replace(/small|sml/g,  '992px');
                  strReflowAt = strReflowAt.replace(/medium|med/g, '1200px');
                  strReflowAt = strReflowAt.replace(/large|lrg/g,  '10000px');
                  
                  // remove old classes
                  arrClassesToRemove = String(this.classList).match(/width-[0-9]*/g) || [];
                  
                  for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                      this.classList.remove(arrClassesToRemove[i]);
                  }
                  
                  // make sure that this grid hasn't been done before
                  if (!styleElement.classList.contains('col-' + intGridWidth)) {
                      // column CSS
                      
                      // calculate the amount to increase every block width setting by
                      widthIncreaseAmount = 100 / intGridWidth;
                      
                      // create a style for every block
                      for (i = 0, len = intGridWidth, intCurrentWidth = 0, strCSS = ''; i < len; i += 1) {
                          intCurrentWidth += widthIncreaseAmount;
                          strCurrentWidth = String(parseFloat(intCurrentWidth.toFixed(5).toString(), 10));
                          
                          strCSS += 'gs-grid.width-' + intGridWidth + ' > gs-block[width="' + (i + 1) + '"] { width: ' + strCurrentWidth + '%; }\n';
                      }
                      
                      // add col-NUM to the styleElement's "class" attribute
                      styleElement.classList.add('col-' + intGridWidth);
                      
                      // append the column CSS
                      styleElement.innerHTML += '\n/* grid width: ' + intGridWidth + ' */\n' +
                                                strCSS +
                                                'gs-grid.width-' + intGridWidth + ' > gs-block.first-of-row { padding-left: 0; }\n' +
                                                'gs-grid.width-' + intGridWidth + ' > gs-block.last-of-row { padding-right: 0; }\n';
                  }
                  
                  // reflow CSS
                  
                  // remove class from the gs-grid that allowed the generated reflow CSS to apply
                  this.classList.remove('reflow-' + this.strReflowAt);
                  
                  // clean reflow-at attribute variable
                  strReflowAt = strReflowAt.replace(/[^0-9a-z]/gi, '');
                  
                  // if reflow-at contains anything
                  if (strReflowAt) {
                      // if reflow-at doesn't have a unit specified: add 'px' to the end of it
                      if (strReflowAt.replace(/[0-9]/gi, '') === '') {
                          strReflowAt += 'px';
                      }
                      
                      // save the current reflow width so that we can use it later
                      this.strReflowAt = strReflowAt;
                      
                      // add class to the gs-grid so that the generated reflow CSS will apply
                      this.classList.add('reflow-' + strReflowAt);
                      
                      // if the reflow CSS for this grid width doesn't already exist: append it
                      if (!styleElement.classList.contains('reflow-' + strReflowAt)) {
                          
                          // add reflow-SIZE to the styleElement's "class" attribute
                          styleElement.classList.add('reflow-' + strReflowAt);
                          
                          // append the reflow CSS
                          styleElement.innerHTML += '\n/* grid reflow width: ' + strReflowAt + ' */\n' +
                                                    '@media only all and (max-width: ' + strReflowAt + ') {\n' +
                                                    '    gs-grid.reflow-' + strReflowAt + '            { width: 100%; }\n' +
                                                    '    gs-grid.reflow-' + strReflowAt + ' > gs-block { width: auto !important; float: none; }\n' +
                                                    '    gs-grid.reflow-' + strReflowAt + ' > gs-block { padding-left: 0 !important; padding-right: 0 !important; }\n' +
                                                    '}\n';
                      }
                  }
                  
                  // apply CSS for blocks
                  this.classList.add('width-' + intGridWidth);
              },
              
              handleMinWidthCSS: function () {
                  var strMinWidth = this.getAttribute('min-width'), arrMinWidths, strCSS, strCurrentCSS,
                      i, len, arrParts, strWidth, strResult, intCurrentGridID, bolMedia, intCurrentWidth,
                      strCurrentWidth, intGridWidth, widthIncreaseAmount, grid_i, grid_len, intLayout, arrArrGridWidths,
                      column_i, column_len, arrWidths = [], width_i, strNextWidth;
                  
                  // 0 {1,1}; 1000 {2,1}; 10000 {2,1}; 12000 {1,1}
                  // all {reflow}; sml {1,1}; med {1,1,1}; lrg {reflow}
                  
                  strMinWidth = strMinWidth.replace(/\s+/g, ''); // remove all whitespace
                  strMinWidth = strMinWidth.replace(/\}/g, ''); // remove all close curly braces
                  strMinWidth = strMinWidth.toLowerCase(); // lowercase
                  strMinWidth = GS.trim(strMinWidth, ';'); // trim off semicolons
                  
                  // replace shortcuts (lrg => 1200px)
                  strMinWidth = strMinWidth.replace(/all/g,        '0px');
                  strMinWidth = strMinWidth.replace(/small|sml/g,  '768px');
                  strMinWidth = strMinWidth.replace(/medium|med/g, '992px');
                  strMinWidth = strMinWidth.replace(/large|lrg/g,  '1200px');
                  
                  arrMinWidths = strMinWidth.split(';'); // seperate out layouts
                  
                  //console.log(strMinWidth, arrMinWidths);
                  
                  if (arrTakenGrids.indexOf(strMinWidth) === -1) {
                      arrTakenGrids.push(strMinWidth);
                      intCurrentGridID = arrTakenGrids.length - 1;
                      strCSS = '';
                      arrArrGridWidths = [];
                      
                      for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                          arrParts = arrMinWidths[i].split('{');
                          strWidth = arrParts[0] || '0px';
                          strResult = arrParts[1] || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                      .join('1').split('').join(',');
                          bolMedia = parseInt(strWidth) > 0;
                          strCurrentCSS = '';
                          
                          if (strResult === 'reflow') {
                              intLayout += 1;
                              arrArrGridWidths.push('reflow');
                              
                              // reflow css
                              strCurrentCSS += 
                                  '    gs-grid.grid-id-' + intCurrentGridID + '            { width: 100%; }\n' +
                                  '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                              ' { width: auto; float: none; }\n' +
                                  '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                              ' { padding-left: 0; padding-right: 0; }\n';
                              
                          } else {
                              intLayout += 1;
                              arrArrGridWidths.push(strResult.split(','));
                              
                              // grid css
                              intGridWidth = this.getWidthsParameters(strResult).intGridWidth;
                              
                              // calculate the amount to increase every block width setting by
                              widthIncreaseAmount = 100 / intGridWidth;
                              
                              // create a style for every block
                              for (grid_i = 0, grid_len = intGridWidth, intCurrentWidth = 0; grid_i < grid_len; grid_i += 1) {
                                  intCurrentWidth += widthIncreaseAmount;
                                  strCurrentWidth = String(parseFloat(intCurrentWidth.toFixed(5).toString(), 10));
                                  
                                  strCurrentCSS += '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.width-' + (grid_i + 1) + '-layout-' + intLayout + ' { ' +
                                                       'width: ' + strCurrentWidth + '%; float: left; ' +
                                                   '}\n';
                              }
                              
                              strCurrentCSS =
                                  '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.clearfix-layout-' + intLayout +
                                              ' { clear: left; }\n\n' +
                                  '    gs-grid.grid-id-' + intCurrentGridID + '[gutter] > gs-block { padding-left: 0.5em; padding-right: 0.5em; }\n\n' +
                                  '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.first-of-row-layout-' + intLayout +
                                              ' { padding-left: 0; }\n\n' +
                                  '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.last-of-row-layout-' + intLayout +
                                              ' { padding-right: 0; }\n\n' +
                                  strCurrentCSS;
                          }
                          
                          //if (bolMedia) {
                          strNextWidth = '';
                          if (arrMinWidths[i + 1]) {
                              strNextWidth = arrMinWidths[i + 1].split('{')[0];
                              
                              // subtract 1 from the next width so that max-width doesn't allow the
                              //      media to apply at the same time as the next media
                              strNextWidth = (parseInt(strNextWidth) - 1) + strNextWidth.replace(/[0-9]/g, '');
                          }
                          
                          strCurrentCSS = '\n@media (min-width:' + strWidth + ')' + (strNextWidth ? ' and (max-width:' + strNextWidth + ')' : '') + ' {\n' +
                                              strCurrentCSS +
                                          '}\n';
                          //}
                          
                          strCSS += strCurrentCSS;
                      }
                      //console.log(strCSS);
                      
                      // append the column CSS
                      document.getElementById('gs-dynamic-css').innerHTML += '\n/* grid #' + intCurrentGridID + ' */\n' + strCSS;
                      
                  } else {
                      intCurrentGridID = arrTakenGrids.indexOf(strMinWidth);
                      arrArrGridWidths = [];
                      
                      for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                          arrParts = arrMinWidths[i].split('{');
                          strWidth = arrParts[0] || '0px';
                          strResult = arrParts[1] || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                      .join('1').split('').join(',');
                          
                          intLayout += 1;
                          
                          if (strResult !== 'reflow') {
                              arrArrGridWidths.push(strResult.split(','));
                          } else {
                              arrArrGridWidths.push('reflow');
                          }
                      }
                  }
                  
                  //
                  this.intLayouts = intLayout;
                  this.arrArrWidths = arrArrGridWidths;
                  
                  for (i = 0, len = this.arrArrWidths.length; i < len; i += 1) {
                      if (this.arrArrWidths[i] !== 'reflow') {
                          arrWidths.push(0);
                          width_i = arrWidths.length - 1;
                          
                          for (column_i = 0, column_len = this.arrArrWidths[i].length; column_i < column_len; column_i += 1) {
                              this.arrArrWidths[i][column_i] = parseInt(this.arrArrWidths[i][column_i], 10);
                              arrWidths[width_i] += 1;
                          }
                      } else {
                          arrWidths.push('reflow');
                      }
                  }
                  
                  this.arrWidths = arrWidths;
                  
                  // add class so that the CSS can apply
                  this.classList.add('grid-id-' + intCurrentGridID);
              },
              
              handleMediaCSS: function () {
                  var strMinWidth = this.getAttribute('media'), arrMinWidths, strCSS, strCurrentCSS,
                      i, len, arrParts, strMedia, strResult, intCurrentGridID, bolMedia, intCurrentWidth,
                      strCurrentWidth, intGridWidth, widthIncreaseAmount, grid_i, grid_len, intLayout, arrArrGridWidths,
                      column_i, column_len, arrWidths = [], width_i;
                  
                  strMinWidth = strMinWidth.trim().replace(/\}/g, ''); // remove all close curly braces
                  strMinWidth = strMinWidth.toLowerCase(); // lowercase
                  strMinWidth = GS.trim(strMinWidth, ';'); // trim off semicolons
                  
                  // all {reflow}; all and (min-width: small) {2,2,2}; all and (min-width: med) {3,3}; all and (min-width: large) {reflow};
                  
                  // replace shortcuts (lrg => 1200px)
                  strMinWidth = strMinWidth.replace(/small|sml/g,  '768px');
                  strMinWidth = strMinWidth.replace(/medium|med/g, '992px');
                  strMinWidth = strMinWidth.replace(/large|lrg/g,  '1200px');
                  
                  arrMinWidths = strMinWidth.split(';'); // seperate out layouts
                  
                  if (arrTakenGrids.indexOf(strMinWidth) === -1) {
                      arrTakenGrids.push(strMinWidth);
                      intCurrentGridID = arrTakenGrids.length - 1;
                      strCSS = '';
                      arrArrGridWidths = [];
                      
                      //console.log(strMinWidth, arrMinWidths);
                      
                      for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                          arrParts = arrMinWidths[i].split('{');
                          strMedia = arrParts[0].trim() || 'all';
                          strResult = arrParts[1].trim() || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                      .join('1').split('').join(',');
                          strCurrentCSS = '';
                          
                          if (strResult === 'reflow') {
                              intLayout += 1;
                              arrArrGridWidths.push('reflow');
                              
                              // reflow css
                              strCurrentCSS += 
                                  '    gs-grid.grid-id-' + intCurrentGridID + '            { width: 100%; }\n' +
                                  '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                              ' { width: auto; float: none; }\n' +
                                  '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                              ' { padding-left: 0; padding-right: 0; }\n';
                              
                          } else {
                              intLayout += 1;
                              arrArrGridWidths.push(strResult.split(','));
                              
                              // grid css
                              intGridWidth = this.getWidthsParameters(strResult).intGridWidth;
                              
                              // calculate the amount to increase every block width setting by
                              widthIncreaseAmount = 100 / intGridWidth;
                              
                              // create a style for every block
                              for (grid_i = 0, grid_len = intGridWidth, intCurrentWidth = 0; grid_i < grid_len; grid_i += 1) {
                                  intCurrentWidth += widthIncreaseAmount;
                                  strCurrentWidth = String(parseFloat(intCurrentWidth.toFixed(5).toString(), 10));
                                  
                                  strCurrentCSS += '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.width-' + (grid_i + 1) + '-layout-' + intLayout + ' { ' +
                                                       'width: ' + strCurrentWidth + '%; float: left; ' +
                                                   '}\n';
                              }
                              
                              strCurrentCSS =
                                  '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.clearfix-layout-' + intLayout +
                                              ' { clear: left; }\n\n' +
                                  '    gs-grid.grid-id-' + intCurrentGridID + '[gutter] > gs-block { padding-left: 0.5em; padding-right: 0.5em; }\n\n' +
                                  '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.first-of-row-layout-' + intLayout +
                                              ' { padding-left: 0; }\n\n' +
                                  '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.last-of-row-layout-' + intLayout +
                                              ' { padding-right: 0; }\n\n' +
                                  strCurrentCSS;
                          }
                          
                          strCurrentCSS = '\n@media ' + strMedia + ' {\n' +
                                              strCurrentCSS +
                                          '}\n';
                          
                          strCSS += strCurrentCSS;
                      }
                      
                      // append the column CSS
                      document.getElementById('gs-dynamic-css').innerHTML += '\n/* grid #' + intCurrentGridID + ' */\n' + strCSS;
                      
                  } else {
                      intCurrentGridID = arrTakenGrids.indexOf(strMinWidth);
                      arrArrGridWidths = [];
                      
                      for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                          arrParts = arrMinWidths[i].split('{');
                          strWidth = arrParts[0] || '0px';
                          strResult = arrParts[1] || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                      .join('1').split('').join(',');
                          
                          intLayout += 1;
                          
                          if (strResult !== 'reflow') {
                              arrArrGridWidths.push(strResult.split(','));
                          } else {
                              arrArrGridWidths.push('reflow');
                          }
                      }
                  }
                  
                  //
                  this.intLayouts = intLayout;
                  this.arrArrWidths = arrArrGridWidths;
                  
                  for (i = 0, len = this.arrArrWidths.length; i < len; i += 1) {
                      if (this.arrArrWidths[i] !== 'reflow') {
                          arrWidths.push(0);
                          width_i = arrWidths.length - 1;
                          
                          for (column_i = 0, column_len = this.arrArrWidths[i].length; column_i < column_len; column_i += 1) {
                              this.arrArrWidths[i][column_i] = parseInt(this.arrArrWidths[i][column_i], 10);
                              arrWidths[width_i] += 1;
                          }
                      } else {
                          arrWidths.push('reflow');
                      }
                  }
                  
                  this.arrWidths = arrWidths;
                  
                  //
                  this.classList.add('grid-id-' + intCurrentGridID);
              },
              
              
              
              
              
              handleWidthsBlocks: function (arrWidths, intGridWidth) {
                  var i, len, unset_i, arrElements, intNumberOfWidths = arrWidths.length, intCurrentRowWidth = 0, intNextToAdd;
                  
                  // mark initally set blocks
                  arrElements = xtag.queryChildren(this, 'gs-block[width]');
                  
                  for (i = 0, len = arrElements.length; i < len; i += 1) {
                      arrElements[i].initallySet = true;
                  }
                  
                  // get all child blocks
                  arrElements = xtag.queryChildren(this, 'gs-block');
                  
                  // loop through the blocks
                  for (i = 0, unset_i = 0, len = arrElements.length; i < len; i += 1) {
                      intNextToAdd = parseInt(arrElements[i].getAttribute('width'), 10) || arrWidths[unset_i % intNumberOfWidths];
                      
                      // if this block wasn't initally set: remove the width attribute
                      if (!arrElements[i].initallySet) {
                          arrElements[i].removeAttribute('width');
                      }
                      arrElements[i].classList.remove('first-of-row');
                      arrElements[i].classList.remove('last-of-row');
                      arrElements[i].style.clear = '';
                      
                      // if this is the first block in the row
                      if (intCurrentRowWidth === 0) {
                          // set the clear to left, this fixes an issue where a tall cell will move a cell over to the right
                          arrElements[i].style.clear = 'left';
                          arrElements[i].classList.add('first-of-row');
                      }
                      
                      // if this is the last block in the row
                      //console.log(intCurrentRowWidth, intNextToAdd, intGridWidth);
                      if ((intCurrentRowWidth + intNextToAdd) === intGridWidth) {
                          arrElements[i].classList.add('last-of-row');
                      }
                      
                      // if this block doesn't have a set width: set its width (if there are more unset width blocks than widths: the widths repeat)
                      if (!arrElements[i].hasAttribute('width')) {
                          arrElements[i].setAttribute('width', arrWidths[unset_i % intNumberOfWidths]);
                          unset_i += 1;
                      }
                      
                      intCurrentRowWidth += intNextToAdd;
                      intCurrentRowWidth = intCurrentRowWidth % intGridWidth;
                  }
              },
              
              
              
              iterateBlocks: function (intLayouts, arrArrWidths, arrIntGridWidth) {
                  var arrBlocks = xtag.queryChildren(this, 'gs-block'), i, len, block_i, block_len, width_i;
                  
                  for (i = 0, len = intLayouts; i < len; i += 1) {
                      width_i = 0;
                      
                      //console.log(arrArrWidths[i]);
                      if (arrArrWidths[i] !== 'reflow') {
                          for (block_i = 0, block_len = arrBlocks.length; block_i < block_len; block_i += 1) {
                              // if this is the first block in the row:
                              //      set the clear to left, this fixes an issue where a tall cell will move a cell over to the right
                              if (width_i === 0) {
                                  arrBlocks[block_i].classList.add('clearfix-layout-' + (i + 1));
                                  arrBlocks[block_i].classList.add('first-of-row-layout-' + (i + 1));
                              } else if ((width_i + 1) === arrIntGridWidth[i]) {
                                  arrBlocks[block_i].classList.add('last-of-row-layout-' + (i + 1));
                              }
                              
                              arrBlocks[block_i].classList.add('width-' + arrArrWidths[i][width_i] + '-layout-' + (i + 1));
                              
                              //console.log(width_i, arrArrWidths[i][width_i], arrIntGridWidth[i]);
                              width_i += 1;
                              width_i = width_i % arrIntGridWidth[i];
                          }
                      } else {
                          for (block_i = 0, block_len = arrBlocks.length; block_i < block_len; block_i += 1) {
                              arrBlocks[block_i].classList.add('reflow-layout-' + (i + 1));
                          }
                      }
                  }
                  
                  
              },
              
              handleMinWidthBlocks: function () {
                  this.iterateBlocks(this.intLayouts, this.arrArrWidths, this.arrWidths);
              },
              
              handleMediaBlocks: function () {
                  this.iterateBlocks(this.intLayouts, this.arrArrWidths, this.arrWidths);
              }
          }
      });
      
      xtag.register('gs-block', {
          lifecycle: {},
          events: {},
          accessors: {},
          methods: {}
      });
  });window.addEventListener('design-register-element', function () {
      window.designElementProperty_GSGROUP = function (selectedElement) {
          // DISABLED attribute
          addProp('Padded', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('padded') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'padded', this.value === 'true', true);
          });
      };
  });
  
  //global xtag
  //jslint browser:true
  document.addEventListener("DOMContentLoaded", function () {
      "use strict";
      // fill gs-group based on current content
      function buildElement(element) {
          var rootBox = document.createElement("div");
          var innerBox = document.createElement("gs-groupborder");
          var titleBox = document.createElement("gs-grouptitle");
  
          // fill "innerBox" by transfering all of "element"'s child nodes to it (this includes text nodes)
          var arrElements = xtag.toArray(element.childNodes);
          var i = 0;
          var len = arrElements.length;
  
          while (i < len) {
              innerBox.appendChild(arrElements[i]);
              i += 1;
          }
  
          // fill "titleBox"
          titleBox.textContent = element.getAttribute("name");
  
          // give "rootBox" the class "root"
          rootBox.classList.add("root");
  
          // make "rootBox" flex it's content vertically, and make it fill horizontally
          rootBox.setAttribute("flex-vertical", "");
          rootBox.setAttribute("flex-fill", "");
  
          // make "innerBox" flex to fill height
          innerBox.setAttribute("flex", "");
  
          // mark "titleBox" and "innerBox" as dynamic elements
          //      because we want developers to know that these
          //      are generated
          innerBox.setAttribute("gs-dynamic", "");
          titleBox.setAttribute("gs-dynamic", "");
  
          // append "titleBox" and "innerBox" to "rootBox"
          rootBox.appendChild(innerBox);
          rootBox.appendChild(titleBox);
  
          // append "rootBox" to "element"
          element.appendChild(rootBox);
      }
  
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute("suspend-created") && !element.hasAttribute("suspend-inserted")) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
  
                  if (!element.children[0].classList.contains('root')) {
                      buildElement(element);
                  }
              }
          }
      }
  
      xtag.register("gs-groupborder", {});
      xtag.register("gs-grouptitle", {});
      xtag.register("gs-group", {
          lifecycle: {
              inserted: function () {
                  elementInserted(this);
              },
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  var element = this;
  
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === "suspend-created" && newValue === null) {
                      elementInserted(element);
  
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === "suspend-inserted" && newValue === null) {
                      elementInserted(element);
                  }
                  // else if (!element.hasAttribute("suspend-created") && !element.hasAttribute("suspend-inserted")) {
                  //    // attribute code
                  //}
              }
          },
          events: {},
          accessors: {},
          methods: {}
      });
  });
  window.addEventListener('design-register-element', function () {
      registerDesignSnippet('Centered Header', '<gs-header>', '<gs-header><center><h3>$0</h3></center></gs-header>');
      registerDesignSnippet('Header', '<gs-header>', '<gs-header><h3>$0</h3></gs-header>');
      registerDesignSnippet('<gs-header>', '<gs-header>', 'gs-header><h3>$0</h3></gs-header>');
      
      designRegisterElement('gs-header', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-page.html');
      
      window.designElementProperty_GSHEADER = function(selectedElement) {
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          addFlexContainerProps(selectedElement);
          //addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      xtag.register('gs-header', {
          lifecycle: {
              /*inserted: function () {
                  if (this.border_line) {
                      this.removeChild(this.border_line);
                  }
                  
                  this.border_line = document.createElement('div');
                  this.border_line.classList.add('border-line');
                  this.border_line.setAttribute('gs-dynamic', '');
                  
                  this.appendChild(this.border_line);
              },
              removed: function () {
                  if (this.border_line.parentNode === this) {
                      this.removeChild(this.border_line);
                  }
              }*/
          },
          events: {},
          accessors: {},
          methods: {}
      });
  });
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('<gs-img>', '<gs-img>', 'gs-img src="${1}"></gs-img>');
      
      designRegisterElement('gs-img', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-image.html');
      
      window.designElementProperty_GSIMG = function(selectedElement) {
          addProp('Min-Width Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('min-width') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'min-width', this.value);
          });
          
          addProp('Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('media') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'media', this.value);
          });
          
          addProp('Source', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('src') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'src', this.value);
          });
          
          addProp('Alignment', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('align') || '') + '" mini>' +
                                     '    <option value="left">Left</option>' +
                                     '    <option value="">Center</option>' +
                                     '    <option value="right">Right</option>' +
                                     '</gs-select>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'align', this.value);
          });
          
          addProp('Image Cover', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('image-cover') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'image-cover', this.value === 'true', true);
          });
          
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      var arrTakenlayouts = [];
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              
          }
      }
      
      //
      function elementInserted(element) {
          var styleElement;
          
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  
                  // if the style element for the grid column CSS doesn't exist: create it
                  if (!document.getElementById('gs-dynamic-css')) {
                      styleElement = document.createElement('style');
                      styleElement.setAttribute('id', 'gs-dynamic-css');
                      styleElement.setAttribute('gs-dynamic', '');
                      document.head.appendChild(styleElement);
                  }
                  
                  element.handleSrc();
                  
                  if (element.getAttribute('min-width')) {
                      element.handleMinWidthCSS();
                  } else if (element.getAttribute('media')) {
                      element.handleMediaCSS();
                  }
              }
          }
      }
      
      xtag.register('gs-img', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      // if the "min-width" attribute changed
                      if (strAttrName === 'min-width') {
                          this.handleMinWidthCSS();
                          
                      // if the "media" attribute changed
                      } else if (strAttrName === 'media') {
                          this.handleMediaCSS();
                          
                      // if the "src" attribute changed
                      } else if (strAttrName === 'src') {
                          this.handleSrc();
                      }
                  }
              }
          },
          events: {},
          accessors: {},
          methods: {
              handleSrc: function () {
                  var strSrc = this.getAttribute('src');
                  
                  if (strSrc) {
                      this.style.backgroundImage = 'url("' + strSrc + '")';
                  } else {
                      this.style.backgroundImage = '';
                  }
              },
              
              handleMinWidthCSS: function () {
                  var strMinWidth = this.getAttribute('min-width'), arrLayouts, strCSS, strCurrentMinWidth,
                      i, len, arrClassesToRemove, intImageID, arrParts, strDimensions, strWidth, strHeight;
                  
                  // remove old classes
                  arrClassesToRemove = String(this.classList).match(/image-id-[0-9]*/g) || [];
                  
                  for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                      this.classList.remove(arrClassesToRemove[i]);
                  }
                  
                  // all {150px}; lrg {75px};
                  // all {150px, 75px}; lrg {75px, 150px};
                  
                  // remove all whitespace, remove all close curly braces, lowercase, trim off semicolons
                  strMinWidth = GS.trim(strMinWidth.replace(/\s+/g, '').replace(/\}/g, '').toLowerCase(), ';');
                  
                  // replace shortcuts (lrg => 1200px)
                  strMinWidth = strMinWidth.replace(/all/g, '0px')
                                           .replace(/small|sml/g, '768px')
                                           .replace(/medium|med/g, '992px')
                                           .replace(/large|lrg/g, '1200px');
                  
                  // seperate out layouts
                  arrLayouts = strMinWidth.split(';');
                  
                  //console.log(strMinWidth, arrLayouts);
                  
                  if (arrTakenlayouts.indexOf(strMinWidth) === -1) {
                      arrTakenlayouts.push(strMinWidth);
                      intImageID = arrTakenlayouts.length - 1;
                      strCSS = '';
                      
                      for (i = 0, len = arrLayouts.length; i < len; i += 1) {
                          arrParts = arrLayouts[i].split('{');
                          strCurrentMinWidth = arrParts[0] || '0px';
                          strDimensions = arrParts[1];
                          
                          if (strDimensions.indexOf(',') === -1) {
                              strWidth = strDimensions;
                              strHeight = strDimensions;
                          } else {
                              arrParts = strDimensions.split(',');
                              strWidth = arrParts[0];
                              strHeight = arrParts[1];
                          }
                          
                          strCSS +=   '\n@media (min-width:' + strCurrentMinWidth + ') {\n' +
                                      '    gs-img.image-id-' + intImageID + ' { width:' + strWidth + '; height: ' + strHeight + '; }\n' +
                                      '}\n';
                      }
                      
                      //console.log(strCSS);
                      
                      // append the column CSS
                      document.getElementById('gs-dynamic-css').innerHTML += '\n/* image #' + intImageID + ' */\n' + strCSS;
                      
                  } else {
                      intImageID = arrTakenlayouts.indexOf(strMinWidth);
                  }
                  
                  this.classList.add('image-id-' + intImageID);
              },
              
              handleMediaCSS: function () {
                  var strMedia = this.getAttribute('media'), arrLayouts, strCSS, i, len,
                      arrClassesToRemove, arrParts, strCurrentMedia, strWidth, intImageID,
                      arrParts, strCurrentMedia, strDimensions, strWidth, strHeight;
                  
                  // remove old classes
                  arrClassesToRemove = String(this.classList).match(/image-id-[0-9]*/g) || [];
                  
                  for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                      this.classList.remove(arrClassesToRemove[i]);
                  }
                  
                  // print {200px}; all and (max-width: 500px) {500px}; (min-width 500px) {600px};
                  
                  // trim, remove all close curly braces, lowercase, trim off semicolons
                  strMedia = GS.trim(strMedia.trim().replace(/\}/g, '').toLowerCase(), ';');
                  
                  // replace shortcuts (lrg => 1200px)
                  strMedia = strMedia.replace(/small|sml/g, '768px').replace(/medium|med/g, '992px').replace(/large|lrg/g, '1200px');
                  
                  arrLayouts = strMedia.split(';'); // seperate out layouts
                  
                  //console.log(strMedia, arrLayouts);
                  
                  if (arrTakenlayouts.indexOf(strMedia) === -1) {
                      arrTakenlayouts.push(strMedia);
                      intImageID = arrTakenlayouts.length - 1;
                      strCSS = '';
                      
                      for (i = 0, len = arrLayouts.length; i < len; i += 1) {
                          arrParts = arrLayouts[i].split('{');
                          strCurrentMedia = arrParts[0].trim() || 'all';
                          strDimensions = arrParts[1].trim();
                          
                          if (strDimensions.indexOf(',') === -1) {
                              strWidth = strDimensions;
                              strHeight = strDimensions;
                          } else {
                              arrParts = strDimensions.split(',');
                              strWidth = arrParts[0];
                              strHeight = arrParts[1];
                          }
                          
                          strCSS +=   '\n@media ' + strCurrentMedia + ' {\n' +
                                      '    gs-img.image-id-' + intImageID + ' { width:' + strWidth + '; height: ' + strHeight + '; }\n' +
                                      '}\n';
                      }
                      
                      //console.log(strCSS);
                      
                      // append the column CSS
                      document.getElementById('gs-dynamic-css').innerHTML += '\n/* image #' + intImageID + ' */\n' + strCSS;
                      
                  } else {
                      intImageID = arrTakenlayouts.indexOf(strMinWidth);
                  }
                  
                  this.classList.add('image-id-' + intImageID);
              }
          }
      });
  });//jslint white:true
  window.addEventListener('design-register-element', function () {
      registerDesignSnippet('<gs-insert>', '<gs-insert>', 'gs-insert src="${1:test.tpeople}">\n' +
                                                          '    ${2}\n' +
                                                          '</gs-insert>');
      
      designRegisterElement('gs-insert', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-insert.html');
      
      window.designElementProperty_GSINSERT = function(selectedElement) {
          addProp('Source&nbsp;Query', true,
                          '<gs-memo rows="1" autoresize class="target" value="' + encodeHTML(selectedElement.getAttribute('src') ||
                                  selectedElement.getAttribute('source') || '') + '" mini></gs-memo>',
                  function () {
              return setOrRemoveTextAttribute(selectedElement, 'src', this.value);
          });
          
          addProp('Additional&nbsp;Values', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('addin') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'addin', this.value);
          });
          
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          addProp('Primary Keys', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('pk') || '') + '" mini></gs-text>',
                  function () {
              return setOrRemoveTextAttribute(selectedElement, 'pk', this.value);
          });
          
          addProp('Sequences', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('seq') || '') + '" mini></gs-text>',
                  function () {
              return setOrRemoveTextAttribute(selectedElement, 'seq', this.value);
          });
          
          
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
          
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      
      xtag.register('gs-insert', {
          lifecycle: {},
          events: {},
          accessors: {},
          methods: {
              submit: function (callback) {
                  var element = this
                    , srcParts    = GS.templateWithQuerystring(element.getAttribute('src') || '').split('.')
                    , strSchema   = srcParts[0]
                    , strObject   = srcParts[1]
                    , strSeqCols, strPkCols, strAddIn
                    , strColumns = '', strResponseColumns, strInsertRecord = '', strInsertData
                    , arrElement, arrKey, arrValue, i, len, strResponse, parentSrcElement;
                  
                  // addin insert data
                  strAddIn = GS.templateWithQuerystring(element.getAttribute('addin'));
                  if (strAddIn) {
                      arrKey = GS.qryGetKeys(strAddIn);
                      arrValue = GS.qryGetKeys(strAddIn);
                      
                      for (i = 0, len = arrKey.length; i < len; i += 1) {
                          strColumns += (strColumns ? '\t' : '') + GS.encodeForTabDelimited(arrKey[i]);
                          strInsertRecord += (strInsertRecord ? '\t' : '') + GS.encodeForTabDelimited(arrValue[i]);
                      }
                  }
                  
                  // control insert data
                  arrElement = xtag.query(element, '[column]');
                  for (i = 0, len = arrElement.length; i < len; i += 1) {
                      parentSrcElement = GS.findParentElement(arrElement[i].parentNode, '[src]');
                      if (
                          parentSrcElement === element &&
                          (
                              arrElement[i].value !== undefined &&
                              arrElement[i].value !== null &&
                              arrElement[i].value !== ''
                          )) {
                          strColumns += (strColumns ? '\t' : '') + GS.encodeForTabDelimited(arrElement[i].getAttribute('column'));
                          strInsertRecord += (strInsertRecord ? '\t' : '') + GS.encodeForTabDelimited(arrElement[i].value);
                      }
                  }
                  
                  strPkCols = GS.templateWithQuerystring(element.getAttribute('pk') || 'id');
                  strSeqCols = GS.templateWithQuerystring(element.getAttribute('seq') || '');
                  strInsertData = (strColumns + '\n' + strInsertRecord);
                  strResponseColumns = (strPkCols + (strPkCols ? '\t' : '') + strColumns);
                  
                  GS.requestInsertFromSocket(
                          GS.envSocket, strSchema, strObject, strResponseColumns, strPkCols, strSeqCols, strInsertData
                          // beginCallback
                        , function () {}
                          
                          // confirmCallback
                        , function (data, error, transactionID, commitFunction, rollbackFunction) {
                              var arrCells, i, len, arrElements, jsnSelection, focusElement, focusColumnParent, focusColumnParentIndex;
                              
                              if (data !== 'TRANSACTION COMPLETED') {
                                  if (!error) {
                                      strResponse = data;
                                      commitFunction();
                                      
                                  } else {
                                      GS.webSocketErrorDialog(data);
                                      rollbackFunction();
                                  }
                              } else {
                                  commitFunction();
                              }
                          }
                          
                          // finalCallback
                        , function (strType, data, error) {
                              var arrColumns, arrCells, jsnRow = {}, i, len;
                              
                              if (strType === 'COMMIT') {
                                  arrColumns = strResponseColumns.split('\t');
                                  arrCells = (strResponse || '').split('\n')[0].split('\t');
                                  
                                  if (arrColumns.length !== arrCells.length) {
                                      throw 'gs-insert Error: Insert API call isn\'t returning correctly. (' + arrColumns.join(',') + ') -> (' + arrCells.join(',') + ')';
                                  } else {
                                      for (i = 0, len = arrColumns.length; i < len; i += 1) {
                                          jsnRow[GS.decodeFromTabDelimited(arrColumns[i])] = GS.decodeFromTabDelimited(arrCells[i]);
                                      }
                                      
                                      GS.triggerEvent(element, 'after_insert');
                                      
                                      if (typeof callback === 'function') {
                                          callback(GS.decodeFromTabDelimited(arrCells[0]), jsnRow);
                                      }
                                  }
                              }
                          }
                  );
              }
          }
      });
  });//global GS, window, document, xtag, evt, ml, encodeHTML, addFlexProps, setOrRemoveTextAttribute, setOrRemoveBooleanAttribute, addProp
  
  window.addEventListener('design-register-element', function () {
      'use strict';
  
      registerDesignSnippet('<gs-interval>', '<gs-interval>', 'gs-interval column="${1:complete_time}"></gs-interval>');
      registerDesignSnippet('<gs-interval> With Label', '<gs-interval>', 'label for="${1:interval-insert-complete_time}">${2:Time to complete}:</label>\n' +
                                                                 '<gs-interval id="${1:interval-insert-complete_time}" column="${3:complete_time}"></gs-interval>');
      
      designRegisterElement('gs-interval', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-interval.html');
  
      window.designElementProperty_GSINTERVAL = function (selectedElement) {
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
  
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
  
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
  
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
  
          addProp('Time Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-picker')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-picker', (this.value === 'true'), false);
          });
  
          addProp(
              'Unit',
              true,
              '        <gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('unit') || 'hours') + '" mini>' +
                      '    <option value="hours">Hours</option>' +
                      '    <option value="minutes">Minutes</option>' +
                      '    <option value="seconds">Seconds</option>' +
                      '</gs-select>',
              function () {
                  return setOrRemoveTextAttribute(selectedElement, 'unit', this.value);
              }
          );
  
          addProp('Hour Places', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('hour-places') || '3') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'hour-places', this.value);
          });
  
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // TABINDEX attribute
          addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
          });
  
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility',
                  true,
                  '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                  '    <option value="">Visible</option>' +
                  '    <option value="hidden">Invisible</option>' +
                  '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                  '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                  '    <option value="hide-on-phone">Invisible at phone size</option>' +
                  '    <option value="show-on-desktop">Visible at desktop size</option>' +
                  '    <option value="show-on-tablet">Visible at tablet size</option>' +
                  '    <option value="show-on-phone">Visible at phone size</option>' +
                  '</gs-select>',
                  function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
  
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
  
              return selectedElement;
          });
  
          // DISABLED attribute
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
  
          addFlexProps(selectedElement);
  
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
          
          addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
          });
      };
  });
  
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      //x attributes:
      //x      disabled:      copy to control element
      //x      tabindex:      move to control element
      //x      qs:            fill value from querystring, update value as querystring changes
      //x      value:         affects control value
      //x      no-picker:     affects innerHTML because it removes the picker button
      //x      unit
      //x      hour-places
      //x      minute-places
      //x      second-places
  
      //x accessors:
      //x      value:     returns text value
      //x      state:     returns text representation of state: "open" or "closed"
  
      //x methods:
      //x      open:   opens popup
      //x      close:  closes popup
      //x      toggle: toggles open and closed methods
  
      //x text editing behaviours:
      //x      text is divided by colons into portions
      //x      if value is deleted or empty, it displays with zeros
  
      //x events:
      //x      picker button click: runs "toggle" method
      //x      control keydown:
      //x          up arrow:    increase currently selected portion
      //x          down arrow:  previous minute
      //x          left arrow:  select previous portion
      //x          right arrow: select next portion
  
      //x dropdown behaviours:
      //x          if from control to bottom has enough room: popup below
      //x          else: popup above
  
      /*
          unit:
              hours: shows hours only
              minutes: shows minutes and hours
              seconds: shows seconds, minutes and hours
          hour-places: allows the dev to choose the maximum places in the hours
      */
  
  
      // #####################################################################################
      // ################################## EVENT  TRIGGERING ################################
      // #####################################################################################
  
      function handleChange(element) {
          element.close();
          if (element.lastChangeValue !== element.getAttribute('value')) {
              GS.triggerEvent(element, 'change');
              element.lastChangeValue = element.getAttribute('value');
          }
      }
  
      // #####################################################################################
      // ################################## EVENT RETARGETING ################################
      // #####################################################################################
  
      // re-target change event from control to element
      function changeFunction(event) {
          event.preventDefault();
          event.stopPropagation();
  
          event.target.parentNode.setAttribute('value', event.target.value);
          handleChange(event.target.parentNode);
      }
  
      // re-target focus event from control to element
      function focusFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'focus');
          event.target.parentNode.classList.add('focus');
      }
  
      // re-target blur event from control to element
      function blurFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'blur');
          event.target.parentNode.classList.remove('focus');
      }
  
      // mouseout, remove hover class
      function mouseoutFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseout);
          event.target.parentNode.classList.remove('hover');
      }
  
      // mouseover, add hover class
      function mouseoverFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseover);
          event.target.parentNode.classList.add('hover');
      }
  
  
      // #####################################################################################
      // ######################################## VALUE ######################################
      // #####################################################################################
  
      //console.log('1***', translateValue(GS.stringToElement('<gs-interval unit="hours"></gs-interval>'), '5.255')); // 5 hours, 15 mins, 30 seconds
      //console.log('2***', translateValue(GS.stringToElement('<gs-interval unit="minutes"></gs-interval>'), '500.25')); // 8 hours, 20 mins, 15 seconds
      //console.log('3***', translateValue(GS.stringToElement('<gs-interval unit="seconds"></gs-interval>'), '5000')); // 1 hour, 23 mins, 20 seconds
      //console.log('4***', translateValue(GS.stringToElement('<gs-interval unit="seconds"></gs-interval>'), '0.03333333333333333')); // 2 mins
  
      function valueGetCurrentNumber(element) {
          var intValue = 0;
  
          if (element.internal.unit === 'minutes') {
              intValue += (element.internal.value.hours * 60);
              intValue += element.internal.value.minutes;
              //intValue += (element.internal.value.seconds / 60);
          } else if (element.internal.unit === 'seconds') {
              intValue += ((element.internal.value.hours * 60) * 60);
              intValue += (element.internal.value.minutes * 60);
              intValue += element.internal.value.seconds;
          } else {//hours
              intValue += element.internal.value.hours;
              //intValue += parseFloat((element.internal.value.minutes / 60).toFixed(5));
              //intValue += parseFloat(((element.internal.value.seconds / 60) / 60).toFixed(5));
          }
  
          return String(intValue);
      }
  
      function valueGetCurrentDisplay(element) {
          var strValue = '';
          var intHours = element.internal.value.hours;
          var intMinutes = element.internal.value.minutes;
          var intSeconds = element.internal.value.seconds;
  
          if (element.internal.places.hours > 0) {
              strValue += GS.leftPad(intHours || '', '0', element.internal.places.hours);
          }
  
          if (element.internal.places.minutes > 0) {
              strValue += (strValue ? ':' : '');
              strValue += GS.leftPad(intMinutes || '', '0', element.internal.places.minutes);
          }
  
          if (element.internal.places.seconds > 0) {
              strValue += (strValue ? ':' : '');
              strValue += GS.leftPad(intSeconds || '', '0', element.internal.places.seconds);
          }
  
          return String(strValue);
      }
  
      function valueUpdatePicker(element) {
          var currentValue = valueGetCurrentDisplay(element);
          var i;
          var len;
          var arrElements;
          var intColons = 0;
  
          //console.log('currentValue:', currentValue);
          //console.log('PLACES: ', element.internal.places.hours, element.internal.places.minutes, element.internal.places.seconds);
  
          // set value of the select boxes
          i = 0;
          len = element.internal.places.hours;
          arrElements = xtag.query(element.internal.picker, '[data-hour]');
          while (i < len) {
              //console.log('SELECTBOX HR: ', arrElements[i]);
              arrElements[i].value = currentValue[i];
              i += 1;
          }
          if (len > 0) {
              intColons += 1;
          }
  
          i = 0;
          len = element.internal.places.minutes;
          arrElements = xtag.query(element.internal.picker, '[data-minute]');
          while (i < len) {
              //console.log('SELECTBOX MIN: ', arrElements[i]);
              arrElements[i].value =
                      currentValue[element.internal.places.hours + intColons + i];
              i += 1;
          }
          if (len > 0) {
              intColons += 1;
          }
  
          i = 0;
          len = element.internal.places.seconds;
          arrElements = xtag.query(element.internal.picker, '[data-second]');
          while (i < len) {
              //console.log('SELECTBOX SEC: ', arrElements[i]);
              arrElements[i].value =
                      currentValue[element.internal.places.hours + element.internal.places.minutes + intColons + i];
              i += 1;
          }
      }
  
      function valueUpdateDisplay(element) {
          if (element.control) {
              element.control.value = valueGetCurrentDisplay(element);
          } else {
              element.textContent = valueGetCurrentDisplay(element);
          }
      }
  
      function valueUpdateAttribute(element) {
          element.setAttribute('value', valueGetCurrentNumber(element));
      }
  
  
      // #####################################################################################
      // ####################################### CONTROL #####################################
      // #####################################################################################
  
      function refreshControl(element) {
          var i;
          var len;
          var arrPassThroughAttributes;
          var strHTML;
  
          // clear out HTML
          element.innerHTML = '';
  
          // clear out element variables
          element.control = '';
          element.button = '';
  
          // if we are not disabled:
          if (!element.hasAttribute('disabled')) {
              // build HTML
              strHTML =
                      '<input class="control" gs-dynamic type="text" ' +
                      'autocorrect="off" autocapitalize="off" ' +
                      'autocomplete="off" spellcheck="false" />';
              if (!element.hasAttribute('no-picker')) {
                  strHTML += '<gs-button class="time-picker-button" gs-dynamic inline icononly icon="hourglass-o" no-focus></gs-button>';
              }
  
              // set control HTML
              element.innerHTML = strHTML;
  
              // fill element variables
              element.control = element.children[0];
              element.button = element.children[1];
  
              // handle passthrough attributes
              arrPassThroughAttributes = ['name', 'autofocus', 'spellcheck', 'readonly'];
  
              i = 0;
              len = arrPassThroughAttributes.length;
              while (i < len) {
                  if (element.hasAttribute(arrPassThroughAttributes[i])) {
                      element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
                  }
                  i += 1;
              }
  
              // move tabindex, tabindex is special because tabindex affects any displayed element it's used on
              if (element.hasAttribute('tabindex')) {
                  element.oldTabIndex = element.getAttribute('tabindex');
                  element.removeAttribute('tabindex');
              }
  
              if (element.oldTabIndex) {
                  element.control.tabIndex = element.oldTabIndex;
              }
  
              // bind control retargeting
              element.control.removeEventListener('change', changeFunction);
              element.control.addEventListener('change', changeFunction);
  
              element.control.removeEventListener('focus', focusFunction);
              element.control.addEventListener('focus', focusFunction);
  
              element.control.removeEventListener('blur', blurFunction);
              element.control.addEventListener('blur', blurFunction);
  
              element.control.removeEventListener(evt.mouseout, mouseoutFunction);
              element.control.addEventListener(evt.mouseout, mouseoutFunction);
  
              element.control.removeEventListener(evt.mouseout, mouseoverFunction);
              element.control.addEventListener(evt.mouseover, mouseoverFunction);
          }
  
          // display value
          valueUpdateDisplay(element);
          //displayValue(element);
          //setValueDisplay(element, element.getAttribute('value'));
      }
  
      function valueSiphonAttribute(element) {
          var fltValue = parseFloat(element.getAttribute('value') || '0');
  
          var intHours;
          var intMinutes;
          var intSeconds;
  
          if (element.internal.unit === 'minutes') {
              intHours = Math.floor(fltValue / 60);
              fltValue = fltValue - (intHours * 60); // remove the hours from fltValue
  
              intMinutes = Math.floor(fltValue);
              fltValue = fltValue - Math.floor(fltValue); // remove the minutes from fltValue
  
              intSeconds = 0; //Math.floor(fltValue);
  
          } else if (element.internal.unit === 'seconds') {
              intHours = Math.floor((fltValue / 60) / 60);
              fltValue = fltValue - ((intHours * 60) * 60); // remove the hours from fltValue
  
              intMinutes = Math.floor(fltValue / 60);
              fltValue = fltValue - (intMinutes * 60); // remove the minutes from fltValue
  
              intSeconds = Math.round(fltValue);
          } else {
              intHours = Math.floor(fltValue);
              //fltValue = fltValue - intHours; // remove the hours from fltValue
  
              intMinutes = 0;//Math.floor(fltValue * 60);
              //fltValue = fltValue - (intMinutes / 60);
  
              intSeconds = 0;//Math.round((fltValue * 100) * 60);
          }
  
          if (isNaN(intHours)) {
              intHours = 0;
          }
          if (isNaN(intMinutes)) {
              intMinutes = 0;
          }
          if (isNaN(intSeconds)) {
              intSeconds = 0;
          }
  
          //console.log('siphon: ', element);
          //console.log('intHours:   ', intHours);
          //console.log('intMinutes: ', intMinutes);
          //console.log('intSeconds: ', intSeconds);
  
          element.internal.value.hours = intHours;
          element.internal.value.minutes = intMinutes;
          element.internal.value.seconds = intSeconds;
      }
  
  
      // #####################################################################################
      // ##################################### QUERYSTRING ###################################
      // #####################################################################################
  
      //function pushReplacePopHandler(element) {
      //    var strQueryString = GS.getQueryString();
      //    var strQSCol = element.getAttribute('qs');
  
      //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
      //    }
      //}
  
      
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          arrAttr = element.attributes;
          i = 0;
          len = arrAttr.length;
          while (i < len) {
              jsnAttr = arrAttr[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  if (strQSValue !== '' || !element.getAttribute('value')) {
                      element.setAttribute('value', strQSValue);
                  }
              } else {
                  element.setAttribute('value', strQSValue);
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
  
      function handleQS(element) {
          //var strQSValue;
  
          if (!element.qsEventFunction) {
              element.qsEventFunction = function () {
                  pushReplacePopHandler(element);
              };
          }
  
          window.removeEventListener('pushstate', element.qsEventFunction);
          window.removeEventListener('replacestate', element.qsEventFunction);
          window.removeEventListener('popstate', element.qsEventFunction);
  
          // handle "qs" attribute
          if (element.getAttribute('qs')) {
              pushReplacePopHandler(element);
              //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
  
              //if (strQSValue !== '' || !element.getAttribute('value')) {
              //    element.setAttribute('value', strQSValue);
              //}
  
              window.addEventListener('pushstate', element.qsEventFunction);
              window.addEventListener('replacestate', element.qsEventFunction);
              window.addEventListener('popstate', element.qsEventFunction);
          }
      }
  
      // #####################################################################################
      // ################################### PARENT  ELEMENT #################################
      // #####################################################################################
  
      function prepElement(element) {
          element.internal = {};
  
          element.internal.value = {
              "hours": 0,
              "minutes": 0,
              "seconds": 0
          };
  
          element.internal.places = {
              "hours": 0,
              "minutes": 0,
              "seconds": 0
          };
  
          element.internal.unit = '';
  
          element.internal.picker = '';
      }
  
      function siphonElement(element) {
          // siphon the unit
          element.internal.unit = element.getAttribute('unit') || '';
          element.internal.unit = element.internal.unit.toLowerCase();
          element.internal.unit = element.internal.unit || 'minutes';
  
          if (element.internal.unit !== 'hours' &&
                  element.internal.unit !== 'minutes' &&
                  element.internal.unit !== 'seconds') {
              element.internal.unit = 'minutes';
              console.warn(
                  'gs-interval Warning: invalid "unit" attribute. ' +
                          'Please use "hours", "minutes" or "seconds".  ' +
                          'Defaulting "unit" to "minutes"',
                  element
              );
          }
  
          // get the place settings
          var intHourPlaces = parseInt(element.getAttribute('hour-places'), 10);
          var intMinutePlaces = 0;
          var intSecondPlaces = 0;
  
          // default place settings
          if (isNaN(intHourPlaces)) {
              intHourPlaces = 3;
          }
          if (element.internal.unit === 'minutes' || element.internal.unit === 'seconds') {
              intMinutePlaces = 2;
          }
          if (element.internal.unit === 'seconds') {
              intSecondPlaces = 2;
          }
  
          element.internal.places.hours = intHourPlaces;
          element.internal.places.minutes = intMinutePlaces;
          element.internal.places.seconds = intSecondPlaces;
  
          // siphon the value attribute
          // get hours/minutes/seconds from value
          valueSiphonAttribute(element);
      }
  
      // #####################################################################################
      // ###################################### LIFECYCLE ####################################
      // #####################################################################################
  
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              // if the value was set before the "created" lifecycle code runs: set attribute
              //      (discovered when trying to set a value of a date control in the after_open of a dialog)
              //      ("delete" keyword added because of firefox)
              if (element.value) {
                  element.setAttribute('value', element.value);
                  delete element.value;
              }
          }
      }
  
      //
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.innerState = 'closed';
  
                  prepElement(element);
                  siphonElement(element);
                  saveDefaultAttributes(element);
                  refreshControl(element);
  
                  if (element.getAttribute('qs')) {
                      handleQS(element);
                  }
  
                  element.lastChangeValue = element.getAttribute('value');
              }
          }
      }
  
      // ######################################################################################
      // ##################################### REGISTRATION ###################################
      // ######################################################################################
  
      xtag.register('gs-interval', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
  
              inserted: function () {
                  elementInserted(this);
              },
  
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  var element = this;
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(element);
                      elementInserted(element);
  
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(element);
  
                  } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                      if (strAttrName === 'disabled' || strAttrName === 'no-picker' || strAttrName === 'tabindex') {
                          siphonElement(element);
                          refreshControl(element);
  
                      } else if (strAttrName === 'qs') {
                          handleQS(element);
  
                      } else if (strAttrName === 'value' && element.inserted) {
                          ////displayValue(element);
                          //siphonElement(element);
                          //displayValue(element);
                          ////setValueDisplay(element, newValue);
                          valueSiphonAttribute(element);
                          valueUpdateDisplay(element);
  
                          if (element.innerState === 'open') {
                              valueUpdatePicker(element);
                          }
                      }
                  }
              }
          },
          events: {
              'click': function (event) {
                  var element = this;
                  if (event.target === element.button) {
                      element.toggle();
                  }
              },
  
              'mouseup': function (event) {
                  var element = this;
                  var strValue = element.control.value;
                  var jsnTextSelection;
                  var intCursor;
                  var i;
                  var len;
                  var arrDelimiterIndexes;
                  var intSection;
  
                  if (!element.hasAttribute('readonly')) {
                      element.numberOfCharsTyped = 0;
      
                      jsnTextSelection = GS.getInputSelection(element.control);
      
                      i = 0;
                      len = strValue.length;
                      arrDelimiterIndexes = [0];
                      while (i < len) {
                          if (strValue[i] === ':') {
                              arrDelimiterIndexes.push(i);
                          }
                          i += 1;
                      }
                      arrDelimiterIndexes.push(strValue.length);
      
                      event.preventDefault();
      
                      intCursor = jsnTextSelection.start;
      
                      // find out what section the cursor is in
                      i = 1;
                      len = arrDelimiterIndexes.length;
                      while (i < len) {
                          if (intCursor >= arrDelimiterIndexes[i - 1] && intCursor <= arrDelimiterIndexes[i]) {
                              intSection = i;
                              break;
                          }
                          i += 1;
                      }
      
                      // select the section of the value that the cursor is in
                      if (intSection === 1) {
                          GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1], arrDelimiterIndexes[intSection]);
                      } else {
                          GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1] + 1, arrDelimiterIndexes[intSection]);
                      }
                  }
              },
  
              'keydown': function (event) { // don't use the "input" event, doesn't work for this
                  var element = this;
                  var strValue = element.control.value;
                  var intKeyCode = (event.keyCode || event.which);
  
                  var jsnTextSelection;
                  var arrDelimiterIndexes;
                  var i;
                  var len;
                  var intCursor;
                  var intSection;
                  var strPlace;
                  var strChar;
                  var strSection;
  
                  if (!element.hasAttribute('readonly')) {
                      jsnTextSelection = GS.getInputSelection(element.control);
      
                      i = 0;
                      len = strValue.length;
                      arrDelimiterIndexes = [0];
                      while (i < len) {
                          if (strValue[i] === ':') {
                              arrDelimiterIndexes.push(i);
                          }
                          i += 1;
                      }
                      arrDelimiterIndexes.push(strValue.length);
      
                      // get cursor position
                      intCursor = jsnTextSelection.start;
      
                      // find out what section the cursor is in
                      i = 1;
                      len = arrDelimiterIndexes.length;
                      while (i < len) {
                          if (intCursor >= arrDelimiterIndexes[i - 1] && intCursor <= arrDelimiterIndexes[i]) {
                              intSection = i;
                              break;
                          }
                          i += 1;
                      }
      
                      // if key was an arrow
                      if (intKeyCode >= 37 && intKeyCode <= 40) {
                          element.numberOfCharsTyped = 0;
                          event.preventDefault();
      
                          // left     37
                          // top      38
                          // right    39
                          // down     40
      
                          // handle/right arrows moving the cursor
                          if (intKeyCode === 37) {
                              intSection -= 1;
                              intSection = Math.max(intSection, 1);
                          } else if (intKeyCode === 39) {
                              intSection += 1;
                              intSection = Math.min(intSection, arrDelimiterIndexes.length - 1);
                          }
      
                          // select the section of the value that the cursor is in
                          if (intSection === 1) {
                              GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1], arrDelimiterIndexes[intSection]);
                          } else {
                              GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1] + 1, arrDelimiterIndexes[intSection]);
                          }
      
                          // find out what section that the cursor is in (hours, minutes or seconds)
                          if (intSection === 0 || intSection === 1) {
                              strPlace = 'hours';
                          } else if (intSection === 2) {
                              strPlace = 'minutes';
                          } else if (intSection === 3 || intSection === 4) {
                              strPlace = 'seconds';
                          }
      
                          // update text selection variable
                          jsnTextSelection = GS.getInputSelection(element.control);
      
                          // handle up and down arrows incrementing/decrementing
                          //      the value of the currently selected section
                          if (intKeyCode === 38) { // up
                              if (strPlace === 'hours') {
                                  element.internal.value.hours += 1;
                              } else if (strPlace === 'minutes') {
                                  element.internal.value.minutes += 1;
                              } else if (strPlace === 'seconds') {
                                  element.internal.value.seconds += 1;
                              }
      
                              if (String(element.internal.value.hours).length > element.internal.places.hours) {
                                  element.internal.value.hours = parseInt(
                                      '999999999999999'.substring(0, element.internal.places.hours),
                                      10
                                  );
                              }
                              if (element.internal.value.seconds > 59) {
                                  element.internal.value.minutes += 1;
                                  element.internal.value.seconds = 0;
                              }
                              if (element.internal.value.minutes > 59) {
                                  element.internal.value.hours += 1;
                                  element.internal.value.minutes = 0;
                              }
      
                          } else if (intKeyCode === 40) { // down
                              if (strPlace === 'hours') {
                                  element.internal.value.hours -= 1;
                              } else if (strPlace === 'minutes') {
                                  element.internal.value.minutes -= 1;
                              } else if (strPlace === 'seconds') {
                                  element.internal.value.seconds -= 1;
                              }
      
                              if (element.internal.value.seconds < 0) {
                                  if (element.internal.value.minutes > 0) {
                                      element.internal.value.minutes -= 1;
                                      element.internal.value.seconds = 59;
                                  } else if (element.internal.value.hours > 0) {
                                      element.internal.value.hours -= 1;
                                      element.internal.value.minutes = 59;
                                      element.internal.value.seconds = 59;
                                  } else {
                                      element.internal.value.seconds = 0;
                                  }
                              }
                              if (element.internal.value.minutes < 0) {
                                  if (element.internal.value.hours > 0) {
                                      element.internal.value.minutes = 59;
                                      element.internal.value.hours -= 1;
                                  } else {
                                      element.internal.value.minutes = 0;
                                  }
                              }
                              if (element.internal.value.hours < 0) {
                                  element.internal.value.hours = 0;
                              }
                          }
      
                          if (intKeyCode === 38 || intKeyCode === 40) {
                              //trinkleValueDown(element);
                              //displayValue(element);
                              valueUpdateAttribute(element);
                              GS.setInputSelection(element.control, jsnTextSelection.start, jsnTextSelection.end);
                          }
      
                      // if key was a number
                      } else if ((intKeyCode >= 48 && intKeyCode <= 57) || (intKeyCode >= 96 && intKeyCode <= 105)) {
                          element.numberOfCharsTyped = element.numberOfCharsTyped || 0;
                          event.preventDefault();
      
                          // get the character that was typed
                          strChar = String.fromCharCode(intKeyCode);
                          if (intKeyCode === 96) { strChar = '0'; }
                          if (intKeyCode === 97) { strChar = '1'; }
                          if (intKeyCode === 98) { strChar = '2'; }
                          if (intKeyCode === 99) { strChar = '3'; }
                          if (intKeyCode === 100) { strChar = '4'; }
                          if (intKeyCode === 101) { strChar = '5'; }
                          if (intKeyCode === 102) { strChar = '6'; }
                          if (intKeyCode === 103) { strChar = '7'; }
                          if (intKeyCode === 104) { strChar = '8'; }
                          if (intKeyCode === 105) { strChar = '9'; }
      
                          // select the section of the value that the cursor is in
                          if (intSection === 1) {
                              GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1], arrDelimiterIndexes[intSection]);
                          } else {
                              GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1] + 1, arrDelimiterIndexes[intSection]);
                          }
      
                          // find out what section that the cursor is in (hours, minutes or seconds)
                          if (intSection === 0 || intSection === 1) {
                              strPlace = 'hours';
                          } else if (intSection === 2) {
                              strPlace = 'minutes';
                          } else if (intSection === 3 || intSection === 4) {
                              strPlace = 'seconds';
                          }
      
                          // update text selection variable
                          jsnTextSelection = GS.getInputSelection(element.control);
      
                          // when you type in a number,
                          //      if no data is set saying "this is where the typing begins":
                          //              insert the number as the first character of the section
                          //              after that set data to say where the typing begins
                          //      no matter what is typed: stay in the same section
                          strSection = strValue.substring(jsnTextSelection.start, jsnTextSelection.end);
      
                          strSection =
                                  strSection.substring(0, element.numberOfCharsTyped) +
                                  strChar +
                                  strSection.substring(element.numberOfCharsTyped + 1);
      
                          strValue =
                                  strValue.substring(0, jsnTextSelection.start) +
                                  strSection +
                                  strValue.substring(jsnTextSelection.end);
      
                          //console.log(element.numberOfCharsTyped);
                          element.numberOfCharsTyped += 1;
      
                          if (element.numberOfCharsTyped === strSection.length) {
                              element.numberOfCharsTyped = 0;
                          }
      
                          if (strPlace === 'hours') {
                              element.internal.value.hours = parseInt(strSection, 10);
                          }
                          if (strPlace === 'minutes') {
                              element.internal.value.minutes = parseInt(strSection, 10);
                          }
                          if (strPlace === 'seconds') {
                              element.internal.value.seconds = parseInt(strSection, 10);
                          }
      
                          //console.log(strValue, element.control.value, translateValueToNumber(element, strValue));
      
                          if (strValue !== element.control.value) {
                              //trinkleValueDown(element);
                              //displayValue(element);
                              valueUpdateAttribute(element);
                              GS.setInputSelection(element.control, jsnTextSelection.start, jsnTextSelection.end);
                          }
                      } else if (intKeyCode === 13) {
                          element.numberOfCharsTyped = 0;
                          event.preventDefault();
                          handleChange(element);
                      } else if (intKeyCode !== 9 && event.ctrlKey === false && event.metaKey === false) {
                          element.numberOfCharsTyped = 0;
                          event.preventDefault();
                      }
                  }
              },
              'blur': function () {// don't use 'focusout', it doesn't work on firefox
                  var element = this;
                  if (element.innerState === 'closed') {
                      handleChange(element);
                  }
              }
          },
          accessors: {
              value: {
                  get: function () {
                      return this.getAttribute('value');
                  },
                  set: function (newValue) {
                      this.setAttribute('value', newValue);
                  }
              },
              state: {
                  get: function () {
                      return this.innerState;
                  },
                  set: function (newValue) {
                      var element = this;
                      if (newValue === 'open') {
                          element.open();
                      } else {
                          element.close();
                      }
                  }
              }
          },
          methods: {
              focus: function () {
                  this.control.focus();
              },
  
              open: function () {
                  var element = this;
                  var pickerContainerElement;
                  var overlayElement;
                  var pickerElement;
                  var handleLook;
                  var strHTML;
                  var i;
                  var len;
                  var arrElements;
  
                  if (element.innerState === 'closed') {
                      element.innerState = 'open';
                      element.lastClosedValue = element.getAttribute('value');
  
                      // if we are not on a touch device: focus control
                      if (!evt.touchDevice) {
                          element.control.focus();
                          GS.setInputSelection(element.control, 0, element.control.value.length);
                      }
  
                      // create picker elements
                      pickerContainerElement = document.createElement('div');
                      pickerContainerElement.classList.add('gs-interval-time-picker-container');
  
                      overlayElement = document.createElement('div');
                      overlayElement.classList.add('gs-interval-time-picker-overlay');
  
                      pickerElement = document.createElement('div');
                      pickerElement.classList.add('gs-interval-time-picker');
                      element.internal.picker = pickerElement;
  
                      // save picker container
                      element.pickerContainerElement = pickerContainerElement;
  
                      // append picker elements
                      pickerContainerElement.appendChild(overlayElement);
                      pickerContainerElement.appendChild(pickerElement);
  
                      document.body.appendChild(pickerContainerElement);
  
                      // fill picker popup
                      strHTML = '';
                      strHTML += '<div class="time-inner-container">';
  
                      i = 0;
                      len = element.internal.places.hours;
                      while (i < len) {
                          strHTML +=
                                  '<select class="gs-interval-hour" data-hour="' + i + '">' +
                                  '    <option value="0">&nbsp;0</option>' +
                                  '    <option value="1">&nbsp;1</option>' +
                                  '    <option value="2">&nbsp;2</option>' +
                                  '    <option value="3">&nbsp;3</option>' +
                                  '    <option value="4">&nbsp;4</option>' +
                                  '    <option value="5">&nbsp;5</option>' +
                                  '    <option value="6">&nbsp;6</option>' +
                                  '    <option value="7">&nbsp;7</option>' +
                                  '    <option value="8">&nbsp;8</option>' +
                                  '    <option value="9">&nbsp;9</option>' +
                                  '</select>';
                          i += 1;
                      }
  
                      if (element.internal.places.hours > 0 && element.internal.places.minutes > 0) {
                          strHTML += '<span class="colon">:</span>';
                      }
  
                      i = 0;
                      len = element.internal.places.minutes;
                      while (i < len) {
                          strHTML +=
                                  '<select class="gs-interval-minute" data-minute="' + i + '">' +
                                  '    <option value="0">&nbsp;0</option>' +
                                  '    <option value="1">&nbsp;1</option>' +
                                  '    <option value="2">&nbsp;2</option>' +
                                  '    <option value="3">&nbsp;3</option>' +
                                  '    <option value="4">&nbsp;4</option>' +
                                  '    <option value="5">&nbsp;5</option>';
  
                          if (i > 0) {
                              strHTML +=
                                      '<option value="6">&nbsp;6</option>' +
                                      '<option value="7">&nbsp;7</option>' +
                                      '<option value="8">&nbsp;8</option>' +
                                      '<option value="9">&nbsp;9</option>';
                          }
  
                          strHTML +=
                                  '</select>';
                          i += 1;
                      }
  
                      if (element.internal.places.minutes > 0 && element.internal.places.seconds > 0) {
                          strHTML += '<span class="colon">:</span>';
                      }
  
                      i = 0;
                      len = element.internal.places.seconds;
                      while (i < len) {
                          strHTML +=
                                  '<select class="gs-interval-second" data-second="' + i + '">' +
                                  '    <option value="0">&nbsp;0</option>' +
                                  '    <option value="1">&nbsp;1</option>' +
                                  '    <option value="2">&nbsp;2</option>' +
                                  '    <option value="3">&nbsp;3</option>' +
                                  '    <option value="4">&nbsp;4</option>' +
                                  '    <option value="5">&nbsp;5</option>';
  
                          if (i > 0) {
                              strHTML +=
                                      '<option value="6">&nbsp;6</option>' +
                                      '<option value="7">&nbsp;7</option>' +
                                      '<option value="8">&nbsp;8</option>' +
                                      '<option value="9">&nbsp;9</option>';
                          }
  
                          strHTML +=
                                  '</select>';
                          i += 1;
                      }
  
                      strHTML += '</div>';
                      pickerElement.innerHTML = strHTML;
  
  
                      // set picker value
                      valueUpdatePicker(element);
  
                      // bind picker click
                      overlayElement.addEventListener('click', function () {
                          element.close();
                      });
  
                      pickerElement.addEventListener('change', function () {//event
                          //var arrElements;
                          //var i;
                          //var len;
                          var newValue = 0;
                          var strCurrentValue;
  
                          if (element.internal.unit === 'hours') {
                              i = 0;
                              len = element.internal.places.hours;
                              arrElements = xtag.query(pickerElement, '[data-hour]');
                              strCurrentValue = '';
                              while (i < len) {
                                  strCurrentValue += arrElements[i].value;
                                  i += 1;
                              }
                              if (arrElements.length > 0) {
                                  newValue += parseInt(strCurrentValue, 10);
                              }
  
                              //i = 0;
                              //len = element.internal.places.minutes;
                              //arrElements = xtag.query(pickerElement, '[data-minute]');
                              //strCurrentValue = '';
                              //while (i < len) {
                              //    strCurrentValue += arrElements[i].value;
                              //    i += 1;
                              //}
                              //if (arrElements.length > 0) {
                              //    newValue += (parseInt(strCurrentValue, 10) / 60);
                              //}
  
                              //i = 0;
                              //len = element.internal.places.seconds;
                              //arrElements = xtag.query(pickerElement, '[data-second]');
                              //strCurrentValue = '';
                              //while (i < len) {
                              //    strCurrentValue += arrElements[i].value;
                              //    i += 1;
                              //}
                              //if (arrElements.length > 0) {
                              //    newValue += ((parseInt(strCurrentValue, 10) / 60) / 60);
                              //}
                          }
                          if (element.internal.unit === 'minutes') {
                              i = 0;
                              len = element.internal.places.hours;
                              arrElements = xtag.query(pickerElement, '[data-hour]');
                              strCurrentValue = '';
                              while (i < len) {
                                  strCurrentValue += arrElements[i].value;
                                  i += 1;
                              }
                              if (arrElements.length > 0) {
                                  newValue += parseInt(strCurrentValue, 10) * 60;
                              }
  
                              i = 0;
                              len = element.internal.places.minutes;
                              arrElements = xtag.query(pickerElement, '[data-minute]');
                              strCurrentValue = '';
                              while (i < len) {
                                  strCurrentValue += arrElements[i].value;
                                  i += 1;
                              }
                              if (arrElements.length > 0) {
                                  newValue += parseInt(strCurrentValue, 10);
                              }
  
                              //i = 0;
                              //len = element.internal.places.seconds;
                              //arrElements = xtag.query(pickerElement, '[data-second]');
                              //strCurrentValue = '';
                              //while (i < len) {
                              //    strCurrentValue += arrElements[i].value;
                              //    i += 1;
                              //}
                              //if (arrElements.length > 0) {
                              //    newValue += ((parseInt(strCurrentValue, 10) * 60) * 60);
                              //}
                          }
                          if (element.internal.unit === 'seconds') {
                              i = 0;
                              len = element.internal.places.hours;
                              arrElements = xtag.query(pickerElement, '[data-hour]');
                              strCurrentValue = '';
                              while (i < len) {
                                  strCurrentValue += arrElements[i].value;
                                  i += 1;
                              }
                              if (arrElements.length > 0) {
                                  newValue += ((parseInt(strCurrentValue, 10) * 60) * 60);
                              }
  
                              i = 0;
                              len = element.internal.places.minutes;
                              arrElements = xtag.query(pickerElement, '[data-minute]');
                              strCurrentValue = '';
                              while (i < len) {
                                  strCurrentValue += arrElements[i].value;
                                  i += 1;
                              }
                              if (arrElements.length > 0) {
                                  newValue += parseInt(strCurrentValue, 10) * 60;
                              }
  
                              i = 0;
                              len = element.internal.places.seconds;
                              arrElements = xtag.query(pickerElement, '[data-second]');
                              strCurrentValue = '';
                              while (i < len) {
                                  strCurrentValue += arrElements[i].value;
                                  i += 1;
                              }
                              if (arrElements.length > 0) {
                                  newValue += parseInt(strCurrentValue, 10);
                              }
                          }
  
                          element.setAttribute('value', newValue);
                          //trinkleValueDown(element);
                          //setValueDisplay(element, newValue);
                      });
  
                      // handle/bind positioning and look
                      handleLook = function () {
                          var positionData;
                          var intPopupHeight;
                          var intPopupWidth;
  
                          if (pickerContainerElement.parentNode !== document.body) {
                              window.removeEventListener('resize', handleLook);
                              window.removeEventListener('orientationchange', handleLook);
                              return;
                          }
  
                          // clear current styles
                          pickerElement.style.top = '';
                          pickerElement.style.left = '';
                          pickerElement.style.marginTop = '';
                          //pickerContainerElement.classList.remove('modal');
  
                          // get position/size data
                          positionData = GS.getElementPositionData(element);
                          intPopupHeight = pickerElement.offsetHeight;
                          intPopupWidth = pickerElement.offsetWidth;
  
                          // if from control to bottom has enough room: popup below
                          if (positionData.intRoomBelow > intPopupHeight) {
                              pickerElement.style.top = (positionData.objElementOffset.top + positionData.intElementHeight) + 'px';
  
                          // else: popup above
                          } else {
                              pickerElement.style.top = (positionData.objElementOffset.top - intPopupHeight) + 'px';
                          }
  
                          pickerElement.style.left =
                                  (((positionData.objElementOffset.left + positionData.intElementWidth) - intPopupWidth) - 4) + 'px';
                      };
  
                      handleLook();
  
                      window.addEventListener('resize', handleLook);
                      window.addEventListener('orientationchange', handleLook);
                  }
              },
  
              close: function () {
                  var element = this;
  
                  if (element.innerState === 'open') {
                      element.innerState = 'closed';
                      if (element.pickerContainerElement) {
                          document.body.removeChild(element.pickerContainerElement);
                          element.pickerContainerElement = '';
                      }
                      if (element.getAttribute('value') !== element.lastClosedValue) {
                          handleChange(element);
                      }
                  }
              },
  
              toggle: function () {
                  var element = this;
  
                  if (element.innerState === 'open') {
                      element.close();
                  } else {
                      element.open();
                  }
              }
          }
      });
  });
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('<gs-jumbo>', '<gs-jumbo>', 'gs-jumbo>\n' +
                                                                  '    ${0}\n' +
                                                                  '</gs-jumbo>');
      
      designRegisterElement('gs-jumbo', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-container-jumbo.html');
      
      window.designElementProperty_GSJUMBO = function(selectedElement) {
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      
      xtag.register('gs-jumbo', {});
  });
  window.addEventListener('design-register-element', function () {
      registerDesignSnippet('Static Template <gs-listbox>', '<gs-listbox>', 'gs-listbox>\n'+
                                                                       '    <template>\n'+
                                                                       '        <table>\n'+
                                                                       '            <tbody>\n'+
                                                                       '                <tr value="${1}">\n'+
                                                                       '                    <td>${0}</td>\n'+
                                                                       '                </tr>\n'+
                                                                       '            </tbody>\n'+
                                                                       '        </table>\n'+
                                                                       '    </template>\n' +
                                                                       '</gs-listbox>');
      registerDesignSnippet('Custom Template <gs-listbox>', '<gs-listbox>', 'gs-listbox src="${1:test.tpeople}">\n'+
                                                                       '    <template>\n'+
                                                                       '        <table>\n'+
                                                                       '            <tbody>\n'+
                                                                       '                <tr value="{{! row.id }}">\n'+
                                                                       '                    <td>{{! row.${3:name} }}</td>\n'+
                                                                       '                </tr>\n'+
                                                                       '            </tbody>\n'+
                                                                       '        </table>\n'+
                                                                       '    </template>\n' +
                                                                       '</gs-listbox>');
      registerDesignSnippet('Dynamic Template <gs-listbox>', '<gs-listbox>', 'gs-listbox src="${1:test.tpeople}"></gs-listbox>');
      registerDesignSnippet('<gs-listbox>', '<gs-listbox>', 'gs-listbox src="${1:test.tpeople}"></gs-listbox>');
  
      designRegisterElement('gs-listbox', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-listbox.html');
  
      window.designElementProperty_GSLISTBOX = function(selectedElement) {
          addProp('Source', true, '<gs-memo class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('src') ||
                                                                              selectedElement.getAttribute('source') || '')) + '" mini></gs-memo>',
                  function () {
              return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
          });
  
          addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                  function () {
              return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
          });
  
          addProp('Hide Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('hide') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'hide', this.value);
          });
  
          addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('where') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'where', this.value);
          });
  
          addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
          });
  
          addProp('Limit', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
          });
  
          addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
          });
  
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
  
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
  
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
  
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // TABINDEX attribute
          addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
          });
  
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
  
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
  
              return selectedElement;
          });
  
          // DISABLED attribute
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
  
          // NO-SELECT attribute
          addProp('Dissallow&nbsp;Select', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-select') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-select', this.value === 'true', true);
          });
  
          // LETTER-SCROLLBAR attribute
          addProp('Letter&nbsp;Scrollbar', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('letter-scrollbar') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'letter-scrollbar', this.value === 'true', true);
          });
  
          // LETTER-DIVIDERS attribute
          addProp('Letter Dividers', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('letter-dividers') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'letter-dividers', this.value === 'true', true);
          });
          
          addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
              this.removeAttribute('refresh-on-querystring-change');
              return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
          });
          
          addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
              this.removeAttribute('refresh-on-querystring-values');
              return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
          });
          
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
  
      // removes selected class from old selected records adds class selected to record
      function highlightRecord(element, record) { //TODO: XLD
          var i, len, arrSelectedTrs;
  
          //console.log(record);
  
          if (element.tableElement && xtag.queryChildren(element.tableElement, 'tbody')[0]) {
              // clear previous selection
              arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]');
  
              for (i = 0, len = arrSelectedTrs.length; i < len; i += 1) {
                  arrSelectedTrs[i].removeAttribute('selected');
              }
          }
  
          // select/highlight the record that was provided
          if (record) {
              if (record.length >= 0) {
  
                  for (i = 0, len = record.length; i < len; i += 1) {
                      record[i].setAttribute('selected', '');
                  }
              } else {
                  record.setAttribute('selected', '');
              }
          }
      }
  
      // loops through the records and finds a record using the parameter
      function findRecordFromValue(element, searchValue) {
          var i, len, matchedRecord, arrTrs, strSearchString;
  
          if (element.tableElement && xtag.queryChildren(element.tableElement, 'tbody')[0]) {
              //console.log('1***', element.tableElement);
              //console.log('2***', xtag.queryChildren(element.tableElement, 'tbody')[0]);
              //console.log('3***', xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr'));
              arrTrs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr');
              strSearchString = String(searchValue);
  
              // search exact text and search both the value attribute (if present) and the first td text
              for (i = 0, len = arrTrs.length; i < len; i += 1) {
                  if (arrTrs[i].getAttribute('value') === strSearchString || xtag.queryChildren(arrTrs[i], 'td')[0].textContent === strSearchString) {
                      matchedRecord = arrTrs[i];
                      break;
                  }
              }
          }
  
          return matchedRecord;
      }
  
      function getTRFromTarget(element) {
          var currentElement = element;
  
          while (currentElement.nodeName !== 'TR') {
              currentElement = currentElement.parentNode;
          }
  
          return currentElement;
      }
      //snapback
      
      //boladd should be true if event.metaKey is true
      
      //if boladd is true:
      //  selected records that were clicked become non-selected
      //  non-select records that were clicked become selected
  
      // if bolShift is true and not negative:
      //  select from element.lastClicked to the clicked record
      // if bolShift is true and negative:
      //  de-select from element.lastClicked to the clicked record
      //
      //
  
      function selectRecord(element, handle, bolChange, bolAdd, strType, bolShift) {
          if (!element.hasAttribute('no-select') && element.tableElement) {
              //console.log(element.secondLastClicked, element.lastClicked);
              var record, arrSelectedRecords = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected], tr[selected-secondary]');
              //console.log(handle, bolChange, bolAdd, strType, bolShift);
              //console.trace('A');
              if (!bolAdd && !bolShift) {
                  var i, len, arrRecords = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr');
                  element.secondLastClicked = null;
                  for (i = 0, len = arrRecords.length; i < len; i += 1) {
                      arrRecords[i].removeAttribute('selected');
                      if (arrRecords[i].classList.contains('originTR')) {
                          arrRecords[i].classList.remove('originTR');
                      }
                  }
              }
  
              if (typeof handle === 'string' || typeof handle === 'number') {
                  record = findRecordFromValue(element, handle);
                  if (!record && handle !== '') {
                      console.warn('Listbox warning: record not found' + (typeof handle === 'string' ? ': "' + handle + '"' : ''));
                  }
              } else {
                  record = handle;
              }
  
              if (element.hasAttribute('multi-select')) {
                  if (handle.length >= 0) {
                      record = record;
                  } else {
                      record = [record];
                  }
              }
  
              if (bolShift && strType === 'down') {
                  var clickFrom, newClicked, arrOrigins = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr.originTR')
                      , arrAllRecords = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr'), bolDeselect, intDistanceBetween = 0
                      , intSelected = 0, bolRemoveClicked = false;
                  //if we have a lastClicked
                  //    use that
                  //else if we have an originTR
                  //    use that
                  //else if there is one selected record
                  //    use that
                  if (element.lastClicked) {
                      clickFrom = element.lastClicked
                  } else if (arrOrigins.length === 1) {
                      clickFrom = arrOrigins[0].getAttribute('data-record_no');
                  } else if (arrSelectedRecords.length === 1) {
                      clickFrom = arrSelectedRecords[0].getAttribute('data-record_no');
                  }
  
                  //get the record that was just clicked
                  if (typeof handle === 'object' && handle.tagName) {
                      newClicked = parseInt(handle.getAttribute('data-record_no'), 10);
                  }
  
                  //console.log(clickFrom, newClicked);
                  if (newClicked) {
                      //find how many are selected between clickFrom and newClicked
                      if (clickFrom < newClicked) {
                          for (var i = clickFrom, len = newClicked; i < len; i++) {
                              if (handle.hasAttribute('selected') || handle.hasAttribute('selected-secondary')) {
                                  intSelected += 1;
                              }
                          }
                      } else {
                          for (var i = newClicked - 1, len = clickFrom - 1; i < len; i++) {
                              if (handle.hasAttribute('selected') || handle.hasAttribute('selected-secondary')) {
                                  intSelected += 1;
                              }
                          }
                      }
  
                      if (clickFrom < newClicked) {
                          intDistanceBetween = newClicked - clickFrom;
                      } else {
                          intDistanceBetween = clickFrom - newClicked;
                      }
  
                      //if all of the records are selected
                      //    bolDeselect = true
                      //else
                      //    bolDeselect = false
                      if (intDistanceBetween <= intSelected) {
                          bolDeselect = true;
                      } else {
                          bolDeselect = false;
                      }
  
  
                      //console.log(bolDeselect, intDistanceBetween, intSelected);
                      //if clickFrom is higher in the list than newClicked
                      //    select down from clickFrom to newClicked
                      //else
                      //    select down from newClicked to clickFrom
                      if (clickFrom < newClicked) {
                          if (bolDeselect) {
                              clickFrom -= 1;
                              newClicked -= 1;
                          }
                          for (var i = clickFrom, len = newClicked; i < len; i++) {
                              if (bolDeselect) {
                                  if (arrAllRecords[i].hasAttribute('selected')) {
                                      arrAllRecords[i].removeAttribute('selected');
                                  }
                                  if (arrAllRecords[i].hasAttribute('selected-secondary')) {
                                      arrAllRecords[i].removeAttribute('selected-secondary');
                                  }
                              } else {
                                  arrAllRecords[i].setAttribute('selected', '');
                              }
                              arrAllRecords[i].classList.remove('originTR');
                          }
                      } else {
                          if (bolDeselect) {
                              newClicked += 1;
                              clickFrom += 1
                          }
                          for (var i = newClicked - 1, len = clickFrom; i < len; i++) {
                              if (bolDeselect) {
                                  if (arrAllRecords[i].hasAttribute('selected')) {
                                      arrAllRecords[i].removeAttribute('selected');
                                  }
                                  if (arrAllRecords[i].hasAttribute('selected-secondary')) {
                                      arrAllRecords[i].removeAttribute('selected-secondary');
                                  }
                              } else {
                                  arrAllRecords[i].setAttribute('selected', '');
                              }
                              arrAllRecords[i].classList.remove('originTR');
                          }
                      }
                  }
  
  
                  //if bolDeselect is false
                  //    deselect from clickFrom to the first non-selected record
                  if (!bolDeselect) {
                      if (clickFrom < newClicked) {
                          if (element.secondLastClicked > clickFrom && element.secondLastClicked < newClicked) {
                              bolRemoveClicked = true;
                          }
                      } else {
                          if (element.secondLastClicked < clickFrom && element.secondLastClicked > newClicked) {
                              bolRemoveClicked = true;
                          }
                      }
                      
                      if (bolRemoveClicked) {
                          if (clickFrom < newClicked) {
                              for (var i = element.secondLastClicked - 2; i > 0; i--) {
                                      // console.log(arrAllRecords[i].outerHTML, arrAllRecords[i].hasAttribute('selected'), arrAllRecords[i].hasAttribute('selected-secondary'));
                                      arrAllRecords[i].classList.remove('originTR');
  
                                      if (arrAllRecords[i].hasAttribute('selected')) {
                                          arrAllRecords[i].removeAttribute('selected');
                                      } else if (arrAllRecords[i].hasAttribute('selected-secondary')) {
                                          arrAllRecords[i].removeAttribute('selected-secondary');
                                      } else {
                                          // console.log(arrAllRecords[i]);
                                          break;
                                      }
                              }
                          } else {
                              for (var i = element.secondLastClicked, len = arrAllRecords.length; i < len; i++) {
                                      arrAllRecords[i].classList.remove('originTR');
                                      if (arrAllRecords[i].hasAttribute('selected')) {
                                          arrAllRecords[i].removeAttribute('selected');
                                      } else if (arrAllRecords[i].hasAttribute('selected-secondary')) {
                                          arrAllRecords[i].removeAttribute('selected-secondary');
                                      } else {
                                          break;
                                      }
                              }
                          }
                      }
                      // console.log(bolRemoveClicked, i, len, bolDeselect, clickFrom < newClicked, element.secondLastClicked);
                  }
  
  
  
                  // var i_shift, len_shift, newNumber, arrOrigins = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr.originTR');
                  // for (i_shift = 0, len_shift = arrOrigins.length; i_shift < len_shift; i_shift += 1) {
                  //     arrOrigins[i_shift] = parseInt(arrOrigins[i_shift].getAttribute('data-record_no'),10);
                  // }
                  // newNumber = parseInt(handle.getAttribute('data-record_no'),10);
  
                  // var currentNumber = arrOrigins[0];
                  // var diff = Math.abs (newNumber - currentNumber);
                  // for (var val = 0; val < arrOrigins.length; val++) {
                  //     var newdiff = Math.abs (newNumber - arrOrigins[val]);
                  //     if (newdiff < diff) {
                  //         diff = newdiff;
                  //         currentNumber = arrOrigins[val];
                  //     }
                  // }
                  // // for (i_shift = 0, len_shift = arrOrigins.length; i_shift < len_shift; i_shift += 1) {
                  // //     currentDiff = Math.abs(arrOrigins[i_shift] - newNumber);
                  // //     //console.log(currentDiff, arrDiffs);
                  // //     arrDiffs.push(currentDiff);
                  // //     for (var i_diff = 0, len_diff = arrDiffs.length; i_diff < len_diff; i_diff += 1) {
                  // //         if (currentDiff > arrDiffs[i_diff]) {
                  // //             currentDiff = arrDiffs[i_diff];
                  // //             currentNumber = arrOrigins[i_diff - 1];
                  // //             // console.log(arrDiffs, i_diff);
                  // //             //console.log(currentDiff, arrDiffs);
                  // //         }
                  // //     }
                  // // }
                  // var arrAllRecords = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr');
                  // //console.log(newNumber, currentNumber);
                  // //console.log(arrOrigins);
                  // //console.log(handle.hasAttribute('selected') || handle.hasAttribute('selected-secondary'));
                  // if (handle.hasAttribute('selected') || handle.hasAttribute('selected-secondary')) {
                  //     if (arrOrigins.length === 1) {
                  //         currentNumber = arrAllRecords.length;
                  //     } else {
                  //         if (newNumber > currentNumber) {
                  //             if (arrOrigins[arrOrigins.indexOf(currentNumber) + 1]) {
                  //                 currentNumber = arrOrigins[arrOrigins.indexOf(currentNumber) + 1] - 1;
                  //             } else {
                  //                 currentNumber = arrOrigins[arrOrigins.indexOf(currentNumber)];
                  //             }
                  //         } else {
                  //             if (arrOrigins[arrOrigins.indexOf(currentNumber) - 1]) {
                  //                 currentNumber = arrOrigins[arrOrigins.indexOf(currentNumber) - 1] - 1;
                  //             } else {
                  //                 currentNumber = arrOrigins[arrOrigins.indexOf(currentNumber)];
                  //             }
                  //         }
                  //     }
                  //     // console.log(newNumber, currentNumber);
                  //     if (newNumber < currentNumber) {
                  //         for (var i = newNumber - 1, len = currentNumber; i < len; i++) {
                  //             arrAllRecords[i].removeAttribute('selected', '');
                  //             arrAllRecords[i].classList.remove('originTR');
                  //             //console.log(arrAllRecords[i]);
                  //         }
                  //     } else {
                  //         for (var i = currentNumber, len = newNumber; i < len; i++) {
                  //             arrAllRecords[i].removeAttribute('selected', '');
                  //             arrAllRecords[i].classList.remove('originTR');
                  //             //console.log(arrAllRecords[i]);
                  //         }
                  //     }
                      
                  // } else {
                  //     if (newNumber < currentNumber) {
                  //         for (var i = newNumber - 1, len = currentNumber; i < len; i++) {
                  //             arrAllRecords[i].setAttribute('selected-secondary', '');
                  //             //console.log(arrAllRecords[i]);
                  //         }
                  //     } else {
                  //         for (var i = currentNumber, len = newNumber; i < len; i++) {
                  //             arrAllRecords[i].setAttribute('selected-secondary', '');
                  //             //console.log(arrAllRecords[i]);
                  //         }
                  //     }
                  //     handle.classList.add('originTR');
                  // }
  
              } else if (strType === 'down') {
                  element.originTR = record[0];
                  //console.log(arrSelectedRecords);//handle, handle.hasAttribute('selected'));
                  if (bolAdd && handle.hasAttribute('selected') && arrSelectedRecords.length > 1) {
                      handle.removeAttribute('selected');
                      if (handle.classList.contains('originTR')) {
                          handle.classList.remove('originTR');
                      }
                  } else {
                      element.originTR.setAttribute('selected-secondary', '');
                  }
              } else if (strType === 'move' && !bolShift) {
                  var arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected-secondary]');
  
                  // if (element.tableElement && xtag.queryChildren(element.tableElement, 'tbody')[0]) {
                  //     // clear previous selection
                  //     k
                  //     for (i = 0, len = arrSelectedTrs.length; i < len; i += 1) {
                  //         arrSelectedTrs[i].removeAttribute('selected-secondary');
                  //     }
                  // }
  
                  var arrRecords = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr');
                  var i, len, arrRecordsToAffect =
                      arrRecords.slice(Math.min(element.originTR.getAttribute('data-record_no')
                                          , record[0].getAttribute('data-record_no')) - 1
                                      , Math.max(element.originTR.getAttribute('data-record_no')
                                          , record[0].getAttribute('data-record_no')));
  
                  for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                      arrRecordsToAffect[i].setAttribute('selected-secondary', '');
                  }
                  
                  //console.log('origin: ', element.originTR.rowIndex);
                  //console.log('destination: ', record[0].rowIndex);
                  //console.log('arrRecordsToAffect', arrRecordsToAffect);
                  //console.log('arrRecordsToAffect.length', arrRecordsToAffect.length);
                  //console.log('record', record);
              } else if (strType === 'up') {
                  if (element.tableElement && xtag.queryChildren(element.tableElement, 'tbody')[0]) {
                      // clear previous selection
                      arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected-secondary]');
  
                      for (i = 0, len = arrSelectedTrs.length; i < len; i += 1) {
                          arrSelectedTrs[i].removeAttribute('selected-secondary');
                          arrSelectedTrs[i].setAttribute('selected', '');
                      }
                  }
                  if (record[0]) {
                      //console.trace('triggerchange 1');
                      element.triggerChange();
                  }
              } else if (record) {
                  // highlightRecord has its own checking for no record supplied,
                  // so this deselects any rows then selects the supplied record or none
                  if (element.hasAttribute('multi-select')) {
                      for (i = 0, len = record.length; i < len; i += 1) {
                          record[i].setAttribute('selected', '');
                      }
                  } else {
                      record.setAttribute('selected', '');
                  }
                  //highlightRecord(element, record);
                  //console.trace('triggerchange 2');
                  element.triggerChange();
              }
              
              if (element.originTR) {
                  element.originTR.classList.add('originTR');
              }
              
              //Save last clicked tr no for Shift-selecting
              if (typeof handle === 'object' && handle.tagName && strType === 'down') {
                  //console.log(typeof handle, handle);
                  if (element.lastClicked) {
                      element.secondLastClicked = element.lastClicked;
                  }
                  element.lastClicked = parseInt(handle.getAttribute('data-record_no'), 10);
              }
              // console.log(record, 'record');
              //console.log('3***', element.selectedRecord, element.value);
          }
      }
  
  
      // #################################################################
      // ########################## USER EVENTS ##########################
      // #################################################################
  
      // handle behaviours on keydown
      function handleKeyDown(event) {
          var element = event.target.parentNode, intKeyCode = event.keyCode || event.which, selectedTr, trs, i, len, selectedRecordIndex;
          
          if (!element.hasAttribute('disabled')) {
              if (!element.hasAttribute('no-select')) {
                  if ((intKeyCode === 40 || intKeyCode === 38) && (!event.shiftKey) && !event.metaKey && !event.ctrlKey && !element.error) {
                      //console.log(element.parentNode);
                      trs = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr:not(.divider)');
                      
                      for (i = 0, len = trs.length; i < len; i += 1) {
                          if (trs[i].hasAttribute('selected')) {
                              selectedRecordIndex = i;
                              selectedTr = trs[i];
                              trs[i].removeAttribute('selected');
                              
                              break;
                          }
                      }
                      
                      if (intKeyCode === 40) {// next record or circle to first record or start selection at the first
                          if (!selectedTr || selectedRecordIndex === trs.length - 1) {
                              highlightRecord(element, trs[0]);
                              selectedTr = trs[0];
                              
                          } else {
                              highlightRecord(element, trs[selectedRecordIndex + 1]);
                              selectedTr = trs[selectedRecordIndex + 1];
                          }
                          
                      } else if (intKeyCode === 38) {// prev record or circle to last record or start selection at the last
                          if (!selectedTr || selectedRecordIndex === 0) {
                              highlightRecord(element, trs[trs.length - 1]);
                              selectedTr = trs[trs.length - 1];
                              
                          } else {
                              highlightRecord(element, trs[selectedRecordIndex - 1]);
                              selectedTr = trs[selectedRecordIndex - 1];
                          }
                      }
                      
                      //GS.scrollIntoView(selectedTr);
                      element.scrollToSelectedRecord();
                      event.preventDefault();
                      event.stopPropagation();
                      
                  } else if (event.keyCode === 13) {
                      selectedTr = xtag.query(xtag.query(element.tableElement, 'tbody')[0], 'tr[selected]')[0];
                      
                      if (element.tableElement && selectedTr) {
                          selectRecord(element, selectedTr, true);
                      }
                  }
              }
          } else {
              if (event.keyCode !== 9) {
                  event.preventDefault();
                  event.stopPropagation();
              }
          }
          
          //console.log('handleKeyDown', intKeyCode, event);
      }
      
      function handleFocusout(event) {
          //TODO: XLD
          /*
          var element = event.target, selectedTr;
          
          if (element.tableElement) {
              selectedTr = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]')[0];
              
              if (selectedTr) {
                  selectRecord(element, selectedTr, true);
              }
          }
          */
      }
      
      
      // #################################################################
      // ######################### DATA HANDLING #########################
      // #################################################################
      
      
      // handles fetching the data
      //      if bolInitalLoad === true then
      //          use: initialize query COALESCE TO source query
      //      else
      //          use: source query
      function getData(element, callback, bolInitalLoad, bolClearPrevious) {
          var strSrc     = GS.templateWithQuerystring(
                              (bolInitalLoad && element.getAttribute('initialize')
                                  ? element.getAttribute('initialize')
                                  : element.getAttribute('src')
                              )
                          )
            , srcParts   = strSrc[0] === '(' ? [strSrc, ''] : strSrc.split('.')
            , strSchema  = srcParts[0]
            , strObject  = srcParts[1]
            , strColumns = GS.templateWithQuerystring(element.getAttribute('cols') || '*').split(',').join('\t')
            , strWhere   = GS.templateWithQuerystring(element.getAttribute('where') || '')
            , strOrd     = GS.templateWithQuerystring(element.getAttribute('ord') || '')
            , strLimit   = GS.templateWithQuerystring(element.getAttribute('limit') || '')
            , strOffset  = GS.templateWithQuerystring(element.getAttribute('offset') || '')
            , response_i = 0, response_len = 0, arrTotalRecords = [];
          
          GS.addLoader(element, 'Loading...');
          GS.requestSelectFromSocket(GS.envSocket, strSchema, strObject, strColumns
                                   , strWhere, strOrd, strLimit, strOffset
                                   , function (data, error) {
              var arrRecords, arrCells, envData
                , i, len, cell_i, cell_len;
              
              //console.log(data);
              
              if (!error) {
                  if (data.strMessage !== 'TRANSACTION COMPLETED') {
                      arrRecords = GS.trim(data.strMessage, '\n').split('\n');
                      
                      for (i = 0, len = arrRecords.length; i < len; i += 1) {
                          arrCells = arrRecords[i].split('\t');
                          
                          for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                              arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                          }
                          
                          arrTotalRecords.push(arrCells);
                      }
                  } else {
                      GS.removeLoader(element);
                      element.arrColumnNames = data.arrColumnNames;
                      
                      envData = {'arr_column': element.arrColumnNames, 'dat': arrTotalRecords};
                      
                      handleData(element, bolInitalLoad, envData);
                      GS.triggerEvent(element, 'after_select');
                      if (typeof callback === 'function') {
                          callback();
                      }
                  }
              } else {
                  handleData(element, bolInitalLoad, data, error);
                  GS.removeLoader(element);
              }
          });
      }
      
      // handles data result from method function: getData 
      //      success:  template
      //      error:    add error classes
      function handleData(element, bolInitalLoad, data, error) {
          var strTemplate, divElement, tableElement, theadElement, theadCellElements, tbodyElement, tbodyCellElements, lastRecordElement,
              recordElements, recordElement, currentCellLabelElement, template, i, len, arrHeaders = [], arrHide, intVisibleColumns, strHeaderCells, strRecordCells, jsnTemplate, strHTML;
          
          // clear any old error status
          element.classList.remove('error');
          element.setAttribute('title', '');
          
          //console.log(error, data, bolInitalLoad);
          
          // if there was no error
          if (!error) {
              element.error = false;
              
              if (element.tableTemplate) {// element.tableTemplateElement
                  strTemplate = element.tableTemplate;// element.tableTemplateElement
                  
              } else {
                  // create an array of hidden column numbers
                  arrHide = (element.getAttribute('hide') || '').split(/[\s]*,[\s]*/);
                  
                  // build up the header cells variable and the record cells variable
                  for (i = 0, len = data.arr_column.length, strHeaderCells = '', strRecordCells = '', intVisibleColumns = 0; i < len; i += 1) {
                      // if this column is not hidden
                      if (arrHide.indexOf((i + 1) + '') === -1 && arrHide.indexOf(data.arr_column[i]) === -1) {
                          // append a new cell to each of the header cells and record cells variables
                          strHeaderCells += '<th gs-dynamic>' + encodeHTML(data.arr_column[i]) + '</th> ';
                          strRecordCells += '<td gs-dynamic>{{! row[\'' + data.arr_column[i] + '\'] }}</td> ';
                          intVisibleColumns += 1;
                      }
                  }
                  
                  // put everything together
                  strTemplate =   '<table gs-dynamic>';
                  
                  if (intVisibleColumns > 1) { // data.arr_column.length (didn't take into account hidden columns)
                      strTemplate +=  '<thead gs-dynamic>' +
                                          '<tr gs-dynamic>' +
                                              strHeaderCells +
                                          '</tr>' +
                                      '</thead>';
                  }
                  
                  strTemplate +=      '<tbody gs-dynamic>' +
                                          '<tr data-record_no="{{! row.row_number }}" value="{{! row[\'' + data.arr_column[0] + '\'] }}" gs-dynamic>' +
                                              strRecordCells +
                                          '</tr>' +
                                      '</tbody>' +
                                  '<table>';
              }
              
              divElement = document.createElement('div');
              divElement.innerHTML = strTemplate;
              
              tableElement = xtag.queryChildren(divElement, 'table')[0];
              theadElement = xtag.queryChildren(tableElement, 'thead')[0];
              tbodyElement = xtag.queryChildren(tableElement, 'tbody')[0];
              
              // if there is a tbody
              if (tbodyElement) {
                  recordElement = xtag.queryChildren(tbodyElement, 'tr')[0];
                  
                  // if there is a record: template
                  if (recordElement) {
                      
                      // if there is a thead element: add reflow cell headers to the tds
                      if (theadElement) {
                          theadCellElements = xtag.query(theadElement, 'td, th');
                          tbodyCellElements = xtag.query(tbodyElement, 'td, th');
                          
                          for (i = 0, len = theadCellElements.length; i < len; i += 1) {
                              currentCellLabelElement = document.createElement('b');
                              currentCellLabelElement.classList.add('cell-label');
                              currentCellLabelElement.setAttribute('data-text', (theadCellElements[i].textContent || '') + ':');
                              
                              if (tbodyCellElements[i].childNodes) {
                                  tbodyCellElements[i].insertBefore(currentCellLabelElement, tbodyCellElements[i].childNodes[0]);
                              } else {
                                  tbodyCellElements[i].insertChild(currentCellLabelElement);
                              }
                          }
                      }
                      
                      // template
                      jsnTemplate = GS.templateHideSubTemplates(tbodyElement.innerHTML, true);
                      strHTML = GS.templateWithEnvelopeData(jsnTemplate.templateHTML, data);
                      tbodyElement.innerHTML = GS.templateShowSubTemplates(strHTML, jsnTemplate);
                      
                      element.tableElement = tableElement;
                      element.syncView();
                      element.internalData.records = data;
                  }
              }
              
              //console.log('1***', bolInitalLoad, element.getAttribute('value'));
              
              //if (bolInitalLoad && element.getAttribute('value')) {
              //    //console.log('2***', bolInitalLoad, element.getAttribute('value'));
              //    selectRecord(element, element.getAttribute('value'), false);
              //    element.scrollToSelectedRecord();
              //    
              //// select first record
              //} else
              
              if (bolInitalLoad && !element.getAttribute('value') && element.hasAttribute('select-first')) {
                  selectRecord(element, xtag.query(element, 'tbody tr')[0].getAttribute('value'), false);
                  element.scrollToSelectedRecord();
              }
              
          // else there was an error: add error class, title attribute
          } else {
              element.error = true;
              element.classList.add('error');
              element.setAttribute('title', 'This listbox has failed to load.');
              
              element.setAttribute('disabled', '');
              
              GS.ajaxErrorDialog(data);
          }
      }
      
      function getParentCell(element) {
          var currentElement = element;
          
          while (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH' && currentElement.nodeName !== 'HTML') {
              currentElement = currentElement.parentNode;
          }
          
          if (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH') {
              return undefined;
          }
          
          return currentElement;
      }
      
      function windowResizeHandler() {
          var i, len, arrElement;
          
          arrElement = document.getElementsByTagName('gs-listbox');
          
          for (i = 0, len = arrElement.length; i < len; i += 1) {
              if (GS.pxToEm(document.body, this.oldWidth) !== GS.pxToEm(document.body, this.offsetWidth) && // <== if the width (in ems) changes
                  arrElement[i].hasAttribute('letter-scrollbar') &&
                  arrElement[i].tableElement) {
                  
                  if (arrElement[i].hasAttribute('letter-dividers') || arrElement[i].hasAttribute('letter-scrollbar')) {
                      arrElement[i].refreshDividingPoints();
                  }
                  arrElement[i].letterScrollbarHandler();
                  this.oldWidth = this.offsetWidth;
              }
          }
      }
      
      window.addEventListener('resize', windowResizeHandler);  // I want to debounce this event but that would require a timer -michael
      window.addEventListener('orientationchange', windowResizeHandler);
      
      //function pushReplacePopHandler(element) {
      //    var i, len, currentValue, bolRefresh = false, strQueryString = GS.getQueryString(), arrPopKeys, strQSCol = element.getAttribute('qs');
      //    
      //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1 && element.value !== GS.qryGetVal(strQueryString, strQSCol)) {
      //        element.value = GS.qryGetVal(strQueryString, strQSCol);
      //    }
      //    
      //    // if this element has a refresh-on-querystring-values attribute: check for changes
      //    if (element.hasAttribute('refresh-on-querystring-values')) {
      //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
      //        
      //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
      //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
      //            
      //            if ((element.popValues[arrPopKeys[i]] || '') !== currentValue) {
      //                bolRefresh = true;
      //            }
      //            
      //            element.popValues[arrPopKeys[i]] = currentValue;
      //        }
      //        
      //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
      //        bolRefresh = true;
      //    }
      //    
      //    if (bolRefresh) {
      //        element.refresh();
      //    }
      //}
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          i = 0;
          len = element.attributes.length;
          arrAttr = element.attributes;
          while (i < len) {
              jsnAttr = element.attributes[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var arrPopKeys;
          var currentValue;
          var bolRefresh;
          var strOperator;
  
          element.supressChange = false;
  
          if (strQSCol) {
              if (strQSCol.indexOf('=') !== -1) {
                  arrAttrParts = strQSCol.split(',');
                  i = 0;
                  len = arrAttrParts.length;
                  while (i < len) {
                      strQSCol = arrAttrParts[i];
      
                      if (strQSCol.indexOf('!=') !== -1) {
                          strOperator = '!=';
                          arrQSParts = strQSCol.split('!=');
                      } else {
                          strOperator = '=';
                          arrQSParts = strQSCol.split('=');
                      }
      
                      strQSCol = arrQSParts[0];
                      strQSAttr = arrQSParts[1] || arrQSParts[0];
      
                      // if the key is not present or we've got the negator: go to the attribute's default or remove it
                      if (strOperator === '!=') {
                          // if the key is not present: add the attribute
                          if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                              element.setAttribute(strQSAttr, '');
                          // else: remove the attribute
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      } else {
                          // if the key is not present: go to the attribute's default or remove it
                          if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                              if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                  element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                              } else {
                                  element.removeAttribute(strQSAttr);
                              }
                          // else: set attribute to exact text from QS
                          } else {
                              element.setAttribute(strQSAttr, (
                                  GS.qryGetVal(strQS, strQSCol) ||
                                  element.internal.defaultAttributes[strQSAttr] ||
                                  ''
                              ));
                          }
                      }
                      i += 1;
                  }
              } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                  strQSValue = GS.qryGetVal(strQS, strQSCol);
      
                  if (element.internal.bolQSFirstRun !== true) {
                      if (strQSValue !== '' || !element.getAttribute('value')) {
                          element.supressChange = true;
                          element.setAttribute('value', strQSValue);
                      }
                  } else if (element.value !== strQSValue) {
                      element.value = strQSValue;
                  }
              }
          }
          
          // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
          if (element.internal.bolQSFirstRun === true) {
              if (element.hasAttribute('refresh-on-querystring-values')) {
                  arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                  
                  for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                      currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);
                      
                      if (element.popValues[arrPopKeys[i]] !== currentValue) {
                          bolRefresh = true;
                      }
                      
                      element.popValues[arrPopKeys[i]] = currentValue;
                  }
              } else if (element.hasAttribute('refresh-on-querystring-change')) {
                  bolRefresh = true;
              }
              
              if (bolRefresh && element.hasAttribute('src')) {
                  getData(element);
              } else if (bolRefresh && !element.hasAttribute('src')) {
                  console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
              }
          } else {
              if (element.hasAttribute('refresh-on-querystring-values')) {
                  arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                  
                  for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                      element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                  }
              }
          }
          
          element.internal.bolQSFirstRun = true;
      }
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              // if the value was set before the "created" lifecycle code runs: set attribute
              //      (discovered when trying to set a value of a date control in the after_open of a dialog)
              //      ("delete" keyword added because of firefox)
              if (element.value && !element.getAttribute('value')) {
                  element.setAttribute('value', element.value);
                  delete element.value;
                  //element.value = null;
              }
          }
      }
  
      // ############# COPY EVENTS #############
      function unbindCopy(element) {
          element.removeEventListener(
              'copy',
              element.copySelection
          );
      }
      function bindCopy(element) {
          // console.log('running1');
          element.copySelection = function (event) {
              // console.log('running2');
              var jsnCopyString = {};
              var focusedElement;
  
              // saving the currently focused element for easy/quick access
              focusedElement = document.activeElement;
  
              // if the focus is on the hidden focus control of if the text
              //      selection of the currently focused element is not
              //      selecting multiple characters
              if (
                  focusedElement.classList.contains('hidden-focus-control') ||
                  focusedElement.selectionStart === focusedElement.selectionEnd
              ) {
                  console.time('copy');
  
                  // focus the hidden focus control and select all of it's text so
                  //      that Firefox will allow us to override the clipboard
                  focusedElement = element.hiddenFocusControl;
                  focusedElement.focus();
  
                  GS.setInputSelection(
                      focusedElement,
                      0,
                      focusedElement.value.length
                  );
  
                  jsnCopyString.text = '';
                  jsnCopyString.html = '';
  
                  // we want to override the text and HTML mime type clipboards,
                  //      so we get the copy text for both types
                  var selectedRecords = element.selectedRecord;
                  if (selectedRecords[0]) {
                      for (var i = 0, len = selectedRecords.length; i < len; i++) {
                          if (i < 1) {
                              jsnCopyString.text += selectedRecords[i].innerText;
                              //jsnCopyString.html += selectedRecords[i].innerHTML;
                          } else {
                              jsnCopyString.text += '\n' + selectedRecords[i].innerText;
                              //jsnCopyString.html += '\n' + selectedRecords[i].innerHTML;
                          }
                      }
                  //not multi-select
                  } else {
                      jsnCopyString.text = selectedRecords.innerText;
                      //jsnCopyString.html = selectedRecords.innerHTML;
                      // console.log(selectedRecords);
                  }
                  // console.log(jsnCopyString);
                  //jsnCopyString = getCopyStrings(element);
  
                  // override clipboard (prevent event default if we are
                  //      successful)
                  if (handleClipboardData(event, jsnCopyString.text, 'text')) {
                      event.preventDefault(event);
                  }
                  // if (handleClipboardData(event, jsnCopyString.html, 'html')) {
                  //     event.preventDefault(event);
                  // }
  
  
                  console.timeEnd('copy');
              }
          };
  
          element.hiddenFocusControl.addEventListener(
              'copy',
              element.copySelection
          );
      }
  
      function handleClipboardData(event, strCopyString, strType) {
          var clipboardData = event.clipboardData || window.clipboardData;
          var strMime;
  
          if (!clipboardData) {
              return;
          }
          if (!clipboardData.setData) {
              return;
          }
  
          if (strType === 'text') {
              if (window.clipboardData && window.clipboardData.getData) { // IE
                  strMime = 'Text';
              } else if (event.clipboardData && event.clipboardData.getData) {
                  strMime = 'text/plain';
              }
          } else if (strType === 'html') {
              if (window.clipboardData && window.clipboardData.getData) { // IE
                  strMime = '';
              } else if (event.clipboardData && event.clipboardData.getData) {
                  strMime = 'text/html';
              }
          } else {
              throw 'handleClipboardData Error: Type "' + strType + '" not ' +
                      'recognized, recognized types are "text" and "html".';
          }
  
          if (strMime) {
              if (strCopyString && strMime) {
                  return clipboardData.setData(strMime, strCopyString) !== false;
              } else {
                  return clipboardData.getData(strMime);
              }
          }
      }
  
      //
      function elementInserted(element) {
          var tableTemplateElement, arrElement, recordElement, tableTemplateElementCopy, strQSValue, i, len, currentElement;
          
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.error = false;
                  element.internal = {};
                  element.internalData = {};
                  saveDefaultAttributes(element);
                  // handle "qs" attribute
                  if (element.hasAttribute('qs') ||
                          element.hasAttribute('refresh-on-querystring-values') ||
                          element.hasAttribute('refresh-on-querystring-change')) {
                      element.popValues = {};
                      //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                      //
                      //if (strQSValue !== '' || !element.getAttribute('value')) {
                      //    element.setAttribute('value', strQSValue);
                      //}
  
                      pushReplacePopHandler(element);
                      window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                      window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                      window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                      //element.popValues = GS.qryToJSON(GS.getQueryString());
                  }
  
                  // allows the element to have focus
                  if (!element.hasAttribute('tabindex')) {
                      element.setAttribute('tabindex', '0');
                  }
  
                  element.skipFocus = false;
  
                  // select for template
                  tableTemplateElement = xtag.queryChildren(element, 'template')[0];
                  if (tableTemplateElement && (tableTemplateElement.innerHTML.indexOf('&gt;') > -1 || tableTemplateElement.innerHTML.indexOf('&lt;') > -1)) {
                      console.warn('GS-LISTBOX WARNING: &gt; or &lt; detected in table template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                  }
                  
                  
                  if (element.getAttribute('src') || element.getAttribute('source')) {
                      if (element.innerHTML.trim() !== '') {
                          var trSet = xtag.query(tableTemplateElement.content, 'tbody > tr');//:not(.divider)');
                          //console.log(trSet);
                          for (var i = 0, len = trSet.length; i < len; i++) {
                              trSet[i].setAttribute('data-record_no', '{{! row.row_number }}');
                              // console.log(trSet[i]);
                          }
                      }
                  }
                  
                  if (tableTemplateElement) {
                      // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                      element.tableTemplate = GS.templateColumnToValue(tableTemplateElement.innerHTML);
                  }
  
                  if (element.getAttribute('src') || element.getAttribute('source')) {
                      // if (element.innerHTML.trim() !== '') {
                      //     var trSet = xtag.query(tableTemplateElement.content, 'tbody > tr');//:not(.divider)');
                      //     //console.log(trSet);
                      //     for (var i = 0, len = trSet.length; i < len; i++) {
                      //         trSet[i].setAttribute('data-record_no', '{{! row.row_number }}');
                      //         // console.log(trSet[i]);
                      //     }
                      // }
                      getData(element, '', true);
                  } else {
                      if (tableTemplateElement) {
                          //developer provided template
                          element.tableElement = xtag.query(tableTemplateElement.content, 'table')[0];
                      } else if (xtag.queryChildren(element, 'table')[0]) {
                          element.tableElement = xtag.queryChildren(element, 'table')[0];
                      } else {
                          element.tableElement = document.createElement('table');
                      }
                      //loop through and add the data-record_no attribute
                      //console.log(element.innerHTML);
                      var trSet = xtag.query(tableTemplateElement.content, 'tr');//:not(.divider)');
                      //console.log(trSet);
                      for (var i = 0, len = trSet.length; i < len; i++) {
                          //console.log(trSet[i]);
                          trSet[i].setAttribute('data-record_no', i);
                      }
                      element.syncView();
                  }
              }
          }
      }
      
      xtag.register('gs-listbox', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      if (strAttrName === 'value' && newValue !== oldValue) {
                          this.value = newValue;
                      }
                  }
              }
          },
          events: {},
          accessors: {
              value: {
                  get: function () {
                      var element = this;
                      if (element.tableElement) {
                          var arrRecords = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]');//:not(.divider)
                          //console.log(arrRecords);
                          if (this.hasAttribute('multi-select')) {
                              var arrResult = [], i;
                              for (i = 0; i < arrRecords.length; i++) {
                                  if (this.internalData.records.dat[arrRecords[i].getAttribute('data-record_no') - 1]) {
                                      arrResult.push(this.internalData.records.dat[arrRecords[i].getAttribute('data-record_no') - 1][0]);
                                  }
                              }
                              return arrResult;
                          } else {
                              // console.trace('sonofagun');
                              if (arrRecords.length > 0) {
                                  // console.log(arrRecords);
                                  // console.log('test1', arrRecords[0].rowIndex);
                                  // console.log('test2', this.internalData.records.dat[arrRecords[0].rowIndex]);
                                  if (this.internalData.records.dat[arrRecords[0].getAttribute('data-record_no') - 1]) {
                                      return this.internalData.records.dat[arrRecords[0].getAttribute('data-record_no') - 1][0];
                                  }
                              }
                          }
                      }
                  },
                  
                  set: function (strNewValue) {
                      selectRecord(this, strNewValue);
                      this.scrollToSelectedRecord();
                  }
              },
              
              selectedRecord: {
                  get: function () {
                      var element = this;
                      if (element.tableElement) {
                          var arrRecords = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]');
                          //console.log('arrRecords', arrRecords);
                          if (this.hasAttribute('multi-select')) {
                              return arrRecords;
                          } else {
                              return arrRecords[0];
                          }
                      }
                  },
                  
                  set: function (newValue) {
                      selectRecord(this, newValue);
                      this.scrollToSelectedRecord();
                  }
              },
              
              textValue: {
                  get: function () {
                      var element = this;
                      if (element.tableElement) {
                          var arrRecords = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]');
                          
                          if (this.hasAttribute('multi-select')) {
                              var strResult, i;
                              for (i = 0; i < arrRecords.length; i++) {
                                  // console.log(arrRecords, i, xtag.queryChildren(arrRecords[i], 'td'));
                                  if (xtag.queryChildren(arrRecords[i], 'td').length > 0) {
                                      strResult += xtag.queryChildren(arrRecords[i], 'td')[0].textContent;
                                  }
                              }
                              return strResult;
                          } else {
                              return arrRecords[0].textContent;
                          }
                      }
                  },
                  
                  set: function () {
                      selectRecord(this, strNewValue);
                      this.scrollToSelectedRecord();
                  }
              }
          },
          methods: {
              // just a semantic alias to the getData function
              refresh: function (callback) {
                  getData(this, callback);
              },
              
              column: function (strColumn) {
                  //console.log('no', Number(this.innerSelectedRecord.rowIndex) - 1);
                  //console.log('data', this.internalData.records);
                  //console.log('return', this.internalData.records.dat[Number(this.innerSelectedRecord.rowIndex) - 1]);
                  var element = this;
                  if (this.hasAttribute('multi-select')) {
                      var arrStrResult = [], i;
                      for (i = 0; i < this.selectedRecord.length; i++) {
                          arrStrResult.push(this.internalData.records.dat[this.selectedRecord[i].rowIndex - 1][this.internalData.records.arr_column.indexOf(strColumn)]);
                      }
                      //console.log('this.selectedRecord', this.selectedRecord);
                      //console.log('arrStrResult', arrStrResult);
                      return arrStrResult;
                  } else {
                      return this.internalData.records.dat[this.selectedRecord.rowIndex - 1][this.internalData.records.arr_column.indexOf(strColumn)];
                  }
              },
              
              // #################################################################
              // ########### SELECTION / HIGHLIGHTING / RECORD / VALUE ###########
              // #################################################################
              
              // scroll the dropdown to the selected record
              scrollToSelectedRecord: function () {
                  var selectedTr;
                  
                  if (this.tableElement) {
                      selectedTr = xtag.query(this.tableElement, 'tr[selected]')[0];
                      
                      if (selectedTr) {
                          GS.scrollIntoView(selectedTr);
                      }
                  }
                  
                  /*var scrollingContainer, arrTrs, i, len, intScrollTop, bolFoundSelected = false;
                  
                  if (this.tableElement) {
                      scrollingContainer = this;
                      arrTrs = xtag.query(this.tableElement, 'tr');
                      
                      for (i = 0, intScrollTop = 0, len = arrTrs.length; i < len; i += 1) {
                          if (arrTrs[i].hasAttribute('selected')) {
                              intScrollTop += arrTrs[i].offsetHeight / 2;
                              
                              bolFoundSelected = true;
                              
                              break;
                          } else {
                              intScrollTop += arrTrs[i].offsetHeight;
                          }
                      }
                      
                      if (bolFoundSelected) {
                          intScrollTop = intScrollTop - scrollingContainer.offsetHeight / 2;
                      } else {
                          intScrollTop = 0;
                      }
                      
                      scrollingContainer.scrollTop = intScrollTop;
                  }*/
              },
              
              // ################################################################
              // ####################### LETTER SCROLLBAR #######################
              // ################################################################
              
              letterScrollbarHandler: function () {
                  var element = this, i, len, intTextHeight, intLettersDropped, intSkipperHeight,
                      intElementHeight, intDistance, strHTML, arrSkippers;
                  
                  // if there is no letter scrollbar container: create it
                  if (xtag.queryChildren(element, '.letter-scrollbar-container').length === 0) {
                      element.letterScrollbarContainer = document.createElement('div');
                      element.letterScrollbarContainer.classList.add('letter-scrollbar-container');
                      element.letterScrollbarContainer.setAttribute('gs-dynamic', '');
                      element.appendChild(element.letterScrollbarContainer);
                      
                  // else: clear out the old letterScrollbarContainer
                  } else {
                      element.letterScrollbarContainer.innerHTML = '';
                  }
                  
                  if (element.clientHeight < element.scrollContainer.scrollHeight) {
                      intTextHeight = GS.getTextHeight(element.letterScrollbarContainer);
                      intSkipperHeight = intTextHeight * this.arrDividingPoints.length;
                      intElementHeight = element.clientHeight / this.arrDividingPoints.length;
                      
                      if (intElementHeight < intTextHeight) {
                          intElementHeight = intTextHeight;
                      }
                      
                      if (intSkipperHeight > element.clientHeight) { 
                          intLettersDropped = 0;
                          while (intSkipperHeight > element.clientHeight && intLettersDropped < 100) {
                              intSkipperHeight -= intTextHeight;
                              intLettersDropped += 1;
                          }
                          intDistance = Math.ceil(this.arrDividingPoints.length / intLettersDropped);
                      }
                      
                      for (i = 0, len = this.arrDividingPoints.length, strHTML = ''; i < len; i += 1) {
                          if (intLettersDropped === undefined || (intLettersDropped > 0 && i % intDistance !== 0)) {
                              strHTML += '<div class="skipper" gs-dynamic ' +
                                              'style="height: ' + intElementHeight + 'px; line-height: ' + intElementHeight + 'px;" ' + 
                                              'data-target-offset="' + this.arrDividingPoints[i].offset + '">' +
                                              '<span gs-dynamic>' + this.arrDividingPoints[i].letter + '</span>' +
                                          '</div>';
                          }
                      }
                      
                      element.letterScrollbarContainer.innerHTML = strHTML;
                      
                      if (element.paddingElement && element.paddingElement.parentNode === element.scrollContainer) {
                          element.scrollContainer.removeChild(element.paddingElement);
                      }
                      
                      element.paddingElement = document.createElement('div');
                      element.paddingElement.setAttribute('gs-dynamic', '');
                      if (this.arrDividingPoints.length > 0) {
                      element.paddingElement.style.height = (element.clientHeight -
                                                          (element.scrollContainer.scrollHeight - parseInt(this.arrDividingPoints[this.arrDividingPoints.length - 1].offset, 10))) + 'px';
                      }
                      element.scrollContainer.appendChild(element.paddingElement);
                      
                      // bind skipper click, mousedown-then-drag
                      arrSkippers = element.letterScrollbarContainer.children;
                      
                      if (element.mousedownHandler) {
                          window.removeEventListener(evt.mousedown, element.mousedownHandler);
                          window.removeEventListener(evt.mousemove, element.mousemoveHandler);
                          window.removeEventListener(evt.mouseup, element.mouseupHandler);
                      }
                      
                      //element.clickHandler = function () {
                      //    //console.log('-webkit-overflow-scrolling: touch;',   element.scrollContainer.scrollTop);
                      //    element.style.webkitOverflowScrolling = 'initial';
                      //    //console.log('-webkit-overflow-scrolling: initial;', element.scrollContainer.scrollTop);
                      //    element.scrollContainer.scrollTop = parseInt(this.getAttribute('data-target-offset'), 10);
                      //    //console.log('-webkit-overflow-scrolling: initial;', element.scrollContainer.scrollTop);
                      //    element.style.webkitOverflowScrolling = 'touch';
                      
                      element.clickHandler = function () {
                          //console.log('-webkit-overflow-scrolling: touch;',   element.scrollContainer.scrollTop);
                          element.style.webkitOverflowScrolling = 'initial';
                          //console.log('-webkit-overflow-scrolling: initial;', element.scrollContainer.scrollTop);
                          element.scrollContainer.scrollTop = parseInt(this.getAttribute('data-target-offset'), 10);
                          //console.log('-webkit-overflow-scrolling: initial;', element.scrollContainer.scrollTop);
                          element.style.webkitOverflowScrolling = 'touch';
                          
                          //alert('Here I am');
                          
                          //element.scrollContainer.className = element.scrollContainer.className;
                          //element.scrollContainer.style.outline = '1px solid #000000';
                          //element.scrollContainer.style.outline = '';
                          //console.log('-webkit-overflow-scrolling: touch;',   element.scrollContainer.scrollTop);
                          //console.log('test');
                      };
                      element.mousedownHandler = function (event) { // event
                          window.addEventListener(evt.mousemove, element.mousemoveHandler);
                          if (event.target.classList.contains('skipper') && evt.touchDevice) {
                              element.style.webkitOverflowScrolling = 'initial';
                          }
                          //element.mousemoveHandler(event);
                      };
                      element.mousemoveHandler = function (event) {
                          var jsnMousePosition, targetElement;
                          
                          if (event.which !== 0 || evt.touchDevice) {
                              jsnMousePosition = GS.mousePosition(event);
                              targetElement = document.elementFromPoint(jsnMousePosition.left, jsnMousePosition.top);
                              
                              if (targetElement) {
                                  if (targetElement.nodeName === 'SPAN') {
                                      targetElement = targetElement.parentNode;
                                  }
                                  
                                  //console.log(targetElement, jsnMousePosition);
                                  
                                  if (targetElement.classList.contains('skipper')) {
                                      element.style.webkitOverflowScrolling = 'initial';
                                      event.preventDefault();
                                      element.scrollContainer.scrollTop = parseInt(targetElement.getAttribute('data-target-offset'), 10);
                                  }
                              }
                          } else {
                              window.removeEventListener(evt.mousemove, element.mousemoveHandler);
                          }
                      };
                      element.mouseupHandler = function () {
                          element.style.webkitOverflowScrolling = 'touch';
                          window.removeEventListener(evt.mousemove, element.mousemoveHandler);
                      };
                      
                      //window
                      element.addEventListener(evt.mousedown, element.mousedownHandler);
                      //window
                      element.addEventListener(evt.mouseup, element.mouseupHandler);
                      
                      for (i = 0, len = arrSkippers.length; i < len; i += 1) {
                          arrSkippers[i].addEventListener('click', element.clickHandler);
                      }
                      //}
                  }
              },
              
              
              // #################################################################
              // ########################### UTILITIES ###########################
              // #################################################################
              
              refreshDividingPoints: function () {
                  var tbodyElement, arrElement, arrLetter, dividerElement, strLetter, intOffset, numColumns, theadElement, i, len;
                  
                  tbodyElement = xtag.queryChildren(this.tableElement, 'tbody')[0];
                  
                  arrElement = xtag.queryChildren(tbodyElement, 'tr.divider');
                  
                  for (i = 0, len = arrElement.length; i < len; i += 1) {
                      tbodyElement.removeChild(arrElement[i]);
                  }
                  
                  this.arrDividingPoints = [];
                  
                  arrElement = xtag.queryChildren(tbodyElement, 'tr');
                  
                  if (arrElement.length > 0) {
                      numColumns = arrElement[0].children.length;
                      
                      
                      //console.log(theadElement, (theadElement ? theadElement.offsetHeight : 0));
                      theadElement = xtag.queryChildren(this.tableElement, 'thead')[0];
                      intOffset = (theadElement ? theadElement.offsetHeight : 0);
                      
                      for (i = 0, len = arrElement.length, arrLetter = []; i < len; i += 1) {
                          strLetter = xtag.queryChildren(arrElement[i], 'td')[0].textContent.substring(0, 1).toUpperCase();
                          
                          if (arrLetter.indexOf(strLetter) === -1) {
                              this.arrDividingPoints.push({
                                  'letter': strLetter,
                                  'offset': intOffset
                              });
                              
                              if (this.hasAttribute('letter-dividers')) {
                                  dividerElement = document.createElement('tr');
                                  dividerElement.classList.add('divider');
                                  dividerElement.setAttribute('gs-dynamic', '');
                                  dividerElement.setAttribute('data-target-offset', intOffset);
                                  //if (!this.hasAttribute('letter-dividers')) { <== messed with odd and even record colors when letter-scrollbar but not letter-dividers -michael
                                  //    dividerElement.setAttribute('hidden', '');
                                  //}
                                  
                                  dividerElement.innerHTML = '<td colspan="' + numColumns + '" gs-dynamic>' + encodeHTML(strLetter) + '</td>';
                                  
                                  tbodyElement.insertBefore(dividerElement, arrElement[i]);
                                  
                                  intOffset += dividerElement.offsetHeight;
                              }
                              
                              arrLetter.push(strLetter);
                          }
                          
                          intOffset += arrElement[i].offsetHeight;
                      }
                  }
              },
              
              syncView: function () {
                  var element = this, tbodyElement, i, len, arrElements, clickHandler, mousedownHandler, mousemoveHandler, mouseupHandler, mouseoutHandler, mouseoverHandler;
                  
                  element.removeEventListener('keydown', handleKeyDown);
                  element.addEventListener('keydown', handleKeyDown);
                  
                  element.removeEventListener('focusout', handleFocusout);
                  element.addEventListener('focusout', handleFocusout);
                  
                  element.innerHTML = '';
                  
                  element.scrollContainer = document.createElement('div');
                  element.scrollContainer.setAttribute('gs-dynamic', '');
                  element.scrollContainer.classList.add('root');
                  element.scrollContainer.classList.add('scroll-container');
                  element.scrollContainer.appendChild(element.tableElement);
                  
                  element.appendChild(element.scrollContainer);
                  tbodyElement = xtag.queryChildren(element.tableElement, 'tbody')[0];
                  
                  // add dividers
                  if (element.hasAttribute('letter-dividers') || element.hasAttribute('letter-scrollbar')) {
                      element.refreshDividingPoints();
                      
                      // if we have the letter-scrollbar attribute: add the letter scrollbar
                      if (element.hasAttribute('letter-scrollbar')) {
                          element.letterScrollbarHandler();
                      }
                  }
                  
                  // this fixes the fact that this function was clearing the selection
                  if (this.getAttribute('value')) {
                      selectRecord(this, this.getAttribute('value'));
                      this.scrollToSelectedRecord();
                  }
                  
                  // click handling code
                  // get list of record elements
                  arrElements = xtag.toArray(tbodyElement.children);
                  
                  if (element.hasAttribute('multi-select')) {
                      // if we are not on a touch device: hover and down events
                      if (!evt.touchDevice) {
                          var mouseIsDown = false;
                          mousedownHandler = function (event) {
                              mouseIsDown = true;
                              this.classList.add('down');
                              element.addEventListener(evt.mousemove, mousemoveHandler);
                              window.addEventListener(evt.mouseup, mouseupHandler);
                              selectRecord(element, this, true, (event.ctrlKey || event.metaKey), 'down', event.shiftKey);
                          };
                          mousemoveHandler = function (event) {
                              if (mouseIsDown) {
                                  selectRecord(element, getTRFromTarget(event.target), true, (event.ctrlKey || event.metaKey), 'move', event.shiftKey);
                              }
                          };
                          mouseupHandler = function (event) {
                              mouseIsDown = false;
                              selectRecord(element, this, true, (event.ctrlKey || event.metaKey), 'up', event.shiftKey);
                              element.removeEventListener(evt.mousemove, mousemoveHandler);
                              window.removeEventListener(evt.mouseup, mouseupHandler);
                          };
                          mouseoutHandler = function () {
                              this.classList.remove('down');
                              this.classList.remove('hover');
                          };
                          mouseoverHandler = function () {
                              this.classList.remove('down');
                              this.classList.add('hover');
                          };
                      
                          // add click event with click event function to all record elements that are not dividers
                          for (i = 0, len = arrElements.length; i < len; i += 1) {
                              if (!arrElements[i].classList.contains('divider')) {
                                  arrElements[i].addEventListener(evt.mousedown, mousedownHandler);
                                  arrElements[i].addEventListener(evt.mouseout, mouseoutHandler);
                                  arrElements[i].addEventListener(evt.mouseover, mouseoverHandler);
                              }
                          }
                      } else {
                          //TODO: toggle
                          // create click event function
                          clickHandler = function (event) {
                              this.classList.remove('down');
                              selectRecord(element, this, true);
                          };
                      }
                  } else {
                      // create click event function
                      clickHandler = function (event) {
                          this.classList.remove('down');
                          selectRecord(element, this, true);
                      };
                      
                      // add click event with click event function to all record elements that are not dividers
                      for (i = 0, len = arrElements.length; i < len; i += 1) {
                          if (!arrElements[i].classList.contains('divider')) {
                              arrElements[i].addEventListener('click', clickHandler);
                          }
                      }
                      
                      // if we are not on a touch device: hover and down events
                      if (!evt.touchDevice) {
                          mousedownHandler = function () {
                              this.classList.add('down');
                          };
                          mouseoutHandler = function () {
                              this.classList.remove('down');
                              this.classList.remove('hover');
                          };
                          mouseoverHandler = function () {
                              this.classList.remove('down');
                              this.classList.add('hover');
                          };
                      
                          // add click event with click event function to all record elements that are not dividers
                          for (i = 0, len = arrElements.length; i < len; i += 1) {
                              if (!arrElements[i].classList.contains('divider')) {
                                  arrElements[i].addEventListener(evt.mousedown, mousedownHandler);
                                  arrElements[i].addEventListener(evt.mouseout, mouseoutHandler);
                                  arrElements[i].addEventListener(evt.mouseover, mouseoverHandler);
                              }
                          }
                      }
                  }
                  
                  //tbodyElement.addEventListener('click', function (event) {
                  //    var parentRecord = GS.findParentTag(event.target, 'TR');
                  //    
                  //    if (parentRecord && !parentRecord.classList.contains('divider')) {
                  //        selectRecord(element, parentRecord, true);
                  //    }
                  //});
                  var focusElement = document.createElement('textarea');
                  focusElement.classList.add('hidden-focus-control');
                  focusElement.setAttribute('value', 'text makes this textarea Firefox worthy');
  
                  element.appendChild(focusElement);
                  element.hiddenFocusControl = focusElement;
  
                  element.addEventListener('focus', function (event) {
                      event.preventDefault();
                      event.stopPropagation
                      if (event.target !== element.hiddenFocusControl) {
                          element.hiddenFocusControl.focus();
                          GS.triggerEvent(element.hiddenFocusControl, 'focus');
                          // console.log(document.activeElement);
                          element.skipFocus = true;
                          // console.log(element.skipFocus);
                      }
                  });
                  bindCopy(element);
                  //console.log(element.tableTemplate);
                  
                  
              },
              
              triggerChange: function () {
                  if (this.supressChange === true) {
                      this.supressChange = false;
                  } else {
                      xtag.fireEvent(this, 'change', {
                          bubbles: true,
                          cancelable: true
                      });
                  }
              }
          }
      });
  });//element.clientHeight < element.scrollHeight
  
  window.addEventListener('design-register-element', function () {
      
      registerDesignSnippet('<gs-memo>', '<gs-memo>', 'gs-memo column="${1:name}"></gs-memo>');
      registerDesignSnippet('<gs-memo> With Label', '<gs-memo>', 'label for="${1:memo-insert-note}">${2:Notes}:</label>\n' +
                                                                 '<gs-memo id="${1:memo-insert-note}" column="${3:note}"></gs-memo>');
      
      designRegisterElement('gs-memo', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-memo.html');
      
      window.designElementProperty_GSMEMO = function(selectedElement) {
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
          
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
          
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
          
          addProp('Rows', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('rows') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'rows', this.value);
          });
          
          addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
          });
          
          //console.log(selectedElement.hasAttribute('mini'));
          
          addProp('Autoresize', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('autoresize')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'autoresize', (this.value === 'true'), true);
          });
          
          addProp('Allow tab', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('allow-tab-char')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'allow-tab-char', (this.value === 'true'), true);
          });
          
          addProp('Resize Handle', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-resize-handle')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-resize-handle', (this.value === 'true'), false);
          });
          
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
          
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          // TABINDEX attribute
          addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
          });
          
          addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
          });
          
          addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
          });
          
          addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
          });
          
          addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
          });
          
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
          
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
          
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
          
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          // DISABLED attribute
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
          
          addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
          });
          
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  // trigger resize to text on window resize
  window.addEventListener('resize', function () {
      var i, len, arrElements = document.getElementsByTagName('gs-memo');
      
      for (i = 0, len = arrElements.length; i < len; i += 1) {
          //if (arrElements[i].control.clientHeight < arrElements[i].control.scrollHeight) {
          arrElements[i].handleResizeToText();
          //}
      }
  });
  
  
  if (!evt.touchDevice) {
      window.gsMemo = {};
      window.gsMemo.bolFirstMouseMoveWhileDown = true;
      window.gsMemo.currentMouseTarget = null;
      
      window.addEventListener('mousemove', function (event) {
          var mousePosition, intWhich;// = GS.mousePosition(event);
          
          // firefox sometimes doesn't permit access to "event.which"
          //      so this try/catch statement will prevent the error and nothing will run
          try {
              intWhich = event.which;
          } catch (e) {}
          
          if (window.bolFirstMouseMoveWhileDown === true && intWhich !== undefined && intWhich !== 0) {
              mousePosition = GS.mousePosition(event);
              
              window.bolFirstMouseMoveWhileDown = false;
              window.gsMemo.currentMouseTarget = document.elementFromPoint(mousePosition.x, mousePosition.y);
              
          } else if (intWhich !== undefined && intWhich === 0) {
              window.bolFirstMouseMoveWhileDown = true;
          }
          
          if (window.gsMemo.currentMouseTarget &&
              intWhich !== undefined && intWhich !== 0 &&
              window.gsMemo.currentMouseTarget.nodeName === 'TEXTAREA' &&
              window.gsMemo.currentMouseTarget.parentNode.nodeName === 'GS-MEMO' && //event.target === element.control &&
              window.bolFirstMouseMoveWhileDown === false &&
                  (window.gsMemo.currentMouseTarget.lastWidth !== window.gsMemo.currentMouseTarget.clientWidth ||
                  window.gsMemo.currentMouseTarget.lastHeight !== window.gsMemo.currentMouseTarget.clientHeight)) {// && //element.control === window.lastMouseDownElement) {
              
              //GS.triggerEvent(window.gsMemo.currentMouseTarget.parentNode, 'size-changed');
              
              window.gsMemo.currentMouseTarget.style.margin = '';
              window.gsMemo.currentMouseTarget.style.marginLeft = '';
              window.gsMemo.currentMouseTarget.style.marginRight = '';
              window.gsMemo.currentMouseTarget.style.marginTop = '';
              window.gsMemo.currentMouseTarget.style.marginBottom = '';
              window.gsMemo.currentMouseTarget.lastWidth  = window.gsMemo.currentMouseTarget.clientWidth;
              window.gsMemo.currentMouseTarget.lastHeight = window.gsMemo.currentMouseTarget.clientHeight;
              
              GS.triggerEvent(window.gsMemo.currentMouseTarget.parentNode, 'size-changed');
              
              //console.log('mousemove (' + new Date().getTime() + ')');
          }
      });
      
      window.addEventListener('mouseup', function (event) {
          //var mousePosition = GS.mousePosition(event);
          
          window.bolFirstMouseMoveWhileDown = true;
          //console.log('3***'); //, document.elementFromPoint(mousePosition.x, mousePosition.y)); //event.target);
          //window.lastMouseDownElement = element.control;
      });
  }
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      
      var multiLineTemplateElement = document.createElement('template'),
          multiLineTemplate;
      
      multiLineTemplateElement.innerHTML = '<textarea class="control" gs-dynamic></textarea>';
      
      multiLineTemplate = multiLineTemplateElement.content;
      
      // re-target change event from control to element
      function changeFunction(event) {
          event.preventDefault();
          event.stopPropagation();
          
          GS.triggerEvent(event.target.parentNode, 'change');
      }
  
      // re-target focus event from control to element
      function focusFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'focus');
          event.target.parentNode.classList.add('focus');
      }
  
      // re-target blur event from control to element
      function blurFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'blur');
          event.target.parentNode.classList.remove('focus');
      }
  
      // mouseout, remove hover class
      function mouseoutFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseout);
          event.target.parentNode.classList.remove('hover');
      }
  
      // mouseover, add hover class
      function mouseoverFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseover);
          event.target.parentNode.classList.add('hover');
      }
  
      // function focusFunction(event) {
      //     event.preventDefault();
      //     event.stopPropagation();
      //     if (event.target.parentNode.hasAttribute('first-value')) {
      //             console.log(event);
      //         //GS.triggerEvent(event.target.parentNode, 'focus');
      //     } else {
      //         event.target.parentNode.setAttribute('first-value', event.target.value);
      //         GS.triggerEvent(event.target.parentNode, 'focus');
      //         //console.log('test');
      //     }
      // }
      
      //
      function keydownFunction(event) {
          var element = event.target;
          if (!element.hasAttribute('readonly')) {
              if (element.getAttribute('disabled') !== null && !(event.keyCode === 122 && event.metaKey)) {
                  event.preventDefault();
                  event.stopPropagation();
              } else if (event.keyCode === 9 && element.parentNode.hasAttribute('allow-tab-char') === true) {
                  event.preventDefault();
                  event.stopPropagation();
                  var cursor_pos_memo = parseInt(element.selectionStart, 10);
                  element.value = element.value.substring(0, cursor_pos_memo) + '\t' + element.value.substring(cursor_pos_memo, element.value.length);
                  GS.setInputSelection(element, parseInt(cursor_pos_memo, 10) + 1, parseInt(cursor_pos_memo, 10) + 1);
              } else {
                  //this.parentNode.syncView();
                  element.parentNode.setAttribute('value', element.value);
                  element.parentNode.handleResizeToText();
              }
          }
      }
      
      //
      function keyupFunction(event) {
          var element = event.target;
          if (!element.hasAttribute('readonly')) {
              //this.parentNode.syncView();
              element.parentNode.setAttribute('value', element.value);
              element.parentNode.handleResizeToText();
          }
      }
      
      function insertFunction(event) {
          var element = event.target;
          element.parentNode.handleResizeToText();
      }
      
      ////
      //function createPushReplacePopHandler(element) {
      //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
      //    
      //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.value = GS.qryGetVal(strQueryString, strQSCol);
      //    }
      //}
      
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          arrAttr = element.attributes;
          i = 0;
          len = arrAttr.length;
          while (i < len) {
              jsnAttr = arrAttr[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function createPushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  if (strQSValue !== '' || !element.getAttribute('value')) {
                      element.value = strQSValue;
                  }
              } else {
                  element.value = strQSValue;
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              // if the value was set before the "created" lifecycle code runs: set attribute
              //      (discovered when trying to set a value of a date control in the after_open of a dialog)
              //      ("delete" keyword added because of firefox)
              if (element.value) {
                  element.setAttribute('value', element.value);
                  delete element.value;
                  //element.value = null;
              }
          }
      }
  
      //
      function elementInserted(element) {
          //var strQSValue;
  
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
  
                  if (element.hasAttribute('tabindex')) {
                      element.setAttribute('data-tabindex', element.getAttribute('tabindex'));
                      element.removeAttribute('tabindex');
                  }
  
                  element.appendChild(multiLineTemplate.cloneNode(true));
                  if (element.hasAttribute('data-tabindex')) {
                      xtag.query(element, '.control')[0].setAttribute('tabindex', element.getAttribute('data-tabindex'));
                  }
                  // set a variable with the control element for convenience and speed
                  element.control = xtag.queryChildren(element, '.control')[0];
  
                  element.control.lastWidth = element.control.clientWidth;
                  element.control.lastHeight = element.control.clientHeight;
                  element.syncView();
  
                  if (element.getAttribute('qs')) {
                      //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                      //
                      //if (strQSValue !== '' || !element.getAttribute('value')) {
                      //    element.value = strQSValue;
                      //}
  
                      createPushReplacePopHandler(element);
                      window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                      window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                      window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                  }
              }
          }
      }
  
      xtag.register('gs-memo', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      //console.log(this.getAttribute('id'), strAttrName, oldValue, newValue);
                      if (strAttrName === 'disabled' && newValue !== null) {
                          this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder');
                      } else if (strAttrName === 'disabled' && newValue === null) {
                          this.innerHTML = '';
                          this.appendChild(multiLineTemplate.cloneNode(true));
                          if (this.hasAttribute('data-tabindex')) {
                              xtag.query(this, '.control')[0].setAttribute('tabindex', this.getAttribute('data-tabindex'));
                          }
                          // set a variable with the control element for convenience and speed
                          this.control = xtag.queryChildren(this, '.control')[0];
                          
                          this.control.lastWidth = this.control.clientWidth;
                          this.control.lastHeight = this.control.clientHeight;
                          this.syncView();
                      } else if (strAttrName === 'value' && newValue !== oldValue) {
                          this.value = newValue;
                      }
                  }
              }
          },
          events: {},
          accessors: {
              value: {
                  // get value straight from the input
                  get: function () {
                      if (this.control) {
                          return this.control.value;
                      } else {
                          return this.innerHTML;
                      }
                  },
                  
                  // set the value of the input and set the value attribute
                  set: function (strNewValue) {
                      if (this.getAttribute('value') !== strNewValue) {
                          this.setAttribute('value', strNewValue);
                      }
                      if (this.control) {
                          this.control.value = strNewValue;
                      } else {
                          this.innerHTML = strNewValue;
                      }
                      this.syncView();
                  }
              },
              textValue: {
                  // get value straight from the input
                  get: function () {
                      if (this.control) {
                          return this.control.value;
                      } else {
                          return this.innerHTML;
                      }
                  },
                  
                  // set the value attribute
                  set: function (newValue) {
                      //this.setAttribute('value', newValue);
                      this.value = newValue;
                  }
              }
          },
          methods: {
              focus: function () {
                  if (this.control) {
                      this.control.focus();
                  }
              },
              
              // sync control and resize to text
              syncView: function () {
                  var element = this, arrPassThroughAttributes, i, len;
                  
                  /*
                  if (this.innerHTML === '') {
                      this.appendChild(multiLineTemplate.cloneNode(true));
                  }
                  */
                  /*
                  if ((! this.hasAttribute('disabled')) && (! this.control)) {
                      this.appendChild(multiLineTemplate.cloneNode(true));
                      // set a variable with the control element for convenience and speed
                      this.control = xtag.queryChildren(this, '.control')[0];
                      
                      this.control.lastWidth = this.control.clientWidth;
                      this.control.lastHeight = this.control.clientHeight;
                  }
                  */
                  
                  if (this.hasAttribute('rows')) {
                      if (this.control) {
                          this.control.setAttribute('rows', this.getAttribute('rows'));
                      }
                  }
                  
                  if (this.control) {
                      this.control.removeEventListener('change', changeFunction);
                      this.control.addEventListener('change', changeFunction);
                      
                      this.control.removeEventListener('focus', focusFunction);
                      this.control.addEventListener('focus', focusFunction);
                      
                      this.control.removeEventListener('blur', blurFunction);
                      this.control.addEventListener('blur', blurFunction);
  
                      this.control.removeEventListener(evt.mouseout, mouseoutFunction);
                      this.control.addEventListener(evt.mouseout, mouseoutFunction);
                      
                      this.control.removeEventListener(evt.mouseout, mouseoverFunction);
                      this.control.addEventListener(evt.mouseover, mouseoverFunction);
                      
                      this.control.removeEventListener('keydown', keydownFunction);
                      this.control.addEventListener('keydown', keydownFunction);
                      
                      this.control.removeEventListener('insert', insertFunction);
                      this.control.addEventListener('insert', insertFunction);
                  }
                  
                  if (this.control) {
                      this.control.value = this.getAttribute('value');
                  } else {
                      this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder') || '';
                  }
                      
                  if (this.getAttribute('value')) {
                      this.handleResizeToText();
                  }
                  
                  if (this.control) {
                      arrPassThroughAttributes = [
                          'placeholder',
                          'name',
                          'maxlength',
                          'autocorrect',
                          'autocapitalize',
                          'autocomplete',
                          'autofocus',
                          'rows',
                          'spellcheck',
                          'readonly'
                      ];
                      for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                          if (this.hasAttribute(arrPassThroughAttributes[i])) {
                              this.control.setAttribute(arrPassThroughAttributes[i], this.getAttribute(arrPassThroughAttributes[i]) || '');
                          }
                      }
                  }
                  
                  // copy passthrough attributes to control
              },
              
              // if element is multiline and autoresize is not turned off: resize the element to fit the content
              handleResizeToText: function () {
                  var element = this, intMinHeight;
                  
                  if (element.control) {
                      if (element.hasAttribute('autoresize')) {
                          element.control.style.height = '';
                          intMinHeight = element.control.offsetHeight;
                          element.control.style.height = ''; // '0';
                          
                          if (element.control.scrollHeight > intMinHeight) {
                              element.control.style.height = element.control.scrollHeight + 'px';
                          } else {
                              element.control.style.height = intMinHeight + 'px';
                          }
                      }
                      
                      
                      if (element.control.lastWidth !== element.control.clientWidth && element.control.lastHeight !== element.control.clientHeight) {
                          element.control.lastWidth = element.control.clientWidth;
                          element.control.lastHeight = element.control.clientHeight;
                          
                          GS.triggerEvent(element, 'size-changed');
                      }
                  }
              }
          }
      });
  });
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('<gs-scroller>', '<gs-scroller>', 'gs-scroller>\n' +
                                                          '    <gs-scroller-inner style="width: ${1:1000px}; height: ${2:1000px};">\n' +
                                                          '        ${0}\n' +
                                                          '    </gs-scroller-inner>\n' +
                                                          '</gs-scroller>');
      
      designRegisterElement('gs-scroller', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-scroller.html');
      
      window.designElementProperty_GSSCROLLER = function (selectedElement) {
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
          
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
          
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
      };
  });
  
  
  Math.easeOutQuad = function (current_time, start_value, end_change, end_time) {
      'use strict';
      // Quadratic equation (produced by Robert Penner (www.robertpenner.com))
      current_time /= end_time;
      return -end_change * current_time * (current_time - 2) + start_value;
  };
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      
      // using element, direction and X delta: move element using quadratic equation
      function easeOutX(dragElement, target, bolRight, intXDelta, intervalEaseXID) {
          var intFrames = Math.ceil(intXDelta / 0.25), intFrame = 0, intInterval = 20
            , intTotalTime = (intFrames * intInterval);
          
          //console.log(bolRight, intXDelta);
          
          if (intXDelta > 5) {
              intervalEaseXID = setInterval(function () {
                  var intLeft;
                  
                  if (intFrame < intFrames) {
                      intLeft = parseInt(dragElement.style.left, 10);
                      
                      if (bolRight) {
                          intLeft = intLeft - Math.easeOutQuad((intFrame * intInterval), intXDelta, -intXDelta, intTotalTime);
                      } else {
                          intLeft = intLeft + Math.easeOutQuad((intFrame * intInterval), intXDelta, -intXDelta, intTotalTime);
                      }
                      
                      setElementLeft(dragElement, target, intLeft);
                  } else {
                      clearTimeout(intervalEaseXID);
                  }
                  
                  intFrame += 1;
              }, intInterval);
          }
          return intervalEaseXID;
      }
      
      // using element, direction and Y delta: move element using quadratic equation
      function easeOutY(dragElement, target, bolBottom, intYDelta, intervalEaseYID) {
          var intFrames = Math.ceil(intYDelta / 0.25), intFrame = 0, intInterval = 20
            , intTotalTime = (intFrames * intInterval);
          
          if (intYDelta > 5) {
              intervalEaseYID = setInterval(function () {
                  var intTop;
                  
                  if (intFrame < intFrames) {
                      intTop = parseInt(dragElement.style.top, 10);
                      
                      if (bolBottom) {
                          intTop = intTop - Math.easeOutQuad((intFrame * intInterval), intYDelta, -intYDelta, intTotalTime);
                      } else {
                          intTop = intTop + Math.easeOutQuad((intFrame * intInterval), intYDelta, -intYDelta, intTotalTime);
                      }
                      
                      setElementTop(dragElement, target, intTop);
                  } else {
                      clearTimeout(intervalEaseYID);
                  }
                  
                  intFrame += 1;
              }, intInterval);
          }
          return intervalEaseYID;
      }
      
      // set left and respect boundries
      function setElementLeft(dragElement, target, intLeft) {
          var intWidth = dragElement.offsetWidth, minRight = target.offsetWidth;
          
          // target right edge must never get < container right edge
          if ((intLeft + intWidth) < minRight) {
              intLeft = (minRight - intWidth);
          }
          
          // target left edge must never get > container left edge
          if (intLeft > 0) {
              intLeft = 0;
          }
          
          dragElement.style.left = intLeft + 'px';
      }
      
      // set top and respect boundries
      function setElementTop(dragElement, target, intTop) {
          var intHeight = dragElement.offsetHeight, minBottom = target.offsetHeight;
          
          // target bottom edge must never get < container bottom edge
          if ((intTop + intHeight) < minBottom) {
              intTop = (minBottom - intHeight);
          }
          
          // target top edge must never get > container top edge
          if (intTop > 0) {
              intTop = 0;
          }
          
          dragElement.style.top = intTop + 'px';
      }
      
      function handleVerticalBoundries(dragElement, target) {
          var intTop = parseFloat(dragElement.style.top)
            , intHeight = dragElement.offsetHeight
            , minBottom = target.offsetHeight;
          
          // target bottom edge must never get < container bottom edge
          if ((intTop + intHeight) < minBottom) {
              intTop = (minBottom - intHeight);
          }
          
          // target top edge must never get > container top edge
          if (intTop > 0) {
              intTop = 0;
          }
          
          dragElement.style.top = intTop + 'px';
      }
      
      function handleHorizontalBoundries(dragElement, target) {
          var intLeft = parseFloat(dragElement.style.left)
            , intWidth = dragElement.offsetWidth
            , minRight = target.offsetWidth;
          
          // target right edge must never get < container right edge
          if ((intLeft + intWidth) < minRight) {
              intLeft = (minRight - intWidth);
          }
          
          // target left edge must never get > container left edge
          if (intLeft > 0) {
              intLeft = 0;
          }
          
          dragElement.style.left = intLeft + 'px';
      }
      
      function bindEvents(element) {
          var target = element, dragElement = element.children[0], intervalEaseXID
            , intervalEaseYID, lastClearTime, intScrollDelta = 0, minZoom = 0.5
            , maxZoom = 6;
          
          // zoom with mousewheel
          target.addEventListener('wheel', function (event) {
              var intDelta = event.deltaY, intNewZoom, currentTime
                , jsnMousePosition = GS.mousePosition(event), mouseEMX, mouseEMY, mousePXX, mousePXY
                , jsnOffsets = GS.getElementOffset(dragElement)
                , jsnTargetOffset
                , intCurrentZoom = (parseFloat(dragElement.style.fontSize) || 1)
                , intOldHeight = dragElement.offsetHeight
                , intOldWidth = dragElement.offsetWidth
                , intNewHeight, intNewWidth, intWidthDifference, intHeightDifference
                , intRelativeX, intRelativeY, intPercentX, intPercentY;
              
              event.preventDefault();
              event.stopPropagation();
              
              // get mouse position over dragElement in ems
              mousePXY = (jsnMousePosition.y - jsnOffsets.top);
              mousePXX = (jsnMousePosition.x - jsnOffsets.left);
              
              mouseEMY = GS.pxToEm(dragElement, mousePXY);
              mouseEMX = GS.pxToEm(dragElement, mousePXX);
              //console.log(jsnOffsets.top, jsnMousePosition.y, mouseEMY);
              //console.log(jsnOffsets.left, jsnMousePosition.x, mouseEMX);
              
              //console.log(event, event.deltaY, intDelta);
              if (lastClearTime) {
                  currentTime = new Date().getTime();
                  
                  //console.log(currentTime - lastClearTime);
                  if ((currentTime - lastClearTime) > 200) {
                      intScrollDelta = 0;
                      lastClearTime = new Date().getTime();
                  }
              }
              
              // need to add clear if change direction
              
              lastClearTime = new Date().getTime();
              
              // if negative delta: increase custom delta by 0.1
              //      (unless we're at the maximum zoom, in which case: reset the delta)
              if (intDelta < 0) {
                  intScrollDelta = (intScrollDelta > 0 ? intScrollDelta : 0);
                  intScrollDelta = 0.05;
                  if (intCurrentZoom < maxZoom) {
                      intScrollDelta += 0.05;
                  } else {
                      intScrollDelta = 0;
                  }
                  
              // if positive delta: decrease custom delta by 0.1
              //      (unless we're at the minimum zoom, in which case: reset the delta)
              } else {
                  intScrollDelta = (intScrollDelta < 0 ? intScrollDelta : 0);
                  intScrollDelta = -0.05;
                  if (intCurrentZoom > minZoom) {
                      intScrollDelta -= 0.05;
                  } else {
                      intScrollDelta = 0;
                  }
              }
              
              // add new delta to current zoom
              intNewZoom = (intCurrentZoom + intScrollDelta);
              
              // if the new zoom is above 6em: cap it off at 6em
              intNewZoom = (intNewZoom > maxZoom ? maxZoom : intNewZoom);
              
              // if the new zoom is below minZoom: cap it off at minZoom
              intNewZoom = (intNewZoom < minZoom ? minZoom : intNewZoom);
              
              //console.log('1:' + intNewZoom, '2:' + intScrollDelta, '3:' + intCurrentZoom);
              
              // apply new zoom
              dragElement.style.fontSize = intNewZoom + 'em';
              
              if (intCurrentZoom !== intNewZoom) {
                  // get new height
                  intNewWidth = dragElement.offsetWidth;
                  intNewHeight = dragElement.offsetHeight;
                  
                  // adjust to mouse position
                  
                  // get full height difference
                  intWidthDifference = (intNewWidth - intOldWidth);
                  intHeightDifference = (intNewHeight - intOldHeight);
                  
                  // get relative x and y
                  jsnTargetOffset = GS.getElementOffset(dragElement);
                  intRelativeX = (jsnMousePosition.x - jsnTargetOffset.left);
                  intRelativeY = (jsnMousePosition.y - jsnTargetOffset.top);
                  
                  // get percentage of x and y
                  intPercentX = ((intRelativeX / intOldWidth) * 100);
                  intPercentY = ((intRelativeY / intOldHeight) * 100);
                  
                  //console.log(intNewWidth, intOldWidth, intWidthDifference, intRelativeX, intPercentX);
                  //console.log(intNewHeight, intOldHeight, intHeightDifference, intRelativeY, intPercentY);
                  
                  // percentage of height difference
                  dragElement.style.left = (parseFloat(dragElement.style.left || '0') - ((intWidthDifference / 100) * intPercentX)) + 'px';
                  dragElement.style.top = (parseFloat(dragElement.style.top || '0') - ((intHeightDifference / 100) * intPercentY)) + 'px';
              }
              
              // handle boundries
              handleVerticalBoundries(dragElement, target);
              handleHorizontalBoundries(dragElement, target);
          });
          
          // scrolling by dragging
          target.addEventListener(evt.mousedown, function (event) {
              var jsnMousePosition = GS.mousePosition(event)
                , jsnTargetOffsets = GS.getElementOffset(target)
                , jsnOffsets = GS.getElementOffset(dragElement)
                , startX = jsnMousePosition.x
                , startY = jsnMousePosition.y
                , offsetX = jsnOffsets.left - jsnTargetOffsets.left
                , offsetY = jsnOffsets.top - jsnTargetOffsets.top
                , lastX = 0, lastY = 0, currentX = 0, currentY = 0
                , deltaX, deltaY
                , mousemoveHandler, mouseupHandler;
              
              // stop text selection
              event.preventDefault();
              
              // stop easing functions
              clearTimeout(intervalEaseXID);
              clearTimeout(intervalEaseYID);
              
              // add "down" class
              dragElement.classList.add('down');
              
              mousemoveHandler = function (event) {
                  var jsnMousePosition;
                  
                  if (event.which === 0 && !evt.touchDevice) {
                      mouseupHandler(event);
                      
                  } else {
                      // handle move
                      jsnMousePosition = GS.mousePosition(event);
                      
                      // saving the current postition and the previous position for calculating the delta
                      lastX = currentX;
                      lastY = currentY;
                      currentX = jsnMousePosition.x;// - jsnTargetOffsets.left;
                      currentY = jsnMousePosition.y;// - jsnTargetOffsets.top;
                      
                      // moving element
                      //console.log(offsetX, currentX, startX);//, jsnTargetOffsets.left);
                      //console.log(offsetY, currentY, startY);//, jsnTargetOffsets.top);
                      setElementLeft(dragElement, target, (offsetX + (currentX - startX)));
                      setElementTop(dragElement, target, (offsetY + (currentY - startY)));
                      
                      event.preventDefault();
                  }
              };
              
              mouseupHandler = function (event) {
                  // calculate delta
                  deltaX = lastX - currentX;
                  deltaY = lastY - currentY;
                  
                  // ease out
                  intervalEaseXID = easeOutX(dragElement, target, (deltaX > 0), Math.abs(deltaX), intervalEaseXID);
                  intervalEaseYID = easeOutY(dragElement, target, (deltaY > 0), Math.abs(deltaY), intervalEaseYID);
                  
                  // remove "down" class
                  dragElement.classList.remove('down');
                  
                  // unbind mousemove and mouseup
                  document.body.removeEventListener(evt.mousemove, mousemoveHandler);
                  document.body.removeEventListener(evt.mouseup, mouseupHandler);
              };
              
              document.body.addEventListener(evt.mousemove, mousemoveHandler);
              document.body.addEventListener(evt.mouseup, mouseupHandler);
          });
      }
      
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              
          }
      }
      
      //
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  
                  if (element.children.length > 1) {
                      throw 'gs-scroller Error: Too many children. gs-scroller elements must have one child and it must be a <gs-scroller-inner> element.';
                      
                  } else if (element.children.length === 0) {
                      throw 'gs-scroller Error: No children. gs-scroller elements must have one child and it must be a <gs-scroller-inner> element.';
                      
                  } else if (element.children[0].nodeName !== 'GS-SCROLLER-INNER') {
                      throw 'gs-scroller Error: Invalid child. gs-scroller elements must have one child and it must be a <gs-scroller-inner> element.';
                  }
                  
                  // if we're not on a touch device: bind events and set the title text
                  if (!evt.touchDevice) {
                      // bind events
                      bindEvents(element);
                      
                      // title text
                      element.children[0].setAttribute('title', 'Click and drag to move around, scroll to zoom.');
                      
                  // else: make the element scrollable
                  } else {
                      element.classList.add('scrollable');
                  }
              }
          }
      }
      
      xtag.register('gs-scroller-inner', {});
      xtag.register('gs-scroller', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      
                  }
              }
          },
          events: {},
          accessors: {},
          methods: {}
      });
  });
  window.addEventListener('design-register-element', function () {
  
      registerDesignSnippet('<gs-number>', '<gs-number>', 'gs-number column="${1:name}"></gs-number>');
      registerDesignSnippet('<gs-number> With Label', '<gs-number>', 'label for="${1:number-insert-qty}">${2:Quantity}:</label>\n' +
                                                                     '<gs-number id="${1:number-insert-qty}" column="${3:qty}"></gs-number>');
  
      designRegisterElement('gs-number', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-number.html');
  
      window.designElementProperty_GSNUMBER = function(selectedElement) {
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
  
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
  
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
  
          addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
          });
  
          //console.log(selectedElement.hasAttribute('mini'));
  
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
  
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // TABINDEX attribute
          addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
          });
  
          addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
          });
  
          addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
          });
  
          addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
          });
  
          addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
          });
  
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
  
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
  
              return selectedElement;
          });
  
          // DISABLED attribute
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
          
          addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
          });
  
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      var singleLineTemplateElement = document.createElement('template'),
          singleLineTemplate;
  
      singleLineTemplateElement.innerHTML = '<input class="control" gs-dynamic type="text" />';
      singleLineTemplate = singleLineTemplateElement.content;
  
      // re-target change event from control to element
      function changeFunction(event) {
          event.preventDefault();
          event.stopPropagation();
  
          GS.triggerEvent(event.target.parentNode, 'change');
  
          handleFormat(event.target.parentNode, event);
      }
  
      // re-target focus event from control to element
      function focusFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'focus');
          event.target.parentNode.classList.add('focus');
      }
  
      // re-target blur event from control to element
      function blurFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'blur');
          event.target.parentNode.classList.remove('focus');
      }
  
      // mouseout, remove hover class
      function mouseoutFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseout);
          event.target.parentNode.classList.remove('hover');
      }
  
      // mouseover, add hover class
      function mouseoverFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseover);
          event.target.parentNode.classList.add('hover');
      }
  
      //function createPushReplacePopHandler(element) {
      //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
  
      //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.value = GS.qryGetVal(strQueryString, strQSCol);
      //    }
      //}
      
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          arrAttr = element.attributes;
          i = 0;
          len = arrAttr.length;
          while (i < len) {
              jsnAttr = arrAttr[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function createPushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  if (strQSValue !== '' || !element.getAttribute('value')) {
                      element.setAttribute('value', strQSValue);
                  }
              } else {
                  element.value = strQSValue;
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
  
      // sync control value and resize to text
      function syncView(element) {
          if (element.control) {
              if (element.getAttribute('value') !== element.control.value) {
                  element.setAttribute('value', element.control.value);
              }
          } else {
              if (element.getAttribute('value') !== element.innerHTML) {
                  element.setAttribute('value', element.innerHTML);
              }
          }
      }
  
      function handleFormat(element, event, bolAlertOnError) {
          var strFormat, intValue;
  
          if (element.hasAttribute('format')) {
              strFormat = element.getAttribute('format');
  
              intValue = element.value; // parseFloat(element.value.replace(/[^0-9.]*/g, ''), 10);
  
              if (isNaN(intValue)) {
                  if (bolAlertOnError !== undefined && bolAlertOnError !== false) {
                      alert('Invalid Number: ' + element.value);
                  }
  
                  if (element.control) {
                      GS.setInputSelection(element.control, 0, element.value.length);
                  }
  
                  if (event) {
                      event.stopPropagation();
                      event.preventDefault();
                  }
  
              } else {
                  if (element.control) {
                      element.control.value = formatNumber(intValue, strFormat);
                  } else {
                      element.innerHTML = formatNumber(intValue, strFormat);
                  }
              }
          }
      }
  
      function formatNumber(intValue, strFormat) {
          /* (this function contains a (modified) substantial portion of code from another source
              here is the copyright for sake of legality) (Uses code by Matt Kruse)
          Copyright (c) 2006-2009 Rostislav Hristov, Asual DZZD
  
          Permission is hereby granted, free of charge, to any person obtaining a
          copy of this software and associated documentation files
          (the "Software"), to deal in the Software without restriction,
          including without limitation the rights to use, copy, modify, merge,
          publish, distribute, sublicense, and/or sell copies of the Software,
          and to permit persons to whom the Software is furnished to do so,
          subject to the following conditions:
  
          The above copyright notice and this permission notice shall be included
          in all copies or substantial portions of the Software.
  
          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
          IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
          CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
          TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
          SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/
          var groupingSeparator,
              groupingIndex,
              decimalSeparator,
              decimalIndex,
              roundFactor,
              result,
              i,
              locale = {
                  groupingSeparator: ',',
                  decimalSeparator: '.',
                  currencySymbol: '$',
                  percentSymbol: '%'
              };
  
          if (strFormat.toLowerCase() === 'currency') {
              strFormat = locale.currencySymbol + '0.00';
          } else if (strFormat.toLowerCase() === 'percent') {
              intValue = intValue * 100;
              strFormat = locale.percentSymbol + '0.00';
          }
  
          var integer = '',
              fraction = '',
              negative,
              minFraction,
              maxFraction,
              powFraction,
              bolCurrencySymbol = strFormat[0] === locale.currencySymbol,
              bolPercentSymbol = strFormat[0] === locale.percentSymbol;
  
          if (bolCurrencySymbol || bolPercentSymbol) {
              strFormat = strFormat.substring(1);
          }
  
          groupingSeparator = ',';
          groupingIndex = strFormat.lastIndexOf(groupingSeparator);
          decimalSeparator = '.';
          decimalIndex = strFormat.indexOf(decimalSeparator);
  
          negative = intValue < 0;
          minFraction = strFormat.substr(decimalIndex + 1).replace(/#/g, '').length;
          maxFraction = strFormat.substr(decimalIndex + 1).length;
          powFraction = 10;
  
          intValue = Math.abs(intValue);
  
          if (decimalIndex != -1) {
              fraction = locale.decimalSeparator;
              if (maxFraction > 0) {
                  roundFactor = 1000;
                  powFraction = Math.pow(powFraction, maxFraction);
                  var tempRound = Math.round(parseInt(intValue * powFraction * roundFactor -
                              Math.round(intValue) * powFraction * roundFactor, 10) / roundFactor),
                      tempFraction = String(tempRound < 0 ? Math.round(parseInt(intValue * powFraction * roundFactor -
                              parseInt(intValue, 10) * powFraction * roundFactor, 10) / roundFactor) : tempRound),
                      parts = intValue.toString().split('.');
                  if (typeof parts[1] != 'undefined') {
                      for (i = 0; i < maxFraction; i++) {
                          if (parts[1].substr(i, 1) == '0' && i < maxFraction - 1 &&
                                  tempFraction.length != maxFraction) {
                              tempFraction = '0' + tempFraction;
                          } else {
                              break;
                          }
                      }
                  }
                  for (i = 0; i < (maxFraction - fraction.length); i++) {
                      tempFraction += '0';
                  }
                  var symbol, formattedFraction = '';
  
                  for (i = 0; i < tempFraction.length; i++) {
                      symbol = tempFraction.substr(i, 1);
                      if (i >= minFraction && symbol == '0' && (/^0*$/).test(tempFraction.substr(i + 1))) {
                          break;
                      }
                      formattedFraction += symbol;
                  }
                  fraction += formattedFraction;
              }
              if (fraction == locale.decimalSeparator) {
                  fraction = '';
              }
          }
  
          if (decimalIndex !== 0) {
              if (fraction !== '') {
                  integer = String(parseInt(Math.round(intValue * powFraction) / powFraction, 10));
              } else {
                  integer = String(Math.round(intValue));
              }
              var grouping = locale.groupingSeparator,
                  groupingSize = 0;
              if (groupingIndex != -1) {
                  if (decimalIndex != -1) {
                      groupingSize = decimalIndex - groupingIndex;
                  } else {
                      groupingSize = strFormat.length - groupingIndex;
                  }
                  groupingSize--;
              }
              if (groupingSize > 0) {
                  var count = 0, 
                      formattedInteger = '';
                  i = integer.length;
                  while (i--) {
                      if (count !== 0 && count % groupingSize === 0) {
                          formattedInteger = grouping + formattedInteger;    
                      }
                      formattedInteger = integer.substr(i, 1) + formattedInteger;
                      count++;
                  }
                  integer = formattedInteger;
              }
              var maxInteger, maxRegExp = /#|,/g;
              if (decimalIndex != -1) {
                  maxInteger = strFormat.substr(0, decimalIndex).replace(maxRegExp, '').length;
              } else {
                  maxInteger = strFormat.replace(maxRegExp, '').length;
              }
              var tempInteger = integer.length;
              for (i = tempInteger; i < maxInteger; i++) {
                  integer = '0' + integer;
              }
          }
          result = integer + fraction;
          return (bolPercentSymbol ? locale.percentSymbol : '') +
                 (bolCurrencySymbol ? locale.currencySymbol : '') +
                 (negative ? '-' : '') + result;
      }
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              // if the value was set before the "created" lifecycle code runs: set attribute
              //      (discovered when trying to set a value of a date control in the after_open of a dialog)
              //      ("delete" keyword added because of firefox)
              if (element.value) {
                  element.setAttribute('value', element.value);
                  delete element.value;
                  //element.value = null;
              }
          }
      }
  
      function elementInserted(element) {
          //var strQSValue;
  
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
  
                  if (element.hasAttribute('tabindex')) {
                      element.setAttribute('data-tabindex', element.getAttribute('tabindex'));
                      element.removeAttribute('tabindex');
                  }
                  if (element.hasAttribute('disabled')) {
                      element.innerHTML = element.getAttribute('value') || element.getAttribute('placeholder');
                  } else {
                      element.innerHTML = '';
                      element.appendChild(singleLineTemplate.cloneNode(true));
                      if (element.hasAttribute('data-tabindex')) {
                          xtag.query(element, '.control')[0].setAttribute('tabindex', element.getAttribute('data-tabindex'));
                      }
                  }
  
                  if (element.getAttribute('qs')) {
                      //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                      //
                      //if (strQSValue !== '' || !element.getAttribute('value')) {
                      //    element.value = strQSValue;
                      //}
  
                      createPushReplacePopHandler(element);
                      window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                      window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                      window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                  }
  
                  if (element.innerHTML === '') {
                      element.appendChild(singleLineTemplate.cloneNode(true));
                      if (element.hasAttribute('data-tabindex')) {
                          xtag.query(element, '.control')[0].setAttribute('tabindex', element.getAttribute('data-tabindex'));
                      }
                  }
                  element.refresh();
              }
          }
      }
  
      xtag.register('gs-number', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
  
              inserted: function () {
                  elementInserted(this);
              },
  
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
  
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
  
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      // attribute code
                      if (strAttrName === 'disabled') {
                          if (this.hasAttribute('tabindex')) {
                              this.setAttribute('data-tabindex', this.getAttribute('tabindex'));
                              this.removeAttribute('tabindex');
                          }
                          if (this.hasAttribute('disabled')) {
                              this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder');
                          } else {
                              this.innerHTML = '';
                              this.appendChild(singleLineTemplate.cloneNode(true));
                              if (this.hasAttribute('data-tabindex')) {
                                  xtag.query(this, '.control')[0].setAttribute('tabindex', this.getAttribute('data-tabindex'));
                              }
                          }
  
                          this.refresh();
                      } else if (strAttrName === 'value' && newValue !== oldValue) {
                          this.value = newValue;
                      }
                  }
              }
          },
          events: {
              // on keydown and keyup sync the value attribute and the control value
              keydown: function (event) {
                  if (window.bolDesignMode !== true) {
                      if (this.getAttribute('disabled') !== null && event.keyCode !== 9) {
                          event.preventDefault();
                          event.stopPropagation();
                      } else {
                          syncView(this);
                      }
                  }
              },
              keyup: function () {
                  if (window.bolDesignMode !== true) {
                      syncView(this);
                  }
              }//,
              //'change:delegate(.control)': function (event) {
              //    var element = this.parentNode;
              //
              //    event.preventDefault();
              //    event.stopPropagation();
              //
              //    xtag.fireEvent(element, 'change', {
              //        bubbles: true,
              //        cancelable: true
              //    });
              //}
          },
          accessors: {
              value: {
                  // get value straight from the input
                  get: function () {
                      if (this.control) {
                          return parseFloat(this.control.value.replace(/[^-0-9.]*/g, ''), 10); // this.control.value;
                      } else {
                          return parseFloat(this.innerHTML.replace(/[^-0-9.]*/g, ''), 10); // this.control.value;
                      }
                  },
                  
                  // set the value of the input and set the value attribute
                  set: function (strNewValue) {
                      var selection;
                      if (this.control) {
                          selection = GS.getInputSelection(this.control);
                          this.control.value = strNewValue;
                      } else {
                          this.innerHTML = strNewValue;
                      }
                      handleFormat(this);
                      syncView(this);
                      if (selection) {
                          GS.setInputSelection(this.control, selection.start, selection.end);
                      }
                  }
              }
          },
          methods: {
              focus: function () {
                  this.control.focus();
              },
              
              refresh: function () {
                  var arrPassThroughAttributes, i, len;
                  
                  // set a variable with the control element for convenience and speed
                  this.control = xtag.query(this, '.control')[0];
                  
                  if (this.control) {
                      this.control.removeEventListener('change', changeFunction);
                      this.control.addEventListener('change', changeFunction);
                      
                      this.control.removeEventListener('focus', focusFunction);
                      this.control.addEventListener('focus', focusFunction);
                      
                      this.control.removeEventListener('blur', blurFunction);
                      this.control.addEventListener('blur', blurFunction);
                      
                      this.control.removeEventListener(evt.mouseout, mouseoutFunction);
                      this.control.addEventListener(evt.mouseout, mouseoutFunction);
      
                      this.control.removeEventListener(evt.mouseover, mouseoverFunction);
                      this.control.addEventListener(evt.mouseover, mouseoverFunction);
                  }
                  // if there is a value already in the attributes of the element: set the control value
                  if (this.hasAttribute('value')) {
                      if (this.control) {
                          this.control.value = this.getAttribute('value') || this.getAttribute('placeholder');
                      } else {
                          this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder');
                      }
                      handleFormat(this, undefined, false);
                  }
                  
                  if (this.control) {
                      // copy passthrough attributes to control
                      arrPassThroughAttributes = [
                          'placeholder',
                          'name',
                          'maxlength',
                          'autocorrect',
                          'autocapitalize',
                          'autocomplete',
                          'autofocus',
                          'spellcheck',
                          'readonly'
                      ];
                      for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                          if (this.hasAttribute(arrPassThroughAttributes[i])) {
                              this.control.setAttribute(arrPassThroughAttributes[i], this.getAttribute(arrPassThroughAttributes[i]) || '');
                          }
                      }
                  }
              }
          }
      });
  });
  window.addEventListener('design-register-element', function () {
      registerDesignSnippet('<gs-optionbox>', '<gs-optionbox>', 'gs-optionbox column="${1}">\n' +
                                                                '    <gs-option value="${2}">${3}</gs-option>\n' +
                                                                '</gs-optionbox>');
      
      designRegisterElement('gs-optionbox', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-optionbox.html');
      
      window.designElementProperty_GSOPTIONBOX = function(selectedElement) {
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
          
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
          
          addProp('Clearable', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('clearable') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'clearable', this.value === 'true', true);
          });
          
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
          
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', this.value === 'true', true);
          });
          
          addProp('No Targets', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-target') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-target', this.value === 'true', true);
          });
          
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
          
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
          
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
          
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          // DISABLED attribute
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
          
          addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
          });
          
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
      /*
      window.designElementProperty_GSOPTION = function(selectedElement) {
          addProp('Hidden Value:', true, '<gs-text class="target" value="' + (selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
          
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + (selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          addFlexContainerProps(selectedElement);
          //addFlexProps(selectedElement);
      };*/
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      
      // removes selected attribute from old selected option adds selected attribute to option
      function highlightOption(element, option) {
          var i, len, arrSelectedOptions, arrTempSelectedOptions;
          
          // clear previous selection
          arrSelectedOptions = xtag.query(element, 'gs-option[selected]');
          arrTempSelectedOptions = xtag.query(element, 'gs-option[tempselect]');
          for (i = 0, len = arrSelectedOptions.length; i < len; i += 1) {
              arrSelectedOptions[i].removeAttribute('selected');
          }
          
          for (i = 0, len = arrTempSelectedOptions.length; i < len; i += 1) {
              arrTempSelectedOptions[i].removeAttribute('tempselect');
          }
  
          // select/highlight the record that was provided
          if (option) {
              option.setAttribute('selected', '');
          }
      }
  
      // loops through the options and finds a option using the parameter
      function findOptionFromString(element, strSearchString) {
          var i, len, matchedOption, arrOptions = xtag.query(element, 'gs-option');
  
          // search exact text and search both the value attribute (if present) and the text content
          for (i = 0, len = arrOptions.length; i < len; i += 1) {
              if (arrOptions[i].getAttribute('value') === strSearchString || arrOptions[i].textContent === strSearchString) {
                  matchedOption = arrOptions[i];
                  break;
              }
          }
  
          return matchedOption;
      }
  
      function selectOption(element, handle, bolChange) {
          var option, strOptionValue, strOptionText;
  
          if (typeof handle === 'string') {
              option = findOptionFromString(element, handle);
  
              if (!option) {
                  throw 'gs-optionbox Error: value: \'' + handle + '\' not found.';
              }
          } else {
              option = handle;
          }
          
          highlightOption(element, option);
  
          if (option) {
              strOptionValue = option.getAttribute('value');
              strOptionText = option.textContent;
          } else {
              strOptionValue = '';
              strOptionText = '';
          }
  
          if (element.value !== (strOptionValue || strOptionText)) {
              element.innerValue = strOptionValue || strOptionText;
              element.innerSelectedOption = option;
  
              if (bolChange) {
                  xtag.fireEvent(element, 'change', {bubbles: true, cancelable: true});
              }
          }
      }
  
      // #################################################################
      // ########################## USER EVENTS ##########################
      // #################################################################
      /*
      // handle behaviours on keydown
      function handleKeyDown(event) {
          var element = event.target, intKeyCode = event.keyCode || event.which,
              selectedOption, selectedOptionIndex,
              tempSelectedOption, tempSelectedOptionIndex, arrOptions, i, len;
  
          if (!element.hasAttribute('disabled')) {
              if ((intKeyCode === 40 || intKeyCode === 38) && !event.shiftKey && !event.metaKey && !event.ctrlKey && !element.error) {
                  arrOptions = xtag.query(element, 'gs-option');
  
                  for (i = 0, len = arrOptions.length; i < len; i += 1) {
                      if (arrOptions[i].hasAttribute('tempselect')) {
                          tempSelectedOptionIndex = i;
                          tempSelectedOption = arrOptions[i];
                          arrOptions[i].removeAttribute('tempselect');
                      }
  
                      if (arrOptions[i].hasAttribute('selected')) {
                          selectedOptionIndex = i;
                          selectedOption = arrOptions[i];
                      }
  
                      if (selectedOption && tempSelectedOption) {
                          break;
                      }
                  }
  
                  //console.log(selectedOption, selectedOptionIndex, tempSelectedOption, tempSelectedOptionIndex, arrOptions.length);
  
                  if (tempSelectedOption && tempSelectedOptionIndex !== arrOptions.length - 1 && intKeyCode === 40) {
                      if (!arrOptions[tempSelectedOptionIndex + 1].hasAttribute('selected')) {
                          arrOptions[tempSelectedOptionIndex + 1].setAttribute('tempselect', '');
                      }
                  } else if (tempSelectedOption && tempSelectedOptionIndex !== 0 && intKeyCode === 38) {
                      if (!arrOptions[tempSelectedOptionIndex - 1].hasAttribute('selected')) {
                          arrOptions[tempSelectedOptionIndex - 1].setAttribute('tempselect', '');
                      }
                  } else if (!tempSelectedOption && selectedOption && selectedOptionIndex !== arrOptions.length - 1 && intKeyCode === 40) {
                      if (!arrOptions[selectedOptionIndex + 1].hasAttribute('selected')) {
                          arrOptions[selectedOptionIndex + 1].setAttribute('tempselect', '');
                      }
                  } else if (!tempSelectedOption && selectedOption && selectedOptionIndex !== 0 && intKeyCode === 38) {
                      if (!arrOptions[selectedOptionIndex - 1].hasAttribute('selected')) {
                          arrOptions[selectedOptionIndex - 1].setAttribute('tempselect', '');
                      }
                  // tempselect first record
                  } else if (intKeyCode === 40) {
                      if (!arrOptions[0].hasAttribute('selected')) {
                          arrOptions[0].setAttribute('tempselect', '');
                      }
                  // tempselect last record
                  } else if (intKeyCode === 38) {
                      if (!arrOptions[arrOptions.length - 1].hasAttribute('selected')) {
                          arrOptions[arrOptions.length - 1].setAttribute('tempselect', '');
                      }
                  }
                  event.preventDefault();
                  event.stopPropagation();
  
              } else if (event.keyCode === 13 || event.keyCode === 32) {
                  selectedOption = xtag.query(element, 'gs-option[selected]')[0];
                  tempSelectedOption = xtag.query(element, 'gs-option[tempselect]')[0];
  
                  if (tempSelectedOption) {
                      selectOption(element, tempSelectedOption, true);
                  } else if (selectedOption) {
                      selectOption(element, selectedOption, true);
                  }
              }
          } else {
              if (event.keyCode !== 9) {
                  event.preventDefault();
                  event.stopPropagation();
              }
          }
  
          //console.log('handleKeyDown', intKeyCode, event);
      }*/
  
      function getParentOption(element) {
          var currentElement = element;
  
          while (currentElement.nodeName !== 'GS-OPTION' && currentElement.nodeName !== 'HTML') {
              currentElement = currentElement.parentNode;
          }
  
          if (currentElement.nodeName !== 'GS-OPTION') {
              return undefined;
          }
  
          return currentElement;
      }
  
      //function createPushReplacePopHandler(element) {
      //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
      //
      //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.value = GS.qryGetVal(strQueryString, strQSCol);
      //    }
      //}
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          i = 0;
          len = element.attributes.length;
          arrAttr = element.attributes;
          while (i < len) {
              jsnAttr = element.attributes[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function createPushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  if (strQSValue !== '' || !element.getAttribute('value')) {
                      element.setAttribute('value', strQSValue);
                  }
              } else {
                  element.value = strQSValue;
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
  
      function enhanceChildren(element) {
          var arrElement, i, len;
  
          arrElement = xtag.query(element, 'gs-option');
  
          for (i = 0, len = arrElement.length; i < len; i += 1) {
              // this if allows the developer to define the icon position
              if (!arrElement[i].hasAttribute('icontop')
                      && !arrElement[i].hasAttribute('iconleft')
                      && !arrElement[i].hasAttribute('iconbottom')
                      && !arrElement[i].hasAttribute('iconright')) {
                  arrElement[i].setAttribute('iconleft', '');
              }
              arrElement[i].setAttribute('icon', '');
          }
      }
  
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              // if the value was set before the "created" lifecycle code runs: set attribute
              //      (discovered when trying to set a value of a date control in the after_open of a dialog)
              //      ("delete" keyword added because of firefox)
              if (element.value) {
                  element.setAttribute('value', element.value);
                  delete element.value;
                  // element.value = null;
              }
          }
      }
  
      //
      function elementInserted(element) {
          var strQSValue, observer;
  
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
  
                  //// allows the element to have focus
                  //if (!element.hasAttribute('tabindex')) {
                  //    element.setAttribute('tabindex', '0');
                  //}
  
                  if (element.getAttribute('value')) {
                      selectOption(element, element.getAttribute('value'), false);
                  }
  
                  if (element.getAttribute('qs')) {
                      //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
  
                      //if (strQSValue !== '') {
                      //    selectOption(element, strQSValue, false);
                      //}
                      createPushReplacePopHandler(element);
                      window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                      window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                      window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                  }
  
                  // if we are not [no-target]
                  if (!element.hasAttribute('no-target')) {
                      enhanceChildren(element);
  
                      // put an observer on the option element to enhance new children
  
                      // create an observer instance
                      observer = new MutationObserver(function(mutations) {
                          var bolRefreshOptionList = true;
  
                          // check each mutation: if only option and optgroup tags were added: refersh option tags in select
                          mutations.forEach(function(mutation) {
                              var i, len;
  
                              for (i = 0, len = mutation.addedNodes.length; i < len; i += 1) {
                                  if (mutation.addedNodes[i].nodeName !== 'GS-OPTION') {
                                      bolRefreshOptionList = false;
                                  }
                              }
                          });
  
                          if (bolRefreshOptionList) {
                              enhanceChildren(element);
                          }
                      });
  
                      // pass in the element node, as well as the observer options
                      observer.observe(element, {childList: true});
                  }
              }
          }
      }
  
      xtag.register('gs-optionbox', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      if (strAttrName === 'value' && newValue !== oldValue) {
                          selectOption(this, newValue);
                      }
                  }
              }
          },
          events: {
              //'keydown': function (event) {
              //    if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
              //        handleKeyDown(event);
              //    }
              //},
              
              'click': function (event) {
                  if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                      var parentOption = getParentOption(event.target);
                      
                      //console.log(parentOption);
                      
                      //  else if (this.hasAttribute('clearable') && newValue === oldValue) {
                      //     console.log('running');
                      //     selectOption(this, undefined);
                      // }
                      
                      if (parentOption && !parentOption.hasAttribute('selected')) {
                          selectOption(this, parentOption, true);
                      } else if (this.hasAttribute('clearable')) {
                          selectOption(this, undefined);
                      }
                  }
              }//,
              
              //'focusout': function () {
              //    if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
              //        var selectedOption = xtag.query(this, 'gs-option[selected]')[0],
              //            tempSelectedOption = xtag.query(this, 'gs-option[tempselect]')[0];
              //        
              //        if (tempSelectedOption) {
              //            selectOption(this, tempSelectedOption, true);
              //            
              //        } else if (selectedOption) {
              //            selectOption(this, selectedOption, true);
              //        }
              //    }
              //}
          },
          accessors: {
              value: {
                  get: function () {
                      return this.innerValue;
                  },
                  
                  set: function (strNewValue) {
                      selectOption(this, strNewValue);
                  }
              },
              
              selectedOption: {
                  get: function () {
                      return this.innerSelectedOption;
                  },
                  
                  set: function (newValue) {
                      selectOption(this, newValue);
                  }
              },
              
              textValue: {
                  get: function () {
                      return this.innerSelectedOption.textContent;
                  },
                  
                  set: function (newValue) {
                      selectOption(this, newValue);
                  }
              }
          }
      });
  });
  window.addEventListener('design-register-element', function () {
      registerDesignSnippet('Empty <gs-page>', '<gs-page>', 'gs-page>\n' +
                                                            '    $0\n' +
                                                            '</gs-page>');
      registerDesignSnippet('<gs-page> With Header', '<gs-page>', 'gs-page>\n' +
                                                           '    <gs-header>\n' +
                                                           '        <center><h3>${1}</h3></center>\n' +
                                                           '    </gs-header>\n' +
                                                           '    <gs-body>\n' +
                                                           '        $0\n' +
                                                           '    </gs-body>\n' +
                                                           '</gs-page>');
      registerDesignSnippet('Full <gs-page>', '<gs-page>', 'gs-page>\n' +
                                                           '    <gs-header>\n' +
                                                           '        <center><h3>${1}</h3></center>\n' +
                                                           '    </gs-header>\n' +
                                                           '    <gs-body>\n' +
                                                           '        $0\n' +
                                                           '    </gs-body>\n' +
                                                           '    <gs-footer>${2}</gs-footer>\n' +
                                                           '</gs-page>');
      
      designRegisterElement('gs-page', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-page.html');
      
      window.designElementProperty_GSPAGE = function (selectedElement) {
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
          
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
          
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
          
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              var observer,
                  headerElement = xtag.queryChildren(element, 'gs-header')[0],
                  footerElement = xtag.queryChildren(element, 'gs-footer')[0];
              
              // create an observer instance
              observer = new MutationObserver(function(mutations) {
                  element.recalculatePadding();
                  //console.log('mutation observed');
              });
              
              // pass in the element node, as well as the observer options
              if (headerElement) {
                  observer.observe(headerElement, {childList: true, subtree: true});
              }
              if (footerElement) {
                  observer.observe(footerElement, {childList: true, subtree: true});
              }
          }
      }
      
      //
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  
                  element.recalculatePadding();
                  
                  window.addEventListener('load', function () {
                      element.recalculatePadding();
                  });
                  window.addEventListener('resize', function () {
                      element.recalculatePadding();
                  });
                  element.recalculatePadding();
              }
          }
      }
      
      xtag.register('gs-page', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      // attribute code
                  }
              }
          },
          events: {},
          accessors: {},
          methods: {
              recalculatePadding: function () {
                  var headerElement = xtag.queryChildren(this, 'gs-header')[0],
                      footerElement = xtag.queryChildren(this, 'gs-footer')[0];
                  
                  if (headerElement) {
                      //console.log('1***', headerElement.offsetHeight);
                      this.style.paddingTop = headerElement.offsetHeight + 'px';
                  } else {
                      this.style.paddingTop = '';
                  }
                  if (footerElement) {
                      //console.log('2***', footerElement.offsetHeight);
                      this.style.paddingBottom = footerElement.offsetHeight + 'px';
                  } else {
                      this.style.paddingBottom = '';
                  }
              }
          }
      });
  });
  window.addEventListener('design-register-element', function () {
      'use strict';
      registerDesignSnippet('<gs-panel>', '<gs-panel>', 'gs-panel id="panel">\n' +
                                                        '    <gs-page id="${1:left-bar}" style="width: 17em;">\n' +
                                                        '        \n' +
                                                        '    </gs-page>\n' +
                                                        '    <gs-page>\n' +
                                                        '        \n' +
                                                        '    </gs-page>\n' +
                                                        '</gs-panel>');
      
      designRegisterElement('gs-panel', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-panel.html');
      
      window.designElementProperty_GSPANEL = function(selectedElement) {
          // no-shadow-dismiss attribute
          addProp('Dismissible By Clicking The Shadow', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-shadow-dismiss')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-shadow-dismiss', this.value === 'true', false);
          });
          
          // dismissible attribute
          addProp('Dismissible On Desktop', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('dismissible') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'dismissible', this.value === 'true', true);
          });
          
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
          
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      
      function pushReplacePopHandler(element) {
          var query = GS.getQueryString(), arrQueryKeys = GS.qryGetKeys(query),
              strID = element.getAttribute('id'), strAttributeName, i, len, strNewValue;
          
          for (i = 0, len = arrQueryKeys.length; i < len; i += 1) {
              if (arrQueryKeys[i].indexOf(strID + '.') === 0 &&
                  element.panelIDs.indexOf(arrQueryKeys[i].split('.')[1]) > -1) {
                  
                  strAttributeName = arrQueryKeys[i].split('.')[1];
                  strNewValue = GS.qryGetVal(query, arrQueryKeys[i]);
                  
                  if (element.getAttribute(strAttributeName) !== strNewValue) {
                      element.setAttribute(strAttributeName, strNewValue);
                  }
              }
          }
          
          for (i = 0, len = element.arrQueryStringAttributes.length; i < len; i += 1) {
              if (arrQueryKeys.indexOf(element.arrQueryStringAttributes[i]) === -1) {
                  element.removeAttribute(element.arrQueryStringAttributes[i].split('.')[1]);
              }
          }
      }
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              
          }
      }
      
      //
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  
                  var arrElement, i, len, blockerElement, blockerClickHandler;
                  
                  element.arrQueryStringAttributes = [];
                  element.panelIDs = [];
                  
                  blockerClickHandler = function (event) {
                      var target = event.target;
                      
                      if (target.classList.contains('gs-panel-page-blocker')) {
                          element.hide(target.getAttribute('blocking'));
                      }
                  };
                  
                  arrElement = xtag.queryChildren(element, '*');
                  
                  for (i = 0, len = arrElement.length; i < len; i += 1) {
                      if (arrElement[i].style.width === '') {
                          arrElement[i].setAttribute('flex', '');
                      } else {
                          if (!arrElement[i].hasAttribute('id')) {
                              console.warn('gs-panel Warning: No ID attribute on side-page element:',
                                           GS.cloneElement(arrElement[i]),
                                           ', please set ID the attribute');
                              
                              arrElement[i].setAttribute('id', 'side-' + GS.GUID().substring(0, 8));
                          }
                          element.panelIDs.push(arrElement[i].getAttribute('id'));
                          
                          blockerElement = document.createElement('div');
                          blockerElement.classList.add('gs-panel-page-blocker');
                          blockerElement.setAttribute('gs-dynamic', '');
                          blockerElement.setAttribute('blocking', arrElement[i].getAttribute('id'));
                          blockerElement.setAttribute('id', arrElement[i].getAttribute('id') + '-blocker');
                          
                          element.insertBefore(blockerElement, arrElement[i]);
                          
                          arrElement[i].setAttribute('panel-set-width', '');
                          
                          if (arrElement[i].hasAttribute('hidden')) {
                              arrElement[i].removeAttribute('hidden');
                              element.hide(arrElement[i].getAttribute('id'));
                              
                          } else {
                              if (element.getAttribute(arrElement[i].getAttribute('id')) === 'hide') {
                                  element.hide(arrElement[i].getAttribute('id'));
                              }
                          }
                          
                          if (!element.hasAttribute('no-shadow-dismiss')) {
                              blockerElement.addEventListener('click', blockerClickHandler);
                          }
                      }
                  }
                  
                  window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                  window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                  window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                  
                  if (element.hasAttribute('id')) {
                      pushReplacePopHandler(element);
                  }
              }
          }
      }
      
      xtag.register('gs-panel', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      if (document.getElementById(strAttrName) &&
                          document.getElementById(strAttrName).parentNode === this) {
                          if (newValue === 'hide' || newValue === 'show') {
                              this[newValue](strAttrName);
                          }
                          /*if (newValue === 'hide') {
                              this.hide(strAttrName);
                          } else if (newValue === 'show') {
                              this.show(strAttrName);
                          }*/
                      }
                  }
              }
          },
          events: {},
          accessors: {},
          methods: {
              'show': function (strID) {
                  var strQueryString = GS.getQueryString(), strElementID = this.getAttribute('id');
                  //document.getElementById(strID).setAttribute('shown', '');
                  //document.getElementById(strID).removeAttribute('hidden');
                  //document.getElementById(strID + '-blocker').setAttribute('shown', '');
                  //document.getElementById(strID + '-blocker').removeAttribute('hidden');
                  
                  //document.getElementById(strID).style.display = '';
                  //document.getElementById(strID + '-blocker').style.display = '';
                  
                  //if (window.innerWidth <= 768 || this.hasAttribute('dismissible')) {
                  
                  if ((strElementID && GS.qryGetKeys(strQueryString).indexOf(strElementID + '.' + strID) > -1) &&
                      GS.qryGetVal(strQueryString, strElementID + '.' + strID) === 'hide') {
                      GS.pushQueryString(strElementID + '.' + strID + '=show');
                      
                  } else if (this.getAttribute(strID) === 'show') {
                      //document.getElementById(strID).style.left = '';
                      //document.getElementById(strID).style.position = '';
                      //document.getElementById(strID + '-blocker').style.left = ''; // <-- works on a phone
                      document.getElementById(strID).removeAttribute('panel-hide');
                      document.getElementById(strID + '-blocker').removeAttribute('panel-hide');
                      
                      //this.hiddenIDs.splice(this.hiddenIDs.indexOf(strID), 1);
                      //
                      GS.triggerEvent(document.getElementById(strID), 'show');
                      GS.triggerEvent(window, 'resize'); //, {'triggered': true});
                  } else {
                      this.setAttribute(strID, 'show');
                  }
                  //}
              },
              
              'hide': function (strID) {
                  var strQueryString = GS.getQueryString(), strElementID = this.getAttribute('id');
                  //document.getElementById(strID).setAttribute('hidden', '');
                  //document.getElementById(strID).removeAttribute('shown');
                  //document.getElementById(strID + '-blocker').setAttribute('hidden', '');
                  //document.getElementById(strID + '-blocker').removeAttribute('shown');
                  
                  //document.getElementById(strID).style.display = 'none';
                  //document.getElementById(strID + '-blocker').style.display = 'none';
                  
                  if ((strElementID && GS.qryGetKeys(strQueryString).indexOf(strElementID + '.' + strID) > -1) &&
                      GS.qryGetVal(strQueryString, strElementID + '.' + strID) === 'show') {
                      GS.pushQueryString(strElementID + '.' + strID + '=hide');
                      
                  } else if (this.getAttribute(strID) === 'hide') {
                      document.getElementById(strID).setAttribute('panel-hide', '');
                      document.getElementById(strID + '-blocker').setAttribute('panel-hide', '');
                      
                      //if (window.innerWidth <= 768 || this.hasAttribute('dismissible')) {
                      //    document.getElementById(strID).style.left = '-100%';
                      //    document.getElementById(strID).style.position = 'absolute';
                      //    document.getElementById(strID + '-blocker').style.left = '-100%'; // <-- works on a phone
                      //    
                      //    this.hiddenIDs.push(strID);
                      //    
                      GS.triggerEvent(document.getElementById(strID), 'hide');
                      GS.triggerEvent(window, 'resize'); //, {'triggered': true});
                      //}
                  } else {
                      this.setAttribute(strID, 'hide');
                  }
              },
              
              'toggle': function (strID) {
                  var element = document.getElementById(strID);
                  
                  if (element.hasAttribute('shown') || !element.hasAttribute('panel-hide')) {
                      this.hide(strID);
                  } else {
                      this.show(strID);
                  }
              }
          }
      });
  });
  window.addEventListener('design-register-element', function () {
      'use strict';
      registerDesignSnippet('Push Message', 'GS.pushMessage', 'pushMessage(\'${1:HTML}\', ${2:1500}, function () {${3}});');
  });
  
  GS.pushMessage = function (strHTML, intTime, callback) {
      var pushMessageElement, containerElement;
      
      // if there is no html to put in the pushmessage: throw an error
      if (strHTML === undefined) {
          throw 'GS.pushMessage Error: no HTML to display.';
      }
      
      // if there is no container: add it
      if (document.getElementsByTagName('gs-pushmessage-container').length === 0) {
          containerElement = document.createElement('gs-pushmessage-container');
          containerElement.setAttribute('gs-dynamic', '');
          document.body.appendChild(containerElement);
      } else {
          containerElement = document.getElementsByTagName('gs-pushmessage-container')[0];
      }
      
      // create the pushmessage
      pushMessageElement = document.createElement('gs-pushmessage');
      pushMessageElement.setAttribute('gs-dynamic', '');
      pushMessageElement.innerHTML = strHTML;
      
      // append the pushmessage to the container
      containerElement.appendChild(pushMessageElement);
      
      // if there is a callback: run it
      if (typeof callback === 'function') {
          callback.apply(pushMessageElement);
      }
      
      // if there is a time: set a timeout to close the message
      if (intTime) {
          setTimeout(function() {
              GS.closePushMessage(pushMessageElement);
          }, intTime);
      }
      
      // return the pushmessage
      return pushMessageElement;
  };
  
  window.addEventListener('design-register-element', function () {
      'use strict';
      registerDesignSnippet('GS.closePushMessage', 'GS.closePushMessage', 'GS.closePushMessage(${0:pushMessageElement});');
      registerDesignSnippet('Close Push Message',  'Close Push Message',  'GS.closePushMessage(${0:pushMessageElement});');
  });
  
  GS.closePushMessage = function (pushMessageElement) {
      var containerElement = document.getElementsByTagName('gs-pushmessage-container')[0];
      
      // fade the pushmessage out
      GS.animateStyle(pushMessageElement, 'opacity', '1', '0', function () {
          
          // if there is only one pushmessage element: remove the container
          if (document.getElementsByTagName('gs-pushmessage').length === 1) {
              document.body.removeChild(containerElement);
              
          // else: just remove the element
          } else {
              containerElement.removeChild(pushMessageElement);
          }
      }, 250, 100);
  };
  
  
  document.addEventListener('DOMContentLoaded', function () {
      xtag.register('gs-pushmessage', {
          lifecycle: {},
          events: {},
          accessors: {},
          methods: {}
      });
      
      xtag.register('gs-pushmessage-container', {
          lifecycle: {},
          events: {},
          accessors: {},
          methods: {}
      });
  });
  window.addEventListener('design-register-element', function () {
      registerDesignSnippet('<gs-search>', '<gs-search>', 'gs-search id="${1}"></gs-search>');
  
      designRegisterElement('gs-search', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-search.html');
  
      window.designElementProperty_GSSEARCH = function(selectedElement) {
          addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
          });
  
          //console.log(selectedElement.hasAttribute('mini'));
  
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
  
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
  
          addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
          });
  
          addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
          });
  
          addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
          });
  
          addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
          });
  
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
  
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
  
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
  
              return selectedElement;
          });
  
          // DISABLED attribute
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
          
          addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
          });
  
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      var singleLineTemplateElement = document.createElement('template');
      var singleLineTemplate;
  
      singleLineTemplateElement.innerHTML = '<input class="control" gs-dynamic type="text" placeholder="Search..." />';
      singleLineTemplate = singleLineTemplateElement.content;
  
      // re-target change event from control to element
      function changeFunction(event) {
          event.preventDefault();
          event.stopPropagation();
  
          GS.triggerEvent(event.target.parentNode, 'change');
      }
  
      // re-target focus event from control to element
      function focusFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'focus');
          event.target.parentNode.classList.add('focus');
      }
  
      // re-target blur event from control to element
      function blurFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'blur');
          event.target.parentNode.classList.remove('focus');
      }
  
      // mouseout, remove hover class
      function mouseoutFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseout);
          event.target.parentNode.classList.remove('hover');
      }
  
      // mouseover, add hover class
      function mouseoverFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseover);
          event.target.parentNode.classList.add('hover');
      }
  
      //function loadPushReplacePopHandler(element) {
      //    var strQueryString = GS.getQueryString();
      //    var strQSCol = element.getAttribute('qs') || element.getAttribute('id');
  
      //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.value = GS.qryGetVal(strQueryString, strQSCol);
      //    }
      //}
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          i = 0;
          len = element.attributes.length;
          arrAttr = element.attributes;
          while (i < len) {
              jsnAttr = element.attributes[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function loadPushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol && strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  if (strQSValue !== element.getAttribute('value') && (strQSValue !== '' || !element.getAttribute('value'))) {
                      element.setAttribute('value', strQSValue);
                  }
              } else {
                  if (strQSValue !== element.getAttribute('value')) {
                      element.value = strQSValue;
                  }
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
  
  
  
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
  
          }
      }
  
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
  
                  if (element.hasAttribute('tabindex')) {
                      element.oldTabIndex = element.getAttribute('tabindex');
                      element.removeAttribute('tabindex');
                  }
  
                  element.refresh();
  
                  loadPushReplacePopHandler(element);
                  window.addEventListener('pushstate',    function () { loadPushReplacePopHandler(element); });
                  window.addEventListener('replacestate', function () { loadPushReplacePopHandler(element); });
                  window.addEventListener('popstate',     function () { loadPushReplacePopHandler(element); });
              }
          }
      }
  
      xtag.register('gs-search', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              inserted: function () {
                  elementInserted(this);
              },
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  var element = this;
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(element);
                      elementInserted(element);
  
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(element);
  
                  } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                      if (strAttrName === 'disabled') {
                          element.refresh();
                      } else if (strAttrName === 'value' && newValue !== oldValue) {
                          element.value = newValue;
                      }
                  }
              }
          },
          events: {
              // on keydown and keyup sync the value attribute and the control value
              keydown: function (event) {
                  if (!this.hasAttribute('readonly')) {
                      if (this.hasAttribute('disabled') && event.keyCode !== 9) {
                          event.preventDefault();
                          event.stopPropagation();
                      } else {
                          this.syncView();
                      }
                  }
              },
              keyup: function () {
                  if (!this.hasAttribute('readonly')) {
                      this.syncView();
                  }
              },
              change: function () {
                  var strQueryString = GS.getQueryString(), strColumn = (this.getAttribute('qs') || this.getAttribute('id'));
                  
                  if ((GS.qryGetVal(strQueryString, strColumn) || '') !== (this.control.value || '')) {
                      GS.pushQueryString(strColumn + '=' + encodeURIComponent(this.control.value));
                  }
              }
          },
          accessors: {
              value: {
                  // get value straight from the input
                  get: function () {
                      if (this.control) {
                          return this.control.value;
                      } else {
                          return this.innerHTML;
                      }
                  },
                  
                  // set the value of the input and set the value attribute
                  set: function (strNewValue) {
                      var element = this;
                      if (element.control) {
                          if (element.control.value !== strNewValue) {
                              element.control.value = strNewValue;
                          }
                      } else {
                          element.innerHTML = strNewValue;
                      }
                      element.syncView();
                  }
              }
          },
          methods: {
              focus: function () {
                  if (this.control) {
                      this.control.focus();
                  }
              },
              
              // adapt gs-input element to whatever control is in it and
              //      set the value of the control to the value attribute (if there is a value attribute) and
              //      resize the resize to text
              refresh: function () {
                  var element = this;
                  var arrPassThroughAttributes;
                  var i;
                  var len;
  
                  element.innerHTML = '';
                  element.appendChild(singleLineTemplate.cloneNode(true));
                  if (element.oldTabIndex) {
                      xtag.query(element, '.control')[0].setAttribute('tabindex', element.oldTabIndex);
                  }
  
                  // set a variable with the control element for convenience and speed
                  element.control = xtag.query(element, '.control')[0];
  
                  element.control.removeEventListener('change', changeFunction);
                  element.control.addEventListener('change', changeFunction);
  
                  element.control.removeEventListener('focus', focusFunction);
                  element.control.addEventListener('focus', focusFunction);
  
                  element.control.removeEventListener('blur', blurFunction);
                  element.control.addEventListener('blur', blurFunction);
  
                  element.control.removeEventListener(evt.mouseout, mouseoutFunction);
                  element.control.addEventListener(evt.mouseout, mouseoutFunction);
  
                  element.control.removeEventListener(evt.mouseout, mouseoverFunction);
                  element.control.addEventListener(evt.mouseover, mouseoverFunction);
  
                  // if there is a value already in the attributes of the element: set the control value
                  if (element.hasAttribute('value')) {
                      element.control.value = element.getAttribute('value');
                  }
  
                  // copy passthrough attributes to control
                  arrPassThroughAttributes = [
                      'placeholder', 'name', 'type', 'maxlength', 'autocorrect',
                      'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                      'readonly'
                  ];
                  for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                      if (element.hasAttribute(arrPassThroughAttributes[i])) {
                          element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
                      }
                  }
              },
  
              // sync control value and resize to text
              syncView: function () {
                  if (this.control) {
                      if (this.getAttribute('value') !== this.control.value) {
                          this.setAttribute('value', this.control.value);
                      }
                  } else {
                      this.innerHTML = this.control.value;
                  }
              }
          }
      });
  });window.addEventListener('design-register-element', function () {
      registerDesignSnippet('<gs-select>', '<gs-select>', 'gs-select>\n' +
                                                          '    <option>${0}</option>\n' +
                                                          '</gs-select>');
  
      designRegisterElement('gs-select', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-select.html');
  
      window.designElementProperty_GSSELECT = function(selectedElement) {
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
  
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
  
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
  
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
          });
  
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))          { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop')) { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))  { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))   { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop')) { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))  { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))   { strVisibilityAttribute = 'show-on-phone'; }
  
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
  
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
  
              return selectedElement;
          });
  
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
  
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      var templateElement = document.createElement('template'), template;
  
      templateElement.innerHTML = '<select class="control" gs-dynamic></select>';
      template = templateElement.content;
  
      // re-target change event from control to element
      function changeFunction(event) {
          event.preventDefault();
          event.stopPropagation();
          
          GS.triggerEvent(event.target.parentNode, 'change');
          
          //return false;
      }
  
      // re-target focus event from control to element
      function focusFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'focus');
          event.target.parentNode.classList.add('focus');
      }
  
      // re-target blur event from control to element
      function blurFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'blur');
          event.target.parentNode.classList.remove('focus');
      }
  
      // mouseout, remove hover class
      function mouseoutFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseout);
          event.target.parentNode.classList.remove('hover');
      }
  
      // mouseover, add hover class
      function mouseoverFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseover);
          event.target.parentNode.classList.add('hover');
      }
  
  
      //function createPushReplacePopHandler(element) {
      //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
  
      //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.value = GS.qryGetVal(strQueryString, strQSCol);
      //    }
      //}
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          arrAttr = element.attributes;
          i = 0;
          len = arrAttr.length;
          while (i < len) {
              jsnAttr = arrAttr[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function createPushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  if (strQSValue !== '' || !element.getAttribute('value')) {
                      element.value = strQSValue;
                  }
              } else {
                  element.value = strQSValue;
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
  
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              var strValue = element.value, observer;
  
              // if the value was set before the "created" lifecycle code runs: set attribute
              //      (discovered when trying to set a value of a date control in the after_open of a dialog)
              //      ("delete" keyword added because of firefox)
              if (strValue) {
                  element.setAttribute('value', strValue);
                  delete element.value;
              }
  
              // #############################################################
              // ##################### MUTATION OBSERVER #####################
              // #############################################################
  
              // create an observer instance
              observer = new MutationObserver(function(mutations) {
                  var bolRefreshOptionList = true;
  
                  // check each mutation: if only option and optgroup tags were added: refersh option tags in select
                  mutations.forEach(function(mutation) {
                      var i, len;
                      
                      for (i = 0, len = mutation.addedNodes.length; i < len; i += 1) {
                          if (mutation.addedNodes[i].nodeName !== 'OPTION' && mutation.addedNodes[i].nodeName !== 'OPTGROUP') {
                              bolRefreshOptionList = false;
                          }
                      }
                  });
  
                  if (bolRefreshOptionList) {
                      element.refreshOptionList();
                  }
              });
  
              // pass in the element node, as well as the observer options
              observer.observe(element, {childList: true});
          }
      }
  
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
  
                  if (element.hasAttribute('tabindex')) {
                      element.oldTabIndex = element.getAttribute('tabindex');
                      element.removeAttribute('tabindex');
                  }
  
                  element.refreshOptionList();
  
                  //element.control.removeEventListener('change', changeFunction);
                  element.control.addEventListener('change', changeFunction);
  
                  //element.control.removeEventListener('focus', focusFunction);
                  element.control.addEventListener('focus', focusFunction);
  
                  //element.control.removeEventListener('blur', blurFunction);
                  element.control.addEventListener('blur', blurFunction);
  
                  //element.control.removeEventListener(evt.mouseout, mouseoutFunction);
                  element.control.addEventListener(evt.mouseout, mouseoutFunction);
  
                  //element.control.removeEventListener(evt.mouseover, mouseoverFunction);
                  element.control.addEventListener(evt.mouseover, mouseoverFunction);
  
                  // set the value from the value attribute (if it exists)
                  if (element.getAttribute('value')) {
                      element.value = element.getAttribute('value');
                  }
  
                  //handle query-string
                  if (element.getAttribute('qs')) {
                      //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                      //
                      //if (strQSValue !== '' || !element.getAttribute('value')) {
                      //    element.value = strQSValue;
                      //}
                      createPushReplacePopHandler(element);
                      window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                      window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                      window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                  }
              }
          }
      }
  
      xtag.register('gs-select', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
  
              inserted: function () {
                  elementInserted(this);
              },
  
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
  
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
  
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      if (strAttrName === 'value' && newValue !== oldValue) {
                          this.value = newValue;
                      }
                  }
              }
          },
          events: {
              'keydown': function (event) {
                  var intKeyCode = (event.keyCode || event.which);
  
                  if (this.hasAttribute('readonly') &&
                          (
                              (
                                  intKeyCode !== 9 && // if not tab and CMD, CTRL and SHFT are not down: prevent default
                                  !event.metaKey &&
                                  !event.ctrlKey &&
                                  !event.shiftKey
                              ) ||
                              intKeyCode === 32 // if it's space: definitely prevent default
                          )) {
                      event.preventDefault();
                  }
              },
              'keyup': function (event) {
                  var intKeyCode = (event.keyCode || event.which);
  
                  if (this.hasAttribute('readonly') &&
                          (
                              (
                                  intKeyCode !== 9 && // if not tab and CMD, CTRL and SHFT are not down: prevent default
                                  !event.metaKey &&
                                  !event.ctrlKey &&
                                  !event.shiftKey
                              ) ||
                              intKeyCode === 32 // if it's space: definitely prevent default
                          )) {
                      event.preventDefault();
                  }
              },
              'mousedown': function (event) {
                  if (this.hasAttribute('readonly')) {
                      if (evt.touchDevice === false) {
                          this.control.focus();
                      }
                      event.preventDefault();
                  }
              },
              'mouseup': function (event) {
                  if (this.hasAttribute('readonly')) {
                      event.preventDefault();
                  }
              }
          },
          accessors: {
              value: {
                  get: function () {
                      if (this.control) {
                          return this.control.value;
                      } else if (this.getAttribute('value')) {
                          return this.getAttribute('value');
                      }
                      return undefined;
                  },
  
                  set: function (newValue) {
                      if (this.getAttribute('value') !== newValue) {
                          this.setAttribute('value', newValue);
                      }
                      this.control.value = newValue;
                  }
              },
              textValue: {
                  get: function () {
                      return this.control.options[this.control.selectedIndex].text;
                  },
  
                  set: function (newValue) {
                      this.setAttribute('value', newValue);
                      this.control.value = newValue;
                  }
              }
          },
          methods: {
              focus: function () {
                  this.control.focus();
              },
  
              refreshOptionList: function () {
                  var i, len, elementsToMove, oldvalue, arrChildren, controlElement;
  
                  //console.log('refreshOptionList');
  
                  // remove invalid elements from immediate children
                  arrChildren = this.children;
  
                  for (i = arrChildren.length - 1; i > -1; i -= 1) {
                      //console.log(arrChildren[i]);
                      if (arrChildren[i].nodeName !== 'OPTION' &&
                          arrChildren[i].nodeName !== 'OPTGROUP' &&
                          arrChildren[i].nodeName !== 'SELECT' &&
                          arrChildren[i].classList.contains('control')) {
                          this.removeChild(arrChildren[i]);
                      }
                  }
  
                  // if there is already a control
                  controlElement = xtag.queryChildren(this, '.control')[0];
  
                  if (controlElement) { //this.control && this.control.parentNode) {
                      // save the old value
                      oldvalue = controlElement.value;
  
                      // save the old control
                      this.oldcontrol = controlElement;
  
                      // remove the control class from the old control so that when
                      //      we select for the new control we dont get the old control
                      controlElement.classList.remove('control');
                  }
  
                  // append new control
                  this.appendChild(template.cloneNode(true));
  
                  // set a variable with the new control element for convenience and speed
                  this.control = xtag.query(this, '.control')[0];
  
                  // if there is an old control: get the options and optgroups out of it and move them to the new control
                  if (this.oldcontrol) {
                      elementsToMove = xtag.queryChildren(this.oldcontrol, 'option, optgroup');
  
                      for (i = 0, len = elementsToMove.length; i < len; i += 1) {
                          elementsToMove[i].setAttribute('gs-hidden', '');
  
                          this.control.appendChild(elementsToMove[i]);
                      }
                  }
  
                  // fill the control with all of the option and optgroup tags that are direct descendents of the gs-select
                  elementsToMove = xtag.queryChildren(this, 'option, optgroup');
  
                  for (i = 0, len = elementsToMove.length; i < len; i += 1) {
                      this.control.appendChild(elementsToMove[i]);
                  }
  
                  // if there was an old control
                  if (this.oldcontrol) {
                      // this if statement prevents an error when the gs-select shares and ID with another element
                      if (this.oldcontrol.parentNode === this) {
                          // remove the old control if it is currently a child of the select
                          this.removeChild(this.oldcontrol);
                      }
  
                      // set the oldcontrol variable to undefined so that the next time this function is run we dont get the old control
                      this.oldcontrol = undefined;
  
                      // set the value back to the old value
                      //console.log(this.getAttribute('value'));
                      this.control.value = this.getAttribute('value') || oldvalue;
  
                  } else if (this.hasAttribute('value')) {
                      //alert(this.getAttribute('value'));
                      this.control.value = this.getAttribute('value');
                  }
  
                  if (this.oldTabIndex) {
                      this.control.setAttribute('tabindex', this.oldTabIndex);
                  }
              }
          }
      });
  });//global window, GS, addProp, registerDesignSnippet, designRegisterElement, setOrRemoveTextAttribute, setOrRemoveBooleanAttribute, encodeHTML, addFlexContainerProps, addFlexProps
  
  window.addEventListener('design-register-element', function () {
  
      registerDesignSnippet('<gs-static>', '<gs-static>', 'gs-static column="${1:name}"></gs-static>');
  
      designRegisterElement('gs-static', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-static.html');
  
      window.designElementProperty_GSSTATIC = function (selectedElement) {
          addProp('Formatted&nbsp;Text', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('pre')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'pre', (this.value === 'true'), true);
          });
  
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
  
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
  
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
  
          addProp('Inline', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('inline')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'inline', (this.value === 'true'), true);
          });
  
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
  
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility', true,
                  '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                  '    <option value="">Visible</option>' +
                  '    <option value="hidden">Invisible</option>' +
                  '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                  '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                  '    <option value="hide-on-phone">Invisible at phone size</option>' +
                  '    <option value="show-on-desktop">Visible at desktop size</option>' +
                  '    <option value="show-on-tablet">Visible at tablet size</option>' +
                  '    <option value="show-on-phone">Visible at phone size</option>' +
                  '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
  
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
  
              return selectedElement;
          });
  
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
  
      //function createPushReplacePopHandler(element) {
      //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
      //
      //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.value = GS.qryGetVal(strQueryString, strQSCol);
      //    }
      //}
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          arrAttr = element.attributes;
          i = 0;
          len = arrAttr.length;
          while (i < len) {
              jsnAttr = arrAttr[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function createPushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  if (strQSValue !== '' || !element.getAttribute('value')) {
                      element.setAttribute('value', strQSValue);
                  }
              } else {
                  element.value = strQSValue;
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              // if the value was set before the "created" lifecycle code runs: set attribute
              //      (discovered when trying to set a value of a date control in the after_open of a dialog)
              //      ("delete" keyword added because of firefox)
              if (element.value && !element.hasAttribute('value')) {
                  element.setAttribute('value', element.value);
                  delete element.value;
                  //element.value = null;
              }
          }
      }
  
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
  
                  //var strQSValue;
                  element.refresh();
  
                  if (element.getAttribute('qs')) {
                      //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                      //
                      //if (strQSValue !== '' || !element.getAttribute('value')) {
                      //    element.value = strQSValue;
                      //}
                      createPushReplacePopHandler(element);
                      window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                      window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                      window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                  }
              }
          }
      }
      
      xtag.register('gs-static', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      this.refresh();
                  }
              }
          },
          events: {},
          accessors: {
              value: {
                  // get value straight from the input
                  get: function () {
                      return this.getAttribute('value');
                  },
                  
                  // set the value of the input and set the value attribute
                  set: function (strNewValue) {
                      this.setAttribute('value', strNewValue);
                  }
              }
          },
          methods: {
              refresh: function () {
                  this.innerHTML = this.getAttribute('value');
              }
          }
      });
  });
  window.addEventListener('design-register-element', function () {
      'use strict';
  
      registerDesignSnippet('<gs-sticky>', '<gs-sticky>', 'gs-sticky>\n' +
                                                          '    <gs-sticky-inner>\n' +
                                                          '        ${0}\n' +
                                                          '    </gs-sticky-inner>\n' +
                                                          '</gs-sticky>');
      
      designRegisterElement('gs-sticky', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-sticky.html');
  
      window.designElementProperty_GSSTICKY = function (selectedElement) {
          addProp('Direction', true,  '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('direction') || '') + '" mini>' +
                                          '<option value="">Up</option>' +
                                          '<option value="down">Down</option>' +
                                      '</gs-select>',
                                      function () {
              return setOrRemoveTextAttribute(selectedElement, 'direction', this.value);
          });
  
          addProp('Always Stuck', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('stuck') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'stuck', this.value === 'true', true);
          });
  
          addProp('Touch Devices Allowed', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('touch-device-allowed') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'touch-device-allowed', this.value === 'true', true);
          });
  
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      function stickHandler(element) {
          var bolTop = (element.getAttribute('direction') !== 'down'),
              intScrollPosition = document.body.scrollTop,
              jsnElementPositionData = GS.getElementPositionData(element),
              bolShouldBeStuck = (bolTop && jsnElementPositionData.intRoomAbove < 0) || (!bolTop && jsnElementPositionData.intRoomBelow < 0);
          
          if (bolShouldBeStuck && !element.hasAttribute('stuck')) {
              element.style.height = element.offsetHeight + 'px';
              element.setAttribute('stuck', '');
              
              //if (bolTop) {
              //    element.parentNode.style.paddingTop = element.offsetHeight + 'px';
              //} else {
              //    element.parentNode.style.paddingBottom = element.offsetHeight + 'px';
              //}
              
          } else if (!bolShouldBeStuck && element.hasAttribute('stuck')) {
              element.style.height = '';
              element.removeAttribute('stuck');
              //
              //if (bolTop) {
              //    element.parentNode.style.paddingTop = '';
              //} else {
              //    element.parentNode.style.paddingBottom = '';
              //}
          }
          
          //console.log(bolTop, intScrollPosition, jsnElementPositionData);
      }
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              
          }
      }
      
      //
      function elementInserted(element) {
          var currentParent;
          
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  
                  if (element.children.length > 1) {
                      throw 'gs-sticky Error: Too many children. gs-sticky elements must have one child and it must be a <gs-sticky-inner> element.';
                      
                  } else if (element.children.length === 0) {
                      throw 'gs-sticky Error: No children. gs-sticky elements must have one child and it must be a <gs-sticky-inner> element.';
                      
                  } else if (element.children[0].nodeName !== 'GS-STICKY-INNER') {
                      throw 'gs-sticky Error: Invalid child. gs-sticky elements must have one child and it must be a <gs-sticky-inner> element.';
                  }
                  
                  element.parentNode.style.height = 'auto';
                  
                  if (element.hasAttribute('stuck')) {
                      //console.log(element.children[0].offsetHeight, element.getAttribute('direction'));
                      if (element.getAttribute('direction') !== 'down') {
                          element.parentNode.style.paddingTop = element.children[0].offsetHeight + 'px';
                      } else {
                          element.parentNode.style.paddingBottom = element.children[0].offsetHeight + 'px';
                      }
                  }
                  
                  if (!element.hasAttribute('stuck') && (!evt.touchDevice || element.hasAttribute('touch-device-allowed'))) {
                      stickHandler(element);
                      currentParent = element.parentNode;
                      if (currentParent.nodeName !== 'BODY') {
                          console.warn('gs-sticky Warning: Element not immediate child of BODY. This element was designed for being an immediate child of the BODY, doing otherwise may give unexpected results.');
                      }
                      
                      window.addEventListener('resize', function () {
                          if (element.parentNode === currentParent) {
                              stickHandler(element);
                          }
                      });
                      
                      window.addEventListener('scroll', function () {
                          if (element.parentNode === currentParent) {
                              stickHandler(element);
                          }
                      });
                      
                      window.addEventListener('orientationchange', function () {
                          if (element.parentNode === currentParent) {
                              stickHandler(element);
                          }
                      });
                  }
              }
          }
      }
      
      xtag.register('gs-sticky-inner', {});
      xtag.register('gs-sticky', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      
                  }
              }
          },
          events: {},
          accessors: {},
          methods: {}
      });
  });//global window, document, GS, ml, encodeHTML, addFlexContainerProps, addFlexProps, addProp, registerDesignSnippet, designRegisterElement, setOrRemoveTextAttribute, setOrRemoveBooleanAttribute, xtag, doT
  
  window.addEventListener('design-register-element', function () {
      'use strict';
      registerDesignSnippet('<gs-switch>', '<gs-switch>', 'gs-switch>\n' +
                                                          '    <template for="${1:none}"></template>\n' +
                                                          '    <template for="${2:detail}"></template>\n' +
                                                          '</gs-switch>');
  
      designRegisterElement('gs-switch', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-switch.html');
  
      window.designElementProperty_GSSWITCH = function (selectedElement) {
  
          addProp('Template', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'template', this.value);
          });
  
          addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
              this.removeAttribute('refresh-on-querystring-change');
              return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
          });
  
          addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
              this.removeAttribute('refresh-on-querystring-values');
              return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
          });
          
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
  
          addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
  
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
  
      function subsafeTemplate(strTemplate) {
          var templateElement = document.createElement('template');
          var strID;
          var arrTemplates;
          var i;
          var len;
          var jsnTemplates;
          var strRet;
          var arrTemplateNames;
  
          templateElement.innerHTML = strTemplate;
  
          // temporarily remove templates. recursively go through templates whose parents do not have the source attribute
          i = 0;
          arrTemplates = xtag.query(templateElement.content, 'template');
  
          jsnTemplates = {};
          arrTemplateNames = [];
  
          while (arrTemplates.length > 0 && i < 100) {
              //console.log(arrTemplates[0]);
              //console.log(arrTemplates[0].parentNode);
              //console.log(arrTemplates[0].parentNode.hasAttribute('src'));
  
              // if the current template has a source parent: remove temporarily
              if (
                  arrTemplates[0].parentNode &&
                  arrTemplates[0].parentNode.hasAttribute &&
                  (
                      arrTemplates[0].parentNode.hasAttribute('src') ||
                      arrTemplates[0].parentNode.hasAttribute('source')
                  )
              ) {
                  strID = 'UNIqUE_PLaCEhOLDER-' + GS.GUID() + '-UNiQUE_PLaCEhOLdER';
                  jsnTemplates[strID] = arrTemplates[0].outerHTML;
                  arrTemplates[0].outerHTML = strID;
                  arrTemplateNames.push(strID);
  
              // else: add to the arrTemplates array
              } else if (arrTemplates[0].content) {
                  arrTemplates.push.apply(arrTemplates, xtag.query(arrTemplates[0].content, 'template'));
              }
  
              // remove the current template from the arrTemplates array
              arrTemplates.splice(0, 1);
  
              i += 1;
          }
  
          strRet = doT.template(
              '{{##def.snippet:\n' +
                      '    {{ var qs = GS.qryToJSON(GS.getQueryString()); }} {{# def.template }}\n' +
                      '#}}\n' +
                      '{{#def.snippet}}',
              null,
              {"template": templateElement.innerHTML}
          )();
  
          i = 0;
          len = arrTemplateNames.length;
          //for (strID in jsnTemplates) {
          while (i < len) {
              // DO NOT DELETE THE REPLACE, it allows single dollar signs to be inside dot notation
              strRet = strRet.replace(
                  new RegExp(arrTemplateNames[i], 'g'),
                  jsnTemplates[arrTemplateNames[i]].replace(/\$/g, '$$$$')
              );
              i += 1;
          }
  
          return strRet;
      }
  
      //function pushReplacePopHandler(element) { //, eventName
      //    var i;
      //    var len;
      //    var arrPopKeys = [];
      //    var bolRefresh = false;
      //    var strQS = GS.getQueryString();
      //    var currentValue;
      //    var strQSCol = element.getAttribute('qs');
  
      //    //console.log(eventName);
  
      //    if (element.hasAttribute('refresh-on-querystring-values') || element.hasAttribute('qs')) {
      //        if (element.hasAttribute('refresh-on-querystring-values')) {
      //            arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
      //        }
      //        if (strQSCol && GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
      //            GS.listAdd(arrPopKeys, strQSCol);
      //        }
  
      //        //for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
      //        i = 0;
      //        len = arrPopKeys.length;
      //        while (i < len) {
      //            currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);
  
      //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
      //                //console.log(arrPopKeys[i], element.popValues[arrPopKeys[i]], currentValue);
      //                bolRefresh = true;
      //            }
  
      //            element.popValues[arrPopKeys[i]] = currentValue;
      //            i += 1;
      //        }
      //    } else {
      //        bolRefresh = true;
      //    }
  
      //    if (bolRefresh) {
      //        element.refresh();
      //    }
      //}
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          i = 0;
          len = element.attributes.length;
          arrAttr = element.attributes;
          while (i < len) {
              jsnAttr = element.attributes[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var arrPopKeys;
          var currentValue;
          var bolRefresh = false;
          var strOperator;
  
          if (strQSCol && strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          }
  
          // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
          if (element.internal.bolQSFirstRun === true) {
              if (element.hasAttribute('refresh-on-querystring-values') || element.hasAttribute('qs')) {
                  if (element.getAttribute('refresh-on-querystring-values')) {
                      arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                  } else {
                      arrPopKeys = [];
                  }
  
                  if (strQSCol) {
                      GS.listAdd(arrPopKeys, strQSCol);
                  }
  
                  i = 0;
                  len = arrPopKeys.length;
                  //for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                  while (i < len) {
                      currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);
  
                      if (element.popValues[arrPopKeys[i]] !== currentValue) {
                          bolRefresh = true;
                      }
  
                      element.popValues[arrPopKeys[i]] = currentValue;
                      i += 1;
                  }
                  
              } else if (element.hasAttribute('refresh-on-querystring-change')) {
                  bolRefresh = true;
              } else if (element.hasAttribute('template') || element.hasAttribute('value')) {
                  bolRefresh = true;
              }
  
              if (bolRefresh) {
                  element.refresh();
              }
          } else {
              if (element.hasAttribute('refresh-on-querystring-values')) {
                  arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
  
                  i = 0;
                  len = arrPopKeys.length;
                  //for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                  while (i < len) {
                      element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                      i += 1;
                  }
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
  
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
  
          }
      }
  
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  // transfer 'value' attribute to 'template'
                  if (element.hasAttribute('value')) {
                      element.setAttribute('template', element.getAttribute('value'));
                      console.warn('gs-switch Warning: "value" attribute is deprecated. Please use the "template" attribute to replace the "value" attribute.', element);
                  }
                  
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
  
                  // Get templates and define some variables
                  var arrTemplate = xtag.queryChildren(element, 'template');
                  var i;
                  var len;
                  var attr_i;
                  var attr_len;
                  var arrAttrNames;
                  var arrAttrValues;
                  var strAttrName;
                  var root;
                  var template;
                  var arrPopKeys;
                  var strQueryString;
                  var strQSCol;
  
                  element.attributesFromTemplate = [];
                  element.templates = {};
  
                  //for (i = 0, len = arrTemplate.length; i < len; i += 1) {
                  i = 0;
                  len = arrTemplate.length;
                  while (i < len) {
                      if (i === 0) {
                          element.firstTemplate = arrTemplate[i].getAttribute('for') || arrTemplate[i].getAttribute('id');
                      }
  
                      arrAttrNames = [];
                      arrAttrValues = [];
  
                      attr_i = 0;
                      attr_len = arrTemplate[i].attributes.length;
                      //for (attr_i = 0, attr_len = arrTemplate[i].attributes.length; attr_i < attr_len; attr_i += 1) {
                      while (attr_i < attr_len) {
                          strAttrName = arrTemplate[i].attributes[attr_i].nodeName;
  
                          if (strAttrName !== 'for' && strAttrName !== 'id') {
                              arrAttrNames.push(strAttrName);
                              arrAttrValues.push(arrTemplate[i].attributes[attr_i].value);
                          }
                          attr_i += 1;
                      }
  
                      template = arrTemplate[i];
                      element.templates[template.getAttribute('for') || template.getAttribute('id')] = {
                          'content': template.innerHTML,
                          'arrAttrNames': arrAttrNames,
                          'arrAttrValues': arrAttrValues,
                          'templated': !(element.hasAttribute('static') || template.hasAttribute('static'))
                      };
                      if (!(element.hasAttribute('static') || template.hasAttribute('static')) && 
                          (
                              element.templates[template.getAttribute('for') || template.getAttribute('id')].content.indexOf('&gt;') > -1 ||
                              element.templates[template.getAttribute('for') || template.getAttribute('id')].content.indexOf('&lt;') > -1
                          )) {
                          console.warn('GS-SWITCH WARNING: &gt; or &lt; detected in "' + (template.getAttribute('for') || template.getAttribute('id')) + '" template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                      }
  
                      i += 1;
                  }
  
                  // Clear out the templates from the DOM
                  element.innerHTML = '';
  
                  element.arrQueryStringAttributes = [];
                  element.popValues = {};
  
                  if (
                      (
                          element.hasAttribute('template') &&
                          element.getAttribute('template').indexOf('{{') > -1
                      ) ||
                      element.hasAttribute('qs') ||
                      element.hasAttribute('refresh-on-querystring-values') ||
                      element.hasAttribute('refresh-on-querystring-change')
                  ) {
                      //arrPopKeys = [];
                      //strQueryString = GS.getQueryString();
                      //strQSCol = element.getAttribute('qs');
  
                      //if (element.hasAttribute('refresh-on-querystring-values')) {
                      //    arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                      //}
                      //if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
                      //    GS.listAdd(arrPopKeys, strQSCol);
                      //}
  
                      //i = 0;
                      //len = arrPopKeys.length;
                      ////for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                      //while (i < len) {
                      //    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQueryString, arrPopKeys[i]);
                      //    i += 1;
                      //}
                      pushReplacePopHandler(element);
                      window.addEventListener('pushstate', function () {
                          pushReplacePopHandler(element);
                      });
                      window.addEventListener('replacestate', function () {
                          pushReplacePopHandler(element);
                      });
                      window.addEventListener('popstate', function () {
                          pushReplacePopHandler(element);
                      });
                  }
  
                  element.refresh();
              }
          }
      }
  
      xtag.register('gs-switch', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
  
              inserted: function () {
                  elementInserted(this);
              },
  
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  var element = this;
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(element);
                      elementInserted(element);
  
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(element);
  
                  } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                      if (strAttrName === 'value') { // && oldValue !== newValue
                          //element.refresh();
                          element.setAttribute('template', newValue);
                          console.warn('gs-switch Warning: "value" attribute is deprecated. Please use the "template" attribute to replace the "value" attribute.', element);
  
                      } else if (strAttrName === 'template' && element.inserted === true) {
                          element.refresh();
                      }
                  }
              }
          },
          events: {},
          accessors: {
              value: {
                  get: function () {
                      var element = this;
                      console.warn('gs-switch Warning: \'.value\' accessor is deprecated. Please use the \'.template\' accessor to replace the \'.value\' accessor.', element);
                      return element.getAttribute('template');
                  },
                  set: function (newValue) {
                      var element = this;
                      console.warn('gs-switch Warning: \'.value\' accessor is deprecated. Please use the \'.template\' accessor to replace the \'.value\' accessor.', element);
                      element.setAttribute('template', newValue);
                  }
              },
              template: {
                  get: function () {
                      return this.getAttribute('template');
                  },
                  set: function (newValue) {
                      this.setAttribute('template', newValue);
                  }
              }
          },
          methods: {
              refresh: function () {
                  var element = this;
                  var strQueryString = GS.getQueryString();
                  var strQSAttribute = element.getAttribute('qs');
                  var strValueAttribute = element.getAttribute('template') || element.getAttribute('value');
                  var templateName;
                  var i;
                  var len;
  
                  if (strQSAttribute && GS.qryGetVal(strQueryString, strQSAttribute)) {
                      templateName = GS.qryGetVal(strQueryString, strQSAttribute);
                  } else if (strValueAttribute) {
                      templateName = GS.templateWithQuerystring(strValueAttribute);
                  }
  
                  templateName = templateName || element.firstTemplate;
  
                  if (element.templates[templateName] && element.templates[templateName].content) {
                      // if there are values in element.attributesFromTemplate
                      if (element.attributesFromTemplate.length > 0) {
                          // loop through them
                          i = 0;
                          len = element.attributesFromTemplate.length;
                          //for (i = 0, len = element.attributesFromTemplate.length; i < len; i += 1) {
                          while (i < len) {
                              // if attribute was initallySet: set it back to initalvalue
                              if (element.attributesFromTemplate[i].initallySet) {
                                  element.setAttribute(element.attributesFromTemplate[i].name, element.attributesFromTemplate[i].initalValue);
  
                              // else: remove it
                              } else {
                                  element.removeAttribute(element.attributesFromTemplate[i].name);
                              }
                              i += 1;
                          }
                      }
  
                      // clear element.attributesFromTemplate
                      element.attributesFromTemplate = [];
  
                      // if there are values in element.templates[templateName].arrAttrNames
                      if (element.templates[templateName].arrAttrNames.length > 0) {
                          // loop through them
                          i = 0;
                          len = element.templates[templateName].arrAttrNames.length;
                          //for (i = 0, len = element.templates[templateName].arrAttrNames.length; i < len; i += 1) {
                          while (i < len) {
                              // add to element.attributesFromTemplate
                              element.attributesFromTemplate.push({
                                  'name': element.templates[templateName].arrAttrNames[i],
                                  'initallySet': element.hasAttribute(element.templates[templateName].arrAttrNames[i]),
                                  'initalValue': element.getAttribute(element.templates[templateName].arrAttrNames[i])
                              });
  
                              // set attribute
                              element.setAttribute(element.templates[templateName].arrAttrNames[i], GS.templateWithQuerystring(this.templates[templateName].arrAttrValues[i]));
                              i += 1;
                          }
                      }
  
                      if (element.templates[templateName].templated) {
                          element.innerHTML = subsafeTemplate(element.templates[templateName].content);
                      } else {
                          element.innerHTML = element.templates[templateName].content;
                      }
  
                      // if template is not native: handle templates inside the switch
                      if (shimmed.HTMLTemplateElement) {
                          window.HTMLTemplateElement.bootstrap(element);
                      }
                      //console.trace('trace this');
                      GS.triggerEvent(element, 'templatechange', {'templateName': templateName});
                      GS.triggerEvent(element, 'template_change', {'templateName': templateName});
                  } else {
                      element.innerHTML = '';
                  }
              }
          }
      });
  });//global GS, xtag, document, window, ml, evt, doT, Worker
  //jslint browser:true, maxlen:80, white:false, this:true
  
  
  /*
  new datasheet
      select, insert, update,
          delete, copy, paste and selection events (prevent default)
      programatic select, insert, update,
          delete, copy, paste and selection (events marked as programatic)
  
      fixed headers/record selectors
      ace scrolling
      insert record
  
      data source is not required (column list is required if no data source)
  
      header, record, insert record templating (dot.js)
  
      placeholder for null values
      value to set value as null
  
      headers, record selectors, insert record are all optional
  
      copy settings (
          headers always|never|whenselected
          record selectors always|never|whenselected
          quote char
          quote when never|strings|always
          record delim char
          cell delim char
          null value string
      )
      no more table element
  
      selection is stored as ranges
      backwards compatible attributes (transfer to new names and warn)
  
  
  element name:
      <gs-table></gs-table>
  
  helper elements:
      <gs-cell></gs-cell>
  
  attributes:
      pk
      lock
      seq
      cols (required if no src)
      src
      where
      session-filter (where clause that can be overridden by the user)
      ord
      limit
      offset
      column
      child-column
      qs
      refresh-on-querystring-values
      refresh-on-querystring-change
  
      reflow-at (future)
      scroll-past-bottom
          (allows you to scroll until only the bottom record is seen)
      scroll-to-bottom (scrolls all the way down on initial load)
      expand-to-content
  
      no-hudpaginate
      no-hudrefresh
      no-huddelete
      no-filter
  
      suspend-created
      suspend-inserted
  
      no-header
      no-record-selector
      no-selection
  
      null-string (defaults to "")
      null-set-string (defaults to null-string attribute)
  
      no-resize-column
      no-resize-record
  
      default-record-height (pixels, defaults if not present)
      default-column-width (pixels, defaults if not present)
      column-border-width (pixels, defaults if not present)
      record-border-height (pixels, defaults if not present)
  
      socket (name of a property stored on the GS object, needs to be a socket)
  
      copy-header           always|never|selected
      copy-selectors        always|never|selected
      copy-quote-char       text
      copy-escape-char      text
      copy-quote-when       never|strings|always|delimiter-in-content
      copy-delimiter-record text
      copy-delimiter-cell   text
      copy-null-cell        text
  
  templates: (all are dot.js templated before use)
      for="hud" (snippet contains default
                      insert/update/delete/refresh/filter/paginate elements)
      for="header-record"
          <gs-cell>HEADERTEXT</gs-cell>
      for="data-record"
          <gs-cell header="HEADERTEXT">
              <gs-text mini column="COLUMNNAME"></gs-text>
          </gs-cell>
      for="insert-record"
          <gs-cell header="HEADERTEXT" target="COLUMNNAME"></gs-cell>
      for="insert-dialog"
  
  accessors:
      selection (contains JS array of selection ranges)
      data (contains TSV of all data)
      value (value attribute)
  
  events:
      before_select (contains TSV of selection under "records" key)
      before_insert (contains TSV of insert under "records" key)
      before_update (contains TSV of old/new under "records" key ("old", "new"))
      before_delete (contains TSV of delete under "records" key)
      before_selection (contains TSV of selection ranges under "selection" key)
  
      after_select (contains TSV of selection under "records" key)
      after_insert (contains TSV of insert under "records" key)
      after_update (contains TSV of old/new under "records" key ("old", "new"))
      after_delete (contains TSV of delete under "records" key)
      after_selection (contains TSV of selection ranges under "selection" key)
  
      insert_dialog_open (event.relatedTarget = insert dialog)
      before_copy (preventDefault will prevent copy)
      copy
      paste
  
  methods:
      refresh
      render
      scrollToIndex(cell_number, record_number)
      clearSelection()
      addSelectionRange(
          fromCell_number,
          fromRecord_number,
          toCell_number,
          toRecord_number,
          bolNegate (default false)
      )
      getCopyString(
          strMimeType text|html
      )
      paste(paste_string)
      filter(
          filterColumn,
          filterType contains|starts|ends|equals|greaterthan|lessthan,
          showIfMatch true|false,
          filterValue
      )
      selectData
      insertData
      updateData
      deleteData
  
  click behavior:
      if click results in focused input/textarea
              and start/end locations are in the same place:
          select all control contents
      if not no-filter and click results in focused control: filter popup tooltip
  
  mousedown-drag:
      if shift:
          move latest selection range's endpoint
      if no shift:
          clear all selections
          start new selection
      if command/control:
          start new selection
          if selection started on an already selected cell:
              selection is a negator selection
  
  selection behavior:
      if selection origin and end is on a record selector:
          select entire records
      if selection origin and end is on a header selector:
          select entire columns
      if selection origin starts and ends on the top-left selector:
          select all cells
      if selection endpoint is off-screen:
          scroll it to middle
  
  focus behavior:
      cell/record focus location is saved
          (if cell is visible after a render, focus into it)
          (removed on blur)
      on selection with no focused control: focus hidden control
      on mousedown inside the element (on unfocusable element):
          focus hidden control
      on blur after cell change: cause update
      on focus of single cell: set selection to focused cell
  
  copy behavior:
      never copy insert record
      on copy event and hidden focus control is focused:
          copy to html mime type (using applicable copy attributes)
          copy to text mime type (using applicable copy attributes)
      if a record is not selected: no space is made for it in the copy
      if a column is not selected: no space is made for it in the copy
  
  key behavior:
      arrowing around selects the cell, doesn't focus the control
      return on selection focuses selection origin cell control
      "delete"/"forward delete" when no control is focused causes record delete
      on return after cell change: cause update
  
      if arrow:
          if shift:
              "selection" means selection end of latest selection range
          if no shift:
              clear all selection ranges
              "selection" means selection origin/end of new selection range
  
          if all contents selected because of arrow
              or
          if cursor is at boundary in the direction of the arrow:
              if there is a cell in the direction of the arrow:
                  move selection in direction of arrow
              else:
                  if right at last cell of record: first cell of next record
                  if right at last cell of table: first cell of table
                  if left at first cell of record: last cell of previous record
                  if left at first cell of table: last cell of table
                  if up at first cell of column: previous column of bottom record
                  if down at last cell of column: next column of first record
  
  scrollbar behavior:
      whenever the record count is changed: the scrollbar is rerendered
      the scrollbar has a maximum range, stop growing around this height
      if scrollbar is past max height, you'll need to translate the top
          into (1px of scroll height will = >1px of motion)
      after scroll: rerender location
      phone scroll: no scrollbar, needs elastic motion
      scroll render:
          if scrollTop is >0     header shadow
          if scrollLeft is >0    record selector shadow
          if scrollBottom is >0  insert record shadow
          if scrollRight is >0   right side shadow
  
  loader behavior:
      when enabled: a small spinner shows at the top-right of the data area
  
  delete behavior:
      always asks if you're sure
      after success:
          remove record from internal data,
          render current location,
          clear selection range if it's now out of bounds
      during delete: enable element loader
      after delete is initiated: record is no longer clickable
  
  insert behavior:
      asks if you're sure only when inserting multiple records (using paste)
      after success:
          append new data to the end of internal data,
          scroll to bottom,
          render current location,
          clear selection range
      during insert: enable element loader
  
  update behavior:
      asks if you're sure only when updating multiple records (using paste)
      after success:
          update whole record in internal data,
          render current location,
          clear selection range
      during update: enable element loader
      if an update is caused while another update is still resolving: add to queue
  
  select behavior:
      first load: if scroll-to-bottom: scroll to reveal bottom record
      reload: always returns to previous scroll/focus/textselection situation
      during load: enable element loader
  */
  
  
  
  
  
  
  
  // # CODE INDEX:
  //          (use "find" (CTRL-f or CMD-f) to skip to a section)
  //          ("PRE-RENDER" refers to a section of functions that do not depend
  //                  on the viewport being rendered AND dont use any render
  //                  functions)
  //          ("POST-RENDER" refers to a section of functions that either depend
  //                  on the viewport being rendered OR use render functions)
  //      # TOP  (this just brings you back this index)
  //      # ELEMENT CONFIG
  //      # GLOBAL <STYLE></STYLE> ELEMENT SETUP
  //      # SCROLLBAR WIDTH
  //      # CELL DIMENSION DETECTOR
  //      # EXTERIOR LIBRARIES
  //          # GETPLAINTEXT
  //      # PRE-RENDER UTILITY FUNCTIONS
  //      # ELEMENT FUNCTIONS
  //      # RENDER FUNCTIONS
  //      # POST-RENDER UTILITY FUNCTIONS
  //      # LOADER FUNCTIONS
  //      # DATA FUNCTIONS
  //      # COPY FUNCTIONS
  //      # PASTE FUNCTIONS
  //      # BUTTON FUNCTIONS
  //      # EVENT FUNCTIONS
  //          # FOCUS EVENTS
  //          # SCROLL EVENTS
  //          # SELECTION EVENTS
  //          # COLUMN/ROW RESIZE EVENTS
  //          # COLUMN REORDER EVENTS
  //          # UPDATE EVENTS
  //          # INSERT EVENTS
  //          # HUD EVENTS
  //          # KEY EVENTS
  //          # COPY EVENTS
  //          # PASTE EVENTS
  //          # CUT EVENTS
  //          # CONTEXTMENU EVENTS
  //          # COLUMN DROPDOWN EVENTS
  //          # DEVELOPER EVENTS
  //          # HIGH LEVEL BINDING
  //      # XTAG DEFINITION
  //      # ELEMENT LIFECYCLE
  //      # ELEMENT ACCESSORS
  //      # ELEMENT METHODS
  
  // for sections of code that need to be completed:
  //      # NEED CODING
  
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
  // ############################################################################
  // ############################## ELEMENT CONFIG ##############################
  // ############################################################################
  
      var intDefaultRecordHeight = 27; // pixels
      var intDefaultColumnWidth = 75; // pixels
  
  // ############################################################################
  // ############################ GLOBAL ID SEQUENCE ############################
  // ############################################################################
  
      var globalIDSeq = 0;
  
  // ############################################################################
  // ################### GLOBAL <STYLE></STYLE> ELEMENT SETUP ###################
  // ############################################################################
  
      // we need to dynamically generate some CSS because of browser/OS
      //      differences, so here we create the global style element. This
      //      element may only have CSS appended to it at this global level, not
      //      after gs-table elements are instantiated.
      var globalStyleElement = document.createElement("style");
      globalStyleElement.setAttribute("id", "gs-table-style-container");
      document.head.appendChild(globalStyleElement);
  
  // #############################################################################
  // ############################## SCROLLBAR WIDTH ##############################
  // #############################################################################
  
      // we need to handle scrollbar width dynamically because different operating
      //      systems have different scrollbar widths, this section deals with the
      //      scrollbar width for all gs-table elements at the same time.
  
      // return scrollbar width
      function getScrollBarWidth() {
          var container = document.createElement("div");
          var detector = document.createElement("div");
          var ret;
  
          document.body.appendChild(container);
          container.appendChild(detector);
  
          container.style.width = "100px";
          container.style.height = "100px";
          container.style.opacity = "0.2";
          container.style.overflow = "scroll";
  
          detector.style.display = "inline-block";
          detector.style.width = "10px";
          detector.style.height = "100%";
          //detector.style.background = "#F00";
  
          ret = 100 - detector.offsetHeight;
          document.body.removeChild(container);
  
          return ret;
      }
  
      // save scrollbar width to variable
      var intScrollbarWidth = getScrollBarWidth();
  
      // we need some CSS specifically to handle the scrollbar,
      //      this function returns that CSS
      function createGlobalScrollbarStyles() {
          var intScrollbarWidthPadded;
  
          // this variable creates 1px pixels of space in the green box in the
          //      bottom-right corner to make it look well sized and match up
          //      well with the borders around it.
          intScrollbarWidthPadded = (intScrollbarWidth + 1);
  
          // on an iPhone, scrollbars are hidden
          if (intScrollbarWidth === 0) {
              return 'gs-table > ' +
                      '        .table-root > ' +
                      '        .table-table-container > ' +
                      '        .table-data-container {\n' +
                      '    padding-bottom: 0px;\n' +
                      '    padding-right: 0px;\n' +
                      '}\n' +
                      // hide scrollbar containers
                      'gs-table > ' +
                      '        .table-root > ' +
                      '        .table-table-container > ' +
                      '        .table-v-scroll-bar-container {\n' +
                      '    width: 0px;\n' +
                      '    padding-bottom: 0px;\n' +
                      '    display: none;\n' +
                      '}\n' +
                      // hide scrollbar containers
                      'gs-table > ' +
                      '        .table-root > ' +
                      '        .table-table-container > ' +
                      '        .table-h-scroll-bar-container {\n' +
                      '    height: 0px;\n' +
                      '    padding-right: 0px;\n' +
                      '    display: none;\n' +
                      '}\n' +
                      // remove viewport border
                      'gs-table >\n' +
                      '        .table-root >\n' +
                      '        .table-table-container >\n' +
                      '        .table-data-container >\n' +
                      '        .table-data-viewport {\n' +
                      '    border-right: 0 none;\n' +
                      '    border-bottom: 0 none;\n' +
                      '}';
          }
  
          return 'gs-table > ' +
                  '        .table-root > ' +
                  '        .table-table-container > ' +
                  '        .table-data-container {\n' +
                  '    padding-bottom: ' + intScrollbarWidth + 'px;\n' +
                  '    padding-right: ' + intScrollbarWidth + 'px;\n' +
                  '}\n' +
                  'gs-table > ' +
                  '        .table-root > ' +
                  '        .table-table-container > ' +
                  '        .table-v-scroll-bar-container {\n' +
                  '    width: ' + intScrollbarWidth + 'px;\n' +
                  '    padding-bottom: ' + intScrollbarWidthPadded + 'px;\n' +
                  '}\n' +
                  'gs-table > ' +
                  '        .table-root > ' +
                  '        .table-table-container > ' +
                  '        .table-h-scroll-bar-container {\n' +
                  '    height: ' + intScrollbarWidth + 'px;\n' +
                  '    padding-right: ' + intScrollbarWidthPadded + 'px;\n' +
                  '}';
      }
  
      // append scrollbar-specific CSS to global style element
      globalStyleElement.innerHTML += createGlobalScrollbarStyles();
  
  // #############################################################################
  // ########################## CELL DIMENSION DETECTOR ##########################
  // #############################################################################
  
      // we need to be able to detect the cell/border widths/heights dynamically
      //      so that the scrolling functionality can calculate true dimensions
      //      and so that records/columns (which may be dynamically resized) will
      //      have defaults
      function cellDimensionDetector(element) {
          var testDataCell = element.elems.testDataCell;
          var testHeader = element.elems.testHeader;
          var testInsert = element.elems.testInsert;
          var testRecordSelector = element.elems.testRecordSelector;
  
          // first, we'll look at data record/cell dimensions
          element.internalDisplay.columnBorderWidth = parseInt(
              (GS.getStyle(testDataCell, 'border-right-width') || '0'),
              10
          );
          element.internalDisplay.recordBorderHeight = parseInt(
              (GS.getStyle(testDataCell, 'border-bottom-width') || '0'),
              10
          );
          element.internalDisplay.defaultColumnWidth = parseInt(
              (GS.getStyle(testDataCell, 'width') || '0'),
              10
          );
          element.internalDisplay.defaultRecordHeight = parseInt(
              (GS.getStyle(testDataCell, 'height') || '0'),
              10
          );
  
          // next, we'll look at header dimensions
          element.internalDisplay.headerBorderHeight = parseInt(
              (GS.getStyle(testHeader, 'border-bottom-width') || '0'),
              10
          );
  
          // next, we'll look at insert cell dimensions
          element.internalDisplay.insertRecordBorderHeight = parseInt(
              (GS.getStyle(testInsert, 'border-bottom-width') || '0'),
              10
          );
  
          // next, we'll look at record selector cell dimensions
          element.internalDisplay.recordSelectorBorderWidth = parseInt(
              (GS.getStyle(testRecordSelector, 'border-right-width') || '0'),
              10
          );
      }
  
      // we need to know if headers, record selectors or the insert record is
      //      being used. this is so that we can determine the amount of space
      //      to put on each side of the viewport for the data
      function visibilityDetector(element) {
          // we reset everything to visible here so that the code is shorter
          // (innocent until proven guilty)
          element.internalDisplay.headerVisible = true;
          element.internalDisplay.recordSelectorVisible = true;
          element.internalDisplay.insertRecordVisible = true;
  
          // we are checking to see if the header template is empty or just all
          //      whitespace, if it is: we're setting headers to visibility=false
          if (
              !element.internalTemplates.header ||
              !element.internalTemplates.header.trim()
          ) {
              element.internalDisplay.headerVisible = false;
          }
  
          // we are checking to see if the "no-record-selector" attribute is
          //      present, if it is: we're setting the record selectors to
          //      visibility=false
          if (element.hasAttribute('no-record-selector')) {
              element.internalDisplay.recordSelectorVisible = false;
          }
  
          // we are checking to see if the insert record template is empty or
          //      just all whitespace, if it is: we're setting the insert record
          //      to visibility=false
          if (
              !element.internalTemplates.insertRecord ||
              !element.internalTemplates.insertRecord.trim()
          ) {
              element.internalDisplay.insertRecordVisible = false;
          }
      }
  
      // we need to calculate the amount of space to put on each side of the
      //      viewport depending on what features are visible (header, record
      //      selectors, insert record). so, if the insert record is visible
      //      we need to tell everything else that that space is not usable for
      //      anything else
      function offsetDetector(element) {
          // we reset all of the offsets to zero because the way we calculate
          //      the offsets is that we increment the offset if something is
          //      visible (increment/decrement only, no resets after this point)
          element.internalScrollOffsets.top = 0;
          element.internalScrollOffsets.left = 0;
          element.internalScrollOffsets.bottom = 0;
          element.internalScrollOffsets.right = 0;
  
          // if the header is visible, we want to add the height of the header
          //      (plus it's border) to the top offset
          if (
              element.internalDisplay.headerVisible &&
              element.internalDisplay.headerStick === 'top'
          ) {
              element.internalScrollOffsets.top += (
                  element.internalDisplay.headerHeight +
                  element.internalDisplay.headerBorderHeight
              );
          }
  
          // if the record selectors are visible, we want to add the width of
          //      the record selectors (plus the border) to the left offset
          if (
              element.internalDisplay.recordSelectorVisible &&
              element.internalDisplay.selectorStick === 'left'
          ) {
              element.internalScrollOffsets.left += (
                  element.internalDisplay.recordSelectorWidth +
                  element.internalDisplay.recordSelectorBorderWidth
              );
          }
  
          // if the insert record is visible, we want to add the height of the
          //      record (plus it's border) to the bottom offset
          if (
              element.internalDisplay.insertRecordVisible &&
              element.internalDisplay.insertRecordStick === 'bottom'
          ) {
              element.internalScrollOffsets.bottom += (
                  element.internalDisplay.insertRecordHeight +
                  element.internalDisplay.insertRecordBorderHeight
              );
          }
      }
  
  // #############################################################################
  // ############################ EXTERIOR LIBRARIES #############################
  // #############################################################################
  
  // ############ GETPLAINTEXT #############
  
      // original name:     getPlainText()
      // original author:   Mike Wilcox
      // original site:     http://clubajax.org
      // original support:  http://groups.google.com/group/clubajax
      //
      //    DESCRIPTION:
      //        Returns a line-break, properly spaced, normalized plain text
      //        representation of multiple child nodes which can't be done via
      //        textContent or innerText because those two methods are vastly
      //        different, and even innerText works differently across browsers.
  
      /*
      ORIGINAL LICENSE FOR getPlainText():
  
      This is free and unencumbered software released into the public domain.
  
      Anyone is free to copy, modify, publish, use, compile, sell, or
      distribute this software, either in source code form or as a compiled
      binary, for any purpose, commercial or non-commercial, and by any
      means.
  
      In jurisdictions that recognize copyright laws, the author or authors
      of this software dedicate any and all copyright interest in the
      software to the public domain. We make this dedication for the benefit
      of the public at large and to the detriment of our heirs and
      successors. We intend this dedication to be an overt act of
      relinquishment in perpetuity of all present and future rights to this
      software under copyright law.
  
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
      OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
      ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
      OTHER DEALINGS IN THE SOFTWARE.
      */
  
      // This software has been modified from it's original form and thus,
      //      because the original authors of the software relinquished control
      //      to the individual user of the software, we (Workflow Products)
      //      hereby license this modified version of getPlainText() under the
      //      same license as the javascript you find getPlainText() included in.
  
      function getPlainText(node, bolConsumable) {
          var plainText = "";
  
          // used for testing/comparison:
          //return node.innerText || node.textContent;
  
          // clean up double line breaks and spaces
          function normalize(a) {
              if (!a) {
                  return "";
              }
              return a.replace(/\ +/g, " ")
                  .replace(/[\t]+/gm, "")
                  .replace(/[\ ]+$/gm, "")
                  .replace(/^[\ ]+/gm, "")
                  .replace(/\n+/g, "\n")
                  .replace(/\n+$/, "")
                  .replace(/^\n+/, "")
                  .replace(/\nNEWLINE\n/g, "\n\n")
                  .replace(/NEWLINE\n/g, "\n\n"); // IE
          }
  
          // because we format the text ourselves, we want to get rid of empty
          //      text nodes, they'll just get in the way
          function removeWhiteSpace(node) {
              var ws_i;
              var ws_len;
              var ws_node;
              var ws = [];
  
              // recursively find whitespace nodes and push them to "ws" array
              function findWhite(node) {
                  var i = 0;
                  var len = node.childNodes.length;
                  var n;
  
                  while (i < len) {
                      n = node.childNodes[i];
                      if (
                          // if node is a text node
                          n.nodeType === 3 &&
                          // if node contains only whitespace
                          !(/[^\t\n\r\ ]/).test(n.nodeValue)
                      ) {
                          // add node to whitespace node list
                          ws.push(n);
  
                      // else if node contains other nodes:
                      } else if (n.hasChildNodes()) {
                          // search node for more whitespace child nodes
                          findWhite(n);
                      }
                      i += 1;
                  }
              }
  
              // start recursive search
              findWhite(node);
  
              // remove nodes that are in the "ws" array
              ws_i = 0;
              ws_len = ws.length;
              while (ws_i < ws_len) {
                  ws_node = ws[ws_i];
                  ws_node.parentNode.removeChild(ws_node);
  
                  ws_i += 1;
              }
          }
  
          // we want to get the value of the CSS "white-space" and "display"
          //      properties (because they affect how we build the text), so this
          //      function will return CSS properties for a node
          // also, some elements have implied CSS settings (like SCRIPT is
          //      "display: none;") so, this function handles tag-specific
          //      settings
          function sty(n, prop) {
              var s;
              var bolAssumeBlock;
  
              // if the .style property is available, just use that
              if (n.style[prop]) {
                  return n.style[prop];
              }
  
              // coalesce through a couple different ways of retrieving CSS values
              s = (
                  n.currentStyle ||
                  window.getComputedStyle(n, null)
                  // ^ used to be n.ownerDocument.defaultView
              );
  
              if (n.tagName === "SCRIPT") {
                  return "none";
              }
              if (!s[prop]) {
                  bolAssumeBlock = "LI,P,TR".indexOf(n.tagName);
  
                  // if element is an element we assume block for, return block
                  if (bolAssumeBlock) {
                      return "block";
                  }
                  // else return actual style setting
                  return n.style[prop];
              }
              if (s[prop] === "block" && n.tagName === "TD") {
                  return "feaux-inline";
              }
              return s[prop];
          }
  
          var blockTypeNodes = "table-row,block,list-item";
          function isBlock(n) {
              // display:block or something else
              var s = sty(n, "display") || "feaux-inline";
              if (blockTypeNodes.indexOf(s) > -1) {
                  return true;
              }
              return false;
          }
  
          // loop recursively through the nodes and build up the text string
          function recurse(n) {
              var strCSSWhite = sty(n, "whiteSpace");
              var strCSSDisplay = sty(n, "display");
              var gap;
              var i;
              var len;
              var c;
  
              // Loop through all the child nodes
              // and collect the text, noting whether
              // spaces or line breaks are needed.
              if (strCSSWhite.indexOf('pre') !== -1) {
                  plainText += n.innerHTML
                      .replace(/\t/g, " ")
                      .replace(/\n/g, " "); // to match IE
                  return "";
              }
  
              if (strCSSDisplay === "none") {
                  return "";
              }
  
              gap = (
                  isBlock(n)
                      ? "\n"
                      : " "
              );
  
              plainText += gap;
              i = 0;
              len = n.childNodes.length;
              while (i < len) {
                  c = n.childNodes[i];
  
                  // if the node is a text node, append the value to the text
                  if (c.nodeType === 3) {
                      plainText += c.nodeValue;
                  }
  
                  // if the node has children, loop through them
                  if (c.childNodes.length) {
                      recurse(c);
                  }
  
                  i += 1;
              }
  
              plainText += gap;
              return plainText;
          }
  
          // we alter elements within the node that was sent, so clone the
          //      node if it's not consumable
          if (bolConsumable !== true) {
              node = node.cloneNode(true);
          }
  
          // Line breaks aren't picked up by textContent
          node.innerHTML = node.innerHTML.replace(/<br>/g, "\n"); //</br>
  
          // we don't care about line breaks after P tags right now
          //// Double line breaks after P tags are desired, but would get
          //// stripped by the final RegExp. Using placeholder text.
          //var paras = node.getElementsByTagName("p");
          //var i;
          //var len;
          //i = 0;
          //len = paras.length;
          //while (i < len) {
          //    paras[i].innerHTML += "NEWLINE";
          //    i += 1;
          //}
  
          removeWhiteSpace(node);
  
          // Make the call!
          return normalize(recurse(node));
      }
  
  
  // #############################################################################
  // ####################### PRE-RENDER UTILITY FUNCTIONS ########################
  // #############################################################################
  
      // we need a function to prevent html injection
      function encodeHTML(text) {
          var encode = {
              "&": "&#38;",
              "<": "&#60;",
              ">": "&#62;",
              '"': "&#34;",
              "'": "&#39;",
              "/": "&#47;"
          };
  
          if (text) {
              return text.toString().replace(
                  /&|<|>|"|'|\//g,
                  function (letter) {
                      return encode[letter] || letter;
                  }
              );
          }
          return text;
      }
  
      // commented out because we no longer put the styling on the cell
      //// because we need to be able to add styles to an element inside of a
      ////      template string, we have this function take a template (while it's
      ////      still a template element) and add a token to the "style" attribute
      ////      that can be easily replaced
      //function templateCellAddStyleToken(templateElement) {
      //    var arrCell = xtag.query(templateElement.content, 'gs-cell');
      //    var i = 0;
      //    var len = arrCell.length;
      //    var strStyle;
  
      //    while (i < len) {
      //        strStyle = (arrCell[i].getAttribute('style') || '');
      //        strStyle = strStyle.trim();
  
      //        if (strStyle && strStyle[strStyle.length - 1] !== ';') {
      //            strStyle += ';';
      //        }
  
      //        arrCell[i].setAttribute(
      //            'style',
      //            '$$CSSREPLACETOKEN$$ ' + strStyle
      //        );
  
      //        i += 1;
      //    }
      //}
  
      // because we are using the gs-cell element for headers, data cells, insert
      //      cells, record selectors and the all selector: we need a way for the
      //      CSS to identify them differently, so this function takes a template
      //      element and adds a class to the gs-cell elements within it
      function templateCellAddClass(templateElement, strClass) {
          var arrCell = xtag.query(templateElement.content, 'gs-cell');
          var i = 0;
          var len = arrCell.length;
  
          while (i < len) {
              arrCell[i].classList.add(strClass);
              i += 1;
          }
      }
  
      // because we need to be able to target cells by record number, this
      //      function takes a template and adds an attribute to each cell that'll
      //      contain the record number (zero-based) after doT.js
      function templateCellAddRowNumber(templateElement, strOverride) {
          var arrCell = xtag.query(templateElement.content, 'gs-cell');
          var i = 0;
          var len = arrCell.length;
  
          while (i < len) {
              arrCell[i].setAttribute(
                  'data-row-number',
                  (strOverride || '{{! row_number - 1 }}')
              );
              i += 1;
          }
      }
  
      // because we need to be able to target cells by column number, this
      //      function takes a template and adds an attribute to each cell that'll
      //      contain the column number (zero-based)
      function templateCellAddColumnNumber(templateElement) {
          var arrCell = xtag.query(templateElement.content, 'gs-cell');
          var i = 0;
          var len = arrCell.length;
  
          while (i < len) {
              arrCell[i].setAttribute('data-col-number', i);
              i += 1;
          }
      }
  
      // commented out because it has been superceded by the new
      //      "templateExtractVisibleCellRange" function
      //// because we only render what is visible on the screen, we use this
      ////      function to take a template string and extract only the columns
      ////      that will be visible
      //function templateExtractCellRange(strTemplate, fromColumn, toColumn) {
      //    var templateElement = document.createElement('template');
      //    templateElement.innerHTML = strTemplate;
  
      //    var arrCell = xtag.query(templateElement.content, 'gs-cell');
      //    var i = fromColumn;
      //    var len = toColumn;
      //    var strCells = '';
  
      //    while (i < len) {
      //        strCells += arrCell[i].outerHTML;
      //        i += 1;
      //    }
  
      //    return strCells;
      //}
  
      // because we only render what is visible on the screen, we use this
      //      function to take a template string and extract only the columns that
      //      will be visible
      // since we've added the ability to hide columns, we need a template
      //      cell extractor that's aware of visibility.
      function templateExtractVisibleCellRange(
          element,
          strTemplate,
          fromColumn,
          toColumn
      ) {
          var jsnRange;
  
          // if no from and to column have been provided, extract whole visible
          //      range
          if (fromColumn === undefined || toColumn === undefined) {
              jsnRange = element.internalDisplay.currentRange;
              fromColumn = jsnRange.fromColumn;
              toColumn = jsnRange.toColumn;
          }
  
          var templateElement = document.createElement('template');
          templateElement.innerHTML = strTemplate;
  
          var arrCell = xtag.query(templateElement.content, 'gs-cell');
          var i = fromColumn;
          var len = toColumn;
          var strCells = '';
          var arrColumnWidths = element.internalDisplay.columnWidths;
  
          while (i < len) {
              if (arrColumnWidths[i] > 0) {
                  strCells += arrCell[i].outerHTML;
              }
              i += 1;
          }
  
          return strCells;
      }
  
  
      // we need to be able to provide column headings when the user copies some
      //      data, so here we take a template element and we get the text of
      //      every cell and save it for that purpose
      function templateDetermineCopyHeaderList(element, templateElement) {
          var arrHeading = [];
          var arrCell = xtag.query(templateElement.content, 'gs-cell');
          var i = 0;
          var len = arrCell.length;
          var bolHeaderFound = false;
          var strHeading;
  
          while (i < len) {
              strHeading = arrCell[i].getAttribute('header') || '';
              arrHeading.push(strHeading);
  
              //console.log('cell: ', arrCell[i]);
  
              // we want to warn if the copy template has no "header" attributes
              //      so, if one of the cells has a "header" attribute: we'll
              //      prevent the warning code by setting "bolHeaderFound"
              if (arrCell[i].hasAttribute('header')) {
                  bolHeaderFound = true;
              }
  
              i += 1;
          }
  
          //console.log('bolHeaderFound: ', bolHeaderFound);
          //console.log('copy-header:    ', element.getAttribute('copy-header'));
  
          // if no "header" attributes were found (and the "copy-header"
          //      attribute doesn't equal "never"), we want to warn the developer
          //      that when a user copies: they wont have any headers because
          //      none were defined
          if (
              !bolHeaderFound &&
              element.getAttribute('copy-header') !== 'Never'
          ) {
              console.warn('GS-TABLE Warning: No headers found in "copy" ' +
                      'template. Please define headers for the copy by using ' +
                      'the "header" attribute on the gs-cell elements of the ' +
                      '"copy" template. If no headers are defined: when a ' +
                      'user copies they will not get any headers. To dismiss ' +
                      'this warning and prevent users from copying the ' +
                      'header: set the "copy-header" attribute to "never."');
          }
  
          element.internalClip.headerList = arrHeading;
      }
  
      // we need to know what data column is used for each column, so here we
      //      take the record template and find out what column is associated
      //      with what column
      function templateDetermineCopyColumnList(element, templateElement) {
          var arrColumn = [];
          var arrCell = xtag.query(templateElement.content, 'gs-cell');
          var i = 0;
          var len = arrCell.length;
  
          //var strColumn;
          //var cell;
          //var strCell;
          //var columnElement;
          //var arrMatch;
  
          while (i < len) {
              arrColumn.push(arrCell[i].textContent);
  
              //// we clear out this variable so that if we don't find a column
              ////      name, we'll just add empty string to the column list
              //strColumn = '';
  
              //// we save the cell element to a variable for easy access
              //cell = arrCell[i];
  
              //// we'll look for:
              ////      "{{! rowSOMETHINGHERE }}" or "{{= rowSOMETHINGHERE }}" or
              ////      the first element with the "column" attribute
              ////      if we've found one a doT.js statement, we'll trim off the
              ////      braces, "!", "=" and "row" and we'll be left with either
              ////      "['columnname']" or ".columnname"
              ////      if we've found an element with the "column" attribute,
              ////      we'll use it straight as-is
              //columnElement = xtag.query(cell, '[column]')[0];
  
              //if (cell.hasAttribute('copy-column')) {
              //    strColumn = cell.getAttribute('copy-column') || '';
              //} else if (columnElement) {
              //    strColumn = columnElement.getAttribute('column') || '';
              //}
              ////else {
              ////    strCell = cell.innerHTML;
              ////    arrMatch = strCell.match(/\{\{(!|=)\s*row.*\}\}/g);
              ////    if (arrMatch) {
              ////        strCell = arrMatch[0];
              ////        strCell = strCell
              ////                    // removes "{{="
              ////                    // removes "}}"
              ////                    // removes two columns matched together
              ////                    .substring(3, strCell.indexOf('}}'))
              ////                    // removes extra whitespace
              ////                    .trim();
              ////
              ////        //console.log(strCell);
              ////        //console.log(arrMatch);
              ////        //console.log('########################');
              ////    } else {
              ////
              ////    }
              ////}
              //arrColumn.push(strColumn);
              i += 1;
          }
  
          element.internalClip.columnList = arrColumn;
      }
  
      // sometimes, we want to get a list of column names that are used in a
      //      template
      function templateGetColumnList(templateElement) {
          var arrColumn = [];
          var arrElement = xtag.query(templateElement.content, '[column]');
          var i = 0;
          var len = arrElement.length;
          var strColumn;
  
          while (i < len) {
              strColumn = arrElement[i].getAttribute('column');
  
              // if there is a column name in the "column" attribute and the
              //      column isn't already in the list of columns we've found:
              //      add it to the array
              if (strColumn && arrColumn.indexOf(strColumn) === -1) {
                  arrColumn.push(strColumn);
              }
              i += 1;
          }
  
          return arrColumn;
      }
  
      // the user needs to be able to set a custom websocket for this element,
      //      so this function will use an attribute to find out what socket to
      //      use (and it'll default to "GS.envSocket")
      function getSocket(element) {
          if (element.getAttribute('socket')) {
              return GS[element.getAttribute('socket')];
          }
          return GS.envSocket;
      }
  
      // we need to be able to replace all occurences of a dynamic string with
      //      another dynamic string, and because javascript's .replace()
      //      function only replaces the first occurence (unless you send a
      //      regex), we use this function which takes the string to replace and
      //      creates a regex from it (escaping all regex special characters)
      //      then uses javascript's .replace()
      function stringReplaceAll(str, find, replace) {
          return str.replace(
              new RegExp(
                  find.replace(
                      /([\.\*\+\?\^\=\!\:\$\{\}\(\)\|\[\]\/\\])/g,
                      '\\$1'
                  ),
                  'g'
              ),
              replace
          );
      }
  
      // both render partial and render full need to know the visible range
      //      of cells so this function serves them both, it returns the
      //      from/to column/record numbers and the origin top/left point
      function getCurrentCellRange(element) {
          var scrollTop;
          var scrollLeft;
          var arrColumnWidths;
          //var arrColumnBorders;
          var arrRecordHeights;
          var columnBorderWidth;
          var recordBorderHeight;
  
          var fromColumn;
          var toColumn;
          var fromRecord;
          var toRecord;
  
          var i;
          var len;
          var intTemp;
          var intPrev;
  
          var intViewportWidth;
          var intViewportHeight;
          var intCellOriginLeft;
          var intRecordOriginTop;
  
          var bolRecordSelector;
          var bolInsertRecord;
          var bolHeaderRecord;
          var bolRenderAllColumns;
  
          // we need the viewport dimensions because we need to include the
          //      viewport when choosing what cells to show
          intViewportWidth = element.elems.dataViewport.clientWidth;
          intViewportHeight = element.elems.dataViewport.clientHeight;
  
          // save column widths and record heights for easy access
          arrColumnWidths = element.internalDisplay.columnWidths;
          arrRecordHeights = element.internalDisplay.recordHeights;
  
          // we needs the border dimensions to calculate true locations
          columnBorderWidth = element.internalDisplay.columnBorderWidth;
          recordBorderHeight = element.internalDisplay.recordBorderHeight;
  
          // save scroll location and dimensions for easy access
          scrollTop = element.internalScroll.top;
          scrollLeft = element.internalScroll.left;
  
          // the developer can choose to not render hidden columns, this limits
          //      some small bits of functionality (the only example I can think
          //      of is selecting all the columns and double clicking to resize.
          //      when some of the columns are not rendered, they don't get
          //      affected by the resize.). This choice affects scrolling
          //      calculations so we need to find out what the developer wants.
          bolRenderAllColumns = !element.hasAttribute('skip-hidden-columns');
  
          // commented out because we are now going to allow overscrolling,
          //      eventually, it's possible we'll make overscrolling an option
          //      if that happens, we'll want this code back
          //// if we are scrolled all the way to the bottom and there is scroll
          ////      room, we don't want to show the bottom border of the last
          ////      cells, so we'll move the scroll up by the border size
          //if (
          //    scrollTop === element.internalScroll.maxTop &&
          //    element.internalScroll.maxTop > 0
          //) {
          //    scrollTop -= recordBorderHeight;
          //}
  
          // remove some width and height from the viewport because some of it
          //      will be covered by the header, insert and selector cells
          intViewportHeight -= (
              element.internalScrollOffsets.top +
              element.internalScrollOffsets.bottom
          );
          intViewportWidth -= (
              element.internalScrollOffsets.left +
              element.internalScrollOffsets.right
          );
  
          i = 0;
          len = arrColumnWidths.length;
          intTemp = 0;
          intCellOriginLeft = 0;
          while (i < len) {
              // when the column width is zero, it's hidden, so don't factor
              //      it into the calculations
              if (arrColumnWidths[i] > 0) {
                  intPrev = intTemp;
                  intTemp += arrColumnWidths[i];
                  intTemp += columnBorderWidth;
              }
  
              if (fromColumn === undefined && intTemp > scrollLeft) {
                  fromColumn = i;
                  if (bolRenderAllColumns) {
                      intCellOriginLeft = -intPrev;
                  } else {
                      intCellOriginLeft = (intCellOriginLeft - scrollLeft);
                  }
              }
              if (
                  toColumn === undefined &&
                  intTemp > (scrollLeft + intViewportWidth)
              ) {
                  toColumn = i;
                  break;
              }
              if (fromColumn === undefined && bolRenderAllColumns) {
                  intCellOriginLeft = intTemp;
              }
              i += 1;
          }
          fromColumn = Math.max(0, (fromColumn || 0));
          toColumn = (toColumn || i) + 1;
  
          intCellOriginLeft = intCellOriginLeft || 0;
  
          if (toColumn > arrColumnWidths.length) {
              toColumn = arrColumnWidths.length;
          }
  
          // At first, we forced hidden columns to not be rendered. Normally,
          //      we want all columns rendered, even if not every single one
          //      is visible. This allows us to commit operations on hidden
          //      columns. But, sometimes, speed is more important. So, we
          //      have an attribute to make it so that hidden columns are not
          //      rendered.
          if (bolRenderAllColumns) {
              fromColumn = 0;
              toColumn = arrColumnWidths.length;
          }
  
          //console.log(intCellOriginLeft);
          //console.log('columns: ', fromColumn, toColumn);
  
          // figure out start/end records
          i = 0;
          len = arrRecordHeights.length;
          intTemp = 0;
          intRecordOriginTop = 0;
          while (i < len) {
              intTemp += arrRecordHeights[i];
              intTemp += recordBorderHeight;
  
              if (fromRecord === undefined && intTemp > scrollTop) {
                  fromRecord = i;
                  intRecordOriginTop = (intRecordOriginTop - scrollTop);
              }
              if (
                  toRecord === undefined &&
                  intTemp > (scrollTop + intViewportHeight)
              ) {
                  toRecord = i;
                  break;
              }
              if (fromRecord === undefined) {
                  intRecordOriginTop = intTemp;
              }
              i += 1;
          }
          toRecord = ((toRecord || i) + 1);
          intRecordOriginTop = (intRecordOriginTop || 0);
  
          //console.log(
          //    toRecord,
          //    arrRecordHeights.length,
          //    element.internalDisplay.insertRecordVisible,
          //    element.internalDisplay.insertRecordStick,
          //    fromRecord
          //);
  
          bolInsertRecord = false;
          if (toRecord > arrRecordHeights.length) {
              bolInsertRecord = (
                  element.internalDisplay.insertRecordVisible &&
                  element.internalDisplay.insertRecordStick === null
              );
  
              if (
                  element.internalDisplay.insertRecordVisible &&
                  element.internalDisplay.insertRecordStick === null &&
                  fromRecord === undefined
              ) {
                  toRecord = (arrRecordHeights.length + 1);
                  fromRecord = toRecord;
              } else {
                  toRecord = arrRecordHeights.length;
              }
          }
  
          fromRecord = Math.max(0, (fromRecord || 0));
  
          // right now, the gs-table assumes that the header is always
          //      affixed to the top side of the viewport.
          bolHeaderRecord = element.internalDisplay.headerVisible;
  
          // right now, the gs-table assumes that the record selectors are
          //      always affixed to the left side of the viewport.
          bolRecordSelector = element.internalDisplay.recordSelectorVisible;
  
          // because we scroll by forcing the leftmost column to stick to the
          //      left side, there is a discrepancy between the scroll and what
          //      the user sees that the scroll is, we need a variable to store
          //      what the user sees for the scroll
          element.internalScroll.displayTop = (
              scrollTop + intRecordOriginTop
          );
          element.internalScroll.displayLeft = (
              scrollLeft + intCellOriginLeft
          );
  
          //console.log(
          //    element.internalScroll.displayTop,
          //    scrollTop,
          //    intRecordOriginTop
          //);
          //console.log(
          //    element.internalScroll.displayLeft,
          //    scrollLeft,
          //    intCellOriginLeft
          //);
  
          // offset the record/cell origins by the amount that the header cells
          //      and record selectors offset the viewport
          if (bolRenderAllColumns) {
              intCellOriginLeft += element.internalScrollOffsets.left;
          } else {
              intCellOriginLeft = element.internalScrollOffsets.left;
          }
          intRecordOriginTop = element.internalScrollOffsets.top;
  
          // commented out and replaced by the two lines above, these two lines
          //      make scrolling smooth, the two lines above make the scrolling
          //      resolve to the top of the top record and the left of the
          //      leftmost column
          //intCellOriginLeft += element.internalScrollOffsets.left;
          //intRecordOriginTop += element.internalScrollOffsets.top;
  
          //console.log('element: ', element);
          //console.log('intRecordOriginTop: ', intRecordOriginTop);
          //console.log('intCellOriginLeft: ', intCellOriginLeft);
          //console.log('fromRecord: ', fromRecord);
          //console.log('fromColumn: ', fromColumn);
          //console.log('toRecord: ', toRecord);
          //console.log('toColumn: ', toColumn);
  
          return {
              "originTop": intRecordOriginTop,
              "originLeft": intCellOriginLeft,
  
              "fromRecord": fromRecord,
              "fromColumn": fromColumn,
              "toRecord": toRecord,
              "toColumn": toColumn,
  
              "headerRecord": bolHeaderRecord,
              "recordSelector": bolRecordSelector,
              "insertRecord": bolInsertRecord
          };
      }
  
      // in the case of header->line relationships, we need to be able to
      //      silently add in values to form the header->line link, so, here
      //      we generate the values for the link
      function getInsertAddin(element) {
          var jsnRet = {};
  
          if (element.getAttribute('column') || element.getAttribute('qs')) {
              jsnRet.link_column = (
                  element.getAttribute('child-column') ||
                  element.getAttribute('column') ||
                  element.getAttribute('qs')
              );
              jsnRet.link_value = element.value;
          }
  
          return jsnRet;
      }
  
      function delimitedStringToHTML(
          element,
          valueText,
          fieldDelimiter,
          recordDelimiter,
          quoteChar,
          decodeFunction
      ) {
          var i = 0;
          var len = valueText.length;
          var col_i;
          var col_len;
  
          var arrRecords = [];
          var arrRecord = [];
  
          var bolInQuote = false;
          var strCell = '';
          var strRecord;
          var strHTML = '';
          var strPreviousChar;
          var strChar;
          var strNullString;
  
          // we want the null string to be configurable, so we'll read the
          //      "null-string" attribute to get the null string
          // if the "null-string" attribute is present, use the contents
          //      or coalesce to empty string
          if (element.hasAttribute('null-string')) {
              strNullString = element.getAttribute('null-string') || '';
  
          // else, null string is left up to the encoding function
          } else {
              strNullString = undefined;
          }
  
          // sometimes, there is an extra delimiter at the beginning of the first
          //      record. if there is: skip over it.
          if (valueText[0] === recordDelimiter) {
              i += 1;
          }
  
          // make sure there is a recordDelimiter at the end
          if (valueText[len - 1] !== recordDelimiter) {
              valueText += recordDelimiter;
              len = valueText.length;
          }
  
          // looper
          while (i < len) {
              strChar = valueText[i];
              if (
                  strChar === quoteChar &&
                  bolInQuote === false &&
                  (
                      strPreviousChar === fieldDelimiter ||
                      strPreviousChar === recordDelimiter ||
                      strPreviousChar === undefined
                  )
              ) {
                  bolInQuote = true;
  
              } else if (strChar === quoteChar && bolInQuote === true) {
                  bolInQuote = false;
  
              } else if (strChar === fieldDelimiter && bolInQuote === false) {
                  arrRecord.push(decodeFunction(strCell, strNullString));
                  strCell = '';
  
              } else if (strChar === recordDelimiter && bolInQuote === false) {
                  arrRecord.push(decodeFunction(strCell, strNullString));
                  strCell = '';
  
                  arrRecords.push(arrRecord);
                  arrRecord = [];
  
              } else {
                  strCell += strChar;
              }
  
              strPreviousChar = strChar;
              i += 1;
          }
  
          // data structure to html
          i = 0;
          len = arrRecords.length;
          while (i < len) {
              strRecord = '';
              col_i = 0;
              col_len = arrRecords[i].length;
              while (col_i < col_len) {
                  strRecord += (
                      '<td>' +
                          encodeHTML(arrRecords[i][col_i]) +
                      '</td>'
                  );
                  col_i += 1;
              }
  
              strHTML += '<tr>' + strRecord + '</tr>';
              i += 1;
          }
  
          return '<table>' + strHTML + '</table>';
      }
  
      // sometimes we need to have the selection object, but we don't want it to
      //      change when the selection of the table changes (and vice versa). one
      //      occurance of this is when we are about to update the selection,
      //      we'll copy the selection so that we have a backup and then we'll
      //      update the selection and then we trigger a "before_selection" event.
      //      if the "before_selection" event get's prevented than we'll revert
      //      to a copy.
      function getSelectionCopy(element) {
          var jsnOriginal;
          var jsnCopy;
          var jsnRange;
          var i;
          var len;
  
          jsnOriginal = element.internalSelection;
  
          jsnCopy = {
              "ranges": [],
              "insertRecord": jsnOriginal.insertRecord
          };
  
          // hold on a minute there, why can we just use .slice(0) on the
          //      selection range array?
          // well, my young grasshopper, .slice(0) does work for copying arrays.
          //      however, our selection ranges are stored as JSON objects and
          //      JSON objects within an array will not be copied, the copy array
          //      and the original array will both reference the same JSON object
          //      in memory. so, if I copied the selection range array using
          //      .slice(0) and then altered one of the range objects, the
          //      original would show the same changes. so, using .slice(0) would
          //      make this function useless if you're trying to back up the
          //      selection ranges.
          i = 0;
          len = jsnOriginal.ranges.length;
          while (i < len) {
              jsnRange = jsnOriginal.ranges[i];
  
              jsnCopy.ranges.push({
                  "start": {
                      "row": jsnRange.start.row,
                      "column": jsnRange.start.column
                  },
                  "end": {
                      "row": jsnRange.end.row,
                      "column": jsnRange.end.column
                  }
              });
              i += 1;
          }
  
          return jsnCopy;
      }
  
      // sometimes, we need to get the value of a cell. this function returns a
      //      cell in it's unencoded state
      function getCell(
          element,
          strColumn,
          intRow,
          bolDecode,
          strNullStringOverride
      ) {
          var strRecord;
          var rec_i;
          var rec_len;
          var strChar;
          var strCell;
          var strNullString;
  
          var intCurrentColumn;
          var intTargetColumn;
  
          // we need to know the index of the target column
          intTargetColumn = (
              element.internalData.columnNames.indexOf(strColumn)
          );
  
          // we'll iterate through each char until we get the text for the cell
          //      at the correct index
          strRecord = element.internalData.records[intRow];
          intCurrentColumn = 0;
          strCell = '';
          rec_i = 0;
          rec_len = strRecord.length;
          while (rec_i < rec_len) {
              strChar = strRecord[rec_i];
  
              // if the current character is not a tab: add it to the current
              //      cell variable
              if (strChar !== '\t') {
                  strCell += strChar;
              }
  
              // if the current character is a tab or we are at the end of the
              //      record: handle current cell
              if (
                  strChar === '\t' ||
                  rec_i === (rec_len - 1)
              ) {
                  // advance column number
                  intCurrentColumn += 1;
  
                  // if we've reached the start of the column after the desired
                  //      column, stop the loop
                  if (intCurrentColumn === (intTargetColumn + 1)) {
                      break;
                  }
  
                  // clear cell variable
                  strCell = '';
              }
  
              rec_i += 1;
          }
  
          //console.log('RECORD:', strRecord);
          //console.log('COLUMN:', strColumn);
          //console.log('CELL:', strCell);
          //console.log('NULLSTRING:', strNullString);
          //console.log(
          //    'DECODED:',
          //    GS.decodeFromTabDelimited(strCell, strNullString)
          //);
  
          if (bolDecode !== false) {
              // we want the null string to be configurable, so we'll read the
              //      "null-string" attribute to get the null string
              // if the "null-string" attribute is present, use the contents
              //      or coalesce to empty string
              if (strNullStringOverride !== undefined) {
                  strNullString = strNullStringOverride;
  
              } else if (element.hasAttribute('null-string')) {
                  strNullString = element.getAttribute('null-string') || '';
  
              // else, null string is left up to the encoding function
              } else {
                  strNullString = undefined;
              }
  
              return GS.decodeFromTabDelimited(strCell, strNullString);
          }
  
          return strCell;
      }
  
      function getConnectedSelectedColumns(element, intStartColumn) {
          var arrCurrentColumns;
          var arrSelection;
          var i;
  
          // get selected column list
          arrSelection = (
              element.internalSelection.columns
          );
  
          // clear current columns array so that we can start fresh
          arrCurrentColumns = [];
  
          // loop forwards until we run into a column that is not
          //      selected, each sequential column that is in the
          //      selected column list will be added to the current
          //      list
          i = intStartColumn;
          //console.log('forward start', i);
          while (i < 9999) {
              //console.log('forward', i, arrSelection.indexOf(i));
              if (arrSelection.indexOf(i) > -1) {
                  arrCurrentColumns.push(i);
              } else {
                  break;
              }
              i += 1;
          }
  
          // loop backwards until we run into a column that is not
          //      selected, each sequential column that is in the
          //      selected column list will be added to the current
          //      list
          i = (intStartColumn - 1);
          //console.log('backward start', i);
          while (i >= 0) {
              //console.log('backward', i, arrSelection.indexOf(i));
              if (arrSelection.indexOf(i) > -1) {
                  arrCurrentColumns.push(i);
              } else {
                  break;
              }
              i -= 1;
          }
  
          // we need to sort the column number list. this is because
          //      of how we find all of the column numbers to reorder
          arrCurrentColumns.sort();
  
          // ask and you shall receive
          return arrCurrentColumns;
      }
  
      // in partial and full rerender, we need to set the button icons
      //      and the tooltips of the header cells
      function handleHeaderTemplateTokens(
          element,
          strTemplate,
          fromColumn,
          toColumn
      ) {
          var col_i;
          var col_len;
          var filter_i;
          var filter_len;
  
          var columnIndex;
          var strDataColumn;
          var strTitle;
          var strClass;
  
          var arrColumnWidths;
          var arrColumnOrders;
          var arrColumnFilters;
  
          //console.log('1***', strTemplate);
  
          // save the order lists for easy access
          arrColumnOrders = element.internalData.columnOrders;
  
          // save the filter lists for easy access
          arrColumnFilters = element.internalData.columnFilters;
  
          // save column widths for easy access
          arrColumnWidths = element.internalDisplay.columnWidths;
  
          col_i = fromColumn;
          col_len = toColumn;
          while (col_i < col_len) {
              // if the column is not hidden
              if (arrColumnWidths[col_i] > 0) {
                  strDataColumn = (
                      element.internalDisplay.dataColumnName[
                          col_i
                      ]
                  );
  
                  columnIndex = (
                      element.internalData.columnNames.indexOf(
                          strDataColumn
                      )
                  );
  
                  strClass = '';
                  if (arrColumnOrders[columnIndex] !== 'neutral') {
                      strClass += (
                          ' sort-' +
                          arrColumnOrders[columnIndex]
                      );
                  }
                  if (
                      arrColumnFilters[columnIndex] &&
                      arrColumnFilters[columnIndex].length > 0
                  ) {
                      strClass += ' filtered';
                  }
                  strTemplate = strTemplate.replace(
                      '$$HDRBTNCLASS_' + strDataColumn + '$$',
                      strClass
                  );
  
                  // we need to calculate the title attribute for this
                  //      header cell
                  strTitle = '';
  
                  if (arrColumnFilters[columnIndex]) {
                      filter_i = 0;
                      filter_len = arrColumnFilters[columnIndex].length;
                      while (filter_i < filter_len) {
                          strTitle += (
                              strTitle
                                  ? ' '
                                  : ''
                          );
                          strTitle += (
                              arrColumnFilters[columnIndex][filter_i].name
                          );
  
                          filter_i += 1;
                      }
                  }
  
                  // sort in title attribute
                  if (arrColumnOrders[columnIndex] === 'desc') {
                      strTitle += (
                          strTitle
                              ? ' '
                              : ''
                      );
                      strTitle += 'sorted descending';
  
                  } else if (arrColumnOrders[columnIndex] === 'asc') {
                      strTitle += (
                          strTitle
                              ? ' '
                              : ''
                      );
                      strTitle += 'sorted ascending';
                  }
  
                  // replace title token
                  strTemplate = strTemplate.replace(
                      '$$HDR_TITLE_' + strDataColumn + '$$',
                      encodeHTML(strTitle)
                  );
              }
              col_i += 1;
          }
  
          //console.log('2***', strTemplate);
  
          return strTemplate;
      }
  
      // in multiple places we need to turn a direction string into useful
      //      booleans and a resolved direction string
      function directionStringBreakdown(strDirectionString) {
          var bolTop;
          var bolLeft;
          var bolBottom;
          var bolRight;
  
          // prevent uppercase characters
          strDirectionString = strDirectionString.toLowerCase();
  
          // multiple scroll directions could be sent, we need to parse and
          //      resolve the value to something consistent
          bolTop = (strDirectionString.indexOf('top') !== -1);
          bolLeft = (strDirectionString.indexOf('left') !== -1);
          bolBottom = (strDirectionString.indexOf('bottom') !== -1);
          bolRight = (strDirectionString.indexOf('right') !== -1);
  
          // warn if two scroll directions are contradictory
          if (bolTop && bolBottom) {
              console.warn('GS-TABLE Warning: Contradictory parameter sent' +
                      ' to directionStringBreakdown.' +
                      ' "Down" direction will be cancelled.' +
                      ' Parameter Text: "' + strDirectionString + '"');
              bolBottom = false;
          }
          if (bolLeft && bolRight) {
              console.warn('GS-TABLE Warning: Contradictory parameter sent' +
                      ' to directionStringBreakdown.' +
                      ' the left and the right at the same time.' +
                      ' "Right" direction will be cancelled.' +
                      ' Parameter Text: "' + strDirectionString + '"');
              bolRight = false;
          }
  
          // build up consistent scroll direction string
          strDirectionString = '';
          if (bolTop) {
              strDirectionString += 'top';
          }
          if (bolLeft) {
              strDirectionString += 'left';
          }
          if (bolBottom) {
              strDirectionString += 'bottom';
          }
          if (bolRight) {
              strDirectionString += 'right';
          }
  
          return {
              "bolTop": bolTop,
              "bolLeft": bolLeft,
              "bolBottom": bolBottom,
              "bolRight": bolRight,
              "resolvedString": strDirectionString
          };
      }
  
      // there are multiple times where we need to find a specific HUD element.
      //      Any HUD element is allowed to be in either the top or bottom HUD
      //      bar. this function looks for elements by class because HUD elements
      //      are identified by classes. this function will check both the top and
      //      bottom HUD bars.
      // in the future, we want to allow multiple buttons with the same class (for
      //      example, the developer may want a refresh button at the top and at
      //      the bottom).
      // ### NEED CODING ###
      function findHudElement(element, strClass) {
          var hudElement;
  
          // first, we'll try to find it in the bottom HUD
          hudElement = xtag.query(
              element.elems.bottomHudContainer,
              '.' + strClass
          )[0];
  
          // if we couldn't find the element in the bottom HUD,
          //      we'll try the top HUD
          if (!hudElement) {
              hudElement = xtag.query(
                  element.elems.topHudContainer,
                  '.' + strClass
              )[0];
          }
  
          // return whatever we found
          return hudElement;
      }
  
      // in multiple places, we care what data columns selected
      function getSelectedDataColumns(element) {
          var arrSelectedColumns;
          var arrDataColumns;
          var i;
          var len;
          var index;
  
          // we need an array of the selected data columns
          arrSelectedColumns = (
              element.internalSelection.columns
          );
          arrDataColumns = [];
          i = 0;
          len = arrSelectedColumns.length;
          while (i < len) {
              index = arrSelectedColumns[i];
              if (element.internalDisplay.dataColumnName[index]) {
                  arrDataColumns.push(
                      element.internalData.columnNames.indexOf(
                          element.internalDisplay.dataColumnName[index]
                      )
                  );
              }
  
              i += 1;
          }
  
          return arrDataColumns;
      }
  
      // we want the proper event to bubble up when the hidden focus control is
      //      focused. in order to do this, we've moved that code into this
      //      function so that we don't have to repeat it
      function focusHiddenControl(element) {
          element.elems.hiddenFocusControl.focus();
          GS.triggerEvent(element.elems.hiddenFocusControl, 'focus');
      }
  
  
      // sometimes, we need to know what cell the mouse is over
      function getCellFromMouseEvent(element, event) {
          var jsnMousePos;
          var jsnElementPos;
          var intMouseX;
          var intMouseY;
          var row;
          var column;
          var jsnRange;
          var arrColumnWidths;
          var arrRecordHeights;
          var i;
          var len;
          var intLeft;
          var intTop;
          var intColBorderWidth;
          var intRowBorderHeight;
          var intRowSelectorWidth;
          var intHeaderHeight;
          //var intInsertRecordHeight;
          var bolHeader;
          var bolInsertRecord;
          var bolRecordSelector;
  
          // gather display variables
          jsnRange = element.internalDisplay.currentRange;
  
          bolHeader = element.internalDisplay.headerVisible;
          bolInsertRecord = (
              element.internalDisplay.insertRecordVisible &&
              jsnRange.insertRecord
          );
          bolRecordSelector = element.internalDisplay.recordSelectorVisible;
  
          arrColumnWidths = element.internalDisplay.columnWidths;
          arrRecordHeights = element.internalDisplay.recordHeights;
          intColBorderWidth = element.internalDisplay.columnBorderWidth;
          intRowBorderHeight = element.internalDisplay.recordBorderHeight;
          intRowSelectorWidth = (
              bolRecordSelector
                  ? (
                      element.internalDisplay.recordSelectorWidth +
                      element.internalDisplay.recordSelectorBorderWidth
                  )
                  : 0
          );
          intHeaderHeight = (
              bolHeader
                  ? (
                      element.internalDisplay.headerHeight +
                      element.internalDisplay.headerBorderHeight
                  )
                  : 0
          );
          //intInsertRecordHeight = (
          //    bolInsertRecord
          //        ? (
          //            element.internalDisplay.insertRecordHeight +
          //            element.internalDisplay.insertRecordBorderWidth
          //        )
          //        : 0
          //);
  
          // we need the mouse position and the element position
          jsnMousePos = GS.mousePosition(event);
          jsnElementPos = GS.getElementOffset(
              element.elems.dataViewport
          );
  
          // we need the mouse X to be relative to the dataViewport
          intMouseX = (jsnMousePos.left - jsnElementPos.left);
  
          // we need the mouse Y to be relative to the dataViewport
          intMouseY = (jsnMousePos.top - jsnElementPos.top);
  
          // get column. careful, it could be the record selector
  
          // if record selector is visible and the mouse is above it
          if (bolRecordSelector && intMouseX <= intRowSelectorWidth) {
              column = 'selector';
  
          } else {
              intLeft = jsnRange.originLeft;//intRowSelectorWidth;
              i = jsnRange.fromColumn;
              len = jsnRange.toColumn;
              while (i < len) {
                  if (intMouseX >= intLeft) {
                      column = i;
                  } else {
                      break;
                  }
  
                  intLeft += arrColumnWidths[i];
                  intLeft += intColBorderWidth;
                  i += 1;
              }
          }
  
          // get record. careful, it could be the header or the insert record
  
          // if header is visible
          if (
              bolHeader &&
              intMouseY <= intHeaderHeight
          ) {
              row = 'header';
  
          } else {
              intTop = intHeaderHeight;
              i = jsnRange.fromRecord;
              len = jsnRange.toRecord;
              while (i < len) {
                  if (intMouseY >= intTop) {
                      row = i;
                  } else {
                      break;
                  }
  
                  intTop += arrRecordHeights[i];
                  intTop += intRowBorderHeight;
                  i += 1;
              }
  
              if (bolInsertRecord && intMouseY >= intTop) {
                  row = 'insert';
              }
          }
  
          //console.log(intMouseX, intMouseY, row, column);
  
          return {
              "row": row,
              "column": column
          };
      }
  
      // we need a way to compare the selection ranges, this function turns a
      //      selection range array into a string
      function selectionArrayToString(arr) {
          var i;
          var len;
          var strString;
          var jsnRange;
  
          strString = '';
          i = 0;
          len = arr.length;
          while (i < len) {
              jsnRange = arr[i];
              strString += (
                  (
                      jsnRange.negator
                          ? 't'
                          : 'f'
                  ) +
                  String(jsnRange.start.column) +
                  String(jsnRange.start.row) +
                  String(jsnRange.end.column) +
                  String(jsnRange.end.row)
              );
  
              i += 1;
          }
  
          return strString;
      }
  
      // Thanks SO User "Cambium"!
      function roundToNearestMultiple(intNum, intDivisor) {
          if (intNum > 0) {
              return Math.ceil(intNum / intDivisor) * intDivisor;
          }
          if (intNum < 0) {
              return Math.floor(intNum / intDivisor) * intDivisor;
          }
  
          return intDivisor;
      }
  
  
  // #############################################################################
  // ############################# ELEMENT FUNCTIONS #############################
  // #############################################################################
  
      // this section deals with the generation of the gs-table's non-cell HTML
  
      // some attributes can't be used in their normal, dev-friendly format,
      //      this function translates those attributes to their final formats
      // some attributes need to be defaulted, even if they're not present
      function resolveElementAttributes(element) {
          var arrParts;
  
          // GS-TABLE elements that are connected to Envelope need to have "pk"
          //      and "lock" attributes
          if (element.getAttribute('src')) {
              // split "src" into "schema" and "object" attributes
              arrParts = GS.templateWithQuerystring(
                  element.getAttribute('src')
              ).split('.');
  
              // I don't know who added this. I don't inderstand why someone
              //      would put something like "biz.bar.foo" in the "src"
              //      attribute. That's the case that this code handles. If
              //      you added this code: PUT A COMMENT!!!! We have comments
              //      for a reason. Don't ruin this beautiful code. Only YOU
              //      can prevent spaghetti code.
              //  ~Michael
              // It appears to be a solution to quote idented object names that
              //      contain a period like this: test."test.asdf"
              //      The problem with this solution (other than being unclear)
              //      is that it wont work for schema names that contain a period.
              //      We need a better solution for this. Perhaps it's time to
              //      create a function that understands ident quoted names for
              //      real, using actual parsing.
              //  ~Also Michael
              if (arrParts[2]) {
                  arrParts[1] = arrParts[1] + '.' + arrParts[2];
              }
  
              // put the split sections of the object name into separate
              //      attributes
              element.setAttribute('schema', arrParts[0]);
              element.setAttribute('object', arrParts[1]);
  
              // default "pk" and "lock" attributes
              element.setAttribute(
                  'pk',
                  (element.getAttribute('pk') || 'id')
              );
              element.setAttribute(
                  'lock',
                  (element.getAttribute('lock') || 'change_stamp')
              );
          }
  
          // default null string attribute
          element.setAttribute(
              'null-string',
              (
                  element.getAttribute('null-string') ||
                  ''
              )
          );
      }
  
      // replace element HTML with the new HTML
      function prepareElement(element) {
          var rootElement;
          var i;
  
          // all gs-table elements must have an ID attribute
          if (!element.getAttribute('id')) {
              // loop through IDs using the ID sequence until we get to one
              //      that isn't used
              globalIDSeq += 1; // global to the gs-table x-tag definition scope
              i = 0;
              while (
                  i < 500 &&
                  document.getElementById('table-dynamic-id-' + globalIDSeq)
              ) {
                  globalIDSeq += 1;
                  i += 1;
              }
  
              element.setAttribute('id', 'table-dynamic-id-' + globalIDSeq);
  
              // warn the developer
              console.warn('GS-TABLE Warning: All gs-table elements must have' +
                      ' an ID. Adding dynamic ID:' +
                      ' "table-dynamic-id-' + globalIDSeq + '". Do not use' +
                      ' this ID for anything. Do not use it for HTML, CSS or' +
                      ' JS or anything else as it can change between page' +
                      ' loads.');
          }
  
          // the root is created as a variable so that we can append it to the
          //      gs-table without destrying the templates because the next step
          //      of this element's initalization is the "siphon" (where we
          //      extract the info out of the templates)
          rootElement = document.createElement('div');
          rootElement.classList.add('table-root');
          element.appendChild(rootElement);
  
          // create standard gs-table html
          rootElement.innerHTML =
                  // we need a container to hold the HUD, this container will be
                  //      absolutely positioned to the top of the gs-table
                  '<div class="table-hud-container hud-top"></div>' +
                  // we need a container to hold the viewport container and the
                  //      scrollbars
                  '<div class="table-table-container">' +
                  // we need a container for the viewport that will automatically
                  //      size the viewport correctly
                  '    <div class="table-data-container">' +
                  // we need a viewport that will hide anything that doesn't fit
                  //      and won't scroll. the scrolling will be handled by the
                  //      renderer.
                  '        <div class="table-data-viewport"></div>' +
                  '    </div>' +
                  '    <div class="table-v-scroll-bar-container">' +
                  '        <div class="table-v-scroll-bar">' +
                  '            <div class="table-scroll-causer"></div>' +
                  '        </div>' +
                  '    </div>' +
                  '    <div class="table-h-scroll-bar-container">' +
                  '        <div class="table-h-scroll-bar">' +
                  '            <div class="table-scroll-causer"></div>' +
                  '        </div>' +
                  '    </div>' +
                  '</div>' +
                  // we need a textarea that is hidden so that we can intercept
                  //      keyboard events even if none of the controls have been
                  //      focused into. one case where this occurs is when you
                  //      select a range of cells, when selecting a range you
                  //      don't want one of the cells to be focused, and yet, you
                  //      want to be able to press "delete" and delete the
                  //      records.
                  // we also need a dependable focus target for when we handle
                  //      copy/paste events.
                  // this control also need to be after the rest of the cells to
                  //      make tabbing out of the gs-table easier to code. to tab
                  //      out we'll just have to not prevent default
                  '<textarea class="hidden-focus-control"' +
                  '    value="text makes this textarea Firefox worthy">' +
                  '</textarea>' +
                  // we need a static container to hold our loader elements
                  '<div class="table-loader-container"></div>' +
                  // we need a place to hold an example of each type of cell so
                  //      that we can read their style dynamically without causing
                  //      a "Forced Reflow", this will be a speed benefit
                  '<div class="table-cell-test-container">' +
                  '    <gs-cell class="table-cell"></gs-cell>' +
                  '    <gs-cell class="table-header"></gs-cell>' +
                  '    <gs-cell class="table-insert"></gs-cell>' +
                  '    <gs-cell class="table-record-selector"></gs-cell>' +
                  '</div>' +
                  // we need a container to hold the HUD, this container will be
                  //      absolutely positioned to the bottom of the gs-table
                  '<div class="table-hud-container hud-bottom"></div>' +
                  // we need a style tag for dynamic CSS, MS Edge is slow when it
                  //      comes to changing style attributes for a bunch of cells,
                  //      we're going to try not using style attributes and
                  //      instead using a dynamic CSS style element
                  // if it doesn't speed up Edge we may still come up with a new
                  //      use for it so keep it around
                  '<style class="cell-position" style="display:none;"></style>' +
                  // we need to know when the font size changes so that we can
                  //      re-render. this element will always be 1em wide and 1em
                  //      tall. when this element changes pixel size, we'll know
                  //      that the font size has changed.
                  '<div class="table-font-size-detector"></div>';
  
          // we want to easily/quickly be able to get elements without
          //      using selectors
          element.elems = {};
  
          element.elems.root = rootElement;
  
          element.elems.topHudContainer = element.elems.root.children[0];
          element.elems.tableViewport = element.elems.root.children[1];
          element.elems.hiddenFocusControl = element.elems.root.children[2];
          element.elems.loaderContainer = element.elems.root.children[3];
          element.elems.cellTestContainer = element.elems.root.children[4];
          element.elems.bottomHudContainer = element.elems.root.children[5];
          element.elems.cellPositionStyle = element.elems.root.children[6];
          element.elems.fontSizeDetector = element.elems.root.children[7];
  
          element.elems.dataContainer =
                  element.elems.tableViewport.children[0];
          element.elems.yScrollContainer =
                  element.elems.tableViewport.children[1];
          element.elems.xScrollContainer =
                  element.elems.tableViewport.children[2];
  
          element.elems.dataViewport = element.elems.dataContainer.children[0];
  
          element.elems.yScrollBar = element.elems.yScrollContainer.children[0];
          element.elems.xScrollBar = element.elems.xScrollContainer.children[0];
          element.elems.yScrollBarCauser = element.elems.yScrollBar.children[0];
          element.elems.xScrollBarCauser = element.elems.xScrollBar.children[0];
  
          element.elems.testDataCell = (
              element.elems.cellTestContainer.children[0]
          );
          element.elems.testHeader = (
              element.elems.cellTestContainer.children[1]
          );
          element.elems.testInsert = (
              element.elems.cellTestContainer.children[2]
          );
          element.elems.testRecordSelector = (
              element.elems.cellTestContainer.children[3]
          );
  
          // because the resize handles aren't always in the DOM, we'll create
          //      them virtually and store them
          element.elems.handleColumn = document.createElement('div');
          element.elems.handleColumn.classList.add('resize-column-handle');
          element.elems.handleRecord = document.createElement('div');
          element.elems.handleRecord.classList.add('resize-record-handle');
  
          // because the reorder indicator isn't always in the DOM, we'll create
          //      it virtually and store them
          element.elems.handleReorder = document.createElement('div');
          element.elems.handleReorder.classList.add('reorder-column-handle');
  
          // sometimes, we want to open a dialog to a particular pixel instead
          //      of a particular element. so, we'll create an element what for
          //      putting it at a particular pixel an then just use the
          //      standard openDialogToElement function.
          element.elems.pixel = document.createElement('div');
          element.elems.pixel.classList.add('pixel-element');
          element.elems.root.appendChild(element.elems.pixel);
  
          // we want a place to look to for data
          element.internalData = {
              "records": [],
              "columnFilterStatuses": [],
              "columnFilters": [],
              "columnListFilters": [],
              "columnOrders": [],
              "columnNames": [],
              "columnTypes": [],
              "insertRecord": {},
              "insertRecordRetainedColumns": [],
              "bolFirstLoadFinished": false
          };
  
          // we need to be able to make room for fixed objects when scrolling
          //      (like the fixed headers), so we'll define these properties
          //      so that we have a single place to look for them
          element.internalScrollOffsets = {
              "top": 0,
              "bottom": 0,
              "left": 0,
              "right": 0
          };
  
          // we need a place to store event functions because, to unbind a
          //      specific event javascript requires that you have the
          //      original function that was bound to that event
          element.internalEvents = {
              "forceCopy": false
          };
  
          // some events are triggered by something that the gs-table does,
          //      so event code needs to have a place to look to see if
          //      it's been cancelled for one execution
          element.internalEventCancelled = {
              "scrollbarY": false,
              "scrollbarX": false
          };
  
          // we need to manually store the scroll location somewhere because
          //      scrollbars can only cover so much area before breaking
          element.internalScroll = {
              "top": 0,
              "left": 0,
              "maxTop": 0,
              "maxLeft": 0,
              "displayTop": 0,
              "displayLeft": 0,
              "prevTop": 0,
              "prevLeft": 0
          };
  
          // we need to manually store timer IDs so that we can do throttling
          element.internalTimerIDs = {
              "scrollIntervalID": null,
              "visibilityIntervalID": null
          };
  
          // we need a place to store our templates, so we'll create an
          //      element.internalTemplates JSON object and store each
          //      template under a unique name
          element.internalTemplates = {
              "topHUD": "",
              "bottomHUD": "",
              "header": "",
              "originalRecord": "",
              "record": {},
              "insertRecord": "",
              "insertDialog": "",
              "updateDialog": ""
          };
  
          // we need a place to store cell dimensions and other display
          //      related info
          // anything in here set to "undefined" is set that way because the dev
          //      may set it to 0 or [] and we need to be able to tell that it
          //      hasn't been set yet
          element.internalDisplay = {
              "columnPlainTextNames": [],
              "dataColumnName": [],
  
              "columnWidths": [],
              "minColumnWidths": [],
              "maxColumnWidth": 999,
  
              "recordHeights": [],
              "maxRecordHeight": 999,
  
              "columnHandles": [],
              "recordHandles": [],
  
              "currentRange": {},
              "prevRange": {},
  
              // not used yet, null will mean "doesn't stick".
              //      only "top", "bottom" and null allowed.
              "headerStick": "top",
  
              "headerVisible": false,
              "headerHeight": undefined,
              "headerBorderHeight": 0,
  
              // not used yet, null will mean "doesn't stick".
              //      only "left", "right" and null allowed.
              "selectorStick": "left",
  
              "recordSelectorVisible": false,
              "recordSelectorWidth": 0,
              "recordSelectorBorderWidth": 0,
  
              // only "top", "bottom" and null allowed.
              "insertRecordStick": null, //"bottom"
  
              "insertRecordVisible": false,
              "insertRecordHeight": undefined,
              "insertRecordBorderHeight": 0,
  
              "fullRenderRequired": true,
  
              "defaultColumnWidths": [],
              "defaultColumnWidth": 0,
              "defaultRecordHeight": 0,
              "defaultRecordSelectorWidth": 27,
              "defaultHeaderHeight": 27,
              "defaultInsertRecordHeight": 27,
  
              "focus": {
                  "column": null,
                  "row": null,
                  "nodeName": null,
                  "columnAttribute": null,
                  "latest": null,
                  "selectionRange": {}
              }
          };
  
          // we need to default the record selector width
          element.internalDisplay.recordSelectorWidth = (
              element.internalDisplay.defaultRecordSelectorWidth
          );
  
          // we need a place to store selection ranges
          element.internalSelection = {
              "ranges": [],
              "rangeCache": null,
              "insertRecord": false,
              "originRecord": null,
              "resolvedSelection": [],
              "columns": [],
              "rows": [],
              "currentlySelecting": false
          };
  
          // we need a place to store the parameters for copy
          element.internalClip = {
              "columnList": [],
              "headerList": []
          };
  
          // we need a place to store the web worker and it's
          //      associated data
          element.internalWorker = {
              "worker": "",
              "ready": false
          };
  
          // we need a place to store the loader data
          element.internalLoaders = {
              "loaderIDs": [],
              "loaderElements": []
          };
  
          // we need a place to store info for column resizing
          element.internalResize = {
              "currentlyResizing": false,
              "showThrottleID": null,
              "resizeStarted": false,
              "cellOriginX": 0,
              "cellOriginY": 0,
  
              "resizeColumn": false,
              "resizeRecord": false,
  
              "resizeColumnHandleIndex": 0,
              "resizeRecordHandleIndex": 0,
  
              "resizeColumnIndex": null,
              "resizeRecordIndex": null,
  
              "resizingRecordSelectors": false,
              "resizingHeader": false,
              "resizingInsert": false,
  
              "scrollOriginTop": null,
              "scrollOriginLeft": null,
  
              "lastX": 0,
              "lastY": 0,
              "lastWidth": 0,
              "lastHeight": 0
          };
  
          // we need a place to store info for column reorder
          element.internalReorder = {
              "currentlyReordering": false,
              "reorderStarted": false,
              "currentColumns": [],
              "dropLocation": 0,
              "scrollIntervalID": null,
              "scrollDirection": null,
              "scrolling": false,
              "originColumn": null
          };
  
          // we need a place to cache visibility information so that if we
          //      detect a change, we can trigger a re-render
          element.internalPollingCache = {
              "elementWidth": null,
              "elementHeight": null,
              "elementVisibility": null,
              "fontSize": null
          };
  
          // we want to know the cell dimensions so that we can make elements
          //      default and so that scrolling will reflect the correct
          //      dimensions, so we'll detect them here (and during scroll
          //      location renders)
          cellDimensionDetector(element);
      }
  
      // get a gs-table's templates and translate them for future templating
      function siphonElement(element) {
          var topHudTemplate;
          var bottomHudTemplate;
          var headerRecordTemplate;
          var dataRecordTemplate;
          var copyTemplate;
          var insertRecordTemplate;
          var insertDialogTemplate;
          var updateDialogTemplate;
  
          var strHTML;
          var arrColumnPlainTextNames;
          var arrColumnDataNames;
          var arrColumnElements;
          var columnElement;
          var intColumnWidth;
          var buttonElement;
          var i;
          var len;
  
          // get each template element and save them to each their own variable,
          //      for easy access
          topHudTemplate = xtag.queryChildren(
              element,
              '[for="top-hud"]'
          )[0];
  
          bottomHudTemplate = xtag.queryChildren(
              element,
              '[for="bottom-hud"]'
          )[0];
  
          headerRecordTemplate = xtag.queryChildren(
              element,
              '[for="header-record"]'
          )[0];
  
          dataRecordTemplate = xtag.queryChildren(
              element,
              '[for="data-record"]'
          )[0];
  
          copyTemplate = xtag.queryChildren(
              element,
              '[for="copy"]'
          )[0];
  
          insertRecordTemplate = xtag.queryChildren(
              element,
              '[for="insert-record"]'
          )[0];
  
          insertDialogTemplate = xtag.queryChildren(
              element,
              '[for="insert-dialog"]'
          )[0];
  
          updateDialogTemplate = xtag.queryChildren(
              element,
              '[for="update-dialog"]'
          )[0];
  
          // remove all templates from the dom to prevent reflows
          if (topHudTemplate) {
              //console.log(element, topHudTemplate);
              element.removeChild(topHudTemplate);
          }
          if (bottomHudTemplate) {
              element.removeChild(bottomHudTemplate);
          }
          if (headerRecordTemplate) {
              element.removeChild(headerRecordTemplate);
          }
          if (dataRecordTemplate) {
              element.removeChild(dataRecordTemplate);
          }
          if (copyTemplate) {
              element.removeChild(copyTemplate);
          }
          if (insertRecordTemplate) {
              element.removeChild(insertRecordTemplate);
          }
          if (insertDialogTemplate) {
              element.removeChild(insertDialogTemplate);
          }
          if (updateDialogTemplate) {
              element.removeChild(updateDialogTemplate);
          }
  
          if (
              topHudTemplate &&
              (
                  topHudTemplate.innerHTML.indexOf('&gt;') > -1 ||
                  topHudTemplate.innerHTML.indexOf('&lt;') > -1
              )
          ) {
              console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                          'top HUD template, this can have undesired ' +
                          'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                          'lt(x,y), or lte(x,y) to silence this warning.');
          }
          if (
              bottomHudTemplate &&
              (
                  bottomHudTemplate.innerHTML.indexOf('&gt;') > -1 ||
                  bottomHudTemplate.innerHTML.indexOf('&lt;') > -1
              )
          ) {
              console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                          'bottom HUD template, this can have undesired ' +
                          'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                          'lt(x,y), or lte(x,y) to silence this warning.');
          }
          if (
              headerRecordTemplate &&
              (
                  headerRecordTemplate.innerHTML.indexOf('&gt;') > -1 ||
                  headerRecordTemplate.innerHTML.indexOf('&lt;') > -1
              )
          ) {
              console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                          'header record template, this can have undesired ' +
                          'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                          'lt(x,y), or lte(x,y) to silence this warning.');
          }
          if (
              dataRecordTemplate &&
              (
                  dataRecordTemplate.innerHTML.indexOf('&gt;') > -1 ||
                  dataRecordTemplate.innerHTML.indexOf('&lt;') > -1
              )
          ) {
              console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                          'data record template, this can have undesired ' +
                          'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                          'lt(x,y), or lte(x,y) to silence this warning.');
          }
          if (
              copyTemplate &&
              (
                  copyTemplate.innerHTML.indexOf('&gt;') > -1 ||
                  copyTemplate.innerHTML.indexOf('&lt;') > -1
              )
          ) {
              console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                          'copy template, this can have undesired ' +
                          'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                          'lt(x,y), or lte(x,y) to silence this warning.');
          }
          if (
              insertRecordTemplate &&
              (
                  insertRecordTemplate.innerHTML.indexOf('&gt;') > -1 ||
                  insertRecordTemplate.innerHTML.indexOf('&lt;') > -1
              )
          ) {
              console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                          'insert record template, this can have undesired ' +
                          'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                          'lt(x,y), or lte(x,y) to silence this warning.');
          }
          if (
              insertDialogTemplate &&
              (
                  insertDialogTemplate.innerHTML.indexOf('&gt;') > -1 ||
                  insertDialogTemplate.innerHTML.indexOf('&lt;') > -1
              )
          ) {
              console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                          'insert dialog template, this can have undesired ' +
                          'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                          'lt(x,y), or lte(x,y) to silence this warning.');
          }
          if (
              updateDialogTemplate &&
              (
                  updateDialogTemplate.innerHTML.indexOf('&gt;') > -1 ||
                  updateDialogTemplate.innerHTML.indexOf('&lt;') > -1
              )
          ) {
              console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                          'update dialog template, this can have undesired ' +
                          'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                          'lt(x,y), or lte(x,y) to silence this warning.');
          }
  
          // if there's no "data-record" template: error
          if (!dataRecordTemplate) {
              throw 'GS-TABLE Error: no "data-record" template found. ' +
                      'The "data-record" must be a immediate child in ' +
                      'order to be found.';
          }
  
          // if there's no "data-record" template: error
          if (!copyTemplate) {
              console.warn('GS-TABLE Warning: no "copy" template found. ' +
                      'The "copy" template enables copying a selection ' +
                      'from the gs-table. The "copy" template must be a ' +
                      'immediate child in order to be found.');
          }
  
          // get column widths
          if (
              headerRecordTemplate ||
              dataRecordTemplate ||
              insertRecordTemplate
          ) {
              if (headerRecordTemplate) {
                  arrColumnElements = xtag.query(
                      headerRecordTemplate.content,
                      'gs-cell'
                  );
              } else if (dataRecordTemplate) {
                  arrColumnElements = xtag.query(
                      dataRecordTemplate.content,
                      'gs-cell'
                  );
              } else if (insertRecordTemplate) {
                  arrColumnElements = xtag.query(
                      insertRecordTemplate.content,
                      'gs-cell'
                  );
              }
  
              i = 0;
              len = arrColumnElements.length;
              intColumnWidth = (
                  parseInt(element.getAttribute('default-column-width'), 10) ||
                  intDefaultColumnWidth
              );
              while (i < len) {
                  element.internalDisplay.columnWidths.push(
                      parseInt(arrColumnElements[i].style.width, 10) ||
                      intColumnWidth
                  );
  
                  // we need to be able to restore the column widths after the
                  //      user resizes them, so this array contains the column
                  //      widths and cannot be updated by column resizing
                  element.internalDisplay.defaultColumnWidths.push(
                      parseInt(arrColumnElements[i].style.width, 10) ||
                      intColumnWidth
                  );
  
                  // if there is a width, remove it. we do this because the width
                  //      is added dynamically when the header is rendered. if
                  //      someone resizes a cell, we need to set the width with
                  //      the new value
                  if (arrColumnElements[i].style.width) {
                      arrColumnElements[i].style.width = '';
                  }
  
                  i += 1;
              }
          }
  
          // get header height
          if (headerRecordTemplate) {
              arrColumnElements = xtag.query(
                  headerRecordTemplate.content,
                  'gs-cell'
              );
  
              i = 0;
              len = arrColumnElements.length;
              while (i < len) {
                  // if we run into a column with a height defined, use that
                  //      height for the header height and break out of the loop
                  if (arrColumnElements[i].style.height) {
                      element.internalDisplay.headerHeight = (
                          parseInt(arrColumnElements[i].style.height, 10)
                      );
                  }
                  i += 1;
              }
  
              // default
              if (element.internalDisplay.headerHeight === undefined) {
                  element.internalDisplay.headerHeight = (
                      element.internalDisplay.defaultHeaderHeight
                  );
              }
          }
  
          // get insert record height
          if (insertRecordTemplate) {
              arrColumnElements = xtag.query(
                  insertRecordTemplate.content,
                  'gs-cell'
              );
  
              i = 0;
              len = arrColumnElements.length;
              while (i < len) {
                  // if we run into a column with a height defined, use that
                  //      height for the header height and break out of the loop
                  if (arrColumnElements[i].style.height) {
                      element.internalDisplay.insertRecordHeight = (
                          parseInt(arrColumnElements[i].style.height, 10)
                      );
                  }
                  i += 1;
              }
  
              // default to 27 pixels
              if (element.internalDisplay.insertRecordHeight === undefined) {
                  element.internalDisplay.insertRecordHeight = (
                      element.internalDisplay.defaultInsertRecordHeight
                  );
              }
          }
  
          // get plain text column names
          arrColumnPlainTextNames = [];
  
          // if there is a copy template and we still haven't found
          //      plain text column names
          if (
              copyTemplate && (
                  arrColumnPlainTextNames.length === 0 ||
                  arrColumnPlainTextNames.indexOf(null) !== -1
              )
          ) {
              arrColumnElements = xtag.query(
                  copyTemplate.content,
                  'gs-cell'
              );
  
              i = 0;
              len = arrColumnElements.length;
              while (i < len) {
                  if (!arrColumnPlainTextNames[i]) {
                      arrColumnPlainTextNames[i] = (
                          // if there's no header attribute, we'll set the
                          //      column name to null
                          arrColumnElements[i].getAttribute('header')
                      );
                  }
                  i += 1;
              }
          }
  
          // if there is a record template and we still haven't found
          //      plain text column names
          if (
              dataRecordTemplate && (
                  arrColumnPlainTextNames.length === 0 ||
                  arrColumnPlainTextNames.indexOf(null) !== -1
              )
          ) {
              arrColumnElements = xtag.query(
                  dataRecordTemplate.content,
                  'gs-cell'
              );
  
              i = 0;
              len = arrColumnElements.length;
              while (i < len) {
                  if (!arrColumnPlainTextNames[i]) {
                      arrColumnPlainTextNames[i] = (
                          // if there's no header attribute, we'll set the
                          //      column name to null
                          arrColumnElements[i].getAttribute('header')
                      );
                  }
                  i += 1;
              }
          }
  
          // if there is an insert record template and we still haven't
          //      found plain text column names
          if (
              insertRecordTemplate && (
                  arrColumnPlainTextNames.length === 0 ||
                  arrColumnPlainTextNames.indexOf(null) !== -1
              )
          ) {
              arrColumnElements = xtag.query(
                  insertRecordTemplate.content,
                  'gs-cell'
              );
  
              i = 0;
              len = arrColumnElements.length;
              while (i < len) {
                  if (!arrColumnPlainTextNames[i]) {
                      arrColumnPlainTextNames[i] = (
                          // if there's no header attribute, we'll set the
                          //      column name to null
                          arrColumnElements[i].getAttribute('header')
                      );
                  }
                  i += 1;
              }
          }
  
          // if there is a header template and we still haven't found
          //      plain text column names
          if (
              headerRecordTemplate && (
                  arrColumnPlainTextNames.length === 0 ||
                  arrColumnPlainTextNames.indexOf(null) !== -1
              )
          ) {
              arrColumnElements = xtag.query(
                  headerRecordTemplate.content,
                  'gs-cell'
              );
  
              i = 0;
              len = arrColumnElements.length;
              while (i < len) {
                  if (!arrColumnPlainTextNames[i]) {
                      arrColumnPlainTextNames[i] = (
                          // if there's no text, we'll set the
                          //      column name to null
                          arrColumnElements[i].textContent.trim() || null
                      );
                  }
                  i += 1;
              }
          }
  
          // store plain text column names for future use
          element.internalDisplay.columnPlainTextNames = arrColumnPlainTextNames;
  
  
  
          // we need to associate the display columns with their associated data
          //      columns
          arrColumnDataNames = [];
  
          // if there is an insert record template and we still haven't
          //      all of the found data column associations
          if (
              insertRecordTemplate && (
                  arrColumnDataNames.length === 0 ||
                  arrColumnDataNames.indexOf(null) !== -1
              )
          ) {
              arrColumnElements = xtag.query(
                  insertRecordTemplate.content,
                  'gs-cell'
              );
  
              i = 0;
              len = arrColumnElements.length;
              while (i < len) {
                  if (!arrColumnDataNames[i]) {
                      columnElement = xtag.query(
                          arrColumnElements[i],
                          '[column]'
                      )[0];
  
                      if (columnElement) {
                          arrColumnDataNames[i] = (
                              // if there's no column attribute, we'll set the
                              //      column name to null
                              columnElement.getAttribute('column')
                          );
                      } else {
                          arrColumnDataNames[i] = null;
                      }
                  }
                  i += 1;
              }
          }
  
          // if there is an insert record template and we still haven't
          //      all of the found data column associations
          if (
              dataRecordTemplate && (
                  arrColumnDataNames.length === 0 ||
                  arrColumnDataNames.indexOf(null) !== -1
              )
          ) {
              arrColumnElements = xtag.query(
                  dataRecordTemplate.content,
                  'gs-cell'
              );
  
              i = 0;
              len = arrColumnElements.length;
              while (i < len) {
                  if (!arrColumnDataNames[i]) {
                      columnElement = xtag.query(
                          arrColumnElements[i],
                          '[column]'
                      )[0];
  
                      if (columnElement) {
                          arrColumnDataNames[i] = (
                              // if there's no column attribute, we'll set the
                              //      column name to null
                              columnElement.getAttribute('column')
                          );
                      } else {
                          arrColumnDataNames[i] = null;
                      }
                  }
                  i += 1;
              }
          }
  
          // store our associations internally
          element.internalDisplay.dataColumnName = arrColumnDataNames;
  
          // if present, siphon "top-hud" template
          if (topHudTemplate) {
              element.internalTemplates.topHUD = topHudTemplate.innerHTML;
          }
  
          // if present, siphon "bottom-hud" template
          if (bottomHudTemplate) {
              element.internalTemplates.bottomHUD = bottomHudTemplate.innerHTML;
          }
  
          // the header template (if there is one) needs dropdown buttons for
          //      the column dropdown
          if (headerRecordTemplate) {
              // create the button element so we can clone it
              buttonElement = document.createElement('div');
  
              // loop through cells and append buttons
              arrColumnElements = xtag.query(
                  headerRecordTemplate.content,
                  'gs-cell'
              );
              i = 0;
              len = arrColumnElements.length;
              while (i < len) {
                  // a column only get's a column button if there is a data
                  //      column associated with that column
                  if (arrColumnDataNames[i]) {
                      buttonElement.setAttribute(
                          'class',
                          'header-button ' +
                                  '$$HDRBTNCLASS_' + arrColumnDataNames[i] + '$$'
                      );
  
                      arrColumnElements[i].classList.add('right-button');
                      arrColumnElements[i].appendChild(
                          buttonElement.cloneNode(true)
                      );
                  }
                  i += 1;
              }
          }
  
          // if a display column is associated with a data column, we want
          //      to have sort and filter related info in the tooltip
          if (headerRecordTemplate) {
              // loop through header cells and add tokens to the title
              //      attributes
              arrColumnElements = xtag.query(
                  headerRecordTemplate.content,
                  'gs-cell'
              );
              i = 0;
              len = arrColumnElements.length;
              while (i < len) {
                  // a column only get's a column button if there is a data
                  //      column associated with that column
                  if (arrColumnDataNames[i]) {
                      arrColumnElements[i].setAttribute(
                          'title',
                          '$$HDR_TITLE_' + arrColumnDataNames[i] + '$$'
                      );
                  }
                  i += 1;
              }
          }
  
          // if there is a header template, get column min widths
          if (headerRecordTemplate) {
              arrColumnElements = xtag.query(
                  headerRecordTemplate.content,
                  'gs-cell'
              );
  
              i = 0;
              len = arrColumnElements.length;
              while (i < len) {
                  // all of these values are tested in the test header
                  //      element, this element is in a different location
                  //      so the CSS that the user sets may not apply to
                  //      it. we need to transition to a temporary cell
                  //      element in the viewport
                  // ### NEED CODING ###
  
                  // get text width using test header element
                  element.elems.testHeader.innerHTML = (
                      arrColumnElements[i].innerHTML
                  );
  
                  intColumnWidth = (
                      //GS.getTextWidth(
                      //    element.elems.testHeader,
                      //    arrColumnElements[i].textContent,
                      //    true // preserve whitespace
                      //) +
  
                      element.elems.testHeader.offsetWidth +
                      // for some reason, a few pixels are missing
                      3
                  );
  
                  element.elems.testHeader.innerHTML = '';
  
                  //console.log(arrColumnElements[i].textContent);
  
                  // if there is a data column associated, we need to
                  //      add the width of the header button
                  if (arrColumnDataNames[i]) {
                      intColumnWidth += (
                          // em value is hard coded for now
                          GS.emToPx(element.elems.testHeader, 1.25)
                      );
                  }
  
                  //console.log(intColumnWidth);
  
                  element.internalDisplay.minColumnWidths.push(
                      intColumnWidth
                  );
  
                  //console.log(
                  //    intColumnWidth,
                  //    element.internalDisplay.columnWidths[i]
                  //);
                  if (
                      intColumnWidth >
                          element.internalDisplay.columnWidths[i]
                  ) {
                      element.internalDisplay.columnWidths[i] = (
                          intColumnWidth
                      );
                  }
  
                  i += 1;
              }
          }
  
  
          // if present, siphon "header-record" template
          if (headerRecordTemplate) {
              // commented out because we no longer put the styling on the cell
              //// append a token to the end of the style attribute of each
              ////      gs-cell (so that we can dynamically add CSS definitions)
              //templateCellAddStyleToken(headerRecordTemplate);
  
              // add a class of "table-header" to each gs-cell for styling
              templateCellAddClass(headerRecordTemplate, 'table-header');
  
              // add column numbers to the header cells so that we can target
              //      these cells using column precision
              templateCellAddColumnNumber(headerRecordTemplate);
  
              // save the template
              element.internalTemplates.header = (
                  headerRecordTemplate.innerHTML.trim()
              );
  
              //// remove the template element now that it's been siphoned
              //element.removeChild(headerRecordTemplate);
          }
  
          // if present, siphon "data-record" template
          if (dataRecordTemplate) {
              // commented out because we no longer put the styling on the cell
              //// append a token to the end of the style attribute of each
              ////      gs-cell (so that we can dynamically add CSS definitions)
              //templateCellAddStyleToken(dataRecordTemplate);
  
              // add a class of "table-cell" to each gs-cell for styling
              templateCellAddClass(dataRecordTemplate, 'table-cell');
  
              // add column numbers to the record cells so that we can target
              //      these cells using column precision
              templateCellAddColumnNumber(dataRecordTemplate);
  
              // add a record number attribute on each of the cells so that we can
              //      target specific records for deletion, rerender, movement
              //      etc...
              templateCellAddRowNumber(dataRecordTemplate);
  
              // save the template
              strHTML = GS.templateColumnToValue(
                  dataRecordTemplate.innerHTML.trim()
              );
  
              // let's save the original record template text so that we can
              //      modify it in the future
              element.internalTemplates.originalRecord = strHTML;
  
              // we're going run the record template through a function to
              //      turn all of the "column" attributes into "value" attributes
              //      with the proper templating
              element.internalTemplates.record = (
                  GS.templateHideSubTemplates(strHTML, false)
              );
  
              //// remove the template element now that it's been siphoned
              //element.removeChild(dataRecordTemplate);
          }
  
          // if present, siphon "copy" template
          if (copyTemplate) {
              // we want to save the copy template so that we'll always have
              //      access to it's original innerHTML (right now, only for
              //      debugging purposes)
              element.internalTemplates.copy = (
                  copyTemplate.innerHTML
              );
  
              // determine the record copy columns from the "copy" template
              //      so that we can use them when we copy and we need to get data
              templateDetermineCopyColumnList(element, copyTemplate);
  
              // determine the copy headers from the "copy" template so
              //      that we can use them for when we copy and we need to use
              //      the headers
              templateDetermineCopyHeaderList(element, copyTemplate);
  
              //// remove the template element now that it's been siphoned
              //element.removeChild(copyTemplate);
          }
  
          // if present, siphon "insert-record" template
          if (insertRecordTemplate) {
              // commented out because we no longer put the styling on the cell
              //// append a token to the end of the style attribute of each
              ////      gs-cell (so that we can dynamically add CSS definitions)
              //templateCellAddStyleToken(insertRecordTemplate);
  
              // add a class of "table-insert" to each gs-cell for styling
              templateCellAddClass(insertRecordTemplate, 'table-insert');
  
              // add column numbers to the insert cells so that we can target
              //      these cells using column precision
              templateCellAddColumnNumber(insertRecordTemplate);
  
              // add row attributes so that the javascript can look at the cell
              //      and determine that it's an "insert" type cell
              templateCellAddRowNumber(insertRecordTemplate, 'insert');
  
              // save the template
              element.internalTemplates.insertRecord = (
                  insertRecordTemplate.innerHTML.trim()
              );
  
              //// remove the template element now that it's been siphoned
              //element.removeChild(insertRecordTemplate);
          }
  
          // if present, siphon "insert-dialog" template
          if (insertDialogTemplate) {
              element.internalTemplates.insertDialog = (
                  insertDialogTemplate.innerHTML.trim()
              );
  
              //// remove the template element now that it's been siphoned
              //element.removeChild(insertDialogTemplate);
          }
  
          // if present, siphon "update-dialog" template
          if (updateDialogTemplate) {
              // save the template
              strHTML = GS.templateColumnToValue(
                  updateDialogTemplate.innerHTML.trim()
              );
  
              // let's save the original dialog template text so that we can
              //      modify it in the future
              element.internalTemplates.originalUpdateDialog = strHTML;
  
              // we're going run the dialog template through a function to
              //      turn all of the "column" attributes into "value" attributes
              //      with the proper templating
              element.internalTemplates.updateDialog = (
                  GS.templateHideSubTemplates(strHTML, false)
              );
  
              //// remove the template element now that it's been siphoned
              //element.removeChild(updateDialogTemplate);
          }
      }
  
      // we need to use a web worker so that we can move processor expensive
      //      operations to another thread so that we dont freeze the UI
      function createWebWorker(element) {
          //var waitingFunction;
          //var handlerFunction;
  
          //// if no web worker support: throw error so that the developer knows
          ////      that the gs-table element requires web workers
          //if (window.Worker === undefined) {
          //    throw 'GS-TABLE Error: Web Workers are not supported by this ' +
          //            'browser. The GS-TABLE element requires the use of a ' +
          //            'Web Worker.';
          //}
  
          //// get web worker and store it
          //element.internalWorker.worker = new Worker('worker-gs-table.js');
  
          //// this function listens to the web worker after the web worker has
          ////      given the signal that it's ready
          //handlerFunction = function (event) {
          //    var jsnMessage = event.data;
          //    //console.log('handler received', jsnMessage);
          //};
  
          //// this function listens to the web worker until the worker gives the
          ////      signal that it's ready for use
          //waitingFunction = function (event) {
          //    var jsnMessage = event.data;
          //    //console.log('handler received', jsnMessage);
  
          //    if (jsnMessage.content === 'ready') {
                  //// mark the worker as ready so that any code that can only run
                  ////      while the worker is ready will now be able to run
                  //element.internalWorker.ready = true;
  
                  //// re-bind worker lister to the main listener code
                  //element.internalWorker.worker.onmessage = handlerFunction;
  
          // run first select now that the worker is ready
          dataSELECT(element);
  
                  ////console.log('worker ready');
          //    }
          //};
  
          ////element.internalWorker.worker.postMessage({"first": value});
  
          //// bind web worker message event so that we can begin using the worker
          //element.internalWorker.worker.onmessage = waitingFunction;
      }
  
  // ############################################################################
  // ############################## COPY FUNCTIONS ##############################
  // ############################################################################
  
      // there are multiple places where we need to get the copy parameters, so
      //      we use this function so that we can have things like defaults and
      //      we don't need to update multiple sections of code to keep things in
      //      sync
      function getCopyParameters(element) {
          var headerMode;
          var selectorMode;
          var quoteChar;
          var escapeChar;
          var quoteMode;
          var recordDelimiter;
          var cellDelimiter;
          var nullString;
          var copyTypes;
  
          // we need the user to be able to override the copy parameters so that
          //      they can format the copy in the way they need
          // if the attribute is present for a parameter, fill the variable with
          //      the attribute (and default to empty string) else default to
          //      parameter default
          if (element.getAttribute('copy-header')) {
              headerMode = element.getAttribute('copy-header');
          } else {
              headerMode = 'never';
          }
          if (element.getAttribute('copy-selectors')) {
              selectorMode = element.getAttribute('copy-selectors');
          } else {
              selectorMode = 'never';
          }
          if (element.getAttribute('copy-quote-char')) {
              quoteChar = element.getAttribute('copy-quote-char');
          } else {
              quoteChar = '"';
          }
          if (element.getAttribute('copy-escape-char')) {
              escapeChar = element.getAttribute('copy-escape-char');
          } else {
              escapeChar = quoteChar;
          }
          if (element.getAttribute('copy-quote-when')) {
              quoteMode = element.getAttribute('copy-quote-when');
          } else {
              quoteMode = 'delimiter-in-content';
          }
          if (element.getAttribute('copy-delimiter-record')) {
              recordDelimiter =
                      element.getAttribute('copy-delimiter-record')
                  .replace(/\{\{DOS_RETURN\}\}/gi, '\r\n')
                  .replace(/\{\{MAC_RETURN\}\}/gi, '\r')
                  .replace(/\{\{UNIX_RETURN\}\}/gi, '\n');
          } else {
              recordDelimiter = '\n';
          }
          if (element.getAttribute('copy-delimiter-cell')) {
              cellDelimiter = element.getAttribute('copy-delimiter-cell')
                  .replace(/\{\{DOS_RETURN\}\}/gi, '\r\n')
                  .replace(/\{\{MAC_RETURN\}\}/gi, '\r')
                  .replace(/\{\{UNIX_RETURN\}\}/gi, '\n');
          } else {
              cellDelimiter = '\t';
          }
          if (element.getAttribute('copy-null-cell')) {
              nullString = element.getAttribute('copy-null-cell');
          } else {
              nullString = '';
          }
          if (element.getAttribute('copy-types')) {
              copyTypes = element.getAttribute('copy-types');
          } else {
              copyTypes = 'text,html';
          }
  
          // we need to return multiple variables but return only allows one
          //      return value, so we'll return in JSON
          return {
              "headerMode": headerMode,
              "selectorMode": selectorMode,
              "quoteChar": quoteChar,
              "escapeChar": escapeChar,
              "quoteMode": quoteMode,
              "recordDelimiter": recordDelimiter,
              "cellDelimiter": cellDelimiter,
              "nullString": nullString,
              "copyTypes": copyTypes
          };
      }
  
      // we need to know that we're working with valid copy attributes, so
      //      we use this function to throw an error if there is an invalid
      //      copy attribute
      // this function returns the copy parameters in JSON format if they
      //      are all valid
      function validateCopyParameters(element) {
          var jsnCopyParameters;
  
          // we need the user to be able to override the copy parameters so that
          //      they can format the copy in the way they need so here, we gather
          //      the copy parameters
          jsnCopyParameters = getCopyParameters(element);
  
          // we need to verify that the copy parameters are valid
          //console.log('headerMode:      ', jsnCopyParameters.headerMode);
          //console.log('selectorMode:    ', jsnCopyParameters.selectorMode);
          //console.log('quoteChar:       ', jsnCopyParameters.quoteChar);
          //console.log('escapeChar:      ', jsnCopyParameters.escapeChar);
          //console.log('quoteMode:       ', jsnCopyParameters.quoteMode);
          //console.log('recordDelimiter: ', jsnCopyParameters.recordDelimiter);
          //console.log('cellDelimiter:   ', jsnCopyParameters.cellDelimiter);
          //console.log('nullString:      ', jsnCopyParameters.nullString);
  
          //copy-header: always|never|selected
          if (
              !(/^(always|never|selected)$/gi)
                  .test(jsnCopyParameters.headerMode)
          ) {
              throw 'GS-TABLE Error: Copy parameter "copy-header" invalid, ' +
                      'valid values are "always", "never" or "selected" ';
          }
          //copy-selectors: always|never|selected
          if (
              !(/^(always|never|selected)$/gi)
                  .test(jsnCopyParameters.selectorMode)
          ) {
              throw 'GS-TABLE Error: Copy parameter "copy-selectors" invalid, ' +
                      'valid values are "always", "never" or "selected" ';
          }
          //copy-quote-when: never|strings|always|delimiter-in-content
          if (
              !(/^(never|strings|always|delimiter-in-content)$/gi)
                  .test(jsnCopyParameters.quoteMode)
          ) {
              throw 'GS-TABLE Error: Copy parameter "copy-quote-when" invalid, ' +
                      'valid values are "never", "strings", "always" or ' +
                      '"delimiter-in-content".';
          }
          //copy-delimiter-record: not empty
          if (jsnCopyParameters.recordDelimiter.length === 0) {
              throw 'GS-TABLE Error: Copy parameter "copy-delimiter-record" ' +
                      'cannot be empty.';
          }
          //copy-delimiter-cell: not empty
          if (jsnCopyParameters.cellDelimiter.length === 0) {
              throw 'GS-TABLE Error: Copy parameter "copy-delimiter-cell" ' +
                      'cannot be empty.';
          }
  
          // this function gets the copy parameters on it's own, so if a function
          //      were to call this function, we wouldn't want to have to re-get
          //      the copy parameters in that function, so we return the copy
          //      parameters
          return jsnCopyParameters;
      }
  
      // we need to be able to override the clipbard for specific mime types on a
      //      copy event, this function accepts the copy event, the copy string
      //      and the mime type to override
      function handleClipboardData(event, strCopyString, strType) {
          var clipboardData = event.clipboardData || window.clipboardData;
          var strMime;
  
          if (!clipboardData) {
              return;
          }
          if (!clipboardData.setData) {
              return;
          }
  
          if (strType === 'text') {
              if (window.clipboardData && window.clipboardData.getData) { // IE
                  strMime = 'Text';
              } else if (event.clipboardData && event.clipboardData.getData) {
                  strMime = 'text/plain';
              }
          } else if (strType === 'html') {
              if (window.clipboardData && window.clipboardData.getData) { // IE
                  strMime = '';
              } else if (event.clipboardData && event.clipboardData.getData) {
                  strMime = 'text/html';
              }
          } else {
              throw 'handleClipboardData Error: Type "' + strType + '" not ' +
                      'recognized, recognized types are "text" and "html".';
          }
  
          if (strMime) {
              if (strCopyString && strMime) {
                  return clipboardData.setData(strMime, strCopyString) !== false;
              } else {
                  return clipboardData.getData(strMime);
              }
          }
      }
  
      function getCopyStrings(element) {
          var strTextCopyString;
          var strHTMLCopyString;
          var strHTMLRecordCopyString;
          var row_i;
          var row_len;
          var col_i;
          var col_len;
          var cell;
          var row;
          var char;
          var record_i;
          var record_len;
          var cell_i;
  
          var jsnCopyParameters;
          var quoteChar;
          var escapeChar;
          var quoteMode;
          var selectorMode;
          var headerMode;
          var recordDelimiter;
          var cellDelimiter;
          var nullString;
  
          var arrColumns;
          var arrRows;
          var bolHeader;
          var bolSelector;
          var arrHeaders;
          var arrColumnTemplates;
          var arrColumnNames;
          var arrSelection;
          var intRow;
          var intCol;
          var intSel;
  
          var handleCell;
          var jsnQS;
          var jsnRow;
          var arrRow;
          var strRow;
          var strHeader;
  
          var arrSelectedStates = ['B', 'D', 'F', 'H', 'J', 'L'];
  
          var cell_len;
          var delim;
  
          // define the text copy string as empty string so that we can just
          //      append to it without causing an issue where "undefined" is
          //      at the beginning of the string
          strTextCopyString = '';
  
          // define the HTML copy string as a beginning table tag, so that
          //      we only have to append to the string
          strHTMLCopyString =
                  '<' + 'style>' +
                  'br { mso-data-placement:same-cell; } ' +
                  'th, td { white-space: pre-wrap; }' +
                  '<' + '/style>' +
                  '<' + 'table border="0" cellpadding="0" cellspacing="0">';
  
          strHTMLRecordCopyString = '';
  
          // cache copy column template stringss for speed
          arrColumnTemplates = element.internalClip.columnList.slice(0);
  
          // convert the column template strings into dot.js functions for speed
          col_i = 0;
          col_len = arrColumnTemplates.length;
          while (col_i < col_len) {
              arrColumnTemplates[col_i] =
                      '{{ var qs = jo.qs' +
                      ', row = jo.row' +
                      ', arrRow = jo.arrRow' +
                      ', i = jo.i' +
                      ', len = jo.len; }}' +
                      arrColumnTemplates[col_i];
  
              arrColumnTemplates[col_i] = doT.template(
                  arrColumnTemplates[col_i]
              );
  
              col_i += 1;
          }
  
          // we need the user to be able to override the copy parameters so that
          //      they can format the copy in the way they need so here, we gather
          //      the copy parameters
          jsnCopyParameters = getCopyParameters(element);
          quoteChar = jsnCopyParameters.quoteChar;
          escapeChar = jsnCopyParameters.escapeChar;
          quoteMode = jsnCopyParameters.quoteMode;
          selectorMode = jsnCopyParameters.selectorMode;
          headerMode = jsnCopyParameters.headerMode;
          recordDelimiter = jsnCopyParameters.recordDelimiter;
          cellDelimiter = jsnCopyParameters.cellDelimiter;
          nullString = jsnCopyParameters.nullString;
  
          // we dont want to recalculate the Query String JSON once for every
          //      cell, so here we calculate it once (in JSON format)
          jsnQS = GS.qryToJSON(GS.getQueryString());
  
          // bring copy variables in for easy access
          arrColumnNames = element.internalData.columnNames;
          arrSelection = element.internalSelection.resolvedSelection.slice(0);
          arrColumns = element.internalSelection.columns.slice(0);
          arrRows = element.internalSelection.rows.slice(0);
          arrHeaders = element.internalClip.headerList.slice(0);
  
          // if the header is selected, remove it from the list and save it
          //  in another location
          if (
              (
                  headerMode === 'selected' &&
                  arrRows[0] === 'header'
              ) ||
              (
                  headerMode === 'always'
              )
          ) {
              bolHeader = true;
          }
          if (arrRows[0] === 'header') {
              arrRows.shift();
          }
          if (element.internalDisplay.headerVisible) {
              strHeader = arrSelection[0]; //.shift();
          }
  
          // if a selector is selected and we don't copy those, remove it from
          //      the list
          if (
              (
                  selectorMode === 'selected' &&
                  arrColumns[0] === 'selector'
              ) ||
              (
                  selectorMode === 'always'
              )
          ) {
              bolSelector = true;
          }
          if (arrColumns[0] === 'selector') {
              arrColumns.shift();
          }
  
          // if the insert record is selected, remove it from the list
          if (arrRows[arrRows.length - 1] === 'insert') {
              arrRows.pop();
          }
  
          // convert the header template strings into dot.js functions for speed
          col_i = 0;
          col_len = arrHeaders.length;
          while (col_i < col_len) {
              arrHeaders[col_i] = doT.template(
                  '{{ var qs = jo.qs; }}' +
                  arrHeaders[col_i]
              );
              col_i += 1;
          }
  
          //console.log(
          //    arrColumns,
          //    arrRows
          //);
  
          // to handle different quoting policies, we define the "handleCell"
          //      function differently depending on the "quoteMode" variable
          // the "handleCell" function handles quoting, querystring template
          //      and row templating
          // defining the "handleCell" function conditionally is going to make
          //      the "handleCell" function faster because it doesn't have to
          //      recalculate the quote policy once fo reach cell
          //copy-quote-when: never|strings|always|delimiter-in-content
          if (quoteMode === 'never') {
              // no quoting,
              //      template cell with querystring and row
              //      append cell to strTextCopyString
              handleCell = function (cellTemplate, i, len, jsnRow, arrRow) {
                  // template cell with querystring and row
                  var strCell = cellTemplate({
                      'qs': jsnQS,
                      'row': jsnRow,
                      'arrRow': arrRow,
                      'i': i,
                      'len': len
                  });
  
                  // append cell to the HTML copy string
                  strHTMLRecordCopyString +=
                          '<' + 'td rowspan="1" colspan="1">' +
                          strCell +
                          '</td>';
  
                  // append cell to the text copy string
                  strTextCopyString += strCell;
              };
          } else if (quoteMode === 'strings') {
              // string quoting,
              //      template cell with querystring and row
              //      if escapeChar !== quoteChar: double up every escapeChar
              //      put an escapeChar behind every quoteChar
              //      if NaN: wrap cell with quoteChar
              //      append cell to strTextCopyString
              handleCell = function (cellTemplate, i, len, jsnRow, arrRow) {
                  // template cell with querystring and row
                  var strCell = cellTemplate({
                      'qs': jsnQS,
                      'row': jsnRow,
                      'arrRow': arrRow,
                      'i': i,
                      'len': len
                  });
  
                  // before we do any quoting, we need to add the HTML to the
                  //      HTML copy string
                  strHTMLRecordCopyString +=
                          '<' + 'td rowspan="1" colspan="1">' +
                          strCell +
                          '</td>';
  
                  // if escapeChar !== quoteChar: double up every escapeChar
                  if (escapeChar !== quoteChar) {
                      strCell = stringReplaceAll(
                          strCell,
                          escapeChar,
                          escapeChar + escapeChar
                      );
                  }
  
                  // put an escapeChar behind every quoteChar
                  strCell = stringReplaceAll(
                      strCell,
                      quoteChar,
                      escapeChar + quoteChar
                  );
  
                  // if NaN: wrap cell with quoteChar
                  if (isNaN(strCell)) {
                      strCell = quoteChar + strCell + quoteChar;
                  }
  
                  // append cell to copy string
                  strTextCopyString += strCell;
              };
          } else if (quoteMode === 'always') {
              // string quoting,
              //      template cell with querystring and row
              //      if escapeChar !== quoteChar: double up every escapeChar
              //      put an escapeChar behind every quoteChar
              //      wrap cell with quoteChar
              //      append cell to strTextCopyString
              handleCell = function (cellTemplate, i, len, jsnRow, arrRow) {
                  // template cell with querystring and row
                  var strCell = cellTemplate({
                      'qs': jsnQS,
                      'row': jsnRow,
                      'arrRow': arrRow,
                      'i': i,
                      'len': len
                  });
  
                  // before we do any quoting, we need to add the HTML to the
                  //      HTML copy string
                  strHTMLRecordCopyString +=
                          '<' + 'td rowspan="1" colspan="1">' +
                          strCell +
                          '</td>';
  
                  // if escapeChar !== quoteChar: double up every escapeChar
                  if (escapeChar !== quoteChar) {
                      strCell = stringReplaceAll(
                          strCell,
                          escapeChar,
                          escapeChar + escapeChar
                      );
                  }
  
                  // put an escapeChar behind every quoteChar
                  strCell = stringReplaceAll(
                      strCell,
                      quoteChar,
                      escapeChar + quoteChar
                  );
  
                  // wrap cell with quoteChar
                  strCell = quoteChar + strCell + quoteChar;
  
                  // append cell to copy string
                  strTextCopyString += strCell;
              };
          } else if (quoteMode === 'delimiter-in-content') {
              // string quoting,
              //      template cell with querystring and row
              //      if escapeChar !== quoteChar: double up every escapeChar
              //      if quoteChar inside cell
              //          put an escapeChar behind every quoteChar
              //          wrap cell with quoteChar
              //      append cell to strTextCopyString
              handleCell = function (cellTemplate, i, len, jsnRow, arrRow) {
                  // template cell with querystring and row
                  var strCell = cellTemplate({
                      'qs': jsnQS,
                      'row': jsnRow,
                      'arrRow': arrRow,
                      'i': i,
                      'len': len
                  });
  
                  // before we do any quoting, we need to add the HTML to the
                  //      HTML copy string
                  strHTMLRecordCopyString += (
                      '<' + 'td rowspan="1" colspan="1">' +
                      strCell +
                      '</td>'
                  );
  
                  // if escapeChar !== quoteChar: double up every escapeChar
                  if (escapeChar !== quoteChar) {
                      strCell = stringReplaceAll(
                          strCell,
                          escapeChar,
                          escapeChar + escapeChar
                      );
                  }
  
                  // if quoteChar is inside cell
                  if (strCell.indexOf(quoteChar) !== -1) {
                      // put an escapeChar behind every quoteChar
                      strCell = stringReplaceAll(
                          strCell,
                          quoteChar,
                          escapeChar + quoteChar
                      );
  
                      // wrap cell with quoteChar
                      strCell = quoteChar + strCell + quoteChar;
                  }
  
                  // append cell to copy string
                  strTextCopyString += strCell;
              };
          }
  
          //console.log(
          //    bolHeader,
          //    bolSelector,
          //    strHeader,
          //    arrRows,
          //    arrColumns
          //);
  
          // if the header has selected cells, we need to build the header
          if (bolHeader && headerMode !== 'never') {
              // if there are selectors selected, because the header also
              //      has selected columns we need the all selector to fill
              //      in the space to the left of the header that's made
              //      when there are selectors present
              if (bolSelector && selectorMode !== 'never') {
                  // if the "quoteMode" is "always": we need to add a pair
                  //      of quotes where this extra cell is
                  if (quoteMode === 'always') {
                      strTextCopyString += quoteChar + quoteChar;
                  }
  
                  // and finally, add the delimiter
                  strTextCopyString += cellDelimiter;
  
                  // add an empty cell to the HTML copy string to make room
                  //      for the record selector column
                  strHTMLRecordCopyString += (
                      '<td rowspan="1" colspan="1"></td>'
                  );
              }
  
              //console.log(arrSelectedStates);
              //console.log(arrHeaders.slice(0));
  
              // loop to add the rest of the headers
              col_i = 0;
              col_len = arrColumns.length;
              while (col_i < col_len) {
                  // we want to put a delimiter between each cell
                  if (col_i > 0) {
                      strTextCopyString += cellDelimiter;
                  }
  
                  intSel = arrColumns[col_i];
                  intCol = intSel;
                  if (element.internalDisplay.recordSelectorVisible) {
                      intSel = (arrColumns[col_i] + 1);
                      intCol = (intSel - 1);
                  }
  
                  //console.log(
                  //    col_i,
                  //    intSel,
                  //    intCol,
                  //    strHeader[intSel],
                  //    arrHeaders[intCol]
                  //);
  
                  // template, quote and append cell to copy string
                  if (
                      headerMode === 'always' ||
                      arrSelectedStates.indexOf(strHeader[intSel]) > -1
                  ) {
                      handleCell(arrHeaders[intCol], 0, 0);
  
                  } else {
                      strHTMLRecordCopyString += (
                          '<' + 'td rowspan="1" colspan="1"></td>'
                      );
  
                      if (quoteMode === 'always') {
                          strTextCopyString += quoteChar + quoteChar;
                      }
                  }
  
                  col_i += 1;
              }
  
              // append record to HTML copy string, clear current record variable
              strHTMLCopyString += '<tr>' + strHTMLRecordCopyString + '</tr>';
              strHTMLRecordCopyString = '';
  
              // if there are records selected, we want to seperate the header
              //      and the first row using the record delimiter
              if (arrRows.length > 0) {
                  strTextCopyString += recordDelimiter;
              }
          }
  
          // <br />
          //console.log(arrHeaders.slice(0));
  
          // we cache the number of columns because it doesn't change
          col_len = arrColumns.length;
  
          // we need to get the range
          row_i = 0;
          row_len = arrRows.length;
  
          // loop through the rows
          while (row_i < row_len) {
              intSel = arrRows[row_i];
              intRow = intSel;
              if (element.internalDisplay.headerVisible) {
                  intSel = (arrRows[row_i] + 1);
                  intRow = (intSel - 1);
              }
  
              // we need to know the selection status of this record
              row = arrSelection[intSel];
  
              // generate record JSON for template
              jsnRow = {};
              arrRow = [];
              strRow = element.internalData.records[intRow] + '\t';
  
              cell_i = 0;
              cell_len = 9999;
              while (cell_i < cell_len) {// remember, requires \t at
                                         //       the end of the record
                  delim = strRow.indexOf('\t');
                  cell = strRow.substring(0, delim);
                  strRow = strRow.substring(delim + 1);
  
                  //console.log(arrColumnNames[cell_i], cell);
                  if (cell !== '' || strRow !== '') {
                      jsnRow[arrColumnNames[cell_i]] = (
                          GS.decodeFromTabDelimited(cell, nullString)
                      );
                      arrRow.push(jsnRow[arrColumnNames[cell_i]]);
                  } else {
                      break;
                  }
  
                  cell_i += 1;
              }
              //console.log(jsnRow);
              //console.log(strRow);
              //console.log(arrRow);
  
              // version 1, broken: last cell has one char missing, replaced
              //      with faster solution
              //record_i = 0;
              //record_len = strRow.length;
              //cell_i = 0;
              //cell = "";
              //while (record_i < record_len) {
              //    char = strRow[record_i];
  
              //    if (char === "\t" || record_i === (record_len - 1)) {
              //        jsnRow[arrColumnNames[cell_i]] = (
              //            GS.decodeFromTabDelimited(cell, nullString)
              //        );
  
              //        cell = "";
              //        cell_i += 1;
              //    } else {
              //        cell += char;
              //    }
              //    record_i += 1;
              //}
  
              //console.log(
              //    row_i,
              //    intSel,
              //    intRow,
              //    strRow,
              //    jsnRow
              //);
  
              // if record selectors are allowed: add record number
              if (
                  bolSelector &&
                  (
                      selectorMode === 'always' ||
                      (
                          selectorMode === 'selected' &&
                          arrSelectedStates.indexOf(row[0]) > -1
                      )
                  )
              ) {
                  strTextCopyString += (intRow + 1);
  
                  strHTMLRecordCopyString += (
                      '<td rowspan="1" colspan="1">' + (intRow + 1) + '</td>'
                  );
              }
  
              // no matter if we copied the record selector or not,
              //      we need the delimiter if we are copying some
              //      selectors
              if (bolSelector && col_len > 0) {
                  strTextCopyString += cellDelimiter;
              }
  
              col_i = 0;
              while (col_i < col_len) {
                  // we want to put a delimiter between each cell
                  if (col_i > 0) {
                      strTextCopyString += cellDelimiter;
                  }
  
                  intSel = arrColumns[col_i];
                  intCol = intSel;
                  if (element.internalDisplay.recordSelectorVisible) {
                      intSel = (arrColumns[col_i] + 1);
                      intCol = (intSel - 1);
                  }
  
                  //console.log(
                  //    col_i,
                  //    intSel,
                  //    intCol,
                  //    strHeader[intSel],
                  //    arrHeaders[intCol]
                  //);
  
                  // template, quote and append cell to copy string
                  if (arrSelectedStates.indexOf(row[intSel]) > -1) {
                      handleCell(
                          arrColumnTemplates[arrColumns[col_i]],
                          row_i,
                          row_len,
                          jsnRow,
                          arrRow
                      );
  
                  } else {
                      strHTMLRecordCopyString += (
                          '<' + 'td rowspan="1" colspan="1"></td>'
                      );
  
                      if (quoteMode === 'always') {
                          strTextCopyString += quoteChar + quoteChar;
                      }
                  }
  
                  col_i += 1;
              }
  
              // append record to HTML copy string, clear current record variable
              strHTMLCopyString += '<tr>' + strHTMLRecordCopyString + '</tr>';
              strHTMLRecordCopyString = '';
  
              // add record delimiter (unless we're on the last record)
              if ((row_i + 1) < row_len) {
                  strTextCopyString += recordDelimiter;
              }
              row_i += 1;
          }
  
          // add the ending table tag to the HTML copy string
          strHTMLCopyString += '</table>';
  
          // now we'll take our column and row arrays and convert them to a
          //      text MIME type copy string
          //console.log('arrColumns: ', arrColumns);
          //console.log('arrRows: ', arrRows);
          //console.log('arrSelection: ', arrSelection);
          //console.log('HTML:\n' + strHTMLCopyString);
          //console.log('TEXT:\n' + strTextCopyString);
  
  
  
  
  //
  //
  //            // loop through columns and template
  //            col_i = 0;
  //            while (col_i < col_len) {
  //                intCol = col_i;
  //
  //                // if record selectors are visible, we need to offset
  //                //      where we look for the column select state
  //                if (element.internalDisplay.recordSelectorVisible) {
  //                    intCol = arrColumns[col_i] + 1;
  //                }
  //
  //                // we want to put a delimiter between each cell NEEDS WORK
  //                if (
  //                    arrColumns[col_i - 1] !== 'selector' &&
  //                    arrColumns[col_i - 1] !== undefined
  //                ) {
  //                    strTextCopyString += cellDelimiter;
  //                }
  //
  //                // if this cell is selected: template, quote and
  //                //      append cell to copy string
  //                if (arrSelectedStates.indexOf(row[intCol]) > -1) {
  //                    handleCell(
  //                        arrColumnTemplates[arrColumns[col_i]],
  //                        row_i,
  //                        row_len,
  //                        jsnRow
  //                    );
  //                }
  //
  //                col_i += 1;
  //            }
  //
  //        //console.log(strTextCopyString);
  
          return {
              "text": strTextCopyString,
              "html": strHTMLCopyString
          };
      }
  
  // ############################################################################
  // ############################# RENDER FUNCTIONS #############################
  // ############################################################################
  
      function updateHUD(element) {
          var arrDataColumns;
          var sortASCButton;
          var sortDESCButton;
          var sortClearButton;
          var statusElement;
          var intOriginRecord;
  
          // I don't know who put this here but it wasn't commented. If you put
          //      this here: explain yourself. This is the HUD button status
          //      updating function, this has nothing to do with selection.
          //      I suppose this function is called after a selection so someone
          //      thought they were being clever and decided that this was the
          //      place to trigger such an event. But, I should remind you that
          //      we have a selection render function that may have worked the
          //      same but would have been more consistent and clear.
          //  ~Michael
          GS.triggerEvent(element, 'selection_change');
  
          // disable/enable hud sorting buttons
          sortASCButton = findHudElement(element, 'button-sort-asc');
          sortDESCButton = findHudElement(element, 'button-sort-desc');
          sortClearButton = findHudElement(element, 'button-sort-clear');
  
          // we need an array of the selected data columns
          arrDataColumns = getSelectedDataColumns(element);
  
          //console.log(arrDataColumns);
  
          // if there are data columns selected, enable sort buttons
          if (arrDataColumns.length > 0) {
              if (sortASCButton) {
                  sortASCButton.removeAttribute('disabled');
              }
              if (sortDESCButton) {
                  sortDESCButton.removeAttribute('disabled');
              }
              if (sortClearButton) {
                  sortClearButton.removeAttribute('disabled');
              }
  
          // else, no data columns selected, disable sort buttons
          } else {
              if (sortASCButton) {
                  sortASCButton.setAttribute('disabled', '');
              }
              if (sortDESCButton) {
                  sortDESCButton.setAttribute('disabled', '');
              }
              if (sortClearButton) {
                  sortClearButton.setAttribute('disabled', '');
              }
          }
      }
  
      function renderSelection(element) {//<br />
          var bolHeaders;
          var bolSelectors;
          var bolInsert;
          var col_i;
          var col_len;
          var rec_i;
          var rec_len;
          var strRecord;
          var arrSelection;
          var range_i;
          var range_len;
          var range;
          var arrRanges;
          var arrColumnWidths;
          var rangeStartRow;
          var rangeStartColumn;
          var rangeEndRow;
          var rangeEndColumn;
          var intOriginRecord;
          var jsnSelectedToDeselected;
          var jsnDeselectedToSelected;
          var jsnTranslationMatrix;
          var intRecord;
          var intColumn;
          var intChar;
          var intHeaderIndex;
          var intSelectorIndex;
          var intInsertIndex;
          var jsnRange;
          var strCompareString;
  
          var arrElements;
          var i;
          var len;
          var cell;
          var strRow;
          var strCol;
          var intRow;
          var intCol;
          var arrSelectedStates;
          //var arrDeselectedStates;
  
          var arrColumns;
          var arrRows;
          var intMaxColumns;
          var arrSelectionRows;
          var arrSelectionCols;
          var pushValue;
  
          //console.time('selection total');
  
          // first, we should gather some helper variables.
          bolHeaders = (element.internalDisplay.headerVisible);
          bolSelectors = (!element.hasAttribute('no-record-selector'));
          bolInsert = (element.internalDisplay.insertRecordVisible);
          arrSelection = [];
  
          strCompareString = selectionArrayToString(
              element.internalSelection.ranges
          );
  
          // create the blank slate for the resolved selection
          //      Type:              Unselected:   Selected:
          //      HEADER CELL        A             B
          //      RECORD CELL        C             D
          //      INSERT CELL        E             F
          //      ALL SELECTOR       G             H
          //      RECORD SELECTOR    I             J
          //      INSERT SELECTOR    K             L
          arrSelectedStates = ['B', 'D', 'F', 'H', 'J', 'L'];
          //arrDeselectedStates = ['A', 'C', 'E', 'G', 'I', 'K'];
  
          if (strCompareString === element.internalSelection.rangeCache) {
              arrSelection = element.internalSelection.resolvedSelection;
              arrRanges = element.internalSelection.ranges;
              arrColumnWidths = element.internalDisplay.columnWidths;
              arrRows = element.internalSelection.rows;
              arrColumns = element.internalSelection.columns;
  
              arrSelectionRows = element.internalSelection.rows.slice(0);
              rec_i = 0;
              rec_len = arrSelectionRows.length;
              while (rec_i < rec_len) {
                  if (arrSelectionRows[rec_i] === 'header') {
                      arrSelectionRows[rec_i] = 0;
                  } else if (arrSelectionRows[rec_i] === 'insert') {
                      arrSelectionRows[rec_i] = arrSelection.length - 1;
                  } else {
                      arrSelectionRows[rec_i] += 1;
                  }
                  rec_i += 1;
              }
  
              arrSelectionCols = element.internalSelection.columns.slice(0);
              col_i = 0;
              col_len = arrSelectionCols.length;
              while (col_i < col_len) {
                  if (arrSelectionCols[col_i] === 'selector') {
                      arrSelectionCols[col_i] = 0;
                  } else {
                      arrSelectionCols[col_i] += 1;
                  }
                  col_i += 1;
              }
  
          } else {
              element.internalSelection.rangeCache = strCompareString;
  
              col_len = element.internalDisplay.columnWidths.length;
  
              if (bolHeaders) {
                  strRecord = '';
                  if (bolSelectors) {
                      strRecord += 'G';
                  }
  
                  col_i = 0;
                  while (col_i < col_len) {
                      strRecord += 'A';
                      col_i += 1;
                  }
                  arrSelection.push(strRecord);
              }
  
              strRecord = '';
              if (bolSelectors) {
                  strRecord = 'I';
              }
  
              col_i = 0;
              while (col_i < col_len) {
                  strRecord += 'C';
                  col_i += 1;
              }
  
              rec_i = 0;
              rec_len = element.internalData.records.length;
              while (rec_i < rec_len) {
                  arrSelection.push(strRecord);
                  rec_i += 1;
              }
  
              if (bolInsert) {
                  strRecord = '';
                  if (bolSelectors) {
                      strRecord += 'K';
                  }
  
                  col_i = 0;
                  while (col_i < col_len) {
                      strRecord += 'E';
                      col_i += 1;
                  }
                  arrSelection.push(strRecord);
              }
  
              // console.log(arrSelection);
  
              // because of the vast array of column types, we'll (for simplicity
              //      and for brevity) use one of two matrices, a matrix that
              //      translates a selected cell to a deselected cell and one to
              //      do the opposite
              jsnSelectedToDeselected = {
                  "A": "A",
                  "B": "A",
                  "C": "C",
                  "D": "C",
                  "E": "E",
                  "F": "E",
                  "G": "G",
                  "H": "G",
                  "I": "I",
                  "J": "I",
                  "K": "K",
                  "L": "K"
              };
              jsnDeselectedToSelected = {
                  "A": "B",
                  "B": "B",
                  "C": "D",
                  "D": "D",
                  "E": "F",
                  "F": "F",
                  "G": "H",
                  "H": "H",
                  "I": "J",
                  "J": "J",
                  "K": "L",
                  "L": "L"
              };
  
              // because math is faster that string comparison, we need to convert
              //      the special values inside the ranges to numbers. but, we
              //      don't want to recalculate those numbers every time, so,
              //      we'll calculate them here and just reuse them
              intHeaderIndex = -1;
              intSelectorIndex = -1;
              intInsertIndex = (
                  bolInsert
                      ? (arrSelection.length - 1)
                      : null
              );
              if (bolHeaders) {
                  intInsertIndex -= 1;
              }
  
              //console.log(intInsertIndex);
              //console.time('selection resolve');
  
              // loop through each selection and flip the states of the
              //      affected cells
              arrRanges = element.internalSelection.ranges;
              arrColumnWidths = element.internalDisplay.columnWidths;
              range_i = 0;
              range_len = arrRanges.length;
              while (range_i < range_len) {
                  range = arrRanges[range_i];
  
                  // we want to copy the range element so that when we modify it
                  //      we don't modify the original
                  range = {
                      "start": {
                          "row": range.start.row,
                          "column": range.start.column
                      },
                      "end": {
                          "row": range.end.row,
                          "column": range.end.column
                      },
                      "negator": range.negator
                  };
  
                  //console.log(range);
  
                  // gotta convert special values so that we can use math
                  if (range.start.row === 'header') {
                      range.start.row = intHeaderIndex;
                  } else if (range.start.row === 'insert') {
                      range.start.row = intInsertIndex;
                  }
                  if (range.end.row === 'header') {
                      range.end.row = intHeaderIndex;
                  } else if (range.end.row === 'insert') {
                      range.end.row = intInsertIndex;
                  }
                  if (range.start.column === 'selector') {
                      range.start.column = intSelectorIndex;
                  }
                  if (range.end.column === 'selector') {
                      range.end.column = intSelectorIndex;
                  }
  
                  // because the end of the selection may be above and to the left
                  //      of the start of the selection, we need to be sure that:
                  //          the start row/column is the top-left
                  //          the end row/column is the bottom-right
                  rangeStartRow = Math.min(range.start.row, range.end.row);
                  rangeEndRow = Math.max(range.start.row, range.end.row);
                  rangeStartColumn = Math.min(
                      range.start.column,
                      range.end.column
                  );
                  rangeEndColumn = Math.max(range.start.column, range.end.column);
  
                  // if this is the first selection, save the origin record
                  //      number for future reference
                  if (range_i === 0) {
                      intOriginRecord = rangeStartRow;
  
                      // the header can't be the origin record
                      if (intOriginRecord === -1) {
                          intOriginRecord += 1;
                      }
  
                      // save origin record internally
                      element.internalSelection.originRecord = intOriginRecord;
                  }
  
                  // if we are dealing with a non-negation selection, use the
                  //      jsnDeselectedToSelected translation matrix
                  if (range.negator === false) {
                      jsnTranslationMatrix = jsnDeselectedToSelected;
  
                  // else, use the jsnSelectedToDeselected translation matrix
                  } else {
                      jsnTranslationMatrix = jsnSelectedToDeselected;
                  }
  
                  rec_i = 0;
                  rec_len = arrSelection.length;
                  while (rec_i < rec_len) {
                      strRecord = arrSelection[rec_i];
                      intRecord = rec_i;
  
                      if (bolHeaders) {
                          intRecord -= 1;
                      }
  
                      // if the row is in range or all rows are in the range:
                      //      iterate through cells in the row
                      //console.log(intRecord, rangeStartRow, rangeEndRow);
                      if (
                          (
                              intRecord >= rangeStartRow &&
                              intRecord <= rangeEndRow
                          ) ||
                          (
                              rangeStartRow === -1 &&
                              rangeEndRow === -1
                          )
                      ) {
                          col_i = 0;
                          col_len = strRecord.length;
                          while (col_i < col_len) {
                              intChar = col_i;
                              intColumn = col_i;
  
                              if (bolSelectors) {
                                  intColumn = (col_i - 1);
                              }
  
                              //if (rec_i === 0) {
                              //    //console.log(
                              //        'intChar:',
                              //        intChar,
                              //        'intColumn:',
                              //        intColumn,
                              //        'rangeStartColumn:',
                              //        rangeStartColumn,
                              //        'rangeEndColumn:',
                              //        rangeEndColumn
                              //    );
                              //}
  
                              // testing to see if th cell is in the current
                              //      selection range or that the whole record is
                              //      selected
                              if (
                                  (
                                      (
                                          intColumn >= rangeStartColumn &&
                                          intColumn <= rangeEndColumn
                                      ) ||
                                      (
                                          rangeStartColumn === -1 &&
                                          rangeEndColumn === -1
                                      )
                                  ) &&
                                  // we don't want to copy hidden columns
                                  (
                                      intColumn === null ||
                                      intColumn === -1 ||
                                      arrColumnWidths[intColumn] > 0
                                  )
                              ) {
                                  // set cell to "Y" because it is in the
                                  //      selection range
                                  strRecord = (
                                      strRecord.substr(0, intChar) +
                                      jsnTranslationMatrix[strRecord[intChar]] +
                                      strRecord.substr(intChar + 1)
                                  );
                              }
                              col_i += 1;
                          }
  
                          arrSelection[rec_i] = strRecord;
                      }
  
                      rec_i += 1;
                  }
  
                  range_i += 1;
              }
  
              // now, we'll convert the array of rows to an array of record
              //      numbers that will be copied (arrRows)
              arrRows = [];
              arrSelectionRows = [];
              rec_i = 0;
              rec_len = arrSelection.length;
              while (rec_i < rec_len) {
                  // if the row is selected, add it to the list
                  if ((/[BDFHJL]/gi).test(arrSelection[rec_i])) {
                      if (bolHeaders && rec_i === 0) {
                          arrRows.push('header');
  
                      } else if (bolInsert && rec_i === (rec_len - 1)) {
                          arrRows.push('insert');
  
                      } else if (bolHeaders) {
                          arrRows.push(rec_i - 1);
  
                      } else {
                          arrRows.push(rec_i);
                      }
                      arrSelectionRows.push(rec_i);
                  }
                  rec_i += 1;
              }
  
              // we'll loop through every row that has a selected cell in it
              //      (arrRows) and for every "Y" we'll add the column number
              //      (if it's not already present) to our column array we'll
              //      break out of the loop if all columns are included
              arrColumns = [];
              arrSelectionCols = [];
              intMaxColumns = element.internalClip.columnList.length;
              rec_i = 0;
              rec_len = arrSelectionRows.length;
              while (rec_i < rec_len) {
                  strRecord = arrSelection[arrSelectionRows[rec_i]];
                  col_i = 0;
                  col_len = strRecord.length;
                  while (col_i < col_len) {
                      if (bolSelectors && col_i === 0) {
                          pushValue = ('selector');
                      } else if (bolSelectors) {
                          pushValue = (col_i - 1);
                      } else {
                          pushValue = col_i;
                      }
  
                      if (
                          arrSelectedStates.indexOf(strRecord[col_i]) !== -1 &&
                          arrColumns.indexOf(pushValue) === -1
                      ) {
                          arrColumns.push(pushValue);
                          arrSelectionCols.push(col_i);
                      }
  
                      col_i += 1;
                  }
  
                  if (arrColumns.length >= intMaxColumns) {
                      break;
                  }
  
                  rec_i += 1;
              }
          }
  
          //console.timeEnd('selection resolve');
  
          //var test = arrSelection.join('\n');
          //console.log(test.substring(test.length - 20));
  
          //console.time('selection render');
  
          // grab all visible cells
          arrElements = xtag.query(element.elems.dataViewport, 'gs-cell');
  
          // deselect all visible cells
          i = 0;
          len = arrElements.length;
          while (i < len) {
              arrElements[i].removeAttribute('selected');
              arrElements[i].removeAttribute('origin-record');
              arrElements[i].removeAttribute('auto-selected');
              i += 1;
          }
  
          // select all visible cells that are marked as such in the
          //      resolved selection
          i = 0;
          len = arrElements.length;
          while (i < len) {
              cell = arrElements[i];
              strRow = (
                  cell.getAttribute('data-row-number') ||
                  '-1'
              );
              strCol = (
                  cell.getAttribute('data-col-number') ||
                  cell.getAttribute('data-col') ||
                  '-1'
              );
  
              intRow = parseInt(strRow, 10);
              intCol = parseInt(strCol, 10);
  
              if (bolHeaders) {
                  intRow += 1;
              }
              if (bolSelectors) {
                  intCol += 1;
              }
  
              if (strRow === 'insert') {
                  intRow = (arrSelection.length - 1);
              }
  
              if (strCol === 'selector') {
                  intCol = 0;
              }
  
              // highlight origin record
              if (
                  //(
                  (
                      !bolHeaders &&
                      intRow === intOriginRecord
                  ) ||
                  (
                      bolHeaders &&
                      intRow === (intOriginRecord + 1)
                  )
                  //) &&
                  //(
                  //    !cell.classList.contains('table-insert-selector') &&
                  //    !cell.classList.contains('table-record-selector')
                  //)
              ) {
                  arrElements[i].setAttribute('origin-record', '');
              }
  
              strRecord = arrSelection[intRow];
              //console.log(intRow, intCol, strRecord);
              if (strRecord) {
                  if (arrSelectedStates.indexOf(strRecord[intCol]) > -1) {
                      cell.setAttribute('selected', '');
                      //console.log(
                      //    strRecord,
                      //    intCol,
                      //    intRow,
                      //    cell.getAttribute('data-col-number'),
                      //    cell.getAttribute('data-row-number'),
                      //    cell
                      //);
  
                  // sometimes, the user selects some cells without selecting the
                  //      record selectors and/or headers. in this case, we want
                  //      to highlight the record selectors and headers of the
                  //      selected range
                  } else if (
                      (
                          (
                              cell.classList.contains('table-insert-selector') ||
                              cell.classList.contains('table-record-selector')
                          ) &&
                          (
                              arrSelectionRows.indexOf(intRow) > -1
                          )
                      ) ||
                      (
                          (
                              cell.classList.contains('table-all-selector') ||
                              cell.classList.contains('table-header')
                          ) &&
                          (
                              arrSelectionCols.indexOf(intCol) > -1
                          )
                      )
                  ) {
                      //console.log(strRow, intRow);
                      //console.log(
                      //    arrSelectionRows,
                      //    arrSelectionCols,
                      //    arrRows,
                      //    arrColumns,
                      //    intCol,
                      //    intRow,
                      //    cell.getAttribute('data-col-number'),
                      //    cell.getAttribute('data-row-number'),
                      //    cell
                      //);
                      cell.setAttribute('auto-selected', '');
                  }
              }
  
              i += 1;
          }
  
          //console.timeEnd('selection render');
  
          // store selection variables internally for future reference
          element.internalSelection.resolvedSelection = arrSelection;
          element.internalSelection.rows = arrRows;
          element.internalSelection.columns = arrColumns;
  
          // you are not allowed to deselect everything, if you have, we'll
          //      select what we can and then re-render the selection
          if (arrRows.length === 0 || arrColumns.length === 0) {
              // if there is data and the current range is not already selecting
              //      the first cell, select the first cell
              //console.log(element.internalSelection.ranges);
              jsnRange = element.internalSelection.ranges[0];
  
              if (
                  element.internalData.records.length > 0 && (
                      element.internalSelection.ranges &&
                      (
                          element.internalSelection.ranges.length !== 1 ||
                          jsnRange.start.row !== 0 ||
                          jsnRange.start.column !== 0 ||
                          jsnRange.end.row !== 0 ||
                          jsnRange.end.column !== 0 ||
                          jsnRange.negator !== false
                      )
                  )
              ) {
                  element.internalSelection.ranges = [
                      {
                          "start": {
                              "row": 0,
                              "column": 0
                          },
                          "end": {
                              "row": 0,
                              "column": 0
                          },
                          "negator": false
                      }
                  ];
  
                  // if we are currently selecting with the mouse, stop the
                  //      selection
                  if (element.internalSelection.currentlySelecting) {
                      element.internalEvents.selectDragEnd();
                  }
  
                  // rerender the selection so that the user can see it
                  renderSelection(element);
  
                  // stop execution because we'll be re-running this function
                  //      anyway
                  return;
              }
          }
  
          //console.timeEnd('selection total');
  
          // update hud, because it uses the selection
          updateHUD(element);
      }
  
      //We had an issue where if the viewport was to small everything inside
      //  the viewport would break, this function removes everything inside
      //  the viewport so there's nothing inside there to break, Genius right?
      function renderEmpty(element) {
          element.elems.dataViewport.innerhtml = '';
      }
  
      function renderLocationFull(element) {
          //var arrColumnWidths;
          //var arrRecordHeights;
          //var columnBorderWidth;
          //var recordBorderHeight;
  
          var jsnRange;
          var fromColumn;
          var toColumn;
          var fromRecord;
          var toRecord;
  
          var i;
          var len;
          var col_i;
          var col_len;
          //var record_i;
          //var record_len;
  
          //var intCellLeft;
          //var intCellOriginLeft;
          //var intRecordTop;
          //var intRecordOriginTop;
  
          var arrColumnNames;
          var strHeaderTemplate;
          var strDataTemplate;
          var strInsertTemplate;
  
          var arrElements;
          var strColumn;
          var strValue;
  
          var strRecord;
          var arrRecord;
          var jsnRecord;
          var jsnQS;
          var intTotalRecords;
          var strNullString;
          //var strChar;
          var strCell;
          var strHTML;
          //var strCSS;
          var delim;
  
          //var intRecordSelectorBorderWidth;
          //var intInsertRecordBorderHeight;
          //var intHeaderBorderHeight;
  
          var bolOneCellSelected;
          var selectedCellControl;
          var textSelection;
          var textSelectionStart;
          var textSelectionEnd;
  
          //console.log(element.internalSelection.ranges.length, 1);
          //if (element.internalSelection.ranges.length === 1){
              //console.log(element.internalSelection.ranges[0].start.column);
              //console.log(element.internalSelection.ranges[0].end.column);
              //console.log(element.internalSelection.ranges[0].start.row);
              //console.log(element.internalSelection.ranges[0].end.row);
          //}
  
          // get the first range, we need to know if only one cell is selected
          jsnRange = element.internalSelection.ranges[0];
          bolOneCellSelected = (
              element.internalSelection.ranges.length === 1 &&
              jsnRange.start.column === jsnRange.end.column &&
              jsnRange.start.row === jsnRange.end.row
          );
  
          // if only one cell is selected, we want to save the text selection
          //      so that we can restore it. this is because this function
          //      destroys all cells so the text selection of any of those
          //      cells will be lost.
          if (bolOneCellSelected) {
              selectedCellControl = xtag.query(
                  element,
                  (
                      'gs-cell' +
                          '[data-col-number="' + jsnRange.start.column + '"]' +
                          '[data-row-number="' + jsnRange.start.row + '"]' +
                          ' input'
                  )
              )[0];
              textSelectionStart = 0;
              textSelectionEnd = 0;
  
              //console.log('one cell is selected, save text selection');
  
              if (selectedCellControl) {
                  //console.log(
                  //    selectedCellControl.selectionStart,
                  //    selectedCellControl.selectionEnd
                  //);
                  //textSelectionStart = selectedCellControl.selectionStart;
                  //textSelectionEnd = selectedCellControl.selectionEnd;
  
                  textSelection = GS.getInputSelection(selectedCellControl);
                  textSelectionStart = textSelection.start;
                  textSelectionEnd = textSelection.end;
  
                  //console.log(textSelection);
              }
          }
  
  
          // some code adds classes to the viewport. these need to be removed on
          //      a full re-render
          element.elems.dataViewport.setAttribute('class', 'table-data-viewport');
  
          //// save column widths and record heights for easy access
          //arrColumnWidths = element.internalDisplay.columnWidths;
          //arrRecordHeights = element.internalDisplay.recordHeights;
  
          // we needs the border dimensions to calculate true locations
          //columnBorderWidth = element.internalDisplay.columnBorderWidth;
          //recordBorderHeight = element.internalDisplay.recordBorderHeight;
  
          // save the column name array for quick and easy access
          arrColumnNames = element.internalData.columnNames;
  
          // we want the records to have access to the "qs" variable, so we'll
          //      save the query string JSON to a variable so that we only have
          //      to get it once
          jsnQS = GS.qryToJSON(GS.getQueryString());
  
          // we want the user to be able to have access to the total number of
          //      records in their template so we'll save it to a variable so
          //      that we don't need to recalculate
          intTotalRecords = element.internalData.records.length;
  
          // we want the null string to be configurable, so we'll read the
          //      "null-string" attribute to get the null string
          strNullString = element.getAttribute('null-string');
          //snapback
          // get visible range
          jsnRange = element.internalDisplay.currentRange;
          //intCellOriginLeft = jsnRange.originLeft;
          //intRecordOriginTop = jsnRange.originTop;
          fromColumn = jsnRange.fromColumn;
          toColumn = jsnRange.toColumn;
          fromRecord = jsnRange.fromRecord;
          toRecord = jsnRange.toRecord;
  
          //// we need to know the border sizes so that we can calculate cell
          ////      dimensions
          //intRecordSelectorBorderWidth = (
          //    element.internalDisplay.recordSelectorBorderWidth
          //);
          //intInsertRecordBorderHeight = (
          //    element.internalDisplay.insertRecordBorderHeight
          //);
          //intHeaderBorderHeight = (
          //    element.internalDisplay.headerBorderHeight
          //);
  
          //console.log('element: ', element);
          //console.log('jsnRange: ', jsnRange);
          //console.log('intCellOriginLeft: ', intCellOriginLeft);
          //console.log('intRecordOriginTop: ', intRecordOriginTop);
          //console.log('fromColumn: ', fromColumn);
          //console.log('toColumn: ', toColumn);
          //console.log('fromRecord: ', fromRecord);
          //console.log('toRecord: ', toRecord);
  
          // define strHTML as empty so that we can append to it without
          //      the 'undefinedTEXT THAT YOU APPENDED' issue
          strHTML = '';
  
          // we only want to template the columns that fall into the range of
          //      fromColumn->toColumn, so we'll stick the record template HTML
          //      into a template element, yank out the desired cells and
          //      that'll be the html we template with (and we'll repeat this
          //      process for the header and insert columns)
          if (element.internalTemplates.header.trim()) {
              strHeaderTemplate = templateExtractVisibleCellRange(
                  element,
                  element.internalTemplates.header,
                  fromColumn,
                  toColumn
              );
          }
          if (element.internalTemplates.record.templateHTML.trim()) {
              strDataTemplate = templateExtractVisibleCellRange(
                  element,
                  element.internalTemplates.record.templateHTML,
                  fromColumn,
                  toColumn
              );
          }
          if (element.internalTemplates.insertRecord.trim()) {
              strInsertTemplate = templateExtractVisibleCellRange(
                  element,
                  element.internalTemplates.insertRecord,
                  fromColumn,
                  toColumn
              );
          }
  
          //console.log('strHeaderTemplate: ', strHeaderTemplate);
          //console.log('strDataTemplate:   ', strDataTemplate);
          //console.log('strInsertTemplate: ', strInsertTemplate);
  
          // if there is a record template: build cell elements (first so that
          //      they're below everything)
          if (strDataTemplate) {
              var templateFunc = doT.template(
                  '{{ ' +
                      'var row_number = jo.index + 1;' +
                      'var qs = jo.qs;' +
                      'var row = jo.row;' +
                      'var arrRow = jo.arrRow;' +
                      'var i = jo.index;' +
                      'var len = jo.len;' +
                  '}}' +
                  strDataTemplate
              );
  
              //console.log(fromRecord, toRecord);
              i = fromRecord;
              len = toRecord;
              //intRecordTop = intRecordOriginTop;
              while (i < len) {
                  // create cell array for this record
                  strRecord = element.internalData.records[i] + '\t';
                  arrRecord = [];
                  col_i = 0;
                  col_len = element.internalData.columnNames.length;//9999;
                  while (col_i < col_len) {
                      delim = strRecord.indexOf('\t');
                      strCell = strRecord.substring(0, delim);
                      strRecord = strRecord.substring(delim + 1);
  
                      arrRecord.push(
                          GS.decodeFromTabDelimited(strCell, strNullString)
                      );
  
                      col_i += 1;
                  }
  
                  //record_i = 0;
                  //record_len = strRecord.length;
                  //strCell = "";
                  //arrRecord = [];
                  //while (record_i < record_len) {
                  //    strChar = strRecord[record_i];
  
                  //    if (strChar === "\t") {
                  //        arrRecord.push(
                  //            GS.decodeFromTabDelimited(strCell, strNullString)
                  //        );
                  //        strCell = "";
                  //    } else {
                  //        strCell += strChar;
                  //    }
                  //    record_i += 1;
                  //}
                  //arrRecord.push(strCell);
  
                  // create record JSON from the cell array
                  col_i = 0;
                  col_len = arrRecord.length;
                  jsnRecord = {};
                  while (col_i < col_len) {
                      jsnRecord[arrColumnNames[col_i]] = arrRecord[col_i];
                      col_i += 1;
                  }
  
                  strRecord = strDataTemplate;
  
                  // template with JSON
                  strRecord = templateFunc({
                      'qs': jsnQS,
                      'row': jsnRecord,
                      'arrRow': arrRecord,
                      'index': i,
                      'len': intTotalRecords
                  });
                  //console.log(strRecord)
                  //// replace the css tokens so the cells are in the right place
                  //col_i = fromColumn;
                  //col_len = toColumn;
                  //intCellLeft = intCellOriginLeft;
                  //while (col_i < col_len) {
                  //    // if the column is not hidden
                  //    if (arrColumnWidths[col_i] > 0) {
                  //        //strCSS = (
                  //        //    'top:' + intRecordTop + 'px;' +
                  //        //    'left:' + intCellLeft + 'px;' +
                  //        //    'width:' + (
                  //        //        arrColumnWidths[col_i] +
                  //        //        columnBorderWidth
                  //        //    ) + 'px;' +
                  //        //    'height:' + (
                  //        //        arrRecordHeights[i] +
                  //        //        recordBorderHeight
                  //        //    ) + 'px;'
                  //        //);
                  //        strCSS = '';
  
                  //        strRecord = strRecord.replace(
                  //            '$$CSSREPLACETOKEN$$',
                  //            strCSS
                  //        );
  
                  //        intCellLeft += arrColumnWidths[col_i];
                  //        intCellLeft += columnBorderWidth;
                  //    }
                  //    col_i += 1;
                  //}
  
                  // append record to html
                  strHTML += strRecord;
  
                  //// increment record top so that the next record
                  ////      shows below this one
                  //intRecordTop += arrRecordHeights[i];
                  //intRecordTop += recordBorderHeight;
                  i += 1;
              }
          }
  
          // because we prevent templating into other element's templates (the
          //      ones with a "src" attribute) by "hiding" (by replacing them
          //      with a random token and storing the token-template relationship)
          //      them, we have to "show" them (by replacing the token with the
          //      original template strings) at this step
          GS.templateShowSubTemplates(strHTML, element.internalTemplates.record);
  
          //// we need to use the dimensions of the header, record selectors and
          ////      the insert record, so we'll stick them in these variables for
          ////      easy access
          //var intHeaderHeight;
          //var intRecordSelectorWidth;
          //var intInsertRecordHeight;
  
          //intHeaderHeight = element.internalDisplay.headerHeight;
          //intRecordSelectorWidth = element.internalDisplay.recordSelectorWidth;
          //intInsertRecordHeight = element.internalDisplay.insertRecordHeight;
  
          // if there's a header: build column headings (second so that they're
          //      above cells)
          if (strHeaderTemplate) {
              strRecord = strHeaderTemplate;
  
              //col_i = fromColumn;
              //col_len = toColumn;
              //intCellLeft = intCellOriginLeft;
              //while (col_i < col_len) {
              //    // if the column is not hidden
              //    if (arrColumnWidths[col_i] > 0) {
              //        //strCSS = (
              //        //    'top:0;' +
              //        //    'left:' + intCellLeft + 'px;' +
              //        //    'width:' + (
              //        //        arrColumnWidths[col_i] +
              //        //        columnBorderWidth
              //        //    ) + 'px;' +
              //        //    'height:' + (
              //        //        intHeaderHeight +
              //        //        intHeaderBorderHeight
              //        //    ) + 'px;'
              //        //);
              //        strCSS = '';
  
              //        strRecord = strRecord.replace(
              //            '$$CSSREPLACETOKEN$$',
              //            strCSS
              //        );
  
              //        intCellLeft += arrColumnWidths[col_i];
              //        intCellLeft += columnBorderWidth;
              //    }
              //    col_i += 1;
              //}
  
              strRecord = handleHeaderTemplateTokens(
                  element,
                  strRecord,
                  fromColumn,
                  toColumn
              );
  
              strHTML += strRecord;
          }
  
          // because we prevent templating into other element's templates (the
          //      ones with a "src" attribute) by "hiding" (by replacing them
          //      with a random token and storing the token-template relationship)
          //      them, we have to "show" them (by replacing the token with the
          //      original template strings) at this step
          GS.templateShowSubTemplates(strHTML, element.internalTemplates.record);
  
          // if there's a insert record: build it and append to HTML
          if (strInsertTemplate) {
              strRecord = strInsertTemplate;
  
              //col_i = fromColumn;
              //col_len = toColumn;
              //intCellLeft = intCellOriginLeft;
              //while (col_i < col_len) {
              //    // if the column is not hidden
              //    if (arrColumnWidths[col_i] > 0) {
              //        //strCSS = (
              //        //    'top:' + intRecordTop + 'px;' +
              //        //    'left:' + intCellLeft + 'px;' +
              //        //    'width:' + (
              //        //        arrColumnWidths[col_i] +
              //        //        columnBorderWidth
              //        //    ) + 'px;' +
              //        //    'height:' + (
              //        //        intInsertRecordHeight +
              //        //        intInsertRecordBorderHeight
              //        //    ) + 'px;'
              //        //);
              //        strCSS = '';
  
              //        strRecord = strRecord.replace(
              //            '$$CSSREPLACETOKEN$$',
              //            strCSS
              //        );
  
              //        intCellLeft += arrColumnWidths[col_i];
              //        intCellLeft += columnBorderWidth;
              //    }
              //    col_i += 1;
              //}
  
              strHTML += strRecord;
          }
  
          // if record selectors haven't been disabled: build record selectors
          //      (third so that they're above cells)
          if (!element.hasAttribute('no-record-selector')) {
              if (element.getAttribute('update-dialog') === 'show') {
                  i = fromRecord;
                  len = toRecord;
                  //intRecordTop = intRecordOriginTop;
                  while (i < len) {
                      //strCSS = '';
  
                      strHTML += (
                          '<gs-cell class="table-record-selector multi-update" ' +
                          //'    style="' + strCSS + '" ' +
                          '    data-row-number="' + i + '" ' +
                          '    data-col="selector" ' +
                          '    title="Record #' + (i + 1) + '">' +
                          '    <div class="table-multi-update-button"></div>' +
                          '</gs-cell>'
                      );
  
                      //intRecordTop += arrRecordHeights[i];
                      //intRecordTop += recordBorderHeight;
                      i += 1;
                  }
              } else {
                  i = fromRecord;
                  len = toRecord;
                  //intRecordTop = intRecordOriginTop;
                  while (i < len) {
                      //strCSS = (
                      //    'top:' + intRecordTop + 'px;' +
                      //    'left:0;' +
                      //    'width:' + (
                      //        intRecordSelectorWidth +
                      //        intRecordSelectorBorderWidth
                      //    ) + 'px;' +
                      //    'height:' + (
                      //        arrRecordHeights[i] +
                      //        recordBorderHeight
                      //    ) + 'px;'
                      //);
  
                      strHTML += (
                          '<gs-cell class="table-record-selector" ' +
                          //'    style="' + strCSS + '" ' +
                          '    data-row-number="' + i + '" ' +
                          '    data-col="selector" ' +
                          '    title="Record #' + (i + 1) + '">' +
                          (i + 1) +
                          '</gs-cell>'
                      );
  
                      //intRecordTop += arrRecordHeights[i];
                      //intRecordTop += recordBorderHeight;
                      i += 1;
                  }
              }
          }
  
          // if there's an insert record and record selectors haven't been
          //      disabled: build top-left/select all cell (forth so that it's
          //      above record selectors)
          if (strInsertTemplate && !element.hasAttribute('no-record-selector')) {
              //strCSS = (
              //    'top:' + intRecordTop + 'px;' +
              //    'left:0;' +
              //    'width:' + (
              //        intRecordSelectorWidth +
              //        intRecordSelectorBorderWidth
              //    ) + 'px;' +
              //    'height:' + (
              //        intInsertRecordHeight +
              //        intInsertRecordBorderHeight
              //    ) + 'px;'// +
              //    //'line-height:' + (   <-- used with &gt;
              //    //    intInsertRecordHeight +
              //    //    intInsertRecordBorderHeight
              //    //) + 'px;'
              //);
  
              strHTML += (
                  '<gs-cell class="table-insert-selector"' +
                      //' style="' + strCSS + '"' +
                      ' data-row-number="insert"' +
                      ' data-col="selector">*</gs-cell>' //&gt;
              );
          }
  
          // if there's a header and record selectors haven't been disabled: build
          //      top-left/select all cell (last so that it's above all)
          if (strHeaderTemplate && !element.hasAttribute('no-record-selector')) {
              //strCSS = (
              //    'top:0;' +
              //    'left:0;' +
              //    'width:' + (
              //        intRecordSelectorWidth +
              //        intRecordSelectorBorderWidth
              //    ) + 'px;' +
              //    'height:' + (
              //        intHeaderHeight +
              //        intHeaderBorderHeight
              //    ) + 'px;' +
              //    'line-height:' + (
              //        intHeaderHeight +
              //        intHeaderBorderHeight
              //    ) + 'px;'
              //);
  
              strHTML += (
                  '<gs-cell class="table-all-selector"' +
                      //' style="' + strCSS + '"' +
                      ' data-col="selector">#</gs-cell>'
              );
          }
  
          // if there's no data, lets tell the user
          if (element.internalData.records.length === 0) {
              strHTML += '<div class="no-data-label">No Data</div>';
          }
  
          // we want to give the user some feedback about their scrolling position
          //      so, we'll add shadows on sides that have room to scroll in how
          //      this'll need to work is we'll need to add a shadow element at a
          //      z-index above cells but below record selectors, the all selector
          //      and header cells
          //// ### NEED CODING ###
          //strHTML += window.separate1js_html(element);
  
          // fill the data viewport with the rendered cells
  
          // version 1
          //element.elems.dataViewport.innerHTML = strHTML;
  
          // version 2
          //element.elems.dataContainer.removeChild(element.elems.dataViewport);
          //element.elems.dataViewport = '';
          //element.elems.dataViewport.innerHTML = strHTML;
          //element.elems.dataContainer.appendChild(
          //    element.elems.dataViewport
          //);
  
          // version 3
          element.elems.dataContainer.removeChild(element.elems.dataViewport);
          i = 0;
          len = element.elems.dataViewport.children.length;
          while (i < len) {
              element.elems.dataViewport.removeChild(
                  element.elems.dataViewport.lastChild
              );
              i += 1;
          }
          element.elems.dataViewport.innerHTML = strHTML;
          element.elems.dataContainer.appendChild(
              element.elems.dataViewport
          );
  
          //// version 4
          //var newViewport = element.elems.dataViewport.cloneNode(false);
  
          //newViewport.innerHTML = strHTML;
          //element.elems.dataContainer.replaceChild(
          //    newViewport,
          //    element.elems.dataViewport
          //);
  
  
          //element.elems.dataViewport = newViewport;
  
          // fill insert columns with retained values
          arrElements = xtag.query(
              element.elems.dataViewport,
              '.table-insert [column]'
          );
          col_i = 0;
          col_len = arrElements.length;
          while (col_i < col_len) {
              strColumn = arrElements[col_i].getAttribute('column');
              strValue = element.internalData.insertRecord[strColumn];
  
              // if a value was retained for the current column
              if (strValue) {
                  // fill control with retained value
                  arrElements[col_i].value = strValue;
              }
              col_i += 1;
          }
  
          // render cell selection
          renderSelection(element);
  
          // if there is only one cell control selected and there is a text
          //      selection that has been saved: restore the text selection
          //      in the new control
          if (
              selectedCellControl &&
              (
                  textSelectionStart > 0 ||
                  textSelectionEnd > 0
              )
          ) {
              jsnRange = element.internalSelection.ranges[0];
  
              if (jsnRange) {
                  selectedCellControl = xtag.query(
                      element,
                      (
                          'gs-cell' +
                              '[data-col-number="' + jsnRange.start.column + '"]' +
                              '[data-row-number="' + jsnRange.start.row + '"]' +
                              ' input'
                      )
                  )[0];
  
                  //console.log(selectedCellControl);
  
                  if (selectedCellControl) {
                      //selectedCellControl.setSelectionRange(
                      //    textSelectionStart,
                      //    textSelectionEnd
                      //);
                      GS.setInputSelection(
                          selectedCellControl,
                          textSelectionStart,
                          textSelectionEnd
                      );
                  }
              }
          }
      }
  
      // when you are scrolling, a lot of elements don't leave the screen. So,
      //      this function removes the elements that are no longer visible and
      //      then creates elements that are not visible based on the viewport.
      function renderLocationPartial(element) {
          //var arrColumnWidths;
          //var arrRecordHeights;
          //var columnBorderWidth;
          //var recordBorderHeight;
          //var intRecordSelectorBorderWidth;
          //var intInsertRecordBorderHeight;
          //var intHeaderBorderHeight;
  
          var strRow;
          var strCol;
  
          var jsnOldRange;
          var jsnRange;
          var fromColumn;
          var toColumn;
          var fromRecord;
          var toRecord;
          var bolInsertRecord;
  
          //var intCellOriginLeft;
          //var intRecordOriginTop;
          //var intCellLeft;
          //var intCellTop;
  
          var arrColumnNames;
          var jsnQS;
          var intTotalRecords;
          var strNullString;
  
          var intRowNumber;
          var intColNumber;
  
          //var arrColumnLeft;
          //var arrRecordTop;
  
          var arrElements;
          var strColumn;
          var strValue;
  
          var bolUp;
          var bolDown;
          var bolInsert;
          var bolLeft;
          var bolRight;
  
          var i;
          var len;
          var arrCell;
          var cell;
          var cell_i;
          var cell_len;
          var col_i;
          var col_len;
          //var row_i;
          //var row_len;
  
          var strDownTemplate;
          var strUpTemplate;
          var strInsertTemplate;
          var strLeftHeaderTemplate;
          var strLeftRecordTemplate;
          var strLeftInsertTemplate;
          var strRightHeaderTemplate;
          var strRightRecordTemplate;
          var strRightInsertTemplate;
  
          var strHTML;
          var cellElement;
  
          //// save column widths and record heights for easy access
          //arrColumnWidths = element.internalDisplay.columnWidths;
          //arrRecordHeights = element.internalDisplay.recordHeights;
  
          //// we needs the border dimensions to calculate true locations
          //columnBorderWidth = element.internalDisplay.columnBorderWidth;
          //recordBorderHeight = element.internalDisplay.recordBorderHeight;
  
          //// we need to know the border sizes so that we can calculate cell
          ////      dimensions
          //intRecordSelectorBorderWidth = (
          //    element.internalDisplay.recordSelectorBorderWidth
          //);
          //intInsertRecordBorderHeight = (
          //    element.internalDisplay.insertRecordBorderHeight
          //);
          //intHeaderBorderHeight = (
          //    element.internalDisplay.headerBorderHeight
          //);
  
          // save the column name array for quick and easy access
          arrColumnNames = element.internalData.columnNames;
  
          // we want the records to have access to the "qs" variable, so we'll
          //      save the query string JSON to a variable so that we only have
          //      to get it once
          jsnQS = GS.qryToJSON(GS.getQueryString());
  
          // we want the user to be able to have access to the total number of
          //      records in their template so we'll save it to a variable so
          //      that we don't need to recalculate
          intTotalRecords = element.internalData.records.length;
  
          // we want the null string to be configurable, so we'll read the
          //      "null-string" attribute to get the null string
          strNullString = element.getAttribute('null-string');
  
          //// we need to use the dimensions of the header, record selectors and
          ////      the insert record, so we'll stick them in these variables for
          ////      easy access
          //var intHeaderHeight;
          //var intRecordSelectorWidth;
          //var intInsertRecordHeight;
  
          //intHeaderHeight = element.internalDisplay.headerHeight;
          //intRecordSelectorWidth = element.internalDisplay.recordSelectorWidth;
          //intInsertRecordHeight = element.internalDisplay.insertRecordHeight;
  
          // get old visible range
          jsnOldRange = element.internalDisplay.prevRange;
  
          // get visible range
          jsnRange = element.internalDisplay.currentRange;
          //intCellOriginLeft = jsnRange.originLeft;
          //intRecordOriginTop = jsnRange.originTop;
          fromColumn = jsnRange.fromColumn;
          toColumn = jsnRange.toColumn;
          fromRecord = jsnRange.fromRecord;
          toRecord = jsnRange.toRecord;
          bolInsertRecord = jsnRange.insertRecord;
  
          // we create a record selector in multiple places, so to prevent code
          //      duplication, we'll use a function
          var createRecordSelector;
  
          // sometimes, the developer decide that record selectors are not what
          //      they want, in that case, don't create them
          if (element.hasAttribute('no-record-selector')) {
              createRecordSelector = function () {};
          } else {
              createRecordSelector = function (index) {
                  cellElement = document.createElement('gs-cell');
                  //cellElement.style.width = (
                  //    (
                  //        intRecordSelectorWidth +
                  //        intRecordSelectorBorderWidth
                  //    ) + 'px'
                  //);
                  //cellElement.style.height = (
                  //    (
                  //        arrRecordHeights[index] +
                  //        recordBorderHeight
                  //    ) + 'px'
                  //);
                  cellElement.classList.add('table-record-selector');
                  cellElement.setAttribute('data-row-number', index);
                  cellElement.setAttribute('data-col', 'selector');
                  cellElement.setAttribute('title', 'Record #' + (index + 1));
  
                  if (element.getAttribute('update-dialog') === 'show') {
                      cellElement.classList.add('multi-update');
                      cellElement.innerHTML = (
                          '<div class="table-multi-update-button"></div>'
                      );
                  } else {
                      cellElement.textContent = (index + 1);
                  }
  
                  element.elems.dataViewport.appendChild(cellElement);
              };
          }
  
          // we create a record in multiple places, so to prevent code
          //      duplication, we'll use a function
          var createRecord = function (strTemplate, index) {
              var strRecord;
              var arrRecord;
              var jsnRecord;
              //var strCell;
              //var strChar;
              //var record_i;
              //var record_len;
              var strCell;
              var delim;
              var cell_i;
              var cell_len;
  
              // get text of the record data
              strRecord = element.internalData.records[index] + '\t';
  
              // create cell array for this record
              arrRecord = [];
              //console.log(element.internalData.columnNames.length);
              cell_i = 0;
              cell_len = element.internalData.columnNames.length;//9999;
              while (cell_i < cell_len) {
                  delim = strRecord.indexOf('\t');
                  strCell = strRecord.substring(0, delim);
                  strRecord = strRecord.substring(delim + 1);
  
                  //if (strCell !== '' || strRecord !== '') {
                  arrRecord.push(
                      GS.decodeFromTabDelimited(strCell, strNullString)
                  );
                  //} else {
                  //    break;
                  //}
  
                  cell_i += 1;
              }
  
              //record_i = 0;
              //record_len = strRecord.length;
              //strCell = "";
              //arrRecord = [];
              //while (record_i < record_len) {
              //    strChar = strRecord[record_i];
  
              //    if (strChar === "\t") {
              //        arrRecord.push(
              //            GS.decodeFromTabDelimited(strCell, strNullString)
              //        );
              //        strCell = "";
              //    } else {
              //        strCell += strChar;
              //    }
              //    record_i += 1;
              //}
              //arrRecord.push(strCell);
  
              // create record JSON from the cell array
              // the reason we want JSON is so that the template can easily
              //      reference things by column name
              col_i = 0;
              col_len = arrRecord.length;
              jsnRecord = {};
              while (col_i < col_len) {
                  jsnRecord[arrColumnNames[col_i]] = arrRecord[col_i];
                  col_i += 1;
              }
  
              // template with JSON - in the future, we need to change this to
              //      use the dot.js once for all the cells because templating
              //      each record individually is slow ### NEED CODING ###
              strRecord = (
                  '{{' +
                      'var row_number = jo.index + 1;' +
                      'var qs = jo.qs;' +
                      'var row = jo.row;' +
                      'var arrRow = jo.arrRow;' +
                      'var i = jo.index;' +
                      'var len = jo.len;' +
                  '}}' +
                  strTemplate
              );
  
              strRecord = doT.template(strRecord)({
                  'qs': jsnQS,
                  'row': jsnRecord,
                  'arrRow': arrRecord,
                  'index': index,
                  'len': intTotalRecords
              });
  
              //console.log(strRecord);
  
              // return record html
              return strRecord;
          };
  
          var createNonDataCells = function (strTemplate) {
              var strRecord;
  
              //// replace the css tokens so the cells are in the right place
              //strRecord = strTemplate.replace(/\$\$CSSREPLACETOKEN\$\$/gi, '');
              strRecord = strTemplate;
  
              // template with JSON - in the future, we need to change this to
              //      use the dot.js once for all the cells because templating
              //      each record individually is slow ### NEED CODING ###
              strRecord = '{{ var qs = jo.qs; }}' + strRecord;
  
              strRecord = doT.template(strRecord)({'qs': jsnQS});
  
              //console.log(strRecord);
  
              // return record html
              return strRecord;
          };
  
  
          // steps:
          //      remove all cells that are not in the current range
          //      create data cells
          //      create headers
          //      create record selectors
          //      create insert record cells
          //      calculate left and top values
          //      reposition all the cells to their correct locations
  
  
  
          // loop through the cells, if the current cell is not in the current
          //      viewport range, delete it
          var arrDoomed = [];
          arrCell = xtag.queryChildren(
              element.elems.dataViewport,
              '[data-row-number], [data-col-number]'
          );
          cell_i = 0;
          cell_len = arrCell.length;
          while (cell_i < cell_len) {
              cell = arrCell[cell_i];
              strRow = cell.getAttribute('data-row-number');
              strCol = cell.getAttribute('data-col-number');
              intRowNumber = parseInt(strRow, 10);
              intColNumber = parseInt(strCol, 10);
  
              if (
                  intColNumber < fromColumn ||
                  intRowNumber < fromRecord ||
                  // toColumn is the index of the column after the last visible
                  //      column, hence the equal. This fixes the issue of the
                  //      partial render not removing the last record
                  //      occasionally while scrolling
                  intColNumber >= toColumn ||
                  // toRecord is the index of the record after the last visible
                  //      record, hence the equal. This fixes the issue of the
                  //      partial render not removing the last record
                  //      occasionally while scrolling
                  intRowNumber >= toRecord ||
                  (
                      bolInsertRecord === false &&
                      strRow === 'insert'
                  )
              ) {
                  arrDoomed.push(arrCell[cell_i]);
                  //element.elems.dataViewport.removeChild(arrCell[cell_i]);
              }
  
              cell_i += 1;
          }
  
          var deleteNext = function () {
              //element.elems.dataViewport.removeChild(arrDoomed.pop());
              //if (arrDoomed.length > 0) {
              //    requestAnimationFrame(deleteNext);
              //}
  
              cell_i = 0;
              cell_len = arrDoomed.length;
              while (cell_i < cell_len) {
                  if (
                      arrDoomed[cell_i].parentNode === element.elems.dataViewport
                  ) {
                      element.elems.dataViewport.removeChild(arrDoomed[cell_i]);
                  }
                  cell_i += 1;
              }
          };
          if (window.requestAnimationFrame) {
              window.requestAnimationFrame(deleteNext);
          } else {
              deleteNext();
          }
  
          // create data cells
          // create headers
          // create record selectors
          // create insert record cells
  
          // because you can scroll on the X and Y axis at the same time:
          //      we need to know what columns and what rows to create and in
          //      what directions
          // find out what directions to create cells in
          bolUp = (
              fromRecord < jsnOldRange.fromRecord
          );
          bolDown = (
              toRecord > jsnOldRange.toRecord
          );
          bolInsert = (
              bolInsertRecord === true &&
              bolInsertRecord !== jsnOldRange.insertRecord
          );
          bolLeft = (
              fromColumn < jsnOldRange.fromColumn
          );
          bolRight = (
              toColumn > jsnOldRange.toColumn
          );
  
          //console.log(jsnOldRange, jsnRange);
          //console.log(
          //    'Up: ' + bolUp,
          //    'Down: ' + bolDown,
          //    'Left: ' + bolLeft,
          //    'Right: ' + bolRight
          //);
  
          // if we need to create records, get a record template
          if (bolUp || bolDown) {
              // we only want to template the columns that fall into the range of
              //      fromColumn->toColumn, so we'll stick the record template
              //      HTML into a template element, yank out the desired cells and
              //      that'll be the html we template with
              if (element.internalTemplates.record.templateHTML.trim()) {
                  strUpTemplate = templateExtractVisibleCellRange(
                      element,
                      element.internalTemplates.record.templateHTML,
                      fromColumn,
                      toColumn
                  );
  
                  //// replace the css tokens so that they don't interfere
                  //strUpTemplate = (
                  //    strUpTemplate
                  //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                  //);
  
                  // for now, the down and up templates are exactly the same. we
                  //      could use one variable for the down and up templates,
                  //      but, in the future, there may be reason to separate
                  //      them. so, I'm just going to copy the up template into
                  //      the down template variable
                  strDownTemplate = strUpTemplate;
              }
  
              //console.log(strDownTemplate, strUpTemplate);
          }
  
          // if we need columns on the left, get the template
          if (bolLeft) {
              // we only want to template the columns that fall into the range of
              //      fromColumn->toColumn, so we'll stick the record template
              //      HTML into a template element, yank out the desired cells and
              //      that'll be the html we template with (and we'll repeat this
              //      process for the header and insert columns)
  
              // header cells
              if (element.internalTemplates.header.trim()) {
                  strLeftHeaderTemplate = templateExtractVisibleCellRange(
                      element,
                      element.internalTemplates.header,
                      jsnRange.fromColumn,
                      jsnOldRange.fromColumn
                  );
                  strLeftHeaderTemplate = handleHeaderTemplateTokens(
                      element,
                      strLeftHeaderTemplate,
                      jsnRange.fromColumn,
                      jsnOldRange.fromColumn
                  );
                  //// replace the css tokens so that they don't interfere
                  //strLeftHeaderTemplate = (
                  //    strLeftHeaderTemplate
                  //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                  //);
              }
              // record cells
              if (element.internalTemplates.record.templateHTML.trim()) {
                  strLeftRecordTemplate = templateExtractVisibleCellRange(
                      element,
                      element.internalTemplates.record.templateHTML,
                      jsnRange.fromColumn,
                      jsnOldRange.fromColumn
                  );
                  //// replace the css tokens so that they don't interfere
                  //strLeftRecordTemplate = (
                  //    strLeftRecordTemplate
                  //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                  //);
              }
              // insert cells
              if (
                  // if there is an insert template
                  element.internalTemplates.insertRecord.trim() &&
                  // if the insert record has already been added
                  !bolInsert
              ) {
                  strLeftInsertTemplate = templateExtractVisibleCellRange(
                      element,
                      element.internalTemplates.insertRecord,
                      jsnRange.fromColumn,
                      jsnOldRange.fromColumn
                  );
                  //// replace the css tokens so that they don't interfere
                  //strLeftInsertTemplate = (
                  //    strLeftInsertTemplate
                  //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                  //);
              }
  
              //console.log(
              //    strLeftHeaderTemplate,
              //    strLeftRecordTemplate,
              //    strLeftInsertTemplate
              //);
          }
  
          // if we need columns on the right, get the template
          if (bolRight) {
              // we only want to template the columns that fall into the range of
              //      fromColumn->toColumn, so we'll stick the record template
              //      HTML into a template element, yank out the desired cells and
              //      that'll be the html we template with (and we'll repeat this
              //      process for the header and insert columns)
  
              // header cells
              if (element.internalTemplates.header.trim()) {
                  strRightHeaderTemplate = templateExtractVisibleCellRange(
                      element,
                      element.internalTemplates.header,
                      jsnOldRange.toColumn,
                      jsnRange.toColumn
                  );
                  strRightHeaderTemplate = handleHeaderTemplateTokens(
                      element,
                      strRightHeaderTemplate,
                      jsnOldRange.toColumn,
                      jsnRange.toColumn
                  );
                  //// replace the css tokens so that they don't interfere
                  //strRightHeaderTemplate = (
                  //    strRightHeaderTemplate
                  //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                  //);
              }
              // record cells
              if (element.internalTemplates.record.templateHTML.trim()) {
                  strRightRecordTemplate = templateExtractVisibleCellRange(
                      element,
                      element.internalTemplates.record.templateHTML,
                      jsnOldRange.toColumn,
                      jsnRange.toColumn
                  );
                  //// replace the css tokens so that they don't interfere
                  //strRightRecordTemplate = (
                  //    strRightRecordTemplate
                  //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                  //);
              }
              // insert cells
              if (
                  // if there is an insert template
                  element.internalTemplates.insertRecord.trim() &&
                  // if the insert record has already been added
                  !bolInsert
              ) {
                  strRightInsertTemplate = templateExtractVisibleCellRange(
                      element,
                      element.internalTemplates.insertRecord,
                      jsnOldRange.toColumn,
                      jsnRange.toColumn
                  );
                  //// replace the css tokens so that they don't interfere
                  //strRightInsertTemplate = (
                  //    strRightInsertTemplate
                  //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                  //);
              }
  
              //console.log(
              //    strRightHeaderTemplate,
              //    strRightRecordTemplate,
              //    strRightInsertTemplate
              //);
          }
  
          // define strHTML as empty so that we can append to it without
          //      the 'undefinedTEXT THAT YOU APPENDED' issue
          strHTML = '';
  
          // if we need to add cells above the old visible range
          if (bolUp) {
              i = jsnRange.fromRecord;
              len = jsnOldRange.fromRecord;
              while (i < len) {
                  // record selector cell
                  createRecordSelector(i);
  
                  // record cells
                  strHTML += createRecord(strUpTemplate, i);
  
                  i += 1;
              }
          }
  
          // if we need to add cells below the old visible range
          if (bolDown) {
              i = jsnOldRange.toRecord;
              len = jsnRange.toRecord;
              while (i < len) {
                  // record selector cell
                  createRecordSelector(i);
  
                  // record cells
                  strHTML += createRecord(strDownTemplate, i);
  
                  i += 1;
              }
          }
  
          // if we need to add the insert record=
          if (bolInsert) {
              strInsertTemplate = '';
  
              if (!element.hasAttribute('no-record-selector')) {
                  strInsertTemplate += (
                      '<gs-cell ' +
                              'class="table-insert-selector"' +
                              ' data-row-number="insert"' +
                              ' data-col="selector">*' + //&gt;
                      '</gs-cell>'
                  );
              }
  
              strInsertTemplate += (
                  templateExtractVisibleCellRange(
                      element,
                      element.internalTemplates.insertRecord,
                      jsnRange.fromColumn,
                      jsnRange.toColumn
                  )
              );
  
              //// replace the css tokens so that they don't interfere
              //strInsertTemplate = (
              //    strInsertTemplate
              //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
              //);
  
              strHTML += createNonDataCells(strInsertTemplate);
          }
  
          // if we need to add cells to the left of the old visible range
          //      one thing to note is that the up and down templating takes
          //      care of the left and right columns for those records, this
          //      code takes care of the left columns for the existing records
          if (bolLeft) {
              // header cells
              if (strLeftHeaderTemplate) {
                  strHTML += createNonDataCells(strLeftHeaderTemplate);
              }
  
              // record cells
              if (strLeftRecordTemplate) {
                  // loop through records that overlap from the old visible
                  //      range and the new visible range
  
                  if (bolUp) {
                      i = jsnOldRange.fromRecord;
                      len = jsnRange.toRecord;
                  } else if (bolDown) {
                      i = jsnRange.fromRecord;
                      len = jsnOldRange.toRecord;
                  } else {
                      i = jsnRange.fromRecord;
                      len = jsnRange.toRecord;
                  }
  
                  while (i < len) {
                      strHTML += createRecord(strLeftRecordTemplate, i);
  
                      i += 1;
                  }
              }
  
              // insert cells
              if (strLeftInsertTemplate) {
                  strHTML += createNonDataCells(strLeftInsertTemplate);
              }
          }
  
          // if we need to add cells to the right of the old visible range
          //      one thing to note is that the up and down templating takes
          //      care of the left and right columns for those records, this
          //      code takes care of the right columns for the existing records
          if (bolRight) {
              // header cells
              if (strRightHeaderTemplate) {
                  strHTML += createNonDataCells(strRightHeaderTemplate);
              }
  
              // record cells
              if (strRightRecordTemplate) {
                  // loop through records that overlap from the old visible
                  //      range and the new visible range
  
                  if (bolUp) {
                      i = jsnOldRange.fromRecord;
                      len = jsnRange.toRecord;
                  } else if (bolDown) {
                      i = jsnRange.fromRecord;
                      len = jsnOldRange.toRecord;
                  } else {
                      i = jsnRange.fromRecord;
                      len = jsnRange.toRecord;
                  }
  
                  while (i < len) {
                      strHTML += createRecord(strRightRecordTemplate, i);
  
                      i += 1;
                  }
              }
  
              // insert cells
              if (strRightInsertTemplate) {
                  strHTML += createNonDataCells(strRightInsertTemplate);
              }
          }
  
          // because we prevent templating into other element's templates (the
          //      ones with a "src" attribute) by "hiding" (by replacing them
          //      with a random token and storing the token-template relationship)
          //      them, we have to "show" them (by replacing the token with the
          //      original template strings) at this step
          strHTML = GS.templateShowSubTemplates(
              strHTML,
              element.internalTemplates.record
          );
  
          //console.log(strHTML);
  
          // we want to append the html and have the elements to initialize
          //      while in the DOM, so we'll use the recently discovered and
          //      compatible element.insertAdjacentHTML
  
          // version 2
          //element.elems.dataContainer.removeChild(element.elems.dataViewport);
          //element.elems.dataViewport.insertAdjacentHTML('beforeend', strHTML);
          //element.elems.dataContainer.appendChild(element.elems.dataViewport);
  
          // version 3
          //var test = document.createElement('div');
          //test.innerHTML = strHTML;
          //element.elems.dataViewport.appendChild(test);
  
          if (document.createDocumentFragment) {
              // version 4
              var divElement = document.createElement('div');
              var transferFragment = document.createDocumentFragment();
              divElement.innerHTML = strHTML;
  
              i = 0;
              len = divElement.children.length;
              while (i < len) {
                  transferFragment.appendChild(divElement.lastChild);
                  i += 1;
              }
  
              element.elems.dataViewport.appendChild(transferFragment);
          } else {
              // version 1
              element.elems.dataViewport.insertAdjacentHTML('beforeend', strHTML);
          }
  
  
  
          //// calculate left and top values
          //intCellLeft = intCellOriginLeft;
          //arrColumnLeft = [];
          //col_i = fromColumn;
          //col_len = toColumn;
          //while (col_i < col_len) {
          //    arrColumnLeft.push(intCellLeft);
  
          //    // we don't want the border width of 0 width columns to affect
          //    //      positioning
          //    if (arrColumnWidths[col_i] > 0) {
          //        intCellLeft += arrColumnWidths[col_i];
          //        intCellLeft += columnBorderWidth;
          //    }
          //    col_i += 1;
          //}
  
          //intCellTop = intRecordOriginTop;
          //arrRecordTop = [];
          //row_i = fromRecord;
          //row_len = toRecord;
          //while (row_i < row_len) {
          //    arrRecordTop.push(intCellTop);
  
          //    intCellTop += arrRecordHeights[row_i];
          //    intCellTop += recordBorderHeight;
          //    row_i += 1;
          //}
  
          //// if the insert record is visible, add it's top
          //if (bolInsertRecord === true) {
          //    arrRecordTop.push(intCellTop);
  
          //    intCellTop += element.internalDisplay.insertRecordHeight;
          //    intCellTop += element.internalDisplay.insertRecordBorderHeight;
          //}
  
          //// reposition all the cells to their correct locations
          //arrCell = xtag.queryChildren(
          //    element.elems.dataViewport,
          //    'gs-cell'
          //    //'[data-row-number], [data-col-number]'
          //    //      ^- this selector missed the insert and all selector cells
          //);
          //cell_i = 0;
          //cell_len = arrCell.length;
          //while (cell_i < cell_len) {
          //    cell = arrCell[cell_i];
          //    intRowNumber = parseInt(cell.getAttribute('data-row-number'), 10);
          //    intColNumber = parseInt(cell.getAttribute('data-col-number'), 10);
  
          //    // cell has a column number, set left. we can do this because (for
          //    //      example) header cells dont have a row attribute. the
          //    //      reason we do that is because those cells don't represent
          //    //      a row in the data.
          //    if (!isNaN(intColNumber)) {
          //        cell.style.left = (
          //            arrColumnLeft[intColNumber - fromColumn] + 'px'
          //        );
          //        cell.style.width = (
          //            (
          //                arrColumnWidths[intColNumber] +
          //                columnBorderWidth
          //            ) + 'px'
          //        );
  
          //    // right now, the only element that won't have a column number
          //    //      will be the record, insert and all selectors
          //    } else {
          //        cell.style.width = (
          //            intRecordSelectorWidth +
          //            intRecordSelectorBorderWidth
          //        ) + 'px';
          //    }
  
          //    // cell has a row number, set top. we can do this because (for
          //    //      example) header cells dont have a row attribute. the
          //    //      reason we do that is because those cells don't represent
          //    //      a row in the data.
          //    if (!isNaN(intRowNumber)) {
          //        cell.style.top = (
          //            arrRecordTop[intRowNumber - fromRecord] + 'px'
          //        );
          //        cell.style.height = (
          //            (
          //                arrRecordHeights[intRowNumber] +
          //                recordBorderHeight
          //            ) + 'px'
          //        );
          //        //cell.setAttribute(
          //        //    'style',
          //        //    (
          //        //        'top:' + (
          //        //            arrRecordTop[intRowNumber - fromRecord]
          //        //        ) + 'px;' +
          //        //        'height:' + (
          //        //            arrRecordHeights[intRowNumber] +
          //        //            recordBorderHeight
          //        //        ) + 'px;'
          //        //    )
          //        //);
  
          //    // if the cell is a header cell, set the height
          //    } else if (
          //        cell.classList.contains('table-header') ||
          //        cell.classList.contains('table-all-selector')
          //    ) {
          //        cell.style.height = (
          //            intHeaderHeight +
          //            intHeaderBorderHeight
          //        ) + 'px';
          //        //cell.setAttribute(
          //        //    'style',
          //        //    (
          //        //        'height:' + (
          //        //            intHeaderHeight +
          //        //            intHeaderBorderHeight
          //        //        ) + 'px;'
          //        //    )
          //        //);
  
          //    // if the cell is a insert cell, set the height
          //    } else if (
          //        cell.classList.contains('table-insert')
          //    ) {
          //        cell.style.top = (
          //            arrRecordTop[arrRecordTop.length - 1] + 'px'
          //        );
          //        cell.style.height = (
          //            intInsertRecordHeight +
          //            intInsertRecordBorderHeight
          //        ) + 'px';
          //        //cell.setAttribute(
          //        //    'style',
          //        //    (
          //        //        'top:' + (
          //        //            arrRecordTop[arrRecordTop.length - 1]
          //        //        ) + 'px;' +
          //        //        'height:' + (
          //        //            intInsertRecordHeight +
          //        //            intInsertRecordBorderHeight
          //        //        ) + 'px;'
          //        //    )
          //        //);
  
          //    // if the cell is the insert selector, set the height
          //    } else if (
          //        cell.classList.contains('table-insert-selector')
          //    ) {
          //        cell.style.top = (
          //            arrRecordTop[arrRecordTop.length - 1] + 'px'
          //        );
          //        cell.style.left = (0);
          //        cell.style.height = (
          //            intInsertRecordHeight +
          //            intInsertRecordBorderHeight
          //        ) + 'px';
  
          //        //cell.setAttribute(
          //        //    'style',
          //        //    (
          //        //        'top:' + (
          //        //            arrRecordTop[arrRecordTop.length - 1]
          //        //        ) + 'px;' +
          //        //        'left:0px;' +
          //        //        'height:' + (
          //        //            intInsertRecordHeight +
          //        //            intInsertRecordBorderHeight
          //        //        ) + 'px;'
          //        //    )
          //        //);
          //    }
  
          //    //if (cell.classList.contains('table-cell')) {
          //    //} else if (cell.classList.contains('table-all-selector')) {
          //    //} else if (cell.classList.contains('table-header')) {
          //    //} else if (cell.classList.contains('table-record-selector')) {
          //    //} else if (cell.classList.contains('table-insert')) {
          //    //} else if (cell.classList.contains('table-insert-selector')) {
          //    //}
  
          //    cell_i += 1;
          //}
  
          // fill insert columns with retained values
          arrElements = xtag.query(
              element.elems.dataViewport,
              '.table-insert [column]'
          );
          col_i = 0;
          col_len = arrElements.length;
          while (col_i < col_len) {
              strColumn = arrElements[col_i].getAttribute('column');
              strValue = element.internalData.insertRecord[strColumn];
  
              // if a value was retained for the current column
              if (strValue) {
                  // fill control with retained value
                  arrElements[col_i].value = strValue;
              }
              col_i += 1;
          }
  
          // we want to give the user some feedback about their scrolling position
          //      so, we'll add shadows on sides that have room to scroll in how
          //      this'll need to work is we'll need to add a shadow element at a
          //      z-index above cells but below record selectors, the all selector
          //      and header cells
          //// ### NEED CODING ###
          //window.separate1js_elements(element);
  
          // render cell selection
          renderSelection(element);
      }
  
      function renderLocation(element) {
          var i;
          var len;
  
          var intMaximum;
          var intTraversed;
          var intExtremeSide;
  
          var intViewportWidth;
          var intViewportHeight;
  
          var jsnOldRange;
          var jsnRange;
  
          var focusElement;
  
          // get old visible range so that we can decide if it's economical to do
          //      a full re-render
          jsnOldRange = element.internalDisplay.currentRange;
  
          // get current visible range so that we can decide if it's economical
          //      to do a full re-render
          jsnRange = getCurrentCellRange(element);
  
          // save visible range to internal display so that it is cached. the
          //      reason to cache it is so that we can be able to rapidly
          //      retrieve it many times in a row.
          element.internalDisplay.currentRange = jsnRange;
  
          // the partial render need to know the previous visible range, so here
          //      we cache it
          element.internalDisplay.prevRange = jsnOldRange;
  
          // we dont want to force a layout by re-rendering the contents and then
          //      asking for the viewport height/width. so we'll make a
          //      convenience variable
          intViewportWidth = (
              element.elems.dataViewport.clientWidth
          );
          intViewportHeight = (
              element.elems.dataViewport.clientHeight
          );
  
          // we want to either do a full re-render or a partial re-render
          if (intViewportHeight < 3 || intViewportWidth < 3) {
              //console.log('Empty');
              renderEmpty(element);
          } else if (
              // if the internal display says we need to do a full re-render
              element.internalDisplay.fullRenderRequired === true ||
  
              // or if there is no previous cell range
              jsnOldRange.fromRecord === undefined ||
  
              // or if the current range has no overlap with the old range
              jsnRange.fromRecord > jsnOldRange.toRecord ||
              jsnRange.fromColumn > jsnOldRange.toColumn ||
              jsnRange.toRecord < jsnOldRange.fromRecord ||
              jsnRange.toColumn < jsnOldRange.fromColumn
          ) {
              //console.log('Full');
              renderLocationFull(element);
          } else {
              //console.log('Partial');
              renderLocationPartial(element);
          }
  
          // reset full render indicator
          element.internalDisplay.fullRenderRequired = false;
  
          // generate positioning CSS
          // clear old CSS
          element.elems.cellPositionStyle.innerHTML = '';
  
          var intCellLeft = 0;
          var intCellTop = 0;
          var intColumnWidth;
          //var arrMinColumnWidths = element.internalDisplay.minColumnWidths;
  
          var arrColumnWidths = element.internalDisplay.columnWidths;
          var arrRecordHeights = element.internalDisplay.recordHeights;
          var columnBorderWidth = element.internalDisplay.columnBorderWidth;
          var recordBorderHeight = element.internalDisplay.recordBorderHeight;
          var strCSS = '';
          var strCell = (
              '#' + element.getAttribute('id') + ' .table-data-viewport gs-cell'
          );
  
          // calculate left and top values
          intCellLeft = jsnRange.originLeft;
          i = jsnRange.fromColumn;
          len = jsnRange.toColumn;
          while (i < len) {
              //if (arrColumnWidths[i] < 3) {
              //    //console.log(
              //        element.internalDisplay.defaultColumnWidths[i],
              //        element.internalDisplay.minColumnWidths[i],
              //        arrColumnWidths[i]
              //    );
              //    arrColumnWidths[i] = arrMinColumnWidths[i];
              //    element.internalDisplay.columnWidths[i] = (
              //        arrMinColumnWidths[i]
              //    );
              //}
              //console.log('col: ', arrColumnWidths[i]);
              intColumnWidth = arrColumnWidths[i];
  
              // only add to CSS and increment left variable if column is not
              //      hidden
              if (intColumnWidth > 0) {
                  strCSS += (
                      strCell + '[data-col-number="' + i + '"] {' +
                      'left:' + intCellLeft + 'px;' +
                      'width:' + (
                          intColumnWidth + columnBorderWidth
                      ) + 'px;' +
                      '}'
                  );
                  // console.log(strCSS);
  
                  // we don't want the border width of 0 width columns to affect
                  //      positioning
                  intCellLeft += (intColumnWidth + columnBorderWidth);
              }
              i += 1;
          }
  
          intCellTop = jsnRange.originTop;
          i = jsnRange.fromRecord;
          len = jsnRange.toRecord;
          while (i < len) {
              //if (arrRecordHeights[i] < 3) {
              //    arrRecordHeights[i] = (
              //        element.internalDisplay.defaultRecordHeight
              //    );
              //    element.internalDisplay.recordHeights[i] = (
              //        element.internalDisplay.defaultRecordHeight
              //    );
              //}
              //console.log('row: ', arrRecordHeights[i]);
              strCSS += (
                  strCell + '[data-row-number="' + i + '"] {' +
                  'top:' + intCellTop + 'px;' +
                  'height:' + (
                      arrRecordHeights[i] + recordBorderHeight
                  ) + 'px;' +
                  '}'
              );
  
              intCellTop += (arrRecordHeights[i] + recordBorderHeight);
              i += 1;
          }
  
          // if the insert record is visible, add it's top
          if (element.internalDisplay.insertRecordVisible) {
              strCSS += (
                  strCell + '[data-row-number="insert"] {' +
                  'top:' + intCellTop + 'px;' +
                  'height:' + (
                      element.internalDisplay.insertRecordHeight +
                      element.internalDisplay.insertRecordBorderHeight
                  ) + 'px;' +
                  '}'
              );
  
              //intCellTop += element.internalDisplay.insertRecordHeight;
              //intCellTop += element.internalDisplay.insertRecordBorderHeight;
          }
  
          strCSS += (
              strCell + '[data-col="selector"] {' +
              'left:0px;' +
              'width:' + (
                  element.internalDisplay.recordSelectorWidth +
                  element.internalDisplay.recordSelectorBorderWidth
              ) + 'px;' +
              '}' +
  
              strCell + '.table-all-selector,' +
              strCell + '.table-header {' +
              'top:0px;' +
              'height:' + (
                  element.internalDisplay.headerHeight +
                  element.internalDisplay.headerBorderHeight
              ) + 'px;' +
              '}'
          );
  
          //console.log('strCSS:', strCSS);
  
          element.elems.cellPositionStyle.innerHTML = strCSS;
  
  
          // turn the visible range into two arrays of drag handle points, one for
          //      horizontal, one for vertical. This is used by the cell resize
          //      code so that it can tell where the cell resize handles are.
  
          // we need to clear out any old values in the handle lists
          element.internalDisplay.columnHandles = [];
          element.internalDisplay.recordHandles = [];
  
          // find out the maximum position for a column resize handle
          intMaximum = (
              (
                  intViewportWidth -
                  element.internalScrollOffsets.right
              ) +
              // allow room for handle that's right at the right edge, this is
              //      useful when a column is full width
              3
          );
  
          // add record selector to column handle list if it's visible, the reason
          //      it's first is because the cell resize code depends it being
          //      first if recordSelectorVisible is true
          if (element.internalDisplay.recordSelectorVisible === true) {
              element.internalDisplay.columnHandles.push(
                  element.internalScrollOffsets.left
              );
          }
  
          // add displayed columns to column handle list
          intTraversed = jsnRange.originLeft;//0;
          i = jsnRange.fromColumn;
          len = jsnRange.toColumn;
          while (i < len) {
              // we want to add the right side of the column unless the right side
              //      is off of the viewport or is obscured by the right offset
              //      so, we'll put the right side into a variable and we'll build
              //      up a record width variable that we can use to determine if
              //      the right side would be too far
              if (element.internalDisplay.columnWidths[i] === 0) {
                  intExtremeSide = 0;
              } else {
                  intExtremeSide = (
                      element.internalDisplay.columnWidths[i] +
                      element.internalDisplay.columnBorderWidth
                  );
              }
  
              //if (intTraversed <= 0 && intExtremeSide > 0) {
              //    intExtremeSide += jsnRange.originLeft;
              //}
              intTraversed += intExtremeSide;
  
              //console.log(
              //    intTraversed,
              //    element.internalScrollOffsets.left,
              //    intExtremeSide,
              //    jsnRange.originLeft
              //);
  
              if (intTraversed < intMaximum) {
                  // if column is hidden, push null handle so that the array
                  //      indexes still line up with the column numbers
                  if (
                      intExtremeSide === 0 ||
                      intTraversed <= element.internalScrollOffsets.left
                  ) {
                      element.internalDisplay.columnHandles.push(null);
                  } else {
                      element.internalDisplay.columnHandles.push(intTraversed);
                  }
              } else {
                  break;
              }
  
              i += 1;
          }
  
          // now, we add the records to the record handle list
  
          // find out the maximum position for a record resize handle
          intMaximum = (
              intViewportHeight -
              element.internalScrollOffsets.bottom
          );
  
          // add header to record handle list if it's visible, the reason it's
          //      first is because the cell resize code depends it being first
          //      if headerVisible is true
          if (element.internalDisplay.headerVisible === true) {
              element.internalDisplay.recordHandles.push(
                  element.internalScrollOffsets.top
              );
          }
  
          // add displayed records to record handle list
          intTraversed = 0;
          i = jsnRange.fromRecord;
          len = jsnRange.toRecord;
          while (i < len) {
              // we want to add the bottom side of the record unless the bottom
              //      side is off of the viewport or is obscured by the bottom
              //      offset so, we'll put the bottom side into a variable and
              //      we'll build up a record width variable that we can use to
              //      determine if the bottom side would be too far
              intExtremeSide = (
                  element.internalDisplay.recordHeights[i]
              );
  
              if (intTraversed <= 0) {
                  intExtremeSide += (
                      jsnRange.originTop
                  );
              }
              intTraversed += intExtremeSide;
  
              if (intTraversed < intMaximum) {
                  element.internalDisplay.recordHandles.push(intTraversed);
              } else {
                  break;
              }
  
              // we wanted the cursor to appear a little higher
              intTraversed += element.internalDisplay.recordBorderHeight;
  
              i += 1;
          }
  
          // add the insert record to record handle list if it's visible, the
          //      reason it's last is because the cell resize code depends it
          //      being last if insertRecordVisible is true
          if (
              element.internalDisplay.insertRecordVisible === true &&
              jsnRange
          ) {
              element.internalDisplay.recordHandles.push(
                  element.internalDisplay.insertRecordHeight +
                  intTraversed
              );
          }
  
          // commented out because throttling scrolling makes scrolling choppy,
          //      other avenues of speed improvement will need to be attempted
          //// we needed to throttle the location rendering to increase speed
          ////      next, we want to look into only replacing elements that
          ////      need to be replaced as and just moving the rest (and if
          ////      that improves the speed enough, we can remove the throttling)
          //if (element.internalTimerIDs.renderLocation) {
          //    clearTimeout(element.internalTimerIDs.renderLocation);
          //}
          //element.internalTimerIDs.renderLocation = setTimeout(function() {
          //    renderLocationFull(element);
          //    element.internalTimerIDs.renderLocation = null;
          //}, 5);
  
          // we maintain the last focused control, if the last focused control
          //      is in the DOM, we want to focus it
          if (
              // this does two things for us:
              //      "latest" starts out null so this prevents us trying to
              //              focus when we haven't ever had the focus
              //      "latest" is false when the control has lost it's focus
              //              so this prevents wasting effort on trying to
              //              focus if the control is already focused
              element.internalDisplay.focus.latest === false &&
  
              // we only want to try to re-focus if the cell is in the current
              //      range. in the future, we may end up adding the cell if
              //      it's not currently rendered.
              !isNaN(element.internalDisplay.focus.row) &&
              !isNaN(element.internalDisplay.focus.column) &&
              element.internalDisplay.focus.row >= jsnRange.fromRecord &&
              element.internalDisplay.focus.row <= jsnRange.toRecord &&
              element.internalDisplay.focus.column >= jsnRange.fromColumn &&
              element.internalDisplay.focus.column <= jsnRange.toColumn
          ) {
              focusElement = xtag.query(
                  element.elems.dataViewport,
                  (
                      'gs-cell' +
                      '[data-col-number="' +
                          element.internalDisplay.focus.column +
                      '"]' +
                      '[data-row-number="' +
                          element.internalDisplay.focus.row +
                      '"] ' +
                      (
                          element.internalDisplay.focus.nodeName ||
                          ''
                      ).toLowerCase()
                  )
              )[0];
  
              if (focusElement) {
                  focusElement.focus();
  
                  if (element.internalDisplay.focus.selectionRange) {
                      GS.setInputSelection(
                          focusElement,
                          element.internalDisplay.focus.selectionRange.start,
                          element.internalDisplay.focus.selectionRange.end
                      );
                  }
              }
          }
      }
  
      // we need to be able to update the scrollbar location programatically
      function renderScrollLocation(element) {
          var intViewportWidth;
          var intViewportHeight;
          var virtualScrollHeight;
          var virtualScrollWidth;
          var virtualScrollTop;
          var virtualScrollLeft;
          var trueScrollHeight;
          var trueScrollWidth;
          var trueScrollTop;
          var trueScrollLeft;
  
          // we need the viewport dimensions because true scroll dimensions
          //      include the viewport height, which messes with the caluculations
          intViewportWidth = element.elems.dataViewport.clientWidth;
          intViewportHeight = element.elems.dataViewport.clientHeight;
  
          // we are saving the max scroll dimensions for ease of access
          virtualScrollHeight = element.internalScroll.maxTop;
          virtualScrollWidth = element.internalScroll.maxLeft;
  
          // we are saving the current scroll location for ease of access
          virtualScrollTop = element.internalScroll.top;
          virtualScrollLeft = element.internalScroll.left;
  
          // we need the actual scroll height of the scrollbars because we limit
          //      their height and that causes a difference we need to account for
          trueScrollWidth = element.elems.xScrollBar.scrollWidth;
          trueScrollHeight = element.elems.yScrollBar.scrollHeight;
          trueScrollWidth -= intViewportWidth;
          trueScrollHeight -= intViewportHeight;
  
          // we need to translate the virtual top/left into true top/left for the
          //      physical scrollbars
          // we can only translate if the scroll height or width is > 0 because if
          //      we translate a 0, we end up with division by 0
          // if we can't translate: default to 0
  
          trueScrollTop = 0;
          if (virtualScrollHeight > 0) {
              trueScrollTop = (
                  virtualScrollTop / (
                      virtualScrollHeight / trueScrollHeight
                  )
              );
          }
  
          trueScrollLeft = 0;
          if (virtualScrollWidth > 0) {
              trueScrollLeft = (
                  virtualScrollLeft / (
                      virtualScrollWidth / trueScrollWidth
                  )
              );
          }
  
          // we need to cancel the scrollbar events for one iteration because the
          //      scroll we're about to do causes scrollbar events to emit. the
          //      events then get to their bound functions well after the
          //      execution of this thread. this means that if we run this
          //      function and then set focus to a cell: the bound scroll
          //      functions would cause another re-render, which will cause
          //      focus to be lost. that's why we can't set these cancel to true
          //      and then quickly set them back to false, they must be set to
          //      false in the bound function.
          // there is a small issue with this method, after this function if, for
          //      example, the Y scrollbar is triggered but not the X scrollbar:
          //      the user may use the X scrollbar and the first time the user
          //      triggers the X scrollbar: the event will be ignored. however,
          //      I've tested on Google Chrome and I didn't notice the effects of
          //      this downside
          //element.internalEventCancelled.scrollbarY = true;
          //element.internalEventCancelled.scrollbarX = true;
  
          // we need to update the scroll location of the physical scrollbars so
          //      that the user can see where they are
          // to prevent sub-pixel math issues from causing a loop (by moving the
          //      scrollbar 1 pixel which causes a scroll event to take place
          //      which causes this function to run again (moving the scrollbar
          //      another pixel etc...)): if the difference between current true
          //      and new true is <=1 pixel then the scrollbar will not be updated
          //      (to fix this issue I tried disabling the event before the update
          //      and enabling it after the update, this did not work)
          if (
              Math.abs(element.elems.yScrollBar.scrollTop - trueScrollTop) >= 1
          ) {
              element.elems.yScrollBar.scrollTop = trueScrollTop;
          }
          if (
              Math.abs(element.elems.xScrollBar.scrollLeft - trueScrollLeft) >= 1
          ) {
              element.elems.xScrollBar.scrollLeft = trueScrollLeft;
          }
  
          // render cells
          //console.trace('renderScrollLocation');
          //console.log('virtualScrollTop:  ', virtualScrollTop);
          //console.log('virtualScrollLeft: ', virtualScrollLeft);
          //console.log('trueScrollTop:     ', trueScrollTop);
          //console.log('trueScrollLeft:    ', trueScrollLeft);
          renderLocation(element);
          //renderLocation(element);
      }
  
      // we need to be able to update the scrollbar depending on the content
      //      height/width
      function renderScrollDimensions(element) {
          var i;
          var len;
          var arrColumnWidths;
          var arrRecordHeights;
          var columnBorderWidth;
          var recordBorderHeight;
          var intViewportWidth;
          var intViewportHeight;
          var intMaxColumnWidth;
          var intMaxRecordHeight;
  
          var intTotalDataWidth;
          var intTotalDataHeight;
          var intOverscrollWidth;
          var intOverscrollHeight;
          var intNoOverscrollHeight;
          var intNoOverscrollWidth;
  
          // we need to update the cell dimension numbers just in case some CSS
          //      has altered any of the dimensions
          cellDimensionDetector(element);
  
          // we need to update what features are visible (header, record
          //      selectors, insert record)
          visibilityDetector(element);
  
          // we need to update the scroll offsets so that we can make room for
          //      headers, insert records and record selectors in the viewport
          offsetDetector(element);
  
          // we're saving these to variables for quicker/easier access
          columnBorderWidth = element.internalDisplay.columnBorderWidth;
          recordBorderHeight = element.internalDisplay.recordBorderHeight;
  
          // we need to get column and record dimensions
          arrColumnWidths = element.internalDisplay.columnWidths;
          arrRecordHeights = element.internalDisplay.recordHeights;
  
          // we need to get the viewport dimensions
          intViewportWidth = element.elems.dataViewport.clientWidth;
          intViewportHeight = element.elems.dataViewport.clientHeight;
  
          // save max record height and column width
          intMaxColumnWidth = (
              intViewportWidth - (
                  element.internalScrollOffsets.left +
                  element.internalScrollOffsets.right +
                  columnBorderWidth +
                  5 // <-- added for extra room
              )
          );
          intMaxRecordHeight = (
              intViewportHeight - (
                  element.internalScrollOffsets.top +
                  element.internalScrollOffsets.bottom +
                  recordBorderHeight +
                  5 // <-- added for extra room
              )
          );
  
          // store the max cell dimensions internally
          element.internalDisplay.maxColumnWidth = intMaxColumnWidth;
          element.internalDisplay.maxRecordHeight = intMaxRecordHeight;
  
          // we need to add up column widths (including custom ones)
          intTotalDataWidth = 0;
          intOverscrollWidth = 0;
          i = 0;
          len = arrColumnWidths.length;
          while (i < len) {
              // make sure no column is wider than max
              if (
                  intMaxColumnWidth > 3 &&
                  arrColumnWidths[i] > intMaxColumnWidth
              ) {
                  arrColumnWidths[i] = intMaxColumnWidth;
              }
  
              // increment total data width
              intTotalDataWidth += arrColumnWidths[i];
              intTotalDataWidth += columnBorderWidth;
  
              // we want to increase overscroll width until the last record
              if (i < (len - 1)) {
                  intOverscrollWidth = intTotalDataWidth;
              }
  
              i += 1;
          }
  
          // we need to add up record heights (including custom ones)
          intTotalDataHeight = 0;
          intOverscrollHeight = 0;
          i = 0;
          len = arrRecordHeights.length;
          while (i < len) {
              // make sure no record is taller than max
              if (
                  intMaxRecordHeight > 3 &&
                  arrRecordHeights[i] > intMaxRecordHeight
              ) {
                  arrRecordHeights[i] = intMaxRecordHeight;
              }
  
              // increment total data height
              intTotalDataHeight += arrRecordHeights[i];
              intTotalDataHeight += recordBorderHeight;
  
              // we want to increase overscroll height until the last record
              if (
                  (
                      element.internalDisplay.insertRecordVisible &&
                      element.internalDisplay.insertRecordStick === null &&
                      i === (len - 1)
                  ) ||
                  (
                      (
                          !element.internalDisplay.insertRecordVisible ||
                          element.internalDisplay.insertRecordStick !== null
                      ) &&
                      i < (len - 1)
                  )
              ) {
                  // catch overscroll height up to total height
                  intOverscrollHeight = intTotalDataHeight;
              }
              i += 1;
          }
  
  
          //if (
          //    element.internalDisplay.insertRecordVisible &&
          //    element.internalDisplay.insertRecordStick === null
          //) {
          //    intTotalDataHeight += (
          //        element.internalDisplay.insertRecordHeight +
          //        element.internalDisplay.insertRecordBorderHeight
          //    );
          //}
  
          //console.log('columnBorderWidth:  ', columnBorderWidth);
          //console.log('recordBorderHeight: ', recordBorderHeight);
          //console.log('Height:         ', intHeight);
          //console.log('ViewportHeight: ', intViewportHeight);
          //console.log('Width:          ', intWidth);
          //console.log('ViewportWidth:  ', intViewportWidth);
          //console.log('offsetTop:      ', element.internalScrollOffsets.top);
          //console.log('offsetBottom:   ', element.internalScrollOffsets.bottom);
          //console.log('offsetLeft:     ', element.internalScrollOffsets.left);
          //console.log('offsetRight:    ', element.internalScrollOffsets.right);
  
          //// add scroll offsets
          //intHeight += (
          //    element.internalScrollOffsets.top +
          //    element.internalScrollOffsets.bottom
          //);
          //intWidth += (
          //    element.internalScrollOffsets.left +
          //    element.internalScrollOffsets.right
          //);
  
          // save max scroll dimensions
  
          // we need to prevent vertical overscrolling if the
          //      "no-y-overscroll" attribute is present. the reason we can't
          //      just use the old maxTop value conditionally is because we
          //      make scrolling scroll by record, not pixel perfect. this
          //      means the last record will get cut off. so, in order to turn
          //      off overscrolling without this issue we need to calculate
          //      the amount to add to the maxTop in order to give enough room
          //      for the last record to clear the bottom of the viewport
          if (element.hasAttribute('no-y-overscroll')) {
              intNoOverscrollHeight = 0;
              i = 0;
              len = arrRecordHeights.length;
              while (i < len) {
                  if (
                      (
                          intNoOverscrollHeight +
                          intViewportHeight
                      ) > (
                          intTotalDataHeight +
                          element.internalScrollOffsets.top +
                          element.internalScrollOffsets.bottom
                      )
                  ) {
                      break;
                  }
  
                  // increment total data width
                  intNoOverscrollHeight += arrRecordHeights[i];
                  intNoOverscrollHeight += recordBorderHeight;
  
                  i += 1;
              }
  
              if (
                  element.internalDisplay.insertRecordVisible &&
                  element.internalDisplay.insertRecordStick === null
              ) {
                  intNoOverscrollHeight += (
                      element.internalDisplay.insertRecordHeight +
                      element.internalDisplay.insertRecordBorderHeight
                  );
              }
  
              element.internalScroll.maxTop = Math.max(
                  0,
                  intNoOverscrollHeight
              );
  
              //console.log('1***');
              //console.log('   intTotalDataHeight: ', intTotalDataHeight);
              //console.log('  intOverscrollHeight: ', intOverscrollHeight);
              //console.log('intNoOverscrollHeight: ', intNoOverscrollHeight);
              //console.log('    intViewportHeight: ', intViewportHeight);
  
          } else {
              element.internalScroll.maxTop = Math.max(0, intOverscrollHeight);
          }
  
          // we need to prevent horizontal overscrolling if the
          //      "no-x-overscroll" attribute is present. the reason we can't
          //      just use the old maxLeft value conditionally is because we
          //      make scrolling scroll by column, not pixel perfect. this
          //      means the last column will get cut off. so, in order to turn
          //      off overscrolling without this issue we need to calculate
          //      the amount to add to the maxLeft in order to give enough
          //      room for the last column to clear the right of the viewport
          if (element.hasAttribute('no-x-overscroll')) {
              intNoOverscrollWidth = 0;
              i = 0;
              len = arrColumnWidths.length;
              while (i < len) {
                  if (
                      (
                          intNoOverscrollWidth +
                          intViewportWidth
                      ) > (
                          intTotalDataWidth +
                          element.internalScrollOffsets.left +
                          element.internalScrollOffsets.right
                      )
                  ) {
                      break;
                  }
  
                  // increment total data width
                  intNoOverscrollWidth += arrColumnWidths[i];
                  intNoOverscrollWidth += columnBorderWidth;
  
                  i += 1;
              }
  
              element.internalScroll.maxLeft = Math.max(
                  0,
                  intNoOverscrollWidth
              );
  
              //console.log('2***');
              //console.log('   intTotalDataWidth: ', intTotalDataWidth);
              //console.log('  intOverscrollWidth: ', intOverscrollWidth);
              //console.log('intNoOverscrollWidth: ', intNoOverscrollWidth);
              //console.log('    intViewportWidth: ', intViewportWidth);
  
          } else {
              element.internalScroll.maxLeft = Math.max(0, intOverscrollWidth);
          }
  
          //console.log('maxTop:   ', element.internalScroll.maxTop);
          //console.log('maxLeft:  ', element.internalScroll.maxLeft);
  
          // sometimes, you may scroll to the right then widen your gs-table, this
          //      can cause you to get out of bounds
          // if the current scroll location is outside the max dimentions, set
          //      the scroll to the max allowed
          if (element.internalScroll.top > element.internalScroll.maxTop) {
              element.internalScroll.top = element.internalScroll.maxTop;
          }
          if (element.internalScroll.left > element.internalScroll.maxLeft) {
              element.internalScroll.left = element.internalScroll.maxLeft;
          }
  
          // move scrollbar causer elements to create scrollbars
          element.elems.yScrollBarCauser.style.top = (
              // scrollbars only work for a certain range that's why the max
              //      is 100000
              Math.min(
                  (
                      (
                          element.internalScroll.maxTop +
                          intViewportHeight
                      ) - 1 // <-- the causer is px tall, this counteracts that
                  ),
                  100000
              ) + "px"
          );
          element.elems.xScrollBarCauser.style.left = (
              // scrollbars only work for a certain range that's why the max
              //      is 100000
              Math.min(
                  (
                      (
                          element.internalScroll.maxLeft +
                          intViewportWidth
                      ) - 1 // <-- the causer is px wide, this counteracts that
                  ),
                  100000
              ) + "px"
          );
  
          // render scroll location
          renderScrollLocation(element);
      }
  
      function renderHUD(element) {
          var oldTopHUDHeight;
          var newTopHUDHeight;
          var oldBottomHUDHeight;
          var newBottomHUDHeight;
  
  
          // save the current hud height so that we can compare it to after the
          //      changes have been made
          oldTopHUDHeight = element.elems.topHudContainer.offsetHeight;
  
          // if we have a hud template: add hud class that makes the hud element
          //      visible and populate the hud element
          if (element.internalTemplates.topHUD.trim()) {
              element.elems.root.classList.add('show-top-hud');
              element.elems.topHudContainer.innerHTML = (
                  element.internalTemplates.topHUD
              );
  
              // save new HUD height to a variable for clarity
              newTopHUDHeight = element.elems.topHudContainer.offsetHeight;
  
              // update padding to make room for the hud
              element.elems.root.style.paddingTop = newTopHUDHeight + 'px';
  
          // else, we have no template: make hud invisible and clear hud element
          } else {
              element.elems.root.classList.remove('show-top-hud');
              element.elems.topHudContainer.innerHTML = '';
              newTopHUDHeight = 0;
          }
  
  
          // save the current hud height so that we can compare it to after the
          //      changes have been made
          oldBottomHUDHeight = element.elems.bottomHudContainer.offsetHeight;
  
          // if we have a hud template: add hud class that makes the hud element
          //      visible and populate the hud element
          if (element.internalTemplates.bottomHUD.trim()) {
              element.elems.root.classList.add('show-bottom-hud');
              element.elems.bottomHudContainer.innerHTML = (
                  element.internalTemplates.bottomHUD
              );
  
              // save new HUD height to a variable for clarity
              newBottomHUDHeight = element.elems.bottomHudContainer.offsetHeight;
  
              // update padding to make room for the hud
              element.elems.root.style.paddingBottom = newBottomHUDHeight + 'px';
  
          // else, we have no template: make hud invisible and clear hud element
          } else {
              element.elems.root.classList.remove('show-bottom-hud');
              element.elems.bottomHudContainer.innerHTML = '';
              newBottomHUDHeight = 0;
          }
  
  
          // if there is a difference in one of the HUD heights, we want to
          //      re-render the dataviewport because the HUD's height affects
          //      the viewport height
          if (
              oldTopHUDHeight !== newTopHUDHeight ||
              oldBottomHUDHeight !== newBottomHUDHeight
          ) {
              element.internalDisplay.fullRenderRequired = true;
              renderScrollDimensions(element);
          }
      }
  
      // sometimes, the user will resize the selected columns to their respective
      //      header widths. this function is a shortcut for that functionality.
      function resizeColumnsToHeader(element, arrColumnIndexes) {
          var i;
          var len;
          var intIndex;
  
          // loop through each selected column
          i = 0;
          len = arrColumnIndexes.length;
          while (i < len) {
              intIndex = arrColumnIndexes[i];
  
              // set the width the min width, which is the same as the header
              //      width
              element.internalDisplay.columnWidths[intIndex] = (
                  element.internalDisplay.minColumnWidths[intIndex]
              );
  
              i += 1;
          }
  
          // re-render location
          renderLocation(element);
      }
  
      function resizeColumnsToContent(element, arrColumnIndexes) {
          var i;
          var len;
          var elem_i;
          var elem_len;
          var intIndex;
          var arrElements;
          var controlElement;
          var intWidth;
          var jsnRange;
  
          var scopeElement;
          var controlText;
          var intTextWidth;
  
          var intColumnWidth;
          var intScopeElementWidth;
  
          // we only resize content that is rendered. to do that we need to
          //      know the current rendered range.
          jsnRange = element.internalDisplay.currentRange;
  
          // loop through each selected column
          i = 0;
          len = arrColumnIndexes.length;
          while (i < len) {
              intIndex = arrColumnIndexes[i];
  
              // we only pay attention to the content that has been rendered.
              //      so, only do anything if the current column is rendered.
              if (
                  intIndex >= jsnRange.fromColumn &&
                  intIndex <= jsnRange.toColumn
              ) {
                  // console.log(intIndex);
  
                  // start with the min width, any future width settings must be
                  //      larger than this
                  intWidth = element.internalDisplay.minColumnWidths[intIndex];
  
                  // we need the old column width for a calculation
                  intColumnWidth = element.internalDisplay.columnWidths[intIndex];
  
                  // get the rendered cell elements for this column
                  arrElements = xtag.query(
                      element.elems.dataViewport,
                      'gs-cell.table-cell[data-col-number="' + intIndex + '"]'
                  );
  
                  // loop through every data cell for this column
                  elem_i = 0;
                  elem_len = arrElements.length;
                  while (elem_i < elem_len) {
                      // the goal is the find text and an element. once we've
                      //      found both of those, we can use GS.getTextWidth
                      //      to determine the text width and if that's larger
                      //      than the current width, set the current width to
                      //      the text width.
                      // the question is how are we going to find the element
                      //      and it's text seein' as how we can put whatever
                      //      we want in a cell... we'll have four different
                      //      options and each cell will be in one of them.
                      //          option the 1st: input text and it's parent
                      //          option the 2nd: textarea text and it's parent
                      //          option the 3rd: select text and it's parent
                      //          option the 4th: textContent and the cell
  
                      controlElement = xtag.query(
                          arrElements[elem_i],
                          'input, textarea, select'
                      )[0];
  
                      if (
                          controlElement &&
                          (
                              controlElement.nodeName === 'INPUT' ||
                              controlElement.nodeName === 'TEXTAREA' ||
                              controlElement.nodeName === 'SELECT'
                          )
                      ) {
                          scopeElement = controlElement.parentNode;
                          controlText = controlElement.value;
  
                      } else {
                          scopeElement = (
                              // this fixes label-wrapped cells
                              arrElements[elem_i].children[0] ||
                              arrElements[elem_i]
                          );
                          controlText = arrElements[elem_i].textContent;
                      }
  
                      // get text width using the scope element and the control
                      //      text
                      intTextWidth = GS.getTextWidth(
                          scopeElement,
                          controlText,
                          true // preserve whitespace
                      );
  
                      // there may be some padding between the scope element
                      //      and the cell element. so, we want to account for
                      //      that.
                      intScopeElementWidth = Math.ceil(
                          scopeElement.clientWidth - (
                              parseFloat(
                                  GS.getStyle(scopeElement, 'padding-left')
                              ) +
                              parseFloat(
                                  GS.getStyle(scopeElement, 'padding-right')
                              )
                          )
                      );
  
                      //console.log('test0:', controlElement);
                      //console.log('test1:', scopeElement);
                      //console.log('test2:', controlText);
                      //console.log('test3:', intWidth);
                      //console.log('test4:', intTextWidth);
                      //console.log('test5:', intColumnWidth);
                      //console.log('test6:', intScopeElementWidth);
                      //console.log(
                      //    'test7:',
                      //    (intColumnWidth - intScopeElementWidth)
                      //);
                      //console.log(
                      //    'test8:',
                      //    GS.getStyle(scopeElement, 'padding-left')
                      //);
                      //console.log(
                      //    'test9:',
                      //    GS.getStyle(scopeElement, 'padding-right')
                      //);
  
                      // add padding to text width
                      intTextWidth += (intColumnWidth - intScopeElementWidth);
  
                      // add an arbituary amount to deal with small imperfections
                      intTextWidth += 10;
  
                      // if the new text width is greater than the currently
                      //      proposed width, set the currently proposed width
                      //      to the new text width
                      if (intTextWidth > intWidth) {
                          intWidth = intTextWidth;
                      }
  
                      elem_i += 1;
                  }
  
                  // set the width
                  element.internalDisplay.columnWidths[intIndex] = intWidth;
              }
  
              i += 1;
          }
  
          // re-render location
          renderLocation(element);
      }
  
  // ############################################################################
  // ############################# LOADER FUNCTIONS #############################
  // ############################################################################
  
      // loaders are appended to the end of the loader list, this is not where
      //      they belong. so, this function takes a loader element (which has
      //      already been appended) and moves it to the top of the loader
      //      container element
      function moveLoaderToTop(element, loaderElement) {
          // ### NEED CODING ###
      }
  
      // because of the way the loader container works, we need to set a margin
      //      so that the loader becomes visible
      function adjustLoaderWidth(element, loaderElement) {
          var loaderContent;
  
          // get the wrapped content
          loaderContent = loaderElement.children[0];
  
          // set the marginLeft to counteract the width
          loaderContent.style.marginLeft = (
              '-' + (loaderContent.offsetWidth + 10) + 'px'
          );
  
          // old, required getTextWidth which is slow
          //var intWidth;
  
          //// we calculate the width and store it in a variable
          //intWidth = GS.getTextWidth(element, loaderElement.textContent);
  
          //// let's add a little padding
          //intWidth += 25;
  
          //// set loader width and a reverse margin so that it moves to the left
          ////      the same amount
          //loaderElement.style.width = intWidth + 'px';
          //loaderElement.style.marginLeft = '-' + intWidth + 'px';
      }
  
      function addLoader(element, strID, strContent) {
          var loaderElement;
  
          // create loader element
          loaderElement = document.createElement('div');
          loaderElement.classList.add('table-loader-wrapper');
          loaderElement.innerHTML = (
              '<div class="table-loader">' + strContent + '</div>'
          );
  
          // append loader element to loader container
          element.elems.loaderContainer.appendChild(loaderElement);
  
          // append new loader imformation to a place where we can retrieve it
          element.internalLoaders.loaderIDs.push(strID);
          element.internalLoaders.loaderElements.push(loaderElement);
  
          // adjust loader width so that it displays all on one line
          adjustLoaderWidth(element, loaderElement);
  
          // move loader to top
          moveLoaderToTop(element, loaderElement);
  
          //console.log('added loader', loaderElement);
      }
  
      function removeLoader(element, strID, strFinishedContent) {
          var loaderIndex;
          var loaderElement;
          var fadeOut;
          var removeFunction;
  
          // get index of loader in loader array
          loaderIndex = element.internalLoaders.loaderIDs.indexOf(strID);
  
          // get loader element using index
          loaderElement = element.internalLoaders.loaderElements[loaderIndex];
  
          // remove loader from loader arrays immediately so that if another
          //      loader is removed with the same name, we won't remove the same
          //      one twice
          element.internalLoaders.loaderIDs.splice(loaderIndex, 1);
          element.internalLoaders.loaderElements.splice(loaderIndex, 1);
  
          // define a fade out function so that we only need to write the code
          //      once.
          fadeOut = function () {
              // add fade out class
              loaderElement.classList.add('table-fade-out');
  
              // we want to be able to remove this function to free the memory
              removeFunction = function () {
                  // if the loader container is still in use
                  if (
                      element.elems &&
                      element.elems.loaderContainer
                  ) {
                      // remove the loader
                      element.elems.loaderContainer.removeChild(loaderElement);
                  }
  
                  // clear function to free up memory
                  removeFunction = null;
              };
  
              // remove loader from loader container after fade out animation
              //      is complete
              setTimeout(removeFunction, 1000);
  
              // clear function to free up memory
              fadeOut = null;
          };
  
          // if there is strFinishedContent, we need to change the content then
          //      fade out
          if (strFinishedContent) {
              // switch content to loader content
              loaderElement.children[0].innerHTML = strFinishedContent;
  
              // adjust loader width so that it displays all on one line
              adjustLoaderWidth(element, loaderElement);
  
              // move loader to top
              moveLoaderToTop(element, loaderElement);
  
              // fade out after some time has passed to read the new content
              setTimeout(fadeOut, 1000);
  
          // else, just fade loader out
          } else {
              fadeOut();
          }
      }
  
  // ############################################################################
  // ############################## DATA FUNCTIONS ##############################
  // ############################################################################
  
      function dataSELECTcallback(element) {
          var intDifference;
          var i;
          var len;
          var bolFirstLoad;
  
          // we need to know if this was the first load
          bolFirstLoad = (element.internalData.bolFirstLoadFinished === false);
  
          // we may need to add or remove some record heights
          intDifference = (
              element.internalDisplay.recordHeights.length -
                  element.internalData.records.length
          );
  
          // sometimes a record disappears between selects, someone else might
          //      delete a record and then you refresh, in this case we need to
          //      remove a enough records heights to make up the difference
          if (intDifference > 0) {
              i = 0;
              len = intDifference;
              while (i < len) {
                  element.internalDisplay.recordHeights.pop();
                  i += 1;
              }
  
          // there's a possibility of a record being added without an accompanying
          //      record height, if that's happened we add enough record heights
          //      to make up the difference
          } else if (intDifference < 0) {
              i = 0;
              len = Math.abs(intDifference);
              while (i < len) {
                  element.internalDisplay.recordHeights.push(
                      element.internalDisplay.defaultRecordHeight
                  );
                  i += 1;
              }
          }
  
          // make sure that everything knows the first load is over
          if (element.internalData.bolFirstLoadFinished === false) {
              element.internalData.bolFirstLoadFinished = true;
          }
  
          // re-render scroll location because adding records changes scroll
          //      heights, and so that we can show the new data
          element.internalDisplay.fullRenderRequired = true;
          renderScrollDimensions(element);
  
          // sometimes, developers want to have the gs-table select and focus
          //      after it first loads
          if (
              element.hasAttribute('focus-on-load') &&
              bolFirstLoad &&
              // if we are already focused, then ignore
              element.internalSelection.ranges.length === 0
          ) {
              // if there is data, select the first cell
              if (element.internalData.records.length > 0) {
                  element.internalSelection.ranges = [
                      {
                          "start": {
                              "row": 0,
                              "column": 0
                          },
                          "end": {
                              "row": 0,
                              "column": 0
                          },
                          "negator": false
                      }
                  ];
  
                  focusIntoCell(
                      element,
                      0, // record
                      0  // column
                  );
  
              // sometimes, there's no data to select, select the "all"
              //      selector if it's visible
              } else if (
                  element.internalDisplay.recordSelectorVisible &&
                  element.internalDisplay.headerVisible
              ) {
                  element.internalSelection.ranges = [
                      {
                          "start": {
                              "row": "header",
                              "column": "selector"
                          },
                          "end": {
                              "row": "header",
                              "column": "selector"
                          },
                          "negator": false
                      }
                  ];
              }
  
              renderSelection(element);
          }
          GS.triggerEvent(element, 'after_select');
      }
      function dataINSERTcallback(element) {
          // re-render scroll location because adding records changes scroll
          //      heights, and so that we can show the new data
          element.internalDisplay.fullRenderRequired = true;
          renderScrollDimensions(element);
  
          // scroll to the bottom so that the user can see the newly created
          //      records without having to scroll
          // element.internalScroll.top = (
          //     element.internalScroll.maxTop - (
          //         element.elems.dataViewport.clientHeight - (
          //             element.internalScrollOffsets.top +
          //             element.internalScrollOffsets.bottom +
          //             element.internalDisplay.defaultRecordHeight
          //         )
          //     )
          // );
          element.goToLine('last');
  
          // re-render scroll location because we changed the scrollTop
          renderScrollLocation(element);
      }
      function dataUPDATEcallback(element) {
          // re-render location so that if changing the data resulted in
          //      calculated columns changing or some other unknown change
          //      occurs: the user will see the changes
          element.internalDisplay.fullRenderRequired = true;
          renderLocation(element);
          //console.log('In here!!');
      }
      function dataDELETEcallback(element) {
          // clear selection because the stuff that the user selected has
          //      now been deleted
          element.internalSelection.ranges = [];
  
          // re-render scroll location because removing records changes scroll
          //      heights
          element.internalDisplay.fullRenderRequired = true;
          renderScrollDimensions(element);
      }
  
      function getWhereClause(element) {
          var i;
          var len;
          var arrFilter;
          var strColumn;
          var filter_i;
          var filter_len;
          var strFilter;
          var jsnFilter;
          var strListWhere;
  
          var arrOldColumnNames;
          var arrOldColumnTypes;
          var arrOldColumnFilterStatuses;
          var arrOldColumnFilters;
          var arrOldColumnListFilters;
  
          var strWhere;
          var strUserWhere;
          var strWhereColumn;
  
          // we need to include any where clauses added be the developer.
          //      this where clause is templated with the querystring.
          strWhere = GS.templateWithQuerystring(
              element.getAttribute('where') || '1=1'
          );
  
          // add in user filters, if any
          if (element.getAttribute('session-filter')) {
              strWhere = '(' + element.getAttribute('session-filter') + ')';
              strWhere += (
                  strWhere
                      ? ' AND ' + strWhere
                      : ''
              );
          }
  
          // add in a column or qs where, if any
  
          // we need to be able to handle header-line relationships, this code
          //      uses the "column", "qs" and "value" attributes to formulate
          //      a where clause
          if (
              element.getAttribute('value') &&
              (
                  element.getAttribute('column') ||
                  element.getAttribute('qs')
              )
          ) {
              strWhereColumn = (
                  element.getAttribute('child-column') ||
                  element.getAttribute('column') ||
                  element.getAttribute('qs')
              );
  
              // if the value is not a number, we need to do a string
              //      comparison in the where clause.
              if (isNaN(element.value)) {
                  strWhere = (
                      'CAST(' +
                      strWhereColumn + ' AS ' +
                      GS.database.type.text +
                      ') = ' +
                      'CAST(' +
                      '$WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' +
                      GS.database.type.text +
                      ')'
                  );
                  strWhere += (
                      strWhere !== ''
                          ? ' AND (' + strWhere + ')'
                          : ''
                  );
  
              // if the value is a number, we can do simpler, number comparison
              } else {
                  strWhere = strWhereColumn + '=' + (element.value);
                  strWhere += (
                      strWhere !== ''
                          ? ' AND (' + strWhere + ')'
                          : ''
                  );
              }
          }
  
          arrOldColumnNames = element.internalData.columnNames;
          arrOldColumnTypes = element.internalData.columnTypes;
          arrOldColumnFilterStatuses = element.internalData.columnFilterStatuses;
          arrOldColumnFilters = element.internalData.columnFilters;
          arrOldColumnListFilters = element.internalData.columnListFilters;
  
          // we want the user to be able to filter a column, so here we'll look
          //      at what the user set for each column and prepend to the where
          //      clause
          strUserWhere = '';
          i = 0;
          len = arrOldColumnFilters.length;
          while (i < len) {
              arrFilter = arrOldColumnFilters[i];
              strColumn = arrOldColumnNames[i];
  
              // only filter if this column's filters haven't been toggled off
              if (arrOldColumnFilterStatuses[i] === 'on') {
                  filter_i = 0;
                  filter_len = arrFilter.length;
                  while (filter_i < filter_len) {
                      strFilter = arrFilter[filter_i].text;
                      strUserWhere += (
                          strUserWhere
                              ? ' AND '
                              : ''
                      );
  
                      strUserWhere += strFilter;
                      filter_i += 1;
                  }
              }
  
              i += 1;
          }
  
          //console.log('old filter:', arrOldColumnListFilters[0]);
  
          i = 0;
          len = arrOldColumnListFilters.length;
          while (i < len) {
              jsnFilter = arrOldColumnListFilters[i];
              strColumn = arrOldColumnNames[i];
              strListWhere = '';
  
              // only filter if this column's filters haven't been toggled off
              //      and there is a filter
              if (
                  arrOldColumnFilterStatuses[i] === 'on' &&
                  jsnFilter.type &&
                  jsnFilter.values
                  //jsnFilter.values.length > 0
                  //  ^-- when nothing is chosen, we want nothing to match. this
                  //      line was preventing the WHERE from being generated
              ) {
                  if (jsnFilter.type === 'inclusion') {
                      filter_i = 0;
                      filter_len = jsnFilter.values.length;
                      while (filter_i < filter_len) {
                          strListWhere += (
                              strListWhere
                                  ? ' OR '
                                  : ''
                          );
  
                          strListWhere += (
                              strColumn +
                              ' = CAST($werequote$' +
                              jsnFilter.values[filter_i] +
                              '$werequote$ AS ' + arrOldColumnTypes[i] +
                              ')'
                          );
                          filter_i += 1;
                      }
  
                      //console.log(filter_i, filter_len);
  
                      if (filter_len === 0) {
                          strListWhere = '1=2';
                      }
  
                  } else if (jsnFilter.type === 'exclusion') {
                      if (jsnFilter.values.length > 0) {
                          filter_i = 0;
                          filter_len = jsnFilter.values.length;
                          while (filter_i < filter_len) {
                              strListWhere += (
                                  strListWhere
                                      ? ' AND '
                                      : ''
                              );
  
                              strListWhere += (
                                  strColumn +
                                  ' != CAST($werequote$' +
                                  jsnFilter.values[filter_i] +
                                  '$werequote$ AS ' + arrOldColumnTypes[i] +
                                  ')'
                              );
                              filter_i += 1;
                          }
                      }
                  }
  
                  // if we are excluding nothing the blank code causes
                  //      the where to just be "WHERE column is blank"
                  if (
                      (
                          strListWhere &&
                          !(
                              jsnFilter.type === 'exclusion' &&
                              jsnFilter.values.length === 0
                          )
                      ) ||
                      jsnFilter.blanks === false
                  ) {
                      // we need to handle blank values specially
                      if (strListWhere) {
                          strListWhere = '(' + strListWhere + ') ';
                      }
  
                      if (jsnFilter.blanks === true) {
                          if (strListWhere) {
                              strListWhere += ' OR';
                          }
  
                          strListWhere += (
                              ' NULLIF(' +
                                  'CAST(' +
                                      strColumn + ' AS ' +
                                      GS.database.type.text +
                                  '), \'\') IS NULL'
                          );
                      } else {
                          if (strListWhere) {
                              strListWhere += ' AND';
                          }
  
                          strListWhere += (
                              ' NULLIF(' +
                                  'CAST(' +
                                      strColumn + ' AS ' +
                                      GS.database.type.text +
                                  '), \'\') IS NOT NULL'
                          );
                      }
  
                      // console.log(
                      //     jsnFilter,
                      //     strListWhere
                      // );
  
                      strUserWhere += (
                          strUserWhere
                              ? ' AND '
                              : ''
                      );
                      strUserWhere += '(' + strListWhere + ')';
                  }
              }
  
              i += 1;
          }
  
          // if a where is defined by the dev, put it after our new where
          if (strUserWhere && strWhere) {
              strWhere = strUserWhere + ' AND (' + strWhere + ')';
  
          // if there is no where set by the developer, our new where will be
          //      the only one
          } else if (strUserWhere) {
              strWhere = strUserWhere;
          }
  
          return strWhere;
      }
  
      function databaseWSSELECT(element) {
          var socket;
          var strSchema;
          var strObject;
          var strWhere;
          var strOrd;
          var strLimit;
          var strOffset;
          var strReturn;
          var strWhereColumn;
          var bolLoadNewRecordHeights;
          var intRecordHeight;
  
          var arrOldColumnNames;
          var arrOldColumnTypes;
          var arrOldColumnFilterStatuses;
          var arrOldColumnFilters;
          var arrOldColumnListFilters;
          var arrOldColumnOrders;
          var arrOldDisplayColumns;
  
          var i;
          var len;
          var strFilter;
          var strSort;
          var strColumn;
          var strUserOrd;
          var strUserWhere;
          var strListWhere;
          var filter_i;
          var filter_len;
          var arrFilter;
          var jsnFilter;
          var index;
          var arrRecords;
          var arrRecordHeights;
  
          socket = getSocket(element);
          strSchema = GS.templateWithQuerystring(
              element.getAttribute('schema') || ''
          );
          strObject = GS.templateWithQuerystring(
              element.getAttribute('object') || ''
          );
          strWhere = getWhereClause(element);
          strOrd = GS.templateWithQuerystring(
              element.getAttribute('ord') || ''
          );
          strLimit = GS.templateWithQuerystring(
              element.getAttribute('limit') || ''
          );
          strOffset = GS.templateWithQuerystring(
              element.getAttribute('offset') || '0'
          );
          strReturn = '*';
  
          //// disabled, hide or not the pageinate buttons
          //if (strLimit === '') {
          //    element.pageLeftButton.setAttribute('hidden', '');
          //    element.pageRightButton.setAttribute('hidden', '');
          //} else if (strOffset === '' || strOffset === '0') {
          //    element.pageLeftButton.setAttribute('disabled', '');
          //}
  
          // if no records heights exist: we need to load record heights
          bolLoadNewRecordHeights =
                  (element.internalDisplay.recordHeights.length === 0);
  
          // we need to create records with the default record height attached to
          //      them, so we'll use the "default-record-height" attribute
          intRecordHeight = (
              parseInt(element.getAttribute('default-record-height'), 10) ||
              intDefaultRecordHeight
          );
  
          // we need to make sure that no old data persists across select calls,
          //      so we'll clear out the internal data object
          element.internalData.records = [];
  
          // we need to re-link the new column list with the old column sorts,
          //      filters and filter statuses
          arrOldColumnNames = element.internalData.columnNames;
          arrOldColumnTypes = element.internalData.columnTypes;
          arrOldColumnFilterStatuses = element.internalData.columnFilterStatuses;
          arrOldColumnFilters = element.internalData.columnFilters;
          arrOldColumnListFilters = element.internalData.columnListFilters;
          arrOldColumnOrders = element.internalData.columnOrders;
          arrOldDisplayColumns = element.internalDisplay.dataColumnName;
  
          // we want the user to be able to sort on a column, so here we'll look
          //      at what the user set for each column and prepend to the order
          //      by clause
  
          // we'll loop through the display column associations and see if any
          //      of those columns have been sorted
          strUserOrd = '';
          i = 0;
          len = arrOldDisplayColumns.length;
          while (i < len) {
              strColumn = arrOldDisplayColumns[i];
  
              if (strColumn) {
                  index = arrOldColumnNames.indexOf(strColumn);
                  strSort = arrOldColumnOrders[index];
  
                  if (strSort === 'asc') {
                      strUserOrd += (
                          strUserOrd
                              ? ', '
                              : ''
                      );
                      strUserOrd += strColumn + ' ASC';
  
                  } else if (strSort === 'desc') {
                      strUserOrd += (
                          strUserOrd
                              ? ', '
                              : ''
                      );
                      strUserOrd += strColumn + ' DESC';
                  }
              }
              i += 1;
          }
  
          //  ,---- commented out because it did not take column order into
          //  V           account
          //strUserOrd = '';
          //i = 0;
          //len = arrOldColumnOrders.length;
          //while (i < len) {
          //    strSort = arrOldColumnOrders[i];
          //    strColumn = arrOldColumnNames[i];
  
          //    if (strSort === 'asc') {
          //        strUserOrd += (
          //            strUserOrd
          //                ? ', '
          //                : ''
          //        );
          //        strUserOrd += strColumn + ' ASC';
  
          //    } else if (strSort === 'desc') {
          //        strUserOrd += (
          //            strUserOrd
          //                ? ', '
          //                : ''
          //        );
          //        strUserOrd += strColumn + ' DESC';
          //    }
  
          //    i += 1;
          //}
  
          // if an order by is defined by the dev, put it after our new order by
          if (strUserOrd && strOrd) {
              strOrd = strUserOrd + ', ' + strOrd;
  
          // if there is no orderby set by the developer, our new order by will be
          //      the only one
          } else if (strUserOrd) {
              strOrd = strUserOrd;
          }
  
          console.time('data load');
  
          // storing references to the arrays for faster access
          arrRecords = element.internalData.records;
          arrRecordHeights = element.internalDisplay.recordHeights;
  
          // we need the user to know that the envelope is re-fetching data,
          //      so we'll put a loader on
          addLoader(element, 'data-select', 'Loading Data...');
          GS.requestSelectFromSocket(
              socket,
              strSchema,
              strObject,
              strReturn,
              strWhere,
              strOrd,
              strLimit,
              strOffset,
              function (data, error) {
                  //var i;
                  //var len;
                  var col_i;
                  var col_len;
                  var strCol;
                  //var index;
                  var strRecord;
                  var strMessage;
                  //var strChar;
  
                  if (!error) {
                      // if this is the first callback, we need to save
                      //      the column names and types and we need to
                      //      re-link the filters, sorts and filter statuses
                      //
                      // this was below in the else, but requestSelectFromSocket
                      //      will only callback once if there are no records
                      //      - Nunzio 5/29/2017
                      if (data.intCallback === 0) {
                          // clear old column arrays to make remove for any
                          //      changes to the column list
                          element.internalData.columnNames = [];
                          element.internalData.columnTypes = [];
                          element.internalData.columnFilterStatuses = [];
                          element.internalData.columnFilters = [];
                          element.internalData.columnListFilters = [];
                          element.internalData.columnOrders = [];
  
                          // future mike, you need to make is so that the
                          //      column name, filter and sort arrays are
                          //      retained across select calls.
                          // past mike, sounds good, I'll use the old column
                          //      list to get the old sorts filters, and
                          //      filter statuses
                          col_i = 0;
                          col_len = data.arrDecodedColumnNames.length;
                          while (col_i < col_len) {
                              strCol = data.arrDecodedColumnNames[col_i];
                              index = arrOldColumnNames.indexOf(strCol);
  
                              element.internalData.columnNames.push(
                                  strCol
                              );
                              element.internalData.columnTypes.push(
                                  data.arrDecodedColumnTypes[col_i]
                              );
  
                              // if we've got old values from the select,
                              //      bring them over to the new arrays
                              if (index > -1) {
                                  element.internalData
                                      .columnFilterStatuses.push(
                                          arrOldColumnFilterStatuses[index]
                                      );
                                  element.internalData
                                      .columnFilters.push(
                                          arrOldColumnFilters[index]
                                      );
                                  element.internalData
                                      .columnListFilters.push(
                                          arrOldColumnListFilters[
                                              index
                                          ]
                                      );
                                  element.internalData
                                      .columnOrders.push(
                                          arrOldColumnOrders[index]
                                      );
  
                              // else, add empty sort, filter and filter
                              //      status
                              } else {
                                  element.internalData
                                      .columnFilterStatuses.push('on');
                                  element.internalData
                                      .columnFilters.push([]);
                                  element.internalData
                                      .columnListFilters.push({});
                                  element.internalData
                                      .columnOrders.push('neutral');
                              }
  
                              col_i += 1;
                          }
                      }
  
                      // we need to remove the loader at some point, if we see
                      //      the last message of the select: remove loader and
                      //      render
                      if (data.strMessage === 'TRANSACTION COMPLETED') {
                          //// required for v3 test#1
                          //element.internalData.records = (
                          //    arrRecords
                          //);
                          //element.internalDisplay.recordHeights = (
                          //    arrRecordHeights
                          //);
  
                          // back to non-test code
                          console.timeEnd('data load');
                          console.log(
                              'record count:',
                              element.internalData.records.length
                          );
                          removeLoader(element, 'data-select', 'Data Loaded');
                          dataSELECTcallback(element);
  
                      // we need to capture the records and columns and store
                      //      them in the internal data
                      } else {
                          if (
                              data.intCallback === 3 &&
                              element.internalData.bolFirstLoadFinished === false
                          ) {
                              //// required for v3 test#1
                              //element.internalData.records = (
                              //    arrRecords
                              //);
                              //element.internalDisplay.recordHeights = (
                              //    arrRecordHeights
                              //);
  
                              // re-render scroll location because adding records
                              //      changes scroll heights, and so that we can
                              //      show the new data
                              element.internalDisplay.fullRenderRequired = true;
                              renderScrollDimensions(element);
                          }
  
                          // we need to parse the TSV into records and push them
                          //      to the internalData "records" array
                          // now, we have an advantage in that Envelope Websocket
                          //      data is already encoded in the correct format
                          //      and all we have to is split on \n
                          // also, Envelope Websocket data always ends in \n so
                          //      the loop doesn't need to do anything special
                          //      to get the last record
                          strMessage = data.strMessage;
                          strRecord = '';
  
                          //// splitter test#1 v3, slower than v2
                          //var arrRecord = strMessage.split('\n');
                          //arrRecord.pop();
                          //arrRecords = arrRecords.concat(arrRecord);
                          //if (bolLoadNewRecordHeights) {
                          //    i = 0;
                          //    len = (
                          //        (
                          //            arrRecords.length -
                          //            arrRecordHeights.length
                          //        ) +
                          //        1
                          //    );
                          //    while (i < len) {
                          //        arrRecordHeights.push(intRecordHeight);
                          //        i += 1;
                          //    }
                          //}
  
                          // splitter v2, faster than v1 by 1 third
                          //if (window.asdfasdf === true) {
                          //    //console.log(strMessage);
                          //}
                          i = 0;
                          while (i < 15) {
                              index = strMessage.indexOf('\n');
                              strRecord = strMessage.substring(0, index);
                              strMessage = strMessage.substring(index + 1);
  
                              if (strRecord !== '' || strMessage !== '') {
                                  arrRecords.push(strRecord);
  
                                  //if (window.asdfasdfasdf === true) {
                                  //    //console.log(strRecord);
                                  //}
                                  if (bolLoadNewRecordHeights) {
                                      arrRecordHeights.push(intRecordHeight);
                                  }
                              } else {
                                  break;
                              }
  
                              i += 1;
                          }
  
                          //// splitter v1, replaced because it was slow
                          //strMessage = data.strMessage;
                          //strRecord = '';
                          //i = 0;
                          //len = strMessage.length;
                          //while (i < len) {
                          //    strChar = strMessage[i];
  
                          //    if (strChar === '\n') {
                          //        element.internalData.records.push(strRecord);
  
                          //        if (bolLoadNewRecordHeights) {
                          //            element.internalDisplay
                          //                .recordHeights
                          //                .push(intRecordHeight);
                          //        }
  
                          //        strRecord = '';
                          //    } else {
                          //        strRecord += strChar;
                          //    }
  
                          //    i += 1;
                          //}
                      }
  
                  // we need to make sure that the user knows that the select
                  //      failed and we need to prevent using any old select
                  //      info, so we'll re-render, remove the loader and pop
                  //      up an error
                  } else {
                      dataSELECTcallback(element);
                      removeLoader(element, 'data-select', 'Data Failed To Load');
                      GS.webSocketErrorDialog(data);
                  }
              }
          );
      }
      function databaseWSINSERT(element, strMode, jsnInsert) {
          var rec_i;
          var rec_len;
          var col_i;
          var col_len;
          var strColumn;
  
          var strPostfix;
          var insertStep;
          var beforeEvent;
  
          var arrPK;
          var arrSeq;
          var strPK;
          var strSeq;
          var strInsertColumns;
          var strInsertData;
  
          var strSchema;
          var strObject;
          var strReturn;
          var strNullString;
          var intRecordHeight;
  
          // get schema and object attributes and get the return column list
          strSchema = GS.templateWithQuerystring(
              element.getAttribute('schema') || ''
          );
          strObject = GS.templateWithQuerystring(
              element.getAttribute('object') || ''
          );
  
          // the return column list must be defined the same as the column list
          //      that we store the data with, so we define strReturn using the
          //      column list
          strReturn = '';
          col_i = 0;
          col_len = element.internalData.columnNames.length;
          while (col_i < col_len) {
              strReturn += (
                  strReturn
                      ? '\t'
                      : ''
              );
              strReturn += element.internalData.columnNames[col_i].replace(/(\\)/g, '\\\\');
              col_i += 1;
          }
  
          // we need to know if the developer has specified any special primary
          //      key columns and/or sequence columns
          strPK = GS.templateWithQuerystring(
              element.getAttribute('pk') || ''
          );
          strSeq = GS.templateWithQuerystring(
              element.getAttribute('seq') || ''
          );
          arrPK = strPK.split(/[\s]*,[\s]*/);
          arrSeq = strSeq.split(/[\s]*,[\s]*/);
  
          // we want the null string to be configurable, so we'll read the
          //      "null-string" attribute to get the null string
          // if the "null-string" attribute is present, use the contents
          //      or coalesce to empty string
          if (element.hasAttribute('null-string')) {
              strNullString = element.getAttribute('null-string') || '';
  
          // else, null string is left up to the encoding function
          } else {
              strNullString = undefined;
          }
  
          // we need to create records with the default record height attached to
          //      them, so we'll use the "default-record-height" attribute
          intRecordHeight = (
              parseInt(element.getAttribute('default-record-height'), 10) ||
              intDefaultRecordHeight
          );
  
          // there are three different ways to insert records:
          //      1) typing into the insert record
          //      2) filling insert dialog
          //      3) pasting into the insert record.
          //      types 1 and 2 are "single-record" inserts
          //      type 3 is a "multi-record" insert
  
          // "single-record"
          if (strMode === 'single-record') {
              // if there is an addin value and that column was not already in the
              //      insert, add the value to the insert
              if (
                  jsnInsert.data.addin &&
                  jsnInsert.data.addin.link_column &&
                  jsnInsert.data.addin.link_value &&
                  jsnInsert
                      .data
                      .columns
                      .indexOf(jsnInsert.data.addin.link_column) === -1
              ) {
                  strColumn = jsnInsert.data.addin.link_column;
  
                  jsnInsert.data.columns.push(
                      jsnInsert.data.addin.link_column
                  );
                  jsnInsert.data.values[strColumn] = (
                      jsnInsert.data.addin.link_value
                  );
              }
  
              strInsertColumns = '';
              strInsertData = '';
              col_i = 0;
              col_len = jsnInsert.data.columns.length;
              while (col_i < col_len) {
                  strColumn = jsnInsert.data.columns[col_i].replace(/(\\)/g, '\\\\');
  
                  strInsertColumns += (
                      strInsertColumns
                          ? '\t'
                          : ''
                  );
                  strInsertColumns += strColumn;
  
                  strInsertData += (
                      strInsertData
                          ? '\t'
                          : ''
                  );
                  strInsertData += GS.encodeForTabDelimited(
                      (jsnInsert.data.values[strColumn] || 'NULL'),
                      strNullString
                  );
  
                  col_i += 1;
              }
  
              // append a return after the end of the insert data because
              //      the envelope expects it
              strInsertData += '\n';
  
          // "multi-record" assumes that:
          //      1) the data is a dump
          //      2) isn't stored anywhere
          //      3) only affects the currently selected insert record columns
          //              unless none are selected, in that case: all columns
          } else if (strMode === 'multi-record') {
              // if there is an addin value and that column was not already in the
              //      insert, add the value to the insert
              if (
                  jsnInsert.data.addin &&
                  jsnInsert.data.addin.link_column &&
                  jsnInsert.data.addin.link_value &&
                  jsnInsert
                      .data
                      .columns
                      .indexOf(jsnInsert.data.addin.link_column) === -1
              ) {
                  strColumn = jsnInsert.data.addin.link_column;
  
                  jsnInsert.data.columns.push(
                      jsnInsert.data.addin.link_column
                  );
  
                  rec_i = 0;
                  rec_len = jsnInsert.data.values.length;
                  while (rec_i < rec_len) {
                      jsnInsert.data.values[rec_i] += '\t';
                      jsnInsert.data.values[rec_i] += GS.encodeForTabDelimited(
                          jsnInsert.data.addin.link_value
                      );
                      rec_i += 1;
                  }
              }
              console.log(jsnInsert.data.columns, jsnInsert.data.addin);
  
              // build up insert column list
              strInsertColumns = '';
              col_i = 0;
              col_len = jsnInsert.data.columns.length;
              while (col_i < col_len) {
                  strColumn = jsnInsert.data.columns[col_i].replace(/(\\)/g, '\\\\');
  
                  strInsertColumns += (
                      strInsertColumns
                          ? '\t'
                          : ''
                  );
                  strInsertColumns += strColumn;
  
                  col_i += 1;
              }
  
              // build up insert payload by appending each record with a \n in
              //      front of it
              strInsertData = '';
              rec_i = 0;
              rec_len = jsnInsert.data.values.length;
              while (rec_i < rec_len) {
                  strInsertData += jsnInsert.data.values[rec_i];
                  strInsertData += '\n';
                  rec_i += 1;
              }
  
              // no need to append a return after the end of the insert data
              //      because the loop that builds up the record list above
              //      already appends the \n to the end
  
          } else {
              throw 'GS-TABLE Error: Invalid insert type: "' + strMode + '".';
          }
  
          // regardless of insert mode, we need a list of columns that uniquely
          //      identifies a record
          col_i = 0;
          col_len = arrSeq.length;
          while (col_i < col_len) {
              if (jsnInsert.data.columns.indexOf(arrSeq[col_i]) !== -1) {
                  arrSeq[col_i] = '';
              }
              col_i += 1;
          }
  
          strPK = '';
          col_i = 0;
          col_len = arrPK.length;
          while (col_i < col_len) {
              strPK += (
                  strPK
                      ? '\t'
                      : ''
              );
              strPK += GS.encodeForTabDelimited(arrPK[col_i], strNullString);
              col_i += 1;
          }
  
          strSeq = '';
          col_i = 0;
          col_len = arrSeq.length;
          while (col_i < col_len) {
              strSeq += (
                  col_i === 0
                      ? ''
                      : '\t'
              );
              if (jsnInsert.data.columns.indexOf(arrPK[col_i]) === -1) {
                  strSeq += arrSeq[col_i] || '';
              }
              col_i += 1;
          }
  
          // combine columns and data for the websocket call
          strInsertData = strInsertColumns + '\n' + strInsertData;
  
          // trigger a "before_insert" event so that the page has a
          //      chance to cancel the update using event.preventDefault()
          beforeEvent = GS.triggerEvent(element, 'before_insert', {
              "schema": strSchema,
              "object": strObject,
              "insertMode": strMode,
              "insertData": jsnInsert.data
          });
  
          // if the user prevents the default on the "before_update"
          //      event, prevent the execution of the following update code
          if (beforeEvent.defaultPrevented) {
              return;
          }
  
          // the insert step is defined as a sub function because if there
          //      are multiple records involved in this update, we want to open
          //      a dialog before we continue, else we want to immediately update
          insertStep = function () {
              var insertedRecords;
  
              // define "insertedRecords" as empty so that we can append to it
              //      without worrying about an "undefined" at the beginning of
              //      the string
              insertedRecords = '';
  
              // gotta let the user know that an insert is in progress
              addLoader(element, 'data-insert', 'Inserting Data...');
              console.log(strSchema,
                  strObject,
                  strReturn,
                  strPK,
                  strSeq,
                  strInsertData);
              // begin the websocket insert
              GS.requestInsertFromSocket(
                  getSocket(element),
                  strSchema,
                  strObject,
                  strReturn,
                  strPK,
                  strSeq,
                  strInsertData,
                  // transaction start callback
                  function (data, error) {
                      // insert failed, remove loader and popup error dialog
                      if (error) {
                          removeLoader(element, 'data-insert', 'Insert Failed');
                          GS.webSocketErrorDialog(data);
                      }
                  },
  
                  // transaction ready for commit/rollback callback
                  // "ignore" is a placeholder for "transID" and it tells JSLINT
                  //      that it is an unused variable
                  function (data, error, ignore, commit, rollback) {
                      if (!error) {
                          // insert made it through: commit the update
                          if (data === 'TRANSACTION COMPLETED') {
                              commit();
  
                          // else: we've just received a data packet containing
                          //      the inserted records as they appear in the
                          //      database
                          } else {
                              // save this data so that we can use it to update
                              //      the internal data if the insert makes it
                              //      through
                              insertedRecords += data;
                          }
                      // insert failed: popup an error and rollback
                      } else {
                          GS.webSocketErrorDialog(data);
                          rollback();
                      }
                  },
  
                  // transaction commit/rollback finished callback
                  function (strAnswer, data, error) {
                      var arrRecords;
                      var i;
                      var len;
  
                      // the over-the-network part of the update has finished,
                      //      remove the loader now so that if there is an
                      //      execution error below, the loader wont be stuck
                      //      visible
                      removeLoader(
                          element,
                          'data-insert',
                          (
                              error
                                  ? 'Insert Failed'
                                  : 'Insert Successful'
                          )
                      );
  
                      if (!error) {
                          // insert was successfully commited: update internal
                          //      data and re-render
                          if (strAnswer === 'COMMIT') {
                              // refresh internal data by replace each internal
                              //      record that was affected with it's new
                              //      version
                              arrRecords = insertedRecords.split('\n');
                              i = 0;
                              len = arrRecords.length - 1; // the - 1 is because
                                                           //   of the extra \n at
                                                           //   the end of the
                                                           //   returned records
                              while (i < len) {
                                  element.internalData
                                      .records.push(arrRecords[i]);
                                  element.internalDisplay
                                      .recordHeights.push(intRecordHeight);
                                  i += 1;
                              }
  
                              // standard after-insert behaviour
                              dataINSERTcallback(element);
  
                              // trigger an after insert event
                              GS.triggerEvent(element, 'after_insert', {
                                  "insertMode": strMode,
                                  "insertData": jsnInsert.data
                              });
                          }
                      // insert failed: popup an error
                      } else {
                          GS.webSocketErrorDialog(data);
                      }
                  }
              );
          };
  
          // we don't want to be able to insert of there's no insert data, so if
          //      we're doing a multi record insert with no records to insert OR
          //      any kind of insert with no columns: error
          if (
              (
                  strMode !== 'single-record' &&
                  jsnInsert.data.values.length === 0
              ) ||
              jsnInsert.data.columns.length === 0
          ) {
              GS.msgbox(
                  'Nothing To Create',
                  '<center>' +
                          'Please input data to create.' +
                          '</center>',
                  ['Ok']
              );
  
          // sometimes, the insert has already been confirmed by the user. if it
          //      has, just carry on and insert
          } else if (jsnInsert.insertConfirmed === true) {
              insertStep();
  
          // else, we need to confirm with the user and then create the records
          } else {
              strPostfix = (
                  (
                      strMode === 'single-record' ||
                      jsnInsert.data.values.length === 1
                  )
                      ? 'this record'
                      : 'these records'
              );
              GS.msgbox(
                  'Are you sure...',
                  '<center>' +
                          'Are you sure you want to create ' + strPostfix + '?' +
                          '</center>',
                  [
                      'No',
                      'Yes'
                  ],
                  function (strAnswer) {
                      if (strAnswer === 'Yes') {
                          insertStep();
                      }
                  }
              );
          }
      }
      function databaseWSUPDATE(element, strMode, jsnUpdate) {
          console.trace('databaseWSUPDATE');
          var i;
          var len;
          var pk_i;
          var pk_len;
          var lock_i;
          var lock_len;
          var col_i;
          var col_len;
  
          var strPostfix;
          var beforeEvent;
          var updateStep;
          var jsnCurrentData;
  
          var strSchema;
          var strObject;
          var strReturn;
          var strHashColumns;
          var strRecord;
          var strUpdateData;
  
          var intUpdateColumnIndex;
          var arrPK;
          var arrLock;
          var startingIndex;
          var arrRecordIndexes;
          //var strTempRecord;
  
          var strRow;
          var jsnRow;
          var cell_i;
          var cell;
          var char;
  
          var strRoles;
          var strColumns;
          var arrColumnNames;
          var strHashString;
          var strTemp;
  
          // get schema and object attributes and get the return column list
          strSchema = GS.templateWithQuerystring(
              element.getAttribute('schema') || ''
          );
          strObject = GS.templateWithQuerystring(
              element.getAttribute('object') || ''
          );
  
          // the return column list must be defined the same as the column list
          //      that we store the data with, so we define strReturn using the
          //      column list
          strReturn = '';
          col_i = 0;
          col_len = element.internalData.columnNames.length;
          while (col_i < col_len) {
              strReturn += (
                  strReturn
                      ? '\t'
                      : ''
              );
              strReturn += element.internalData.columnNames[col_i].replace(/(\\)/g, '\\\\');
              col_i += 1;
          }
  
          // save the column name array for speed and easy access
          arrColumnNames = element.internalData.columnNames;
  
          // if single cell update: we only need to gather the update info for
          //      one record
          if (strMode === 'single-cell') {
              jsnCurrentData = {
                  "columnName": jsnUpdate.data.columnName.replace(/(\\)/g, '\\\\'),
                  "recordNumber": jsnUpdate.data.recordNumber,
                  "oldValue": ""
              };
              strHashColumns = '';
              strUpdateData = '';
              startingIndex = '';
  
              // turn the updated column name into a column index so that we can
              //      fetch the old data from the data
              intUpdateColumnIndex = (
                  element
                      .internalData
                      .columnNames
                      .indexOf(jsnUpdate.data.columnName)
              );
  
              // get the index of the record that will be updated
              startingIndex = jsnUpdate.data.recordNumber;
  
              // get the cell's old value so that when we emit before_update
              //      and after_update events we can provide the old data
              jsnCurrentData.oldValue = GS.decodeFromTabDelimited(
                  element.internalData
                      .records[startingIndex]
                      .split('\t')[intUpdateColumnIndex]
              );
  
              // get primary key and lock column names into arrays so that we can
              //      use them for getting the PK and LOCK data and so that we
              //      can tell the websocket the names of the PK and LOCK columns
              if (element.getAttribute('pk')) {
                  arrPK = (
                      GS.templateWithQuerystring(
                          element.getAttribute('pk') || ''
                      )
                  ).split(/[\s]*,[\s]*/);
              } else {
                  arrPK = [];
              }
              if (element.getAttribute('lock')) {
                  arrLock = (
                      GS.templateWithQuerystring(
                          element.getAttribute('lock') || ''
                      )
                  ).split(/[\s]*,[\s]*/);
              } else {
                  arrLock = [];
              }
  
              //console.log('arrPK: ', arrPK);
              //console.log('arrLock: ', arrLock);
  
              // define "strHashColumns", "strRoles" and strColumns as empty so
              //      that we can append to them without worrying about an
              //      "undefined" appearing
              strHashColumns = '';
              strHashString = '';
              strRoles = '';
              strColumns = '';
              strUpdateData = '';
  
              // create record json so that we can easily get column values
              //      we need
              strRow = element.internalData.records[startingIndex];
              jsnRow = {};
  
              i = 0;
              len = strRow.length;
              cell_i = 0;
              cell = "";
              while (i < len) {
                  char = strRow[i];
  
                  if (char === "\t") {
                      jsnRow[arrColumnNames[cell_i]] =
                              GS.decodeFromTabDelimited(cell, '\\N');
  
                      cell = "";
                      cell_i += 1;
                  } else {
                      cell += char;
                  }
                  i += 1;
              }
              jsnRow[arrColumnNames[cell_i]] =
                      GS.decodeFromTabDelimited(cell, '\\N');
  
              // build up column name/role list for websocket update headers
              //      using the PK columns and append pk values
              i = 0;
              len = arrPK.length;
              while (i < len) {
                  strRoles += (
                      strRoles
                          ? '\t'
                          : ''
                  );
                  strRoles += 'pk';
                  strColumns += (
                      strColumns
                          ? '\t'
                          : ''
                  );
                  strColumns += arrPK[i];
                  strUpdateData += (
                      strUpdateData
                          ? '\t'
                          : ''
                  );
                  strUpdateData += jsnRow[arrPK[i]];
                  i += 1;
              }
  
              // build up hash column name list for websocket update headers
              //      using the LOCK columns
              i = 0;
              len = arrLock.length;
              while (i < len) {
                  strHashColumns += (
                      strHashColumns
                          ? '\t'
                          : ''
                  );
                  strHashColumns += arrLock[i];
  
                  strHashString += (
                      strHashString
                          ? '\t'
                          : ''
                  );
                  strTemp = jsnRow[arrLock[i]];
  
                  // the C encodes null values as empty string in the hash portion
                  strHashString += (
                      strTemp === '\\N'
                          ? ''
                          : GS.encodeForTabDelimited(strTemp, '\\N')
                  );
                  i += 1;
              }
  
              if (strHashString) {
                  strRoles += (
                      strRoles
                          ? '\t'
                          : ''
                  );
                  strRoles += 'hash';
  
                  strColumns += (
                      strColumns
                          ? '\t'
                          : ''
                  );
                  strColumns += 'hash';
  
                  strUpdateData += (
                      strUpdateData
                          ? '\t'
                          : ''
                  );
                  strUpdateData += GS.utfSafeMD5(strHashString).toString();
              }
  
              // build up column name/role list for websocket update headers
              //      using the update column
              strRoles += (
                  strRoles
                      ? '\t'
                      : ''
              );
              strRoles += 'set';
              strColumns += (
                  strColumns
                      ? '\t'
                      : ''
              );
              strColumns += jsnUpdate.data.columnName.replace(/(\\)/g, '\\\\');
  
              // append new value
              strUpdateData += (
                  strUpdateData
                      ? '\t'
                      : ''
              );
              strUpdateData += GS.encodeForTabDelimited(jsnUpdate.data.newValue);
  
              // append an extra return to the end so just in case the C needs it
              strUpdateData += '\n';
  
              // prepend columns and roles
              strUpdateData = (
                  strRoles + '\n' +
                  strColumns + '\n' +
                  strUpdateData
              );
  
              // add record index to the array
              arrRecordIndexes = [jsnUpdate.data.recordNumber];
  
          // else if multiple cell update: we have to gather the update info for
          //      a dynamic range of columns and rows
          } else if (strMode === 'cell-range') {
              // {
              //     "data": {
              //         "columns": arrColumns,
              //         "records": arrUpdateIndexes,
              //         "values": arrTranslated
              //     },
              //     "updateConfirmed": false
              // }
              jsnCurrentData = {
                  "columns": "",
                  "records": "",
                  "oldValues": "",
                  "newValues": ""
              };
              strHashColumns = '';
              strUpdateData = '';
              strColumns = '';
              strRoles = '';
  
              // we need to save the old data and the new data in jsnCurrentData
              //      so that when we trigger the "before_selection" event, the
              //      "before_selection" event will show all the data the
              //      developer could need about the update
              // ### NEED CODING ###
  
              // get primary key and lock column names into arrays so that we can
              //      use them for getting the PK and LOCK data and so that we
              //      can tell the websocket the names of the PK and LOCK columns
              if (element.getAttribute('pk')) {
                  arrPK = (
                      GS.templateWithQuerystring(
                          element.getAttribute('pk') || ''
                      )
                  ).split(/[\s]*,[\s]*/);
              } else {
                  arrPK = [];
              }
              if (element.getAttribute('lock')) {
                  arrLock = (
                      GS.templateWithQuerystring(
                          element.getAttribute('lock') || ''
                      )
                  ).split(/[\s]*,[\s]*/);
              } else {
                  arrLock = [];
              }
  
              // build up hash column list
              i = 0;
              len = arrLock.length;
              while (i < len) {
                  strHashColumns += (
                      strHashColumns
                          ? '\t'
                          : ''
                  );
                  strHashColumns += arrLock[i];
                  i += 1;
              }
  
              // add pk columns to the list of updated column names
              i = 0;
              len = arrPK.length;
              while (i < len) {
                  strColumns += (
                      strColumns
                          ? '\t'
                          : ''
                  );
                  strColumns += arrPK[i];
                  i += 1;
              }
  
              // build up column names
              i = 0;
              len = jsnUpdate.data.columns.length;
              while (i < len) {
                  strColumns += (
                      strColumns
                          ? '\t'
                          : ''
                  );
                  strColumns += jsnUpdate.data.columns[i].replace(/(\\)/g, '\\\\');
                  i += 1;
              }
  
              // add the hash column to the list of column names
              strColumns += '\t';
              strColumns += 'hash';
  
              // build up column role list
              i = 0;
              len = arrPK.length;
              while (i < len) {
                  strRoles += (
                      strRoles
                          ? '\tpk'
                          : 'pk'
                  );
                  i += 1;
              }
              i = 0;
              len = jsnUpdate.data.columns.length;
              while (i < len) {
                  strRoles += (
                      strRoles
                          ? '\tset'
                          : 'set'
                  );
                  i += 1;
              }
              strRoles += '\t';
              strRoles += 'hash';
  
              // prepend pks to update records
              // append hashes to update records
              i = 0;
              len = jsnUpdate.data.records.length;
              while (i < len) {
                  strRecord = '';
  
                  // pk data
                  pk_i = 0;
                  pk_len = arrPK.length;
                  while (pk_i < pk_len) {
                      strRecord += (
                          strRecord
                              ? '\t'
                              : ''
                      );
                      strRecord += getCell(
                          element,
                          arrPK[pk_i],
                          jsnUpdate.data.records[i],
                          false
                      );
                      pk_i += 1;
                  }
  
                  // new record data
                  strRecord += (
                      strRecord
                          ? '\t'
                          : ''
                  );
                  strRecord += jsnUpdate.data.values[i];
  
                  // hash data
                  strHashString = '';
                  lock_i = 0;
                  lock_len = arrLock.length;
                  while (lock_i < lock_len) {
                      strHashString += (
                          strHashString
                              ? '\t'
                              : ''
                      );
                      strTemp = getCell(
                          element,
                          arrLock[lock_i],
                          jsnUpdate.data.records[i],
                          false
                      );
  
                      // the C encodes null values as empty string
                      //      in the hash portion
                      strHashString += (
                          strTemp === '\\N'
                              ? ''
                              : GS.encodeForTabDelimited(strTemp, '\\N')
                      );
                      lock_i += 1;
                  }
  
                  strRecord += (
                      strRecord
                          ? '\t'
                          : ''
                  );
                  strRecord += GS.utfSafeMD5(strHashString).toString();
  
                  // add record update to update data
                  strUpdateData += strRecord;
                  strUpdateData += '\n';
  
                  //console.log('Record:', strRecord);
                  i += 1;
              }
  
              // combine the data with the columns and roles
              strUpdateData = (
                  strRoles + '\n' +
                  strColumns + '\n' +
                  strUpdateData
              );
  
              arrRecordIndexes = jsnUpdate.data.records;
  
              //console.log('hashcolumns: ', strHashColumns);
              //console.log('    columns: ', strColumns);
              //console.log('      roles: ', strRoles);
              //console.log('       data: ', jsnUpdate);
  
          // else: invalid update type: throw an error
          } else {
              throw 'GS-TABLE Error: Invalid update type. Update type "' +
                      strMode + '" is not valid, please use "single-cell" ' +
                      'or "cell-range".';
          }
  
          // trigger a "before_update" event so that the page has a
          //      chance to cancel the update using event.preventDefault()
          beforeEvent = GS.triggerEvent(element, 'before_update', {
              "schema": strSchema,
              "object": strObject,
              "updateMode": strMode,
              "oldData": jsnCurrentData,
              "newData": jsnUpdate.data
          });
  
          // if the user prevents the default on the "before_update"
          //      event, prevent the execution of the following update code
          if (beforeEvent.defaultPrevented) {
              return;
          }
  
          // the update step is defined as a sub function because if there
          //      are multiple cells involved in this update, we want to open
          //      a dialog before we continue, else we want to immediatly
          //      update
          updateStep = function () {
              var updatedRecords;
  
              // define "updatedRecords" as empty so that we can append to it
              //      without worrying about an "undefined" at the beginning of
              //      the string
              updatedRecords = '';
  
              // gotta let the user know that an update is in progress
              addLoader(element, 'data-update', 'Updating Data...');
  
              // begin the websocket update
              GS.requestUpdateFromSocket(
                  getSocket(element),
                  strSchema,
                  strObject,
                  strReturn,
                  strHashColumns,
                  strUpdateData,
                  // transaction start callback
                  function (data, error) { //transID
                      // update failed: remove loader, popup an error
                      //      and reverse changes
                      if (error) {
                          removeLoader(element, 'data-update', 'Change Failed');
                          GS.webSocketErrorDialog(data);
                          //getData(element);
                      }
                  },
                  // transaction ready for commit/rollback callback
                  // "ignore" is a placeholder for "transID" and it tells JSLINT
                  //      that it is an unused variable
                  function (data, error, ignore, commit, rollback) {
                      if (!error) {
                          // update made it through: commit the update
                          if (data === 'TRANSACTION COMPLETED') {
                              commit();
  
                          // else: we've just received a data packet containing
                          //      the updated records current version
                          } else {
                              // save this data so that we can use it to update
                              //      the internal data if the update makes it
                              //      through
                              //  ,----- data already comes back with an extra \n
                              // v
                              //updatedRecords += (
                              //    updatedRecords
                              //        ? '\n'
                              //        : ''
                              //);
                              updatedRecords += data;
                              //console.log(updatedRecords, data);
                          }
                      // update failed: popup an error, rollback and
                      //      reverse change
                      } else {
                          GS.webSocketErrorDialog(data);
                          rollback();
                          //getData(element);
                      }
                  },
                  // transaction commit/rollback finished callback
                  function (strAnswer, data, error) {
                      var arrRecords;
                      //var i;
                      //var len;
  
                      // the over-the-network part of the update has finished,
                      //      remove the loader now so that if there is an
                      //      execution error below, the loader wont be stuck
                      //      visible
                      removeLoader(
                          element,
                          'data-update',
                          (
                              error
                                  ? 'Change Failed'
                                  : 'Change Saved'
                          )
                      );
  
                      if (!error) {
                          // update was successfully commited: update internal
                          //      data and re-render
                          if (strAnswer === 'COMMIT') {
                              // refresh internal data by replace each internal
                              //      record that was affected with it's new
                              //      version
                              arrRecords = updatedRecords.split('\n');
                              i = 0;
                              len = arrRecords.length - 1; // the - 1 is because
                                                           //   of the extra \n at
                                                           //   the end of the
                                                           //   returned records
                              while (i < len) {
                                  element.internalData
                                      .records[arrRecordIndexes[i]] = (
                                          arrRecords[i]
                                      );
                                  i += 1;
                              }
  
                              dataUPDATEcallback(element);
  
                              // trigger an after update event
                              GS.triggerEvent(element, 'after_update', {
                                  "updateMode": strMode,
                                  "oldData": jsnCurrentData,
                                  "newData": jsnUpdate.data
                              });
                          // transaction was rolled back: reverse change
                          } else {
                              //getData(element);
                          }
                      // update failed: popup an error and reverse change
                      } else {
                          GS.webSocketErrorDialog(data);
                          //getData(element);
                      }
                  }
              );
          };
  
          // if the update has been confirmed: carry on and update
          if (jsnUpdate.updateConfirmed === true) {
              updateStep();
  
          // else, we need to confirm the update
          } else {
              strPostfix = (
                  (
                      !jsnUpdate.data.records ||
                      jsnUpdate.data.records.length === 1
                  )
                      ? 'this record'
                      : 'these records'
              );
              GS.msgbox(
                  'Are you sure...',
                  '<center>' +
                          'Are you sure you want to update ' + strPostfix + '?' +
                          '</center>',
                  [
                      'No',
                      'Yes'
                  ],
                  function (strAnswer) {
                      if (strAnswer === 'Yes') {
                          updateStep();
                      }
                  }
              );
          }
  
          // commented out in favor of "updateConfirmed" logic
          //// if multiple cells will be updated: confirm update
          //if (strMode === 'cell-range') {
          //    GS.msgbox(
          //        'Are you sure...',
          //        '<center>' +
          //                'Are you sure you want to update these records?' +
          //                '</center>',
          //        [
          //            'No',
          //            'Yes'
          //        ],
          //        function (strAnswer) {
          //            if (strAnswer === 'Yes') {
          //                updateStep();
          //            }
          //        }
          //    );
  
          //// else if single cell: update immediately
          //} else if (strMode === 'single-cell') {
          //    updateStep();
          //}
      }
      function databaseWSDELETE(element, jsnDelete) {
          var i;
          var len;
          var col_i;
          var col_len;
          var strSchema;
          var strObject;
          var strPostfix;
  
          var beforeEvent;
          var deleteStep;
  
          var strPK;
          var strLock;
          var arrPK;
          var arrLock;
  
          var intIndex;
          var arrColumns;
  
          var strColumnNames;
          var strColumnRoles;
          var strHashColumns;
          var strRecordToHash;
          var strTemp;
          var strDeleteData;
          var strDeleteRecords;
          var arrDeleteRecord;
          var strRecord;
  
          var strNullString;
  
          // get schema and object attributes and get the return column list
          strSchema = GS.templateWithQuerystring(
              element.getAttribute("schema") || ""
          );
          strObject = GS.templateWithQuerystring(
              element.getAttribute("object") || ""
          );
  
          // we want the null string to be configurable, so we'll read the
          //      "null-string" attribute to get the null string
          // if the "null-string" attribute is present, use the contents
          //      or coalesce to empty string
          if (element.hasAttribute('null-string')) {
              strNullString = element.getAttribute('null-string') || '';
  
          // else, null string is left up to the encoding function
          } else {
              strNullString = undefined;
          }
  
          // create variables for websocket delete call
  
          // we need to know the primary key columns and the lock columns
          strPK = (element.getAttribute("pk") || "");
          strLock = (element.getAttribute("lock") || "");
          arrPK = strPK.split(/[\s]*,[\s]*/);
          arrLock = strLock.split(/[\s]*,[\s]*/);
  
          // when we start getting the data for the records we need to delete,
          //      we're going to need to be able to grab the correct columns by
          //      name, so we'll save the currently selected column list to a
          //      local variable for convenience
          arrColumns = element.internalData.columnNames;
  
          // initialize column name and column role variables so that we
          //      can append to them safely
          strColumnRoles = '';
          strColumnNames = '';
  
          // append pk columns and roles
          i = 0;
          len = arrPK.length;
          while (i < len) {
              strColumnNames += (
                  strColumnNames
                      ? "\t"
                      : ""
              );
              strColumnNames += arrPK[i];
              strColumnRoles += (
                  strColumnRoles
                      ? "\t"
                      : ""
              );
              strColumnRoles += "pk";
              i += 1;
          }
  
          // append column and role for the hash column
          strColumnNames += (
              strColumnNames
                  ? "\t"
                  : ""
          );
          strColumnNames += "hash";
          strColumnRoles += (
              strColumnRoles
                  ? "\t"
                  : ""
          );
          strColumnRoles += "hash";
  
          // build up hash column list
          strHashColumns = '';
          i = 0;
          len = arrLock.length;
          while (i < len) {
              strHashColumns += (
                  strHashColumns
                      ? "\t"
                      : ""
              );
              strHashColumns += arrLock[i];
              i += 1;
          }
  
          // now that we have the metadata taken care of, gather up the records
          strDeleteRecords = '';
          i = 0;
          len = jsnDelete.recordIndexes.length;
  
  
          //// create cell array for this record
          //strRecord = element.internalData.records[i] + '\t';
          //arrDeleteRecord = [];
          //col_i = 0;
          //col_len = element.internalData.columnNames.length;//9999;
          //while (col_i < col_len) {
          //    delim = strRecord.indexOf('\t');
          //    strCell = strRecord.substring(0, delim);
          //    strRecord = strRecord.substring(delim + 1);
  
          //    arrDeleteRecord.push(
          //        GS.decodeFromTabDelimited(strCell, strNullString)
          //    );
  
          //    col_i += 1;
          //}
  
  
          while (i < len) {
              strRecord = '';
              arrDeleteRecord = element.internalData.records[
                  jsnDelete.recordIndexes[i]
              ].split("\t");
  
              // get PK columns
              col_i = 0;
              col_len = arrPK.length;
              while (col_i < col_len) {
                  // get column index for this current PK
                  intIndex = arrColumns.indexOf(arrPK[col_i]);
  
                  // append cell to current delete record
                  strRecord += (
                      strRecord
                          ? "\t"
                          : ""
                  );
                  strRecord += GS.encodeForTabDelimited(
                      arrDeleteRecord[intIndex],
                      strNullString
                  );
  
                  col_i += 1;
              }
  
              // get hash columns
              strRecordToHash = "";
              col_i = 0;
              col_len = arrLock.length;
              while (col_i < col_len) {
                  //// get column index for this current hash column
                  //intIndex = arrColumns.indexOf(arrLock[col_i]);
  
                  // append cell to current hash record
                  strRecordToHash += (
                      strRecordToHash
                          ? "\t"
                          : ""
                  );
                  //strTemp = arrDeleteRecord[intIndex];
                  strTemp = getCell(
                                  element,
                                  arrLock[col_i],
                                  jsnDelete.recordIndexes[i],
                                  false
                              );
  
                  // I saw this in the code I copied while making this:
                  //      "I believe that this needs to
                  //          use the null-string instead of 'NULL'"
                  strRecordToHash += (
                      strTemp === "\\N"
                          ? ""
                          : strTemp
                  );
                  console.log(strTemp, strRecordToHash);
  
                  col_i += 1;
              }
  
              // append record to deleteData
              strDeleteRecords += strRecord;
              strDeleteRecords += (
                  strRecord
                      ? '\t'
                      : ''
              );
              strDeleteRecords += GS.utfSafeMD5(strRecordToHash).toString();
              strDeleteRecords += '\n';
  
              i += 1;
          }
  
          // combine the metadata with the delete records
          strDeleteData = (
              strColumnRoles + '\n' +
              strColumnNames + '\n' +
              strDeleteRecords
          );
  
          // trigger a "before_update" event so that the page has a
          //      chance to cancel the update using event.preventDefault()
          beforeEvent = GS.triggerEvent(element, 'before_delete', {
              "schema": strSchema,
              "object": strObject,
              "recordIndexes": jsnDelete.recordIndexes,
              "deleteConfirmed": jsnDelete.deleteConfirmed,
              "strColumnRoles": strColumnRoles,
              "strColumnNames": strColumnNames,
              "strDeleteRecords": strDeleteRecords
          });
  
          // if the user prevents the default on the "before_update"
          //      event, prevent the execution of the following update code
          if (beforeEvent.defaultPrevented) {
              return;
          }
  
          // the delete step is defined as a sub function because we only
          //      want to do the delete under certain circumstances
          deleteStep = function () {
              // gotta let the user know that an update is in progress
              addLoader(element, 'data-delete', 'Deleting Data...');
  
              // begin the websocket update
              GS.requestDeleteFromSocket(
                  getSocket(element),
                  strSchema,
                  strObject,
                  strHashColumns,
                  strDeleteData,
                  // transaction start callback
                  function (data, error) { //transID
                      // delete failed: remove loader, popup an error
                      if (error) {
                          removeLoader(element, 'data-delete', 'Delete Failed');
                          GS.webSocketErrorDialog(data);
                      }
                  },
                  // transaction ready for commit/rollback callback
                  // "ignore" is a placeholder for "transID" and it tells JSLINT
                  //      that it is an unused variable
                  function (data, error, ignore, commit, rollback) {
                      if (!error) {
                          // delete made it through: commit the delete
                          if (data === 'TRANSACTION COMPLETED') {
                              commit();
                          }
                      // delete failed: popup an error, rollback
                      } else {
                          GS.webSocketErrorDialog(data);
                          rollback();
                      }
                  },
                  // transaction commit/rollback finished callback
                  function (strAnswer, data, error) {
                      var arrRecords;
                      var arrRecordHeights;
  
                      // the over-the-network part of the delete has finished,
                      //      remove the loader now so that if there is an
                      //      execution error below, the loader wont be stuck
                      //      visible
                      removeLoader(
                          element,
                          'data-delete',
                          (
                              error
                                  ? 'Delete Failed'
                                  : 'Delete Successful'
                          )
                      );
  
                      if (!error) {
                          // delete was successfully commited: update internal
                          //      data and re-render
                          if (strAnswer === 'COMMIT') {
                              // now that the delete was successful, we'll
                              //      recreate the record and record height
                              //      arrays and skip the records at the indexes
                              //      that were deleted
                              // Some of you may be asking:
                              //      "why doesn't he just use .splice()?".
                              //      That, young grasshopper, is because through
                              //      my travels I've found .splice() to be
                              //      significantly slower than simply rebuilding
                              //      the array. This is what I do in pgManage's
                              //      tree code.
                              arrRecords = [];
                              arrRecordHeights = [];
  
                              i = 0;
                              len = element.internalData.records.length;
                              while (i < len) {
                                  if (jsnDelete.recordIndexes.indexOf(i) === -1) {
                                      arrRecords.push(
                                          element.internalData.records[i]
                                      );
                                      arrRecordHeights.push(
                                          element.internalDisplay.recordHeights[i]
                                      );
                                  }
                                  i += 1;
                              }
  
                              // set the internal record and record heights to
                              //      the newly pruned arrays
                              element
                                  .internalData
                                  .records = arrRecords;
                              element
                                  .internalDisplay
                                  .recordHeights = arrRecordHeights;
  
                              // standard after delete procedure
                              dataDELETEcallback(element);
  
                              // trigger an after delete event
                              GS.triggerEvent(element, 'after_delete', {
                                  "schema": strSchema,
                                  "object": strObject,
                                  "recordIndexes": jsnDelete.recordIndexes,
                                  "strColumnRoles": strColumnRoles,
                                  "strColumnNames": strColumnNames,
                                  "strDeleteRecords": strDeleteRecords
                              });
                          }
                      // delete failed: popup an error
                      } else {
                          GS.webSocketErrorDialog(data);
                      }
                  }
              );
          };
  
          // if no records have been sent to delete: error
          if (jsnDelete.recordIndexes.length === 0) {
              GS.msgbox(
                  'No Records To Delete',
                  '<center>' +
                          'Please choose a record to delete.' +
                          '</center>',
                  ['Ok']
              );
  
          // else if the delete has been confirmed: carry on and delete
          } else if (jsnDelete.deleteConfirmed === true) {
              deleteStep();
  
          // else, we need to confirm the delete
          } else {
              strPostfix = (
                  jsnDelete.recordIndexes.length === 1
                      ? 'this record'
                      : 'these records'
              );
              GS.msgbox(
                  'Are you sure...',
                  '<center>' +
                          'Are you sure you want to delete ' + strPostfix + '?' +
                          '</center>',
                  [
                      'No',
                      'Yes'
                  ],
                  function (strAnswer) {
                      if (strAnswer === 'Yes') {
                          deleteStep();
                      }
                  }
              );
          }
      }
  
      // sometimes, you dont want to save to the database, that's what these
      //      internal SELECT, INSERT, UPDATE and DELETE functions are for
  
      function internalSELECT(element) {
          var templateElement;
          var arrColumns;
  
          // on the first load, the GS-TABLE doesn't know what the column names
          //      are. so, here we'll scan the templates to come up with a column
          //      list
          if (element.internalData.columnNames.length === 0) {
              templateElement = document.createElement('template');
  
              // we'll check the insertDialog template for column names
              templateElement.innerHTML = element.internalTemplates.insertDialog;
              arrColumns = templateGetColumnList(templateElement);
              arrColumns.forEach(function (strColumn) {
                  if (
                      element.internalData.columnNames.indexOf(strColumn) === -1
                  ) {
                      element.internalData.columnNames.push(strColumn);
                      element.internalData.columnTypes.push('text');
                      element.internalData.columnFilterStatuses.push('on');
                      element.internalData.columnFilters.push([]);
                      element.internalData.columnListFilters.push({});
                      element.internalData.columnOrders.push('neutral');
                  }
              });
  
              // we'll check the insertRecord template for column names
              templateElement.innerHTML = element.internalTemplates.insertRecord;
              arrColumns = templateGetColumnList(templateElement);
              arrColumns.forEach(function (strColumn) {
                  if (
                      element.internalData.columnNames.indexOf(strColumn) === -1
                  ) {
                      element.internalData.columnNames.push(strColumn);
                      element.internalData.columnTypes.push('text');
                      element.internalData.columnFilterStatuses.push('on');
                      element.internalData.columnFilters.push([]);
                      element.internalData.columnListFilters.push({});
                      element.internalData.columnOrders.push('neutral');
                  }
              });
  
              // we'll check the record template for column names
              templateElement.innerHTML = element.internalTemplates.record;
              arrColumns = templateGetColumnList(templateElement);
              arrColumns.forEach(function (strColumn) {
                  if (
                      element.internalData.columnNames.indexOf(strColumn) === -1
                  ) {
                      element.internalData.columnNames.push(strColumn);
                      element.internalData.columnTypes.push('text');
                      element.internalData.columnFilterStatuses.push('on');
                      element.internalData.columnFilters.push([]);
                      element.internalData.columnListFilters.push({});
                      element.internalData.columnOrders.push('neutral');
                  }
              });
          }
  
          // we need to re-render and all that jazz
          dataSELECTcallback(element);
      }
  
      function internalINSERT(element, strMode, jsnInsert) {
          var beforeEvent;
          var insertStep;
          var strPostfix;
          var strNullString;
          var intRecordHeight;
          var strRecord;
          var arrRecords;
          var arrRecord;
          var arrColumns;
          var strColumn;
          var strValue;
          var index;
          var i;
          var len;
          //var rec_i;
          //var rec_len;
          var col_i;
          var col_len;
  
          //console.log(element, strMode, jsnInsert); //multi-record
  
          // we want the null string to be configurable, so we'll read the
          //      "null-string" attribute to get the null string
          // if the "null-string" attribute is present, use the contents
          //      or coalesce to empty string
          if (element.hasAttribute('null-string')) {
              strNullString = element.getAttribute('null-string') || '';
  
          // else, null string is left up to the encoding function
          } else {
              strNullString = undefined;
          }
  
          // we need to create records with the default record height attached to
          //      them, so we'll use the "default-record-height" attribute
          intRecordHeight = (
              parseInt(element.getAttribute('default-record-height'), 10) ||
              intDefaultRecordHeight
          );
  
          // trigger a "before_insert" event so that the page has a
          //      chance to cancel the update using event.preventDefault()
          beforeEvent = GS.triggerEvent(element, 'before_insert', {
              "insertMode": strMode,
              "insertData": jsnInsert.data
          });
  
          // if the user prevents the default on the "before_update"
          //      event, prevent the execution of the following update code
          if (beforeEvent.defaultPrevented) {
              return;
          }
  
          // sometimes, we need to call the insert only after a confirmation.
          //      other times, we insert immediately. separating the insert
          //      code into a sub-function allows us to call it at different
          //      times under different circumstances
          insertStep = function () {
              // gotta let the user know that an insert is in progress
              addLoader(element, 'data-insert', 'Inserting Data...');
  
              // if single record insert:
              if (strMode === "single-record") {
                  /*
                  jsnInsert = {
                      "data": {
                          "addin": {
                              "link_column": "columnname4",
                              "link_value": "value"
                          },
                          "columns": [
                              "columnname1",
                              "columnname2",
                              "columnname3"
                              ...
                          ],
                          "values": {
                              "columnname1": "value",
                              "columnname2": "value",
                              "columnname3": "value"
                              ...
                          }
                      },
                      "insertConfirmed": boolean
                  }
                  */
  
                  // loop through internal column list, build up new record
                  //      ignoring columns that don't exist and adding nulls
                  //      for columns that exist but weren't filled in
                  strRecord = "";
                  arrColumns = element.internalData.columnNames;
                  i = 0;
                  len = arrColumns.length;
                  while (i < len) {
                      strColumn = arrColumns[i];
  
                      // separate columns with tab characters
                      if (i > 0) {
                          strRecord += "\t";
                      }
  
                      // get value for column
                      strValue = jsnInsert.data.values[strColumn];
  
                      // if column is defined in insert values
                      if (strValue !== undefined) {
                          strRecord += GS.encodeForTabDelimited(
                              strValue,
                              strNullString
                          );
  
                      // if column is defined in addin values
                      } else if (jsnInsert.data.addin.link_column === strColumn) {
                          strRecord += GS.encodeForTabDelimited(
                              jsnInsert.data.addin.link_value,
                              strNullString
                          );
  
                      // else, null the cell
                      } else {
                          strRecord += '\\N';
                      }
  
                      i += 1;
                  }
  
                  // append record text and record height to internal variables
                  element.internalData.records.push(strRecord);
                  element.internalDisplay.recordHeights.push(intRecordHeight);
  
              // else if multi record insert:
              } else if (strMode === "multi-record") {
                  /*
                  jsnInsert = {
                      "data": {
                          "addin": {
                              "link_column": "columnname4",
                              "link_value": "value"
                          },
                          "columns": [
                              "columnname1",
                              "columnname2"
                              ...
                          ],
                          "values": [
                              "value1\tvalue1",
                              "value2\tvalue2",
                              "value3\tvalue3"
                              ...
                          ]
                      },
                      "insertConfirmed": boolean
                  }
                  */
  
                  // loop through internal column list, build up new record
                  //      ignoring columns that don't exist and adding nulls
                  //      for columns that exist but weren't filled in
                  arrRecords = [];
                  arrColumns = element.internalData.columnNames;
                  // ### NEED CODING ###
                  i = 0;
                  len = jsnInsert.data.values.length;
                  while (i < len) {
  
                      // split record
                      strRecord = jsnInsert.data.values[i];
                      arrRecord = strRecord.split('\t');
                      //rec_i = 0;
                      //rec_len = strRecord.length;
                      //while (rec_i < rec_len) {
                      //    rec_i += 1;
                      //}
  
                      // create full records
                      strRecord = "";
                      col_i = 0;
                      col_len = arrColumns.length;
                      while (col_i < col_len) {
                          strColumn = arrColumns[col_i];
                          index = jsnInsert.data.columns.indexOf(strColumn);
                          strValue = arrRecord[index];
  
                          // separate columns with tab characters
                          if (col_i > 0) {
                              strRecord += "\t";
                          }
  
                          // get value for current column
                          if (strValue) {
                              strRecord += arrRecord[index];
  
                          // if column is defined in addin values
                          } else if (
                              jsnInsert.data.addin.link_column === strColumn
                          ) {
                              strRecord += GS.encodeForTabDelimited(
                                  jsnInsert.data.addin.link_value,
                                  strNullString
                              );
  
                          // else, null the cell
                          } else {
                              strRecord += '\\N';
                          }
  
                          col_i += 1;
                      }
  
                      // push new record to expanded record list
                      arrRecords.push(strRecord);
  
                      i += 1;
                  }
  
                  // append record text and record height to internal variables
                  i = 0;
                  len = arrRecords.length;
                  while (i < len) {
                      element.internalData.records.push(arrRecords[i]);
                      element.internalDisplay.recordHeights.push(intRecordHeight);
                      i += 1;
                  }
              }
  
              // we need to let the user know the insert is finished
              removeLoader(element, 'data-insert', 'New Record Saved');
  
              // standard after-insert behaviour
              dataINSERTcallback(element);
  
              // trigger an after insert event
              GS.triggerEvent(element, 'after_insert', {
                  "insertMode": strMode,
                  "insertData": jsnInsert.data
              });
          };
  
          // we don't want to be able to insert of there's no insert data, so if
          //      we're doing a multi record insert with no records to insert OR
          //      any kind of insert with no columns: error
          if (
              (
                  strMode !== 'single-record' &&
                  jsnInsert.data.values.length === 0
              ) ||
              jsnInsert.data.columns.length === 0
          ) {
              GS.msgbox(
                  'Nothing To Create',
                  '<center>' +
                          'Please input data to create.' +
                          '</center>',
                  ['Ok']
              );
  
          // sometimes, the insert has already been confirmed by the user. if it
          //      has, just carry on and insert
          } else if (jsnInsert.insertConfirmed === true) {
              insertStep();
  
          // else, we need to confirm with the user and then create the records
          } else {
              strPostfix = (
                  (
                      strMode === 'single-record' ||
                      jsnInsert.data.values.length === 1
                  )
                      ? 'this record'
                      : 'these records'
              );
              GS.msgbox(
                  'Are you sure...',
                  '<center>' +
                          'Are you sure you want to create ' + strPostfix + '?' +
                          '</center>',
                  [
                      'No',
                      'Yes'
                  ],
                  function (strAnswer) {
                      if (strAnswer === 'Yes') {
                          insertStep();
                      }
                  }
              );
          }
      }
      function internalUPDATE(element, strMode, jsnUpdate) {
          var i;
          var len;
          var row_i;
          var row_len;
  
          var strPostfix;
          var beforeEvent;
          var updateStep;
          var jsnCurrentData;
  
          var intUpdateColumnIndex;
          var arrUpdateColumnIndexes;
          var startingIndex;
          var arrUpdatePaste;
  
          var update_i;
          var cell_i;
          var cell;
          var char;
  
          var strOldRow;
          var strNewRow;
          var arrRecordIndexes;
          var arrRecordReplacements;
  
          //console.log(element, strMode, jsnUpdate);
  
          // we need to be able to have unupdatable columns
          // ### NEED CODING ###
  
          // we need to be able to use the data from a header-child relationship
          // ### NEED CODING ###
  
          // this function updates internal data and then re-renders. essentially,
          //      we'll be masking the new data over the old data.
  
          // if single cell update: we only need to gather the update info for
          //      one record
          if (strMode === 'single-cell') {
              jsnCurrentData = {
                  "columnName": jsnUpdate.data.columnName,
                  "recordNumber": jsnUpdate.data.recordNumber,
                  "oldValue": ""
              };
  
              // turn the updated column name into a column index so that we can
              //      fetch the old data from the data
              intUpdateColumnIndex = (
                  element
                      .internalData
                      .columnNames
                      .indexOf(jsnUpdate.data.columnName)
              );
  
              // get the index of the record that will be updated
              startingIndex = jsnUpdate.data.recordNumber;
  
              // get the old record and get the new record variable ready for
              //      masking
              strOldRow = element.internalData.records[startingIndex];
              strNewRow = '';
  
              // loop through each character of the record and begin masking
              i = 0;
              len = strOldRow.length;
              cell_i = 0;
              cell = "";
              while (i < len) {
                  char = strOldRow[i];
  
                  // if the cell end has been reached
                  if (char === "\t" || i === (len - 1)) {
                      // we don't want to chop the last character off
                      if (i === (len - 1)) {
                          cell += char;
                      }
  
                      // if the cell number is the cell we want to replace,
                      //      insert new value instead of the old value
                      if (cell_i === intUpdateColumnIndex) {
                          strNewRow += GS.encodeForTabDelimited(
                              jsnUpdate.data.newValue
                          );
  
                          // save the old value for the developer in the
                          //      "before_update" and "after_update" events
                          jsnCurrentData.oldValue = cell;
  
                      // else, maintain old data
                      } else {
                          strNewRow += cell;
                      }
  
                      cell = "";
                      cell_i += 1;
  
                  // else, keep building up the cell variable
                  } else {
                      cell += char;
                  }
  
                  // we want to maintain the tab characters
                  if (char === "\t") {
                      strNewRow += '\t';
                  }
  
                  i += 1;
              }
  
              // regardless of single or multi-record updates, we use the same
              //      code to make the change in the internal data. this code
              //      needs the record indexes of the update records and the new
              //      version of each of the records
  
              // add record index to the updated record list
              arrRecordIndexes = [startingIndex];
  
              // add new record to updated data array
              arrRecordReplacements = [strNewRow];
  
          // else if multiple cell update: we have to gather the update info for
          //      a dynamic range of columns and rows
          } else if (strMode === 'cell-range') {
              // {
              //     "data": {
              //         "columns": arrColumns,
              //         "records": arrUpdateIndexes,
              //         "values": arrTranslated
              //     },
              //     "updateConfirmed": false
              // }
              jsnCurrentData = {
                  "columns": "",
                  "records": "",
                  "oldValues": "",
                  "newValues": ""
              };
  
              // we need to save the old data and the new data in jsnCurrentData
              //      so that when we trigger the "before_selection" event, the
              //      "before_selection" event will show all the data the
              //      developer could need about the update
              // ### NEED CODING ###
  
              // we need to know the indexes of the columns we're updating
              arrUpdateColumnIndexes = [];
              i = 0;
              len = jsnUpdate.data.columns.length;
              while (i < len) {
                  arrUpdateColumnIndexes.push(
                      element.internalData.columnNames
                          .indexOf(jsnUpdate.data.columns[i])
                  );
  
                  i += 1;
              }
  
              // loop through records and mask over old values for each
              i = 0;
              len = jsnUpdate.data.records.length;
              arrRecordReplacements = [];
              while (i < len) {
                  // get the old record and get the new record variable ready for
                  //      masking
                  strOldRow = element.internalData.records[
                      jsnUpdate.data.records[i]
                  ];
                  strNewRow = '';
                  arrUpdatePaste = jsnUpdate.data.values[i].split('\t');
                  update_i = 0;
  
                  // loop through each character of the record and begin masking
                  row_i = 0;
                  row_len = strOldRow.length;
                  cell_i = 0;
                  cell = "";
                  while (row_i < row_len) {
                      char = strOldRow[row_i];
  
                      // if the cell end has been reached
                      if (char === "\t" || row_i === (row_len - 1)) {
                          // if the cell number is the cell we want to replace,
                          //      insert new value instead of the old value
                          if (arrUpdateColumnIndexes.indexOf(cell_i) > -1) {
                              strNewRow += arrUpdatePaste[update_i] || '\\N';
                              update_i += 1;
  
                          // else, maintain old data
                          } else {
                              strNewRow += cell;
                          }
  
                          cell = "";
                          cell_i += 1;
  
                      // else, keep building up the cell variable
                      } else {
                          cell += char;
                      }
  
                      // we want to maintain the tab characters
                      if (char === "\t") {
                          strNewRow += '\t';
                      }
  
                      row_i += 1;
                  }
  
                  //console.log(' strOldRow: ', strOldRow);
                  //console.log(' strNewRow: ', strNewRow);
  
                  arrRecordReplacements.push(strNewRow);
  
                  i += 1;
              }
  
              arrRecordIndexes = jsnUpdate.data.records;
  
              //console.log('arrUpdateColumnIndexes: ', arrUpdateColumnIndexes);
              //console.log(' arrRecordReplacements: ', arrRecordReplacements);
              //console.log('      arrRecordIndexes: ', arrRecordIndexes);
  
          // else: invalid update type: throw an error
          } else {
              throw 'GS-TABLE Error: Invalid update type. Update type "' +
                      strMode + '" is not valid, please use "single-cell" ' +
                      'or "cell-range".';
          }
  
          // trigger a "before_update" event so that the page has a
          //      chance to cancel the update using event.preventDefault()
          beforeEvent = GS.triggerEvent(element, 'before_update', {
              "updateMode": strMode,
              "oldData": jsnCurrentData,
              "newData": jsnUpdate.data
          });
  
          // if the user prevents the default on the "before_update"
          //      event, prevent the execution of the following update code
          if (beforeEvent.defaultPrevented) {
              return;
          }
  
          // the update step is defined as a sub function because if there
          //      are multiple cells involved in this update, we want to open
          //      a dialog before we continue, else we want to immediatly
          //      update
          updateStep = function () {
              // gotta let the user know that an update is in progress
              addLoader(element, 'data-update', 'Updating Data...');
  
              // utilize the updated record and updated record index arrays to
              //      replace the old data with the new data
              i = 0;
              len = arrRecordIndexes.length;
              while (i < len) {
                  element.internalData.records[
                      arrRecordIndexes[i]
                  ] = (
                      arrRecordReplacements[i]
                  );
  
                  i += 1;
              }
  
              // re-render and do whatever standard after-update items need
              //      to be done
              dataUPDATEcallback(element);
  
              // trigger an after update event
              GS.triggerEvent(element, 'after_update', {
                  "updateMode": strMode,
                  "oldData": jsnCurrentData,
                  "newData": jsnUpdate.data
              });
  
              // the update has finished, let the user know and remove the loader
              removeLoader(element, 'data-update', 'Change Saved');
          };
  
          // if the update has been confirmed: carry on and update
          if (jsnUpdate.updateConfirmed === true) {
              updateStep();
  
          // else, we need to confirm the update
          } else {
              strPostfix = (
                  (
                      !jsnUpdate.data.records ||
                      jsnUpdate.data.records.length === 1
                  )
                      ? 'this record'
                      : 'these records'
              );
              GS.msgbox(
                  'Are you sure...',
                  '<center>' +
                          'Are you sure you want to update ' + strPostfix + '?' +
                          '</center>',
                  [
                      'No',
                      'Yes'
                  ],
                  function (strAnswer) {
                      if (strAnswer === 'Yes') {
                          updateStep();
                      }
                  }
              );
          }
      }
      function internalDELETE(element, jsnDelete) {
          var strPostfix;
  
          var beforeEvent;
          var deleteStep;
  
          // trigger a "before_update" event so that the page has a
          //      chance to cancel the update using event.preventDefault()
          beforeEvent = GS.triggerEvent(element, 'before_delete', {
              "recordIndexes": jsnDelete.recordIndexes,
              "deleteConfirmed": jsnDelete.deleteConfirmed
          });
  
          // if the user prevents the default on the "before_update"
          //      event, prevent the execution of the following update code
          if (beforeEvent.defaultPrevented) {
              return;
          }
  
          // the delete step is defined as a sub function because we only
          //      want to do the delete under certain circumstances
          deleteStep = function () {
              var arrRecords;
              var arrRecordHeights;
              var i;
              var len;
  
              // gotta let the user know that an update is in progress
              addLoader(element, 'data-delete', 'Deleting Data...');
  
              // now that the delete was confirmed, we'll
              //      recreate the record and record height
              //      arrays and skip the records at the indexes
              //      that were deleted
              // Some of you may be asking:
              //      "why doesn't he just use .splice()?".
              //      That, young grasshopper, is because through
              //      my travels I've found .splice() to be
              //      significantly slower than simply rebuilding
              //      the array. This is what I do in pgManage's
              //      tree code.
              arrRecords = [];
              arrRecordHeights = [];
  
              i = 0;
              len = element.internalData.records.length;
              while (i < len) {
                  if (jsnDelete.recordIndexes.indexOf(i) === -1) {
                      arrRecords.push(
                          element.internalData.records[i]
                      );
                      arrRecordHeights.push(
                          element.internalDisplay.recordHeights[i]
                      );
                  }
                  i += 1;
              }
  
              // set the internal record and record heights to
              //      the newly pruned arrays
              element.internalData.records = arrRecords;
              element.internalDisplay.recordHeights = arrRecordHeights;
  
              // gotta let the user know that we finished
              removeLoader(element, 'data-delete', 'Delete Successful');
  
              // standard after delete procedure
              dataDELETEcallback(element);
  
              // trigger an after delete event
              GS.triggerEvent(element, 'after_delete', {
                  "recordIndexes": jsnDelete.recordIndexes
              });
          };
  
          // if no records have been sent to delete: error
          if (jsnDelete.recordIndexes.length === 0) {
              GS.msgbox(
                  'No Records To Delete',
                  '<center>' +
                          'Please choose a record to delete.' +
                          '</center>',
                  ['Ok']
              );
  
          // else if the delete has been confirmed: carry on and delete
          } else if (jsnDelete.deleteConfirmed === true) {
              deleteStep();
  
          // else, we need to confirm the delete
          } else {
              strPostfix = (
                  jsnDelete.recordIndexes.length === 1
                      ? 'this record'
                      : 'these records'
              );
              GS.msgbox(
                  'Are you sure...',
                  '<center>' +
                          'Are you sure you want to delete ' + strPostfix + '?' +
                          '</center>',
                  [
                      'No',
                      'Yes'
                  ],
                  function (strAnswer) {
                      if (strAnswer === 'Yes') {
                          deleteStep();
                      }
                  }
              );
          }
      }
  
  
  
      function databaseWSSELECTcolumnUnique(
          element,
          uniqueFilterElement,
          valueListElement,
          strColumn
      ) {
          var socket = getSocket(element);
          var strSchema;
          var strObject;
          var strWhere;
  
          strSchema = GS.templateWithQuerystring(
              element.getAttribute('schema') || ''
          );
          strObject = GS.templateWithQuerystring(
              element.getAttribute('object') || ''
          );
          strWhere = element.getAttribute('where') || '1=1';
          // This way other filters apply to the current filter
          // TODO: Michael is this correct?
          // I think that the current filter that we are choosing should
          //      not be in this select
  
          var strSrc = (
              ml(function () {/*
                  SELECT count(*) AS count
                       , COALESCE(
                              NULLIF(CAST("{{COLUMN}}" AS text), ''),
                              '(blanks)'
                         ) AS unique_value
                    FROM {{SCHEMA}}.{{OBJECT}}
                    WHERE {{WHERE}}
                GROUP BY NULLIF(CAST("{{COLUMN}}" AS text), '')
                ORDER BY NULLIF(CAST("{{COLUMN}}" AS text), '') ASC NULLS FIRST
              */
              })
                  .replace(/\{\{WHERE\}\}/gi, strWhere)
                  .replace(/\{\{COLUMN\}\}/gi, strColumn)
                  .replace(/\{\{SCHEMA\}\}/gi, strSchema)
                  .replace(/\{\{OBJECT\}\}/gi, strObject)
          );
  
          var bolUncheckedFound = false;
          var arrData;
          var jsnFilter;
  
          arrData = [
              '' // placeholder for "Select All" record
          ];
          jsnFilter = (
              element.internalData.columnListFilters[
                  element.internalData.columnNames.indexOf(strColumn)
              ]
          );
  
          GS.requestArbitrarySelectFromSocket(
              socket,
              '(' + strSrc + ') unique_list',
              '',
              '',
              '',
              '',
              function (data, error) {
                  var i;
                  //var len;
                  var tableElement;
                  //var strCheck;
                  var index;
                  var strValue;
                  //var strType;
                  var strMessage = data.strMessage;
                  var strRecord;
                  //var arrRecords = [];
                  var arrRecord = [];
  
                  if (!error && data.strMessage === 'TRANSACTION COMPLETED') {
                      // we want the select all to only be checked if all
                      //      values are checked
                      if (bolUncheckedFound) {
                          arrData[0] = '0\t\tSelect All';
                      } else {
                          arrData[0] = '-1\t\tSelect All';
                      }
  
                      // we need to make the filter list container visible
                      uniqueFilterElement.removeAttribute('hidden');
  
                      valueListElement.addEventListener(
                          'initialized',
                          function () {
                              // we need to fill our new gs-table.
                              tableElement = valueListElement.children[0];
  
                              tableElement.internalData.records = arrData;
                              tableElement.internalData.columnNames = [
                                  'active', 'count', 'value'
                              ];
                              tableElement.internalData.columnTypes = [
                                  'text', 'text', 'text'
                              ];
                              tableElement.internalData.columnFilterStatuses = [
                                  'on', 'on', 'on'
                              ];
                              tableElement.internalData.columnFilters = [
                                  [], [], []
                              ];
                              tableElement.internalData.columnListFilters = [
                                  {}, {}, {}
                              ];
                              tableElement.internalData.columnOrders = [
                                  'neutral', 'neutral', 'neutral'
                              ];
                              tableElement.internalDisplay.columnWidths = [
                                  27,
                                  (valueListElement.clientWidth - 80),
                                  49
                              ];
  
                              // refresh causes the record heights to be
                              //      calculated
                              tableElement.refresh();
                          }
                      );
  
                      // we need to create a gs-table to hold the unique list
                      //      because we need a local, updatable, wicked-fast
                      //      component to contain this potentially very long
                      //      list.
                      valueListElement.innerHTML = ml(function () {/*
      <gs-table style="width: 100%; height: 100%;"
                  no-record-selector
                  no-x-overscroll
                  no-y-overscroll
                  copy-header="always">
          <template for="data-record">
              <gs-cell>
                  <label>
                      <gs-checkbox column="active" mini></gs-checkbox>
                  </label>
              </gs-cell>
              <gs-cell>
                  {{? row.value === 'Select All' || row.value === '(blanks)' }}
                      <span class="gs-table-text-grey">
                          {{! row.value }}
                      </span>
                  {{??}}
                      <label>{{! row.value }}</label>
                  {{?}}
              </gs-cell>
              <gs-cell>
                  <center class="gs-table-text-grey">
                      {{! row.count }}
                  </center>
              </gs-cell>
          </template>
          <template for="copy">
              <gs-cell header="Include?">{{? row.active==='-1' }}X{{?}}</gs-cell>
              <gs-cell header="Value">{{! row.value }} </gs-cell>
              <gs-cell header="Occurences">{{! row.count }}</gs-cell>
          </template>
      </gs-table>
                      */
                      });
  
                      tableElement.addEventListener(
                          'before_update',
                          function (event) {
                              var rec_i;
                              var rec_len;
                              var arrRecords;
  
                              // the only data change we make is to update the
                              //      checkbox. because of the limited nature of
                              //      the updates (0 to -1 and vice versa), we
                              //      can optimize two things: no need to encode
                              //      the update value and we're always replacing
                              //      everything before the first tab character.
                              var replaceValue = function (strRecord, strValue) {
                                  return (
                                      strValue +
                                      strRecord.substring(
                                          strRecord.indexOf('\t')
                                      )
                                  );
                              };
  
                              // when the user checks "Select All":
                              //      all checkboxes must be set to -1
                              if (
                                  event.newData.columnName === 'active' &&
                                  event.newData.recordNumber === 0 &&
                                  event.newData.newValue === '-1'
                              ) {
                                  //console.log('1***');
                                  arrRecords = tableElement.internalData.records;
                                  rec_i = 0;
                                  rec_len = arrRecords.length;
                                  while (rec_i < rec_len) {
                                      arrRecords[rec_i] = (
                                          replaceValue(arrRecords[rec_i], '-1')
                                      );
                                      rec_i += 1;
                                  }
  
                              // when the user unchecks "Select All":
                              //      all checkboxes must be set to 0
                              } else if (
                                  event.newData.columnName === 'active' &&
                                  event.newData.recordNumber === 0 &&
                                  event.newData.newValue === '0'
                              ) {
                                  //console.log('2***');
                                  arrRecords = tableElement.internalData.records;
                                  rec_i = 0;
                                  rec_len = arrRecords.length;
                                  while (rec_i < rec_len) {
                                      arrRecords[rec_i] = (
                                          replaceValue(arrRecords[rec_i], '0')
                                      );
                                      rec_i += 1;
                                  }
  
                              // when the user unchecks a checkbox:
                              //      the "Select All" checkbox must be set to 0
                              } else if (
                                  event.newData.columnName === 'active' &&
                                  event.newData.recordNumber > 0 &&
                                  event.newData.newValue === '0'
                              ) {
                                  //console.log('3***');
                                  tableElement.internalData.records[0] = (
                                      replaceValue(
                                          tableElement.internalData.records[0],
                                          '0'
                                      )
                                  );
                              }
  
                              //console.log(event);
                              //console.log(
                              //    'column: ' + event.newData.columnName,
                              //    'recordNumber: ' + event.newData.recordNumber,
                              //    'newValue: ' + event.newData.newValue
                              //);
                          }
                      );
  
                  } else if (!error) {
  
                      i = 0;
                      while (i < 15) {
                          index = strMessage.indexOf('\n');
                          strRecord = strMessage.substring(0, index);
                          strMessage = strMessage.substring(index + 1);
  
                          // first load
                          if (strRecord !== '' || strMessage !== '') {
                              arrRecord = strRecord.split('\t');
                              strValue = arrRecord[1];
  
                              if (!jsnFilter || !jsnFilter.type) {
                                  arrData.push('-1\t' + strRecord);
  
                              // nothing
                              } else if (
                                  jsnFilter.type === 'inclusion' &&
                                  jsnFilter.values.length === 0
                              ) {
                                  if (
                                      jsnFilter.blanks &&
                                      strValue === '(blanks)'
                                  ) {
                                      arrData.push('-1\t' + strRecord);
  
                                  } else if (
                                      jsnFilter.blanks === false &&
                                      strValue === '(blanks)'
                                  ) {
                                      arrData.push('0\t' + strRecord);
                                      bolUncheckedFound = true;
  
                                  } else {
                                      arrData.push('0\t' + strRecord);
                                      bolUncheckedFound = true;
                                  }
  
                              // everything
                              } else if (
                                  jsnFilter.type === 'exclusion' &&
                                  jsnFilter.values.length === 0
                              ) {
                                  if (
                                      jsnFilter.blanks &&
                                      strValue === '(blanks)'
                                  ) {
                                      arrData.push('-1\t' + strRecord);
  
                                  } else if (
                                      jsnFilter.blanks === false &&
                                      strValue === '(blanks)'
                                  ) {
                                      arrData.push('0\t' + strRecord);
                                      bolUncheckedFound = true;
  
                                  } else {
                                      arrData.push('-1\t' + strRecord);
                                  }
  
                              } else if (
                                  jsnFilter &&
                                  jsnFilter.type === 'inclusion'
                              ) {
                                  if (
                                      jsnFilter.blanks &&
                                      strValue === '(blanks)'
                                  ) {
                                      arrData.push('-1\t' + strRecord);
  
                                  } else if (
                                      jsnFilter.blanks === false &&
                                      strValue === '(blanks)'
                                  ) {
                                      arrData.push('0\t' + strRecord);
                                      bolUncheckedFound = true;
  
                                  } else if (
                                      jsnFilter.values
                                          .indexOf(strValue) !== -1
                                  ) {
                                      arrData.push('-1\t' + strRecord);
  
                                  } else {
                                      arrData.push('0\t' + strRecord);
                                      bolUncheckedFound = true;
                                  }
  
                              } else if (
                                  jsnFilter &&
                                  jsnFilter.type === 'exclusion'
                              ) {
                                  if (
                                      jsnFilter.blanks &&
                                      strValue === '(blanks)'
                                  ) {
                                      arrData.push('-1\t' + strRecord);
  
                                  } else if (
                                      jsnFilter.blanks === false &&
                                      strValue === '(blanks)'
                                  ) {
                                      arrData.push('0\t' + strRecord);
                                      bolUncheckedFound = true;
  
                                  } else if (
                                      jsnFilter.values
                                          .indexOf(strValue) !== -1
                                  ) {
                                      arrData.push('0\t' + strRecord);
                                      bolUncheckedFound = true;
  
                                  } else {
                                      arrData.push('-1\t' + strRecord);
                                  }
                              }
                          } else {
                              break;
                          }
  
                          i += 1;
                      }
                  }
              }
          );
      }
  
      function internalSELECTcolumnUnique(
          //element,
          //uniqueFilterElement,
          //valueListElement,
          //strColumn
      ) {
          //
      }
  
  
  
  
      function dataSELECTcolumnUnique(
          element,
          uniqueFilterElement,
          valueListElement,
          strColumn
      ) {
          if (element.hasAttribute("src")) {
              databaseWSSELECTcolumnUnique(
                  element,
                  uniqueFilterElement,
                  valueListElement,
                  strColumn
              );
          } else {
              internalSELECTcolumnUnique(
                  element,
                  uniqueFilterElement,
                  valueListElement,
                  strColumn
              );
          }
      }
      function dataSELECT(element) {
          if (element.hasAttribute("src")) {
              databaseWSSELECT(element);
          } else {
              internalSELECT(element);
          }
      }
      function dataINSERT(element, strMode, jsnInsert) {
          if (element.hasAttribute("src")) {
              databaseWSINSERT(element, strMode, jsnInsert);
          } else {
              internalINSERT(element, strMode, jsnInsert);
          }
      }
      function dataUPDATE(element, strMode, jsnUpdate) {
          if (!element.hasAttribute('no-update')) {
              // we want to save the text selection of the current
              //      control before we do the update
              element.internalDisplay.focus.selectionRange = null;
              if (
                  element.internalDisplay.focus.latest &&
                  (
                      document.activeElement.nodeName === 'INPUT' ||
                      document.activeElement.nodeName === 'TEXTAREA'
                  )
              ) {
                  element.internalDisplay.focus.selectionRange = (
                      GS.getInputSelection(document.activeElement)
                  );
              }
  
              if (element.hasAttribute("src")) {
                  databaseWSUPDATE(element, strMode, jsnUpdate);
              } else {
                  internalUPDATE(element, strMode, jsnUpdate);
              }
          }
      }
      function dataDELETE(element, jsnDeleteData) {
          if (element.hasAttribute("src")) {
              databaseWSDELETE(element, jsnDeleteData);
          } else {
              internalDELETE(element, jsnDeleteData);
          }
      }
  
  // #############################################################################
  // ####################### POST-RENDER UTILITY FUNCTIONS #######################
  // #############################################################################
  
      // sometimes you need to know what records are selected, this function
      //      returns the selected record numbers
      function getSelectedRecordIndexes(element) {
          var arrRows = element.internalSelection.rows.slice(0);
  
          if (arrRows[0] === 'header') {
              arrRows.shift();
          }
          if (arrRows[arrRows.length - 1] === 'insert') {
              arrRows.pop();
          }
  
          return arrRows;
      }
  
      // this function takes the cell which is the endpoint of the latest
      //      selection, focuses into it and selects all text of possible
      function focusIntoCell(
          element,
          record,
          column,
          iterationNumber
      ) {
          var jsnViewportRange;
  
          var cellElement;
          var focusElement;
  
          var strTag;
          var strValue;
  
          // default iterationNumber so that if this is the first run
          //      iterationNumber will contain 0
          if (iterationNumber === undefined) {
              iterationNumber = 0;
          }
  
          // if cell is in the rendered range:
          //      warn and stop execution
          jsnViewportRange = element.internalDisplay.currentRange;
          //console.trace(jsnViewportRange, record, column);
          if (
              // if we're not in the insert record:
              //      test if cell is within the current record and column range
              (
                  !jsnViewportRange.insertRecord &&
                  (
                      record < jsnViewportRange.fromRecord ||
                      record > jsnViewportRange.toRecord ||
                      column < jsnViewportRange.fromColumn ||
                      column > jsnViewportRange.toColumn
                  )
              ) ||
              // if we're in the insert record (and the insert record is visible):
              //      test if cell is within the current column range
              (
                  jsnViewportRange.insertRecord && (
                      column < jsnViewportRange.fromColumn ||
                      column > jsnViewportRange.toColumn
                  )
              )
          ) {
              console.warn('GS-TABLE Warning: "focusIntoCell" was called to' +
                      ' focus into a cell that is not rendered. Stopping' +
                      ' execution of "focusIntoCell".');
              return;
          }
  
          // we need to be able to do an element query inside the target cell, so
          //      here we get the cell element
          if (record === 'insert' && jsnViewportRange.insertRecord) {
              cellElement = xtag.query(
                  element.elems.dataViewport,
                  'gs-cell' +
                          '.table-insert' +
                          '[data-col-number="' + column + '"]'
              )[0];
          } else {
              cellElement = xtag.query(
                  element.elems.dataViewport,
                  'gs-cell' +
                          '.table-cell' +
                          '[data-row-number="' + record + '"]' +
                          '[data-col-number="' + column + '"]'
              )[0];
          }
  
          // if the cell was not found:
          //      warn
          //              because we checked and the cell is supposed to be in
          //                  the current viewport range
          //      re-render
          //              to put the element where it's supposed to be
          //      re-run this function
          //              because the re-render may cause the cell to go out of
          //                  range and therefore, we need to re-test
          //      stop execution
          //              because this function needs to run from the beginning
          if (!cellElement) {
              if (iterationNumber < 1) {
                  // warn
                  console.warn('GS-TABLE Warning: "focusIntoCell" was called to' +
                          ' focus into a cell that is not rendered. Stopping' +
                          ' execution of "focusIntoCell".');
  
                  // re-render
                  element.internalDisplay.fullRenderRequired = true;
                  renderScrollDimensions(element);
  
                  // re-run this function
                  focusIntoCell(
                      element,
                      record,
                      column,
                      (iterationNumber + 1)
                  );
  
              // infinite recursion detected, warn
              } else {
                  // warn
                  console.warn('GS-TABLE Warning: infinite loop detected' +
                          ' in "focusIntoCell". Stopping execution of' +
                          ' "focusIntoCell".');
              }
  
              // stop execution
              return;
          }
  
          // traverse into the cell and find first focusable element
          focusElement = xtag.query(
              cellElement,
              'input, textarea, select, [tabindex]'
          )[0];
  
          // if a focus element was found: focus into it
          if (focusElement) {
              focusElement.focus();
  
              // we want all the text selected, so if the focused element is an
              //      INPUT or TEXTAREA and it has a value: select all of the text
              strTag = focusElement.nodeName;
              strValue = (focusElement.value || '');
              if (
                  (strTag === 'INPUT' || strTag === 'TEXTAREA') &&
                  strValue.length > 0
              ) {
                  GS.setInputSelection(focusElement, 0, strValue.length);
              }
          }
      }
  
      // sometimes we wan't a particular cell visible in the viewport, so this
      //      function moves the cell into view. if the cell is already in view,
      //      this function will just re-render the selection
      // strStickMode is a string that can contain one or more of these keywords:
      //          'top'
      //          'bottom'
      //          'left'
      //          'right'
      //      so, if you want the cell to be moved to the bottom-left
      //          you can send 'bottom-left' or 'bottomleft' or 'leftbottom' etc.
      //          however, you will get a warning if you send 'leftright' because
      //          those choices are contradictory
      function scrollCellIntoView(element, cellRecord, cellColumn, strStickMode) {
          var i;
          var len;
  
          var columnBorderWidth;
          var recordBorderHeight;
          var arrColumnWidths;
          var arrRecordHeights;
  
          var intCellWidth;
          var intCellHeight;
          var intCellTop;
          var intCellBottom;
          var intCellLeft;
          var intCellRight;
  
          var intViewportWidth;
          var intViewportHeight;
          var intViewportTop;
          var intViewportBottom;
          var intViewportLeft;
          var intViewportRight;
  
          var bolScrollMoved;
  
          var bolStickTop;
          var bolStickLeft;
          var bolStickBottom;
          var bolStickRight;
  
          // we're saving these to variables for quicker/easier access
          columnBorderWidth = element.internalDisplay.columnBorderWidth;
          recordBorderHeight = element.internalDisplay.recordBorderHeight;
  
          // we need to get column and record dimensions
          arrColumnWidths = element.internalDisplay.columnWidths;
          arrRecordHeights = element.internalDisplay.recordHeights;
  
          // we want shortcuts that turn strStickMode into boolean variables
          if (strStickMode) {
              bolStickTop = (strStickMode.indexOf('top') !== -1);
              bolStickLeft = (strStickMode.indexOf('left') !== -1);
              bolStickBottom = (strStickMode.indexOf('bottom') !== -1);
              bolStickRight = (strStickMode.indexOf('right') !== -1);
  
              // warn if two stick modes are contradictory
              if (bolStickTop && bolStickBottom) {
                  console.warn('GS-TABLE Warning: Contradictory parameter sent' +
                          ' to scrollCellIntoView, you can\'t scroll a' +
                          ' cell to the top and the bottom of the viewport at' +
                          ' the same time. Stick to bottom will be cancelled.' +
                          ' Parameter Text: "' + strStickMode + '"');
                  bolStickBottom = false;
              }
              if (bolStickLeft && bolStickRight) {
                  console.warn('GS-TABLE Warning: Contradictory parameter sent' +
                          ' to scrollCellIntoView, you can\'t scroll a' +
                          ' cell to the left and the right of the viewport at' +
                          ' the same time. Stick to right will be cancelled.' +
                          ' Parameter Text: "' + strStickMode + '"');
                  bolStickRight = false;
              }
          }
  
          // get location of the top, bottom, left and right of the record, we
          //      need these to calculate if we need to scroll to the cell
  
          // if the cell is in the header, we need to grab it's height from the
          //      internal display values
          if (cellRecord === 'header') {
              intCellHeight = element.internalDisplay.headerHeight;
  
          } else if (cellRecord === 'insert') {
              intCellHeight = element.internalDisplay.insertRecordHeight;
  
          // else, we can use the record height array
          } else {
              intCellHeight = arrRecordHeights[cellRecord];
          }
  
          // we want to get how far the record is from the top of the data, so
          //      if the record isn't the header,
          //          add up the record heights until the correct record
          //      else,
          //          default to 0
          intCellTop = 0;
          if (cellRecord === 'header') {
              intCellTop = 0;
  
          } else if (cellRecord === 'insert') {
              i = 0;
              len = arrRecordHeights.length;
              while (i < len) {
                  intCellTop += arrRecordHeights[i];
                  intCellTop += recordBorderHeight;
                  i += 1;
              }
  
          } else {
              i = 0;
              len = cellRecord;
              while (i < len) {
                  intCellTop += arrRecordHeights[i];
                  intCellTop += recordBorderHeight;
                  i += 1;
              }
          }
  
          // if the cell is a record selector, we need to grab it's width from the
          //      internal display values
          if (cellColumn === 'selector') {
              intCellWidth = element.internalDisplay.recordSelectorWidth;
  
          // else, we can use the column width array
          } else {
              intCellWidth = arrColumnWidths[cellColumn];
          }
  
          // we want to get how far the column is from the left of the data, so
          //      if the column isn't the record selector,
          //          add up the column widths until the correct column
          //      else,
          //          default to 0
          intCellLeft = 0;
          if (cellColumn !== 'selector') {
              i = 0;
              len = cellColumn;
              while (i < len) {
                  intCellLeft += arrColumnWidths[i];
                  intCellLeft += columnBorderWidth;
                  i += 1;
              }
          }
  
          // calculate the cell bottom and right
          intCellBottom = (intCellTop + intCellHeight);
          intCellRight = (intCellLeft + intCellWidth);
  
          // get location of the top, bottom, left and right boundery lines of the
          //      viewport, we need these to calculate if we need to scroll to the
          //      cell
          intViewportWidth = (
              element.elems.dataViewport.clientWidth - (
                  element.internalScrollOffsets.left +
                  element.internalScrollOffsets.right
              )
          );
          intViewportHeight = (
              element.elems.dataViewport.clientHeight - (
                  element.internalScrollOffsets.top +
                  element.internalScrollOffsets.bottom
              )
          );
          intViewportTop = (element.internalScroll.top);
          intViewportLeft = (element.internalScroll.left);
          intViewportBottom = (intViewportTop + intViewportHeight);
          intViewportRight = (intViewportLeft + intViewportWidth);
  
          // we need a variable to say if we needed to scroll the viewport
          bolScrollMoved = false;
  
          // if the top of the cell is not visible, scroll it into view
          if (
              intCellTop < intViewportTop ||
              bolStickTop
          ) {
              element.internalScroll.top = intCellTop;
              bolScrollMoved = true;
  
          // if the bottom of the cell is not visible, scroll it into view
          } else if (
              intCellBottom > intViewportBottom ||
              bolStickBottom
          ) {
              element.internalScroll.top = (
                  intCellBottom - intViewportHeight
              );
              bolScrollMoved = true;
          }
  
          // if the left of the cell is not visible, scroll it into view
          if (
              intCellLeft < intViewportLeft ||
              bolStickLeft
          ) {
              element.internalScroll.left = intCellLeft;
              bolScrollMoved = true;
  
          // if the right of the cell is not visible, scroll it into view
          } else if (
              intCellRight > intViewportRight ||
              bolStickRight
          ) {
              element.internalScroll.left = (intCellRight - intViewportWidth);
              bolScrollMoved = true;
          }
  
          // sometimes, using stick mode will cause this function to scroll too
          //      far in order to maintain that stick. so, here we handle
          //      scrolling past the max.
          // why not handle this in the renderScrollLocation function you ask?
          //      if a function touches a shared variable, it should be self
          //          contained when it comes to validation because we don't want
          //          someone to create a new function and forget to validate the
          //          shared variables (and therefore, cause errors). so if you
          //          write a function which touches some shared variable and you
          //          notice an error, make the function clean up it's own mess.
  
          // prevent scrolling past the max left scroll
          if (element.internalScroll.left > element.internalScroll.maxLeft) {
              element.internalScroll.left = element.internalScroll.maxLeft;
  
          // prevent scrolling behind the min left scroll
          } else if (element.internalScroll.left < 0) {
              element.internalScroll.left = 0;
          }
  
          // prevent scrolling past the max top scroll
          if (element.internalScroll.top > element.internalScroll.maxTop) {
              element.internalScroll.top = element.internalScroll.maxTop;
  
          // prevent scrolling behind the min top scroll
          } else if (element.internalScroll.top < 0) {
              element.internalScroll.top = 0;
          }
  
          // if the scroll moved: render location
          if (bolScrollMoved) {
              // render location so the user can see the cell
              renderScrollLocation(element);
  
          // else, just rerender the selection
          } else {
              renderSelection(element);
          }
      }
  
      // sometimes the selection is moved out of view, this function will scroll
      //      the last selection range's endpoint into view and re-render the
      //      scroll location
      // if the selected cell is already in view, this function will just
      //      re-render the selection
      // strStickMode is a string that can contain one or more of these keywords:
      //          'top'
      //          'bottom'
      //          'left'
      //          'right'
      //      so, if you want the selected endpoint to stick to the bottom-left
      //          you can send 'bottom-left' or 'bottomleft' or 'leftbottom' etc.
      //          however, you will get a warning if you send 'leftright' because
      //          those choices are contradictory
      function scrollSelectionIntoView(element, strStickMode) {
          var jsnRange;
          var cellColumn;
          var cellRecord;
  
          // we need to the latest selection range so that we know what cell to
          //      scroll into view
          jsnRange = element.internalSelection.ranges[
              element.internalSelection.ranges.length - 1
          ];
  
          // if there is no selection, there is nothing to scroll to,
          //      so, warn the dev and stop this function from running
          if (!jsnRange) {
              console.warn(
                  'GS-TABLE Warning: scrollSelectionIntoView was ' +
                  'called when there was no selection to scroll into view.'
              );
              return;
          }
  
          // get the cell's column and record number so that we can pass it along
          cellRecord = (jsnRange.end.row);
          cellColumn = (jsnRange.end.column);
  
          // send the cell's location to the scrollCellIntoView function
          scrollCellIntoView(element, cellRecord, cellColumn, strStickMode);
      }
  
      // this function takes the cell which is the endpoint of the latest
      //      selection, focuses into it and selects all text of possible
      function focusIntoSelectedCell(element) {
          var jsnRange;
          var bolReWriteSelection;
  
          // we use the latest range a lot, let's save a shortcut
          jsnRange = element.internalSelection.ranges[
              element.internalSelection.ranges.length - 1
          ];
  
          // if more than one selection: warn and move selection to endpoint of
          //      latest selection
          if (element.internalSelection.ranges.length > 1) {
              console.warn('GS-TABLE Warning: "focusIntoSelectedCell" called' +
                      ' when multiple selections were present. Now clearing all' +
                      ' selections and creating new selection at last' +
                      ' selection\'s endpoint.');
              // because this if block uses the same issue resolution as the
              //      "else if" block below, we'll just set a boolean variable and
              //      below this waterfall we'll add another if statement that
              //      handles this type of resolution
              bolReWriteSelection = true;
  
          // else if one selection that is more than one cell:
          //      warn and move selection to endpoint of latest selection
          } else if (
              jsnRange &&
              (
                  jsnRange.start.column !== jsnRange.end.column ||
                  jsnRange.start.row !== jsnRange.end.row
              )
          ) {
              console.warn('GS-TABLE Warning: "focusIntoSelectedCell" called' +
                      ' when the selection contained multiple cells. Now' +
                      ' clearing all selections and creating new selection at' +
                      ' last selection\'s endpoint.');
              // because this if block uses the same issue resolution as the
              //      "if" block above, we'll just set a boolean variable and
              //      below this waterfall we'll add another if statement that
              //      handles this type of resolution
              bolReWriteSelection = true;
  
          // else if no selections:
          //      warn, focus hiddenFocusControl so we can still listen to
          //      keypresses and stop execution
          } else if (!jsnRange) {
              console.warn('GS-TABLE Warning: "focusIntoSelectedCell" called' +
                      ' when there was no selection to focus into. Stopping' +
                      ' execution of "focusIntoSelectedCell".');
  
              focusHiddenControl(element);
  
              return;
          }
  
          // if there's more than one selection or the only selection contains
          //      multiple, the response is the same: change selection to only
          //      last cell of last selection range, so, instead of copying the
          //      code to resolve it into both cases in the waterfall, they set
          //      a boolean variable if this is what they need done.
          if (bolReWriteSelection) {
              // set the new list of selection ranges to the endpoint of the
              //      latest selection
              element.internalSelection.ranges = [
                  {
                      "start": {
                          "row": jsnRange.end.row,
                          "column": jsnRange.end.column
                      },
                      "end": {
                          "row": jsnRange.end.row,
                          "column": jsnRange.end.column
                      },
                      "negator": false
                  }
              ];
  
              // get the new selection range, this is a shortcut
              jsnRange = element.internalSelection.ranges[0];
  
              // re-render the selection because we've just changed it and
              //      the user needs to see the update
              renderSelection(element);
          }
  
          // pass the last selection's enpoint cell to focusIntoCell
          focusIntoCell(
              element,
              jsnRange.end.row,
              jsnRange.end.column
          );
      }
  
      // there are multiple places where we just want to delete the selected
      //      records. so, we'll make a function that handles all the error
      //      checking involved with using the selection to delete records
      function deleteSelectedRecords(element) {
          // if nothing is selected, open a dialog letting the user know that
          //      they need to choose something
          if (element.internalSelection.ranges.length === 0) {
              GS.msgbox(
                  'No Records To Delete',
                  '<center>' +
                          'Please choose a record to delete.' +
                          '</center>',
                  ['Ok']
              );
  
          // else, everything is copacetic, let's initiate delete
          } else if (!element.hasAttribute('no-delete')) {
              dataDELETE(element, {
                  "recordIndexes": getSelectedRecordIndexes(element),
                  // we still need the user to confirm the delete
                  "deleteConfirmed": false
              });
          }
      }
  
      // this function is used to stop the actions of the next function
      //      "dragScrollStart".
      function dragScrollEnd(element) {
          // we only want to run clearInterval if there is an interval to stop
          if (element.internalTimerIDs.scrollIntervalID !== null) {
              // stop scroll interval to stop the scrolling
              clearInterval(element.internalTimerIDs.scrollIntervalID);
  
              // clear scrolling ID to make it clear that that
              //      interval has been cancelled
              element.internalTimerIDs.scrollIntervalID = null;
          }
  
          // the rest of these commands are harmless even if the scroll was
          //      never started
  
          // clear scrolling direction because we've stopped
          //      scrolling
          element.internalScroll.dragScrollingDirection = null;
  
          // set scrolling status variable to false so that the
          //      element recognizes that scrolling is stopped
          element.internalScroll.dragScrolling = false;
      }
  
      // some actions use a dragging motion, this means that we need to be able
      //      to scroll the viewport if the mouse drags off of the gs-table's
      //      outer bounderies. there is more than one place where this behavior
      //      is desired. the first two that come to mind are column reordering
      //      and column resizing.
      // the way this function works is it kicks off an interval to scroll the
      //      viewport incrementally every iteration until the "dragScrollEnd"
      //      function is called
      // eventually, we'll probably add two parameters, one for vertical speed
      //      and one for horizontal speed. these parameters will need to
      //      default to a reasonable speed
      // ### NEED CODING ###
      function dragScrollStart(element, callback, strScrollDirection) {
          var jsnDirection;
          var bolScrollTop;
          var bolScrollLeft;
          var bolScrollBottom;
          var bolScrollRight;
  
          // set scrolling to true to prevent future mouse events
          //      from starting new scroll events
          element.internalScroll.dragScrolling = true;
  
          // parse direction string
          jsnDirection = directionStringBreakdown(strScrollDirection);
  
          // convenience variables
          bolScrollTop = jsnDirection.bolTop;
          bolScrollLeft = jsnDirection.bolLeft;
          bolScrollBottom = jsnDirection.bolBottom;
          bolScrollRight = jsnDirection.bolRight;
  
          // we need to be able to check of the direction string
          //      changed, so we'll save a copy to compare against
          strScrollDirection = jsnDirection.resolvedString;
  
          //console.log(
          //    'start',
          //    strScrollDirection,
          //    bolScrollTop,
          //    bolScrollLeft,
          //    bolScrollBottom,
          //    bolScrollRight
          //);
  
          // save the scroll direction internally so that other code can work
          //      appropriately for the scroll direction
          element.internalScroll.dragScrollingDirection = (
              strScrollDirection
          );
  
          // remember, we need to be able to scroll two directions at
          //      the same time
  
          // create scroll interval and save the interval ID so
          //      we can stop the interval later
          element.internalTimerIDs.scrollIntervalID = setInterval(
              function () {
                  var newScrollingDirection;
                  var intLeftScrollAmount;
                  var intLeftScroll;
                  var intLeftMax;
                  var intTopScrollAmount;
                  var intTopScroll;
                  var intTopMax;
  
                  // we need to know if the direction string was changed
                  newScrollingDirection = (
                      element.internalScroll.dragScrollingDirection
                  );
  
                  // if the direction string was changed, recalculate
                  //      the direction variables
                  if (newScrollingDirection !== strScrollDirection) {
                      //console.log('SCROLL DIRECTION CHANGED');
  
                      jsnDirection = directionStringBreakdown(
                          newScrollingDirection
                      );
  
                      bolScrollTop = jsnDirection.bolTop;
                      bolScrollLeft = jsnDirection.bolLeft;
                      bolScrollBottom = jsnDirection.bolBottom;
                      bolScrollRight = jsnDirection.bolRight;
  
                      strScrollDirection = jsnDirection.resolvedString;
  
                      // save the scroll direction internally
                      element.internalScroll.dragScrollingDirection = (
                          strScrollDirection
                      );
                  }
  
                  // we want to adjust the speed of the scrolling
                  //      depending on how far to the left or
                  //      right the mouse is
                  // ### NEED CODING ###
                  if (bolScrollLeft || bolScrollRight) {
                      intLeftScrollAmount = 10;
                  }
                  if (bolScrollTop || bolScrollBottom) {
                      intTopScrollAmount = 10;
                  }
  
                  // we should also change to scrolling by column
                  //      right now, the scrolling speed on the
                  //      scrollbar is evenly paced but columns of
                  //      different widths make the viewport
                  //      scroll unevenly
                  // ### NEED CODING ###
  
                  // get current and max scroll for scroll
                  //      direction
                  if (bolScrollLeft || bolScrollRight) {
                      intLeftScroll = (element.internalScroll.left);
                      intLeftMax = (element.internalScroll.maxLeft);
                  }
                  if (bolScrollTop || bolScrollBottom) {
                      intTopScroll = (element.internalScroll.top);
                      intTopMax = (element.internalScroll.maxTop);
                  }
  
                  //console.log(
                  //    strScrollDirection,
                  //    bolScrollTop,
                  //    bolScrollLeft,
                  //    bolScrollBottom,
                  //    bolScrollRight
                  //);
  
                  // if we are at the max of all directions that we
                  //      are scrolling, stop scrolling interval
                  // overscroll is handled in the else
                  // underscroll is handled in the else
                  if (
                      (
                          !bolScrollTop ||
                          intLeftScroll === 0
                      ) &&
                      (
                          !bolScrollLeft ||
                          intLeftScroll === 0
                      ) &&
                      (
                          !bolScrollBottom ||
                          intLeftScroll === intTopMax
                      ) &&
                      (
                          !bolScrollRight ||
                          intLeftScroll === intLeftMax
                      )
                  ) {
                      //console.log('SCROLL STOPPED 1');
                      dragScrollEnd(element);
  
                  } else if (
                      !bolScrollTop &&
                      !bolScrollLeft &&
                      !bolScrollBottom &&
                      !bolScrollRight
                  ) {
                      //console.log('SCROLL STOPPED 2');
                      dragScrollEnd(element);
  
                  // else, advance scroll in every direction we were
                  //      told to
                  } else {
                      if (bolScrollTop || bolScrollBottom) {
                          if (bolScrollTop) {
                              intTopScroll -= intTopScrollAmount;
  
                          } else if (bolScrollBottom) {
                              intTopScroll += intTopScrollAmount;
                          }
  
                          // prevent over/under scrolling
  
                          // prevent scrolling past the max
                          if (intTopScroll > intTopMax) {
                              intTopScroll = intTopMax;
                          }
  
                          // prevent scrolling behind the min
                          if (intTopScroll < 0) {
                              intTopScroll = 0;
                          }
  
                          // apply new scroll to correct direction
                          element.internalScroll.top = intTopScroll;
                      }
  
                      if (bolScrollLeft || bolScrollRight) {
                          if (bolScrollLeft) {
                              intLeftScroll -= intLeftScrollAmount;
  
                          } else if (bolScrollRight) {
                              intLeftScroll += intLeftScrollAmount;
                          }
  
                          // prevent scrolling past the max
                          if (intLeftScroll > intLeftMax) {
                              intLeftScroll = intLeftMax;
                          }
  
                          // prevent scrolling behind the min
                          if (intLeftScroll < 0) {
                              intLeftScroll = 0;
                          }
  
                          // apply new scroll to correct direction
                          element.internalScroll.left = intLeftScroll;
                      }
  
                      //console.log(
                      //    element.internalScroll.left,
                      //    element.internalScroll.top
                      //);
  
                      // render scroll
                      renderScrollLocation(element);
  
                      // the drag actions that use this function will sometimes
                      //      need to refresh something depending on the new
                      //      scroll position. the callback is for that purpose
                      if (callback) {
                          callback();
                      }
                  }
              },
              50 // twentieth of a second refresh rate
          );
      }
  
  // #############################################################################
  // ############################## PASTE FUNCTIONS ##############################
  // #############################################################################
  
      // when you paste for an insert, only some columns might be selected, this
      //      function takes the normalized paste data and trims out anything that
      //      would have been applied to an unseleted cell. after that, this
      //      function turns control over to the internal insert function
      function insertPasteString(element, arrPaste, intMaxPasteColumn) {
          var templateElement;
          var strSelection;
          var strOldRecord;
          var strNewRecord;
          var strCell;
          var strChar;
  
          var intStart;
          var intEnd;
          //var intMaxPasteColumn;
          var intMinPasteColumn;
          var intPastedColumn;
          var intColumn;
  
          var arrColumnElements;
          var arrColumns;
  
          var i;
          var len;
          var rec_i;
          var rec_len;
  
          // we need to know what columns of the insert record are selected
          strSelection = element.internalSelection.resolvedSelection[
              element.internalSelection.resolvedSelection.length - 1
          ];
  
          // if there is a record selector, remove that char from the selection
          //      string
          if (element.internalDisplay.recordSelectorVisible) {
              strSelection = strSelection.substring(1);
          }
  
          // the paste starts at the first selected cell
          intStart = strSelection.indexOf('F');
          intEnd = strSelection.lastIndexOf('F');
  
          // we want to paste the smaller of the selection or the available data,
          //      this is because we will not paste what we do not have and
          //      will not affect data that is not selected
          if ((intEnd - intStart) < intMaxPasteColumn) {
              intMaxPasteColumn = (intEnd - intStart);
          }
  
          intEnd = intStart + intMaxPasteColumn;
  
          // sometimes, an entire record is copied and pasted (including the
          //      record selector), we need to prevent this from being an
          //      issue
          if (element.internalSelection.columns[0] === 'selector') {
              intMinPasteColumn = 1;
          } else {
              intMinPasteColumn = 0;
          }
  
          //console.log('   intEnd:', intEnd);
          //console.log(' intStart:', intStart);
          //console.log('intMinCol:', intMinPasteColumn);
          //console.log('intMaxCol:', intMaxPasteColumn);
  
          // use the selected column list to filter the data of the paste
          i = 0;
          len = arrPaste.length;
          while (i < len) {
              strOldRecord = arrPaste[i];
  
              // null out any cells that would apply to an unselected column
              // remove any cells that go further than the last selected column
              intColumn = 0;
              intPastedColumn = 0;
              strNewRecord = '';
              strCell = '';
              rec_i = 0;
              rec_len = strOldRecord.length;
              while (rec_i < rec_len) {
                  strChar = strOldRecord[rec_i];
  
                  // if the current character is not a tab: add it to the current
                  //      cell variable
                  if (strChar !== '\t') {
                      strCell += strChar;
                  }
  
                  // if the current character is a tab or we are at the end of the
                  //      record: handle current cell
                  if (
                      strChar === '\t' ||
                      rec_i === (rec_len - 1)
                  ) {
                      if (intColumn >= intMinPasteColumn) {
                          // if this isn't the first column: add a tab character
                          //      to separate the cells
                          if (intPastedColumn > 0) {
                              strNewRecord += '\t';
                          }
  
                          // if this column is selected: add cell to paste record
                          if (strSelection[intPastedColumn + intStart] === 'F') {
                              strNewRecord += strCell;
  
                          // else, replace the current cell with NULL
                          } else {
                              strNewRecord += '\\N';
                          }
  
                          intPastedColumn += 1;
  
                          if (intPastedColumn > intMaxPasteColumn) {
                              break;
                          }
                      }
  
                      // clear cell variable and advance column number
                      strCell = '';
                      intColumn += 1;
                  }
  
                  // if this column is past the last column we can paste to:
                  //      stop adding cells from this record and move to the
                  //      next record
                  if (
                      intColumn > (
                          (intEnd - intStart) + intMinPasteColumn
                      )
                  ) {
                      break;
                  }
                  rec_i += 1;
              }
  
              // update the paste data with the new record
              arrPaste[i] = strNewRecord;
              i += 1;
          }
  
          //console.log(arrPaste);
  
          // we need to say what columns we are inserting to, so here we take the
          //      start and end column numbers and turn that into an array of
          //      column names for the insert
  
          templateElement = document.createElement('template');
          templateElement.innerHTML = templateExtractVisibleCellRange(
              element,
              element.internalTemplates.insertRecord,
              intStart,
              (intEnd + 1)
              // the plus one is because the template extract function
              //      expects 0/1 to get the first column, not 0/0
          );
  
          arrColumnElements = xtag.query(
              templateElement.content,
              'gs-cell [column]'
          );
          arrColumns = [];
          i = 0;
          len = arrColumnElements.length;
          while (i < len) {
              arrColumns.push(arrColumnElements[i].getAttribute('column'));
              i += 1;
          }
  
          //console.log(
          //    intMinPasteColumn,
          //    intMaxPasteColumn,
          //    intStart,
          //    intEnd,
          //    //templateElement,
          //    //arrColumnElements,
          //    arrColumns
          //);
  
          // call the internal insert function, to be routed to the correct
          //      insert protocol
          dataINSERT(element, 'multi-record', {
              "data": {
                  "values": arrPaste,
                  "columns": arrColumns,
                  "addin": getInsertAddin(element)
              },
              "insertConfirmed": false
          });
      }
  
      // when you paste for an update, only some cells might be selected, this
      //      function takes the normalized paste data and trims out anything that
      //      would have been applied to an unseleted cell. after that, this
      //      function turns control over to the internal update function
      function updatePasteString(element, arrPaste, intMaxPasteColumn) {
          var arrRecords;
          var arrColumns;
          var intStartColumn;
          var intEndColumn;
          var arrSelection;
          var strSelection;
          var arrUpdateIndexes = [];
          var arrTranslated = [];
  
          var paste_i;
          var update_i;
          var i;
          var len;
          var rec_i;
          var rec_len;
  
          var strOldRecord;
          var strNewRecord;
          var intColumn;
          var intMinPasteColumn;
          var strCell;
          var strChar;
          var intPasteColumn;
          var intColumnOffset;
  
          var templateElement;
          var arrInsertCellElements;
          var arrUpdateCellElements;
          var arrCellElements;
          var arrColumnElements;
          var arrColumnNames;
  
          var arrSelectedStates = ['B', 'D', 'F', 'H', 'J', 'L'];
  
          // save selection cache so that we can check if a particular cell is
          //      selected
          arrSelection = element.internalSelection.resolvedSelection;
  
          // you can't paste into the header
          if (element.internalDisplay.headerVisible) {
              arrSelection.shift();
          }
  
          // you can't paste into the insert from here
          if (element.internalDisplay.insertRecordVisible) {
              arrSelection.pop();
          }
  
          // save the indexes of the records that we're going to paste over
          arrRecords = element.internalSelection.rows;
  
          // you can't paste into the header
          if (arrRecords[0] === 'header') {
              arrRecords.shift();
          }
  
          // you can't paste into the insert from here
          if (arrRecords[arrRecords.length - 1] === 'insert') {
              arrRecords.pop();
          }
  
          // save the indexes of the columns that we're going to paste over
          arrColumns = element.internalSelection.columns;
  
          // you can't paste into the record selector
          if (arrColumns[0] === 'selector') {
              arrColumns.shift();
          }
  
          // get the first selected row and column number
          intStartColumn = arrColumns[0];
  
          // get the last selected row and column number
          intEndColumn = arrColumns[arrColumns.length - 1];
  
          // we want to paste the smaller of the selection or the available data,
          //      this is because we will not paste what we do not have and
          //      will not affect data that is not selected
          if ((intEndColumn - intStartColumn) < intMaxPasteColumn) {
              intMaxPasteColumn = (intEndColumn - intStartColumn);
          }
  
          intEndColumn = (intStartColumn + intMaxPasteColumn);
  
          //console.log(intStartColumn, intEndColumn, intMaxPasteColumn);
  
          // we need to know the offset in the row selection string caused by
          //      the record selectors
          intColumnOffset = 0;
          if (element.internalDisplay.recordSelectorVisible) {
              intColumnOffset = 1;
          }
  
          // we need to know what columns we are updating, so here we take the
          //      start and end column numbers and turn that into an array of
          //      column names for the update
          templateElement = document.createElement('template');
  
          templateElement.innerHTML = (
              element.internalTemplates.insertRecord
          );
          arrInsertCellElements = xtag.query(
              templateElement.content,
              'gs-cell'
          );
  
          templateElement.innerHTML = (
              element.internalTemplates.record.templateHTML
          );
          arrUpdateCellElements = xtag.query(
              templateElement.content,
              'gs-cell'
          );
  
          if (arrInsertCellElements.length > 0) {
              arrCellElements = arrInsertCellElements;
          } else {
              arrCellElements = arrUpdateCellElements;
          }
  
          // if we have an insert record, get the column names from there
          arrColumnNames = [];
          i = 0;
          len = arrColumns.length;
          while (i < len) {
              //console.log('test 1 1', arrColumns[i]);
              //console.log('test 1 2', arrCellElements[arrColumns[i]]);
  
              arrColumnElements = xtag.query(
                  arrCellElements[arrColumns[i]],
                  '[column]'
              );
  
              //console.log('test 1 3', arrColumnElements);
  
              if (arrColumnElements && arrColumnElements.length > 0) {
                  arrColumnNames.push(
                      arrColumnElements[0].getAttribute('column')
                  );
  
                  //console.log(arrColumnNames.length, intMaxPasteColumn);
                  if (arrColumnNames.length === (intMaxPasteColumn + 1)) {
                      break;
                  }
              } else {
                  arrColumns.splice(i, 1);
                  i -= 1;
                  len -= 1;
              }
              i += 1;
          }
  
          // loop through rows starting from start row
          paste_i = 0; // paste record index
          update_i = 0; // update record index
          len = arrPaste.length;
  
          // sometimes the paste is longer than the list of selected records, so
          //      if that's the case than we want to use the selection length
          if (len > arrRecords.length) {
              len = arrRecords.length;
          }
  
          // sometimes a header is selected, if it is, skip the first record
          if (element.internalSelection.rows[0] === 'header') {
              paste_i += 1;
          }
  
          // sometimes, an entire record is copied and pasted (including the
          //      record selector), we need to prevent this from being an
          //      issue
          if (element.internalSelection.columns[0] === 'selector') {
              intMinPasteColumn = 1;
          } else {
              intMinPasteColumn = 0;
          }
  
          while (update_i < len) {
              strOldRecord = arrPaste[paste_i];
  
              // we want the selection string for the current record
              strSelection = arrSelection[arrRecords[update_i]];
  
              // null out any cells that would apply to an unselected column
              // remove any cells that go further than the last selected column
              intColumn = 0;
              strNewRecord = '';
              strCell = '';
              intPasteColumn = 0;
              rec_i = 0;
              rec_len = strOldRecord.length;
              while (rec_i < rec_len) {
                  strChar = strOldRecord[rec_i];
  
                  // if the current character is not a tab: add it to the current
                  //      cell variable
                  if (strChar !== '\t') {
                      strCell += strChar;
                  }
  
                  // if the current character is a tab or we are at the end of the
                  //      record: handle current cell
                  if (
                      strChar === '\t' ||
                      rec_i === (rec_len - 1)
                  ) {
                      if (intColumn >= intMinPasteColumn) {
                          // if this isn't the first column: add a tab character
                          //      to separate the cells
                          if (intPasteColumn > 0) {
                              strNewRecord += '\t';
                          }
  
                          // if this column is selected: add cell to paste record
                          if (
                              arrSelectedStates.indexOf(
                                  strSelection[
                                      (
                                          arrColumns[intPasteColumn] +
                                          intColumnOffset
                                      )
                                  ]
                              ) > -1
                          ) {
                              strNewRecord += strCell;
  
                          // else, replace the current cell with it's current
                          //      value
                          } else {
                              strNewRecord += getCell(
                                  element,
                                  arrColumnNames[intPasteColumn],
                                  arrRecords[update_i],
                                  false // not decoded
                              );
                          }
                          intPasteColumn += 1;
  
                          if (intPasteColumn > intMaxPasteColumn) {
                              break;
                          }
                      }
  
                      // clear cell variable and advance column number
                      strCell = '';
                      intColumn += 1;
                  }
  
                  // if this column is past the last column we can paste to:
                  //      stop adding cells from this record and move to the
                  //      next record
                  if (
                      intColumn > (
                          (intEndColumn - intStartColumn) + intMinPasteColumn
                      )
                  ) {
                      break;
                  }
                  rec_i += 1;
              }
  
              // add the new record to the translated record list
              arrUpdateIndexes.push(arrRecords[update_i]);
              arrTranslated.push(strNewRecord);
              paste_i += 1;
              update_i += 1;
          }
  
          //console.log('test1', arrColumns.length, arrColumns);
          //console.log('test2', arrColumnNames.length, arrColumnNames);
          //console.log('test3', arrUpdateIndexes.length, arrUpdateIndexes);
          //console.log('test4', arrTranslated.length, arrTranslated);
  
          // lets make the update
          dataUPDATE(element, 'cell-range', {
              "data": {
                  "columns": arrColumnNames,
                  "records": arrUpdateIndexes,
                  "values": arrTranslated
              },
              "updateConfirmed": false
          });
      }
  
      // the goal of this function is to normalize the data from a paste. once
      //      that's done, this function will route the paste data to either the
      //      insert or update paste functions
      function usePasteString(element, strUnnormalizedPasteString) {
          var elementMaker = document.createElement('template');
  
          var tableElement;
          var tbodyElement;
          var arrRecord;
          var arrUpdateRecord;
          var arrInsertRecord;
          var arrCell;
          var strRecord;
          var strCell;
          var intMaxUpdateRecord;
          var arrSelectedRows;
  
          var rec_i;
          var rec_len;
  
          var col_i;
          var col_len;
  
          // because pasting a large amount of data takes time, add a
          //      loader to let the user know we've started, just in case
          addLoader(element, 'paste-parse', 'Parsing Pasted Data...');
  
          // if no HTML or no valid HTML: build HTML using plain text
          if (
              strUnnormalizedPasteString.indexOf('<' + 'table') === -1 &&
              strUnnormalizedPasteString.indexOf('<' + 'tr') === -1
          ) {
              strUnnormalizedPasteString = delimitedStringToHTML(
                  element,
                  strUnnormalizedPasteString,
                  '\t',
                  '\n',
                  '"',
                  GS.decodeFromTabDelimited
              );
          }
  
          // second, get record elements
          elementMaker.innerHTML = strUnnormalizedPasteString;
  
          // we don't want any header or footer records to be pasted
          tableElement = xtag.query(elementMaker.content, 'table')[0];
          tbodyElement = xtag.queryChildren(tableElement, 'tbody')[0];
  
          // if there's a TBODY, get records from within there
          if (tbodyElement) {
              arrRecord = xtag.queryChildren(tbodyElement, 'tr');
  
          // else (no TBODY), get immediate children of table
          } else {
              arrRecord = xtag.queryChildren(tableElement, 'tr');
          }
  
          // third, create an array of text records from the HTML, make
          //      sure to split the records up into insert and update records
  
          // we need to know how many of the records are for the update and
          //      how many are for the insert. to do this, we'll take the
          //      selection rows length, subtract one for 'insert' and/or
          //      'header' if their present.
          arrSelectedRows = element.internalSelection.rows;
          intMaxUpdateRecord = arrSelectedRows.length - 1;
  
          if (arrSelectedRows[intMaxUpdateRecord] === 'insert') {
              intMaxUpdateRecord -= 1;
          }
          if (arrSelectedRows[0] === 'header') {
              intMaxUpdateRecord -= 1;
          }
  
          //console.log(intMaxUpdateRecord);
  
          // begin the loop!
          arrUpdateRecord = [];
          arrInsertRecord = [];
          rec_i = 0;
          rec_len = arrRecord.length;
          col_len = arrRecord[0].children.length;
          while (rec_i < rec_len) {
              strRecord = '';
              arrCell = xtag.toArray(arrRecord[rec_i].children);
              col_i = 0;
              while (col_i < col_len) {
                  strRecord += (
                      strRecord
                          ? '\t'
                          : ''
                  );
  
                  if (arrCell[col_i]) {
                      strCell = getPlainText(arrCell[col_i], true);
  
                      if (strCell && strCell.trim()) {
                          strRecord += GS.encodeForTabDelimited(strCell);
                      } else {
                          strRecord += '\\N';
                      }
                  } else {
                      strRecord += '\\N';
                  }
  
                  col_i += 1;
              }
  
              // if we've normalized this record for update,
              //      stick it in the update array.
              if (rec_i <= intMaxUpdateRecord) {
                  arrUpdateRecord.push(strRecord);
  
              // else, we've normalized this record for insert,
              //      stick it in the insert array.
              } else {
                  arrInsertRecord.push(strRecord);
              }
  
              rec_i += 1;
          }
  
          //console.log('arrUpdateRecord:', arrUpdateRecord);
          //console.log('arrInsertRecord:', arrInsertRecord);
  
          // fourth, initiate insert and/or paste
          if (
              arrInsertRecord.length > 0 &&
              element.internalDisplay.insertRecordVisible &&
              arrSelectedRows[arrSelectedRows.length - 1] === 'insert'
          ) {
              insertPasteString(element, arrInsertRecord, (col_len - 1));
          }
          if (arrUpdateRecord.length > 0) {
              updatePasteString(element, arrUpdateRecord, (col_len - 1));
          }
  
          // remove pasting loader
          removeLoader(element, 'paste-parse', 'Paste Data Parsed');
      }
  
      // the goal of this function is to extract the data in a paste event. once
      //      that's done, this function will route the paste data to the
      //      function in charge of using a paste string.
      function usePasteEvent(element, event) {
          var clipboardData;
          var pastePlain;
          var pasteHTML;
  
          // we don't want to do any pasting if there is nothing selected
          if (
              element.internalSelection.columns.length === 0 &&
              element.internalSelection.rows.length === 0
          ) {
              addLoader(
                  element,
                  'paste-fail',
                  'Can\'t paste, nothing selected...'
              );
              removeLoader(
                  element,
                  'paste-fail',
                  'Can\'t paste, nothing selected...'
              );
  
          // else, there is something selected, initiate paste
          } else {
              // because pasting a large amount of data takes time, add a
              //      loader to let the user know we've started, just in case
              addLoader(element, 'paste-extract', 'Extracting Pasted Data...');
  
              // to handle IE differences without having to write a lot of code to
              //      handle IE vs non-IE, we'll have one variable for the
              //      clipboardData and it will either be from the event object
              //      (non-IE) or it will come from the window (IE), this will cut
              //      down on browser specific code
              clipboardData = (event.clipboardData || window.clipboardData);
  
              // first, extract the unnormalized text
  
              // this is the main difference for IE vs non-IE, in IE we only get
              //      the text MIME type (we don't even try for HTML), everywhere
              //      else we try to get HTML
              if (window.clipboardData) {
                  pastePlain = clipboardData.getData('Text');
              } else {
                  pasteHTML = clipboardData.getData('text/html');
                  pastePlain = clipboardData.getData('Text');
              }
  
              // remove pasting loader
              removeLoader(element, 'paste-extract', 'Paste Data Extracted');
  
              //console.log('##########################################');
              //console.log('################## HTML ##################');
              //console.log('##########################################');
              //console.log('|' + pasteHTML + '|');
  
              //console.log('##########################################');
              //console.log('############### PLAIN TEXT ###############');
              //console.log('##########################################');
              //console.log('|' + pastePlain + '|');
  
              // send paste string to be utilized
              usePasteString(
                  element,
                  (pasteHTML || pastePlain)
              );
          }
      }
  
  // #############################################################################
  // ############################# BUTTON FUNCTIONS ##############################
  // #############################################################################
  
      function openInsertDialog(element) {
          var strTemplate;
          var templateElement;
          var beforeEvent;
  
          // get the template string from internal storage
          strTemplate = element.internalTemplates.insertDialog;
  
          // we want a template element because that's what we're going to send to
          //      the dialog function
          templateElement = document.createElement("template");
  
          // fill template element
          templateElement.innerHTML = ml(function () {/*
              <gs-page gs-dynamic>
                  <gs-header>
                      <center><h3>Create</h3></center>
                  </gs-header>
                  <gs-body padded>
                      {{HTML}}
                  </gs-body>
                  <gs-footer>
                      <gs-grid gutter>
                          <gs-block>
                              <gs-button dialogclose>Cancel</gs-button>
                          </gs-block>
                          <gs-block>
                              <gs-button dialogclose
                                         listen-for-return
                                         bg-primary>Create</gs-button>
                          </gs-block>
                      </gs-grid>
                  </gs-footer>
              </gs-page>
          */
          }).replace("{{HTML}}", strTemplate);
  
          // send out a before insert dialog open event, so that the developer
          //      can cancel it
          beforeEvent = GS.triggerEvent(element, "before_insert_dialog_open");
  
          // if the user prevents the default on the "before_insert_dialog_open"
          //      event, prevent the execution of the insert dialog
          if (beforeEvent.defaultPrevented) {
              return;
          }
  
          // open the dialog
          GS.openDialog(
              templateElement,
              // after open callback
              function () {
                  var dialog = this;
                  var arrElements;
                  var element_i;
                  var element_len;
                  var strColumn;
                  var strValue;
  
                  // if the user has started typing into the insert record and
                  //      then clicked the insert button, show the values from
                  //      the insert record
                  arrElements = xtag.query(dialog, '[column]');
                  element_i = 0;
                  element_len = arrElements.length;
                  while (element_i < element_len) {
                      strColumn = arrElements[element_i].getAttribute('column');
                      strValue = element.internalData.insertRecord[strColumn];
  
                      // if a value was retained for the current column
                      if (strValue) {
                          // fill control with retained value
                          arrElements[element_i].value = strValue;
                      }
                      element_i += 1;
                  }
  
                  // trigger after insert dialog open so the dev can run code
                  GS.triggerEvent(element, "after_insert_dialog_open", {
                      "relatedTarget": dialog
                  });
              },
              // before close callback
              // ignore is the placeholder for "event", jslint ignores unused
              //      parameters that are named "ignore"
              function (ignore, strAnswer) {
                  var dialog = this;
                  var arrElements;
                  var element_i;
                  var element_len;
                  var strColumn;
                  var strValue;
  
                  // we want the data that the user has put into the insert
                  //      dialog to be put into internal storage, gather the
                  //      values
                  arrElements = xtag.query(dialog, '[column]');
                  element_i = 0;
                  element_len = arrElements.length;
                  while (element_i < element_len) {
                      strColumn = arrElements[element_i].getAttribute('column');
                      strValue = arrElements[element_i].value;
  
                      // we only want to retain the value if there's a value to
                      //      retain
                      if (strValue) {
                          // retain the value in the internalData
                          element.internalData.insertRecord[strColumn] = strValue;
  
                          // some insert fields may be changed twice before an
                          //      insert, so only add the column name to the
                          //      changed columns list if that column name isn't
                          //      already in the list
                          if (
                              element
                                  .internalData
                                  .insertRecordRetainedColumns
                                  .indexOf(strColumn) === -1
                          ) {
                              element
                                  .internalData
                                  .insertRecordRetainedColumns
                                  .push(strColumn);
                          }
  
                      // if the user clears out a field that was previously
                      //      retained, we want to remove that value from the
                      //      retained list
                      } else if (
                          !strValue &&
                          element
                              .internalData
                              .insertRecordRetainedColumns
                              .indexOf(strColumn) > -1
                      ) {
                          element
                              .internalData
                              .insertRecord[strColumn] = undefined;
                          element
                              .internalData
                              .insertRecordRetainedColumns
                              .splice(
                                  element
                                      .internalData
                                      .insertRecordRetainedColumns
                                      .indexOf(strColumn)
                              );
                      }
                      element_i += 1;
                  }
  
                  // if the answer is to insert the record: do so
                  if (strAnswer !== 'Cancel' || strAnswer === 'Create') {
                      dataINSERT(element, "single-record", {
                          "data": {
                              "values": (
                                  element
                                      .internalData
                                      .insertRecord
                              ),
                              "columns": (
                                  element
                                      .internalData
                                      .insertRecordRetainedColumns
                              ),
                              "addin": getInsertAddin(element)
                          },
                          "insertConfirmed": true
                      });
  
                      // the insert attempt has been made, so we clear out the
                      //      retained values
                      element.internalData.insertRecord = {};
                      element.internalData.insertRecordRetainedColumns = [];
  
                  // else, re-render so that the internal storage is used to fill
                  //      the insert controls
                  } else {
                      element.internalDisplay.fullRenderRequired = true;
                      renderLocation(element);
                  }
              }
          );
      }
  
      // after a column is hidden, there is no way to unhide it. we need a
      //      function that will open a dialog to give the user the option of
      //      showing or hiding any column
      function openColumnHideDialog(element, targetElement, callback) {
          var templateElement;
          var afterOpenCallback;
          var beforeCloseCallback;
  
          templateElement = document.createElement('template');
          templateElement.setAttribute('data-max-width', '15em');
          templateElement.setAttribute('no-background', '');
          templateElement.innerHTML = ml(function () {/*
              <gs-page gs-dynamic class="gs-table-contextmenu">
                  <gs-header><h4>Unhide Columns</h4></gs-header>
                  <gs-body class="gs-table-column-checklist-container" padded>
                  </gs-body>
                  <gs-footer>
                      <gs-grid gutter>
                          <gs-block>
                              <gs-button dialogclose>Cancel</gs-button>
                          </gs-block>
                          <gs-block>
                              <gs-button dialogclose bg-primary>Apply</gs-button>
                          </gs-block>
                      </gs-grid>
                  </gs-footer>
              </gs-page>
          */
          });
  
          // because we open the dialog different ways depending on parameters,
          //      we'll put the callbacks in variables for convenience
          afterOpenCallback = function () {
              var dialog = this;
              var containerElement;
              var i;
              var len;
              var strHTML;
              var bolVisible;
              var arrColumnNames;
              var arrColumnWidths;
  
              // we want to know the column widths so that we can pre-check any
              //      hidden columns
              arrColumnWidths = element.internalDisplay.columnWidths;
  
              // we want to show the user column names that make sense.
              arrColumnNames = element.internalDisplay.columnPlainTextNames;
  
              // we want to fill the gs-body with the column list so that the
              //      user can check and uncheck columns
              containerElement = xtag.query(
                  dialog,
                  '.gs-table-column-checklist-container'
              )[0];
  
              strHTML = '';
              i = 0;
              len = arrColumnWidths.length;
              while (i < len) {
                  bolVisible = (arrColumnWidths[i] > 0);
                  strHTML += (
                      '<gs-checkbox ' +
                      '        data-col-number="' + i + '"' +
                      '        value="' + bolVisible.toString() + '">&nbsp;' +
                          encodeHTML(arrColumnNames[i]) +
                      '</gs-checkbox>'
                  );
  
                  i += 1;
              }
  
              containerElement.innerHTML = strHTML;
  
              // we want the top gs-page to have corner rounding
              dialog.classList.add('gs-table-contextmenu');
          };
  
          // event parameter ignored
          beforeCloseCallback = function (ignore, strAnswer) {
              var dialog = this;
              var arrCheckbox;
              var arrColumnWidths;
              var arrDefaultColumnWidths;
              var i;
              var len;
              var colIndex;
  
              if (strAnswer !== 'Cancel') {
                  // we want a shortcut to the column widths
                  arrColumnWidths = (
                      element.internalDisplay.columnWidths
                  );
  
                  // we want a shortcut to the default column widths
                  arrDefaultColumnWidths = (
                      element.internalDisplay.defaultColumnWidths
                  );
  
                  // loop through each checkbox and show or hide the columns
                  //      depending on the checkbox value
                  arrCheckbox = xtag.query(dialog, 'gs-checkbox');
                  i = 0;
                  len = arrCheckbox.length;
                  while (i < len) {
                      colIndex = parseInt(
                          arrCheckbox[i].getAttribute('data-col-number'),
                          10
                      );
  
                      if (
                          // if column is not hidden
                          arrColumnWidths[colIndex] > 0 &&
                          // and checkbox says to hide the column
                          arrCheckbox[i].value === 'false'
                      ) {
                          // hide the column
                          arrColumnWidths[colIndex] = 0;
  
                      } else if (
                          // if column is hidden
                          arrColumnWidths[colIndex] === 0 &&
                          // and checkbox says to show the column
                          arrCheckbox[i].value === 'true'
                      ) {
                          // restore the column to it's default width
                          arrColumnWidths[colIndex] = (
                              arrDefaultColumnWidths[colIndex]
                          );
                      }
                      i += 1;
                  }
  
                  // master, you updated arrColumnWidths but didn't update
                  //      the internal storage!
                  // that is correct, grasshopper, arrColumnWidths is a
                  //      reference to the original array variable and
                  //      therefore when we make changes to arrColumnWidths
                  //      the changes will automatically be reflected in the
                  //      internal storage.
  
                  // partial re-render doesn't know how to insert columns
                  //      into the middle of the viewport
                  element.internalDisplay.fullRenderRequired = true;
                  renderLocation(element);
              }
  
              if (callback) {
                  callback(strAnswer);
              }
          };
  
          if (targetElement) {
              GS.openDialogToElement(
                  targetElement,
                  templateElement,
                  'right',
                  afterOpenCallback,
                  beforeCloseCallback
              );
          } else {
              GS.openDialog(
                  templateElement,
                  afterOpenCallback,
                  beforeCloseCallback
              );
          }
      }
  
  
  
      function openDataSettingsDialog(element, buttonElement) {
          var templateElement = document.createElement('template');
  
          templateElement.setAttribute('data-max-width', '20em');
          templateElement.setAttribute('no-background', '');
          templateElement.setAttribute('data-overlay-close', 'true');
          templateElement.innerHTML = ml(function () {/*
  <gs-page class="gs-table-contextmenu">
      <gs-body class="gs-table-contextmenu" padded>
          <div class="context-menu-header">Show Rows:</div>
  <table>
      <tbody>
          <tr>
              <td>From:</td>
              <td><gs-number class="pref-limit-from" mini></gs-number></td>
          </tr>
          <tr>
              <td>To:</td>
              <td><gs-number class="pref-limit-to" mini></gs-number></td>
          </tr>
      </tbody>
  </table>
          <hr />
          <gs-grid gutter>
              <gs-block>
                  <gs-button dialogclose>Cancel</gs-button>
              </gs-block>
              <gs-block>
                  <gs-button dialogclose bg-primary>Apply</gs-button>
              </gs-block>
          </gs-grid>
      </gs-body>
  </gs-page>
              */
          });
  
          // the control elements are found in the "after open" callback.
          //      the reason these variables are defined here is so that
          //      the "before close" callback has access to them for free.
          var limitFromControl;
          var limitToControl;
  
          GS.openDialogToElement(
              buttonElement,
              templateElement,
              'down',
              function () {
                  var dialog = this;
                  var intLimit;
                  var intOffset;
  
                  // we want the top gs-page to have corner rounding
                  dialog.classList.add('gs-table-contextmenu');
  
                  // find all of the control elements
                  limitFromControl = xtag.query(
                      dialog,
                      '.pref-limit-from'
                  )[0];
                  limitToControl = xtag.query(
                      dialog,
                      '.pref-limit-to'
                  )[0];
  
                  intLimit = parseInt(
                      element.getAttribute('limit'),
                      10
                  );
                  intOffset = parseInt(
                      (element.getAttribute('offset') || '0'),
                      10
                  );
  
                  // set the values of all the controls
                  limitFromControl.value = (intOffset + 1);
                  limitToControl.value = (
                      (intLimit + intOffset) ||
                      element.internalData.records.length
                  );
              },
              // event parameter is ignored
              function (ignore, strAnswer) {
                  var intLimitFrom;
                  var intLimitTo;
                  var intLimit;
  
                  var strOldLimit;
                  var strOldOffset;
  
                  if (strAnswer === 'Apply') {
                      // gather the control values
                      intLimitFrom = parseInt(
                          (limitFromControl.value || '0'),
                          10
                      ) - 1;
                      intLimitTo = parseInt(
                          (limitToControl.value || '0'),
                          10
                      );
                      intLimit = (intLimitTo - intLimitFrom);
  
                      // save the old limit and offset so that we can know
                      //      if the limit or offset changed
                      strOldLimit = element.getAttribute('limit');
                      strOldOffset = element.getAttribute('offset');
  
                      // only set the limit and offset attribute if we could
                      //      calculate them. else, remove them.
                      if (!isNaN(intLimit)) {
                          element.setAttribute('limit', intLimit);
                      } else {
                          element.removeAttribute('limit');
                      }
                      if (!isNaN(intLimitFrom)) {
                          element.setAttribute('offset', intLimitFrom);
                      } else {
                          element.removeAttribute('offset');
                      }
  
                      // if the limit or the offset changed, refresh the table
                      if (
                          element.getAttribute('limit') !== strOldLimit &&
                          element.getAttribute('offset') !== strOldOffset
                      ) {
                          dataSELECT(element);
                      }
                  }
              }
          );
      }
  
      function openClipboardSettingsDialog(element, buttonElement) {
          var templateElement = document.createElement('template');
  
          templateElement.setAttribute('data-max-width', '20em');
          templateElement.setAttribute('no-background', '');
          templateElement.setAttribute('data-overlay-close', 'true');
          templateElement.innerHTML = ml(function () {/*
  <gs-page class="gs-table-contextmenu">
      <gs-body class="gs-table-contextmenu" padded>
          <div class="context-menu-header">Paste Format:</div>
          <table>
              <tbody>
  <tr>
      <td>Headers?</td>
      <td>
          <gs-select class="pref-copy-headers" mini>
              <option value="always">Always</option>
              <option value="never">Never</option>
              <option value="selected">Only when selected</option>
          </gs-select>
      </td>
  </tr>
  <tr>
      <td>Row Numbers?</td>
      <td>
          <gs-select class="pref-copy-selectors" mini>
              <option value="always">Always</option>
              <option value="never">Never</option>
              <option value="selected">Only when selected</option>
          </gs-select>
      </td>
  </tr>
  <tr>
      <td>Quote Character:</td>
      <td>
          <gs-select class="pref-quote-char" mini>
              <option value="\">Backslash (\)</option>
              <option value="/">Forward Slash (/)</option>
              <option value="|">Pipe (|)</option>
              <option value="&quot;">Double Quote (&quot;)</option>
              <option value="'">Single Quote (')</option>
          </gs-select>
      </td>
  </tr>
  <tr>
      <td>Escape Character:</td>
      <td>
          <gs-select class="pref-escape-char" mini>
              <option value="\">Backslash (\)</option>
              <option value="/">Forward Slash (/)</option>
              <option value="|">Pipe (|)</option>
              <option value="&quot;">Double Quote (&quot;)</option>
              <option value="'">Single Quote (')</option>
          </gs-select>
      </td>
  </tr>
  <tr>
      <td>Quote?</td>
      <td>
          <gs-select class="pref-copy-quote" mini>
              <option value="always">Always</option>
              <option value="never">Never</option>
              <option value="strings">Only on strings</option>
              <option value="delimiter-in-content">
                  Cell contains separator
              </option>
          </gs-select>
      </td>
  </tr>
  <tr>
      <td>Record Separator:</td>
      <td>
          <gs-select class="pref-delimiter-record" mini>
              <option value="{{DOS_RETURN}}">DOS (\r\n)</option>
              <option value="{{MAC_RETURN}}">Mac (\r)</option>
              <option value="{{UNIX_RETURN}}">UNIX (\n)</option>
              <option value="|">Vertical Bar (|)</option>
              <option value=",">Comma (,)</option>
              <option value="{{TAB}}">Tab</option>
          </gs-select>
      </td>
  </tr>
  <tr>
      <td>Cell Separator:</td>
      <td>
          <gs-select class="pref-delimiter-cell" mini>
              <option value="{{DOS_RETURN}}">DOS (\r\n)</option>
              <option value="{{MAC_RETURN}}">Mac (\r)</option>
              <option value="{{UNIX_RETURN}}">UNIX (\n)</option>
              <option value="|">Vertical Bar (|)</option>
              <option value=",">Comma (,)</option>
              <option value="{{TAB}}">Tab</option>
          </gs-select>
      </td>
  </tr>
  <tr>
      <td>Empty values:</td>
      <td>
          <gs-select class="pref-null-value" mini>
              <option value="">(nothing)</option>
              <option value="NULL">"NULL"</option>
              <option value="null">"null"</option>
              <option value="EMPTY">"EMPTY"</option>
              <option value="empty">"empty"</option>
              <option value="Nothing">"Nothing"</option>
          </gs-select>
      </td>
  </tr>
  <tr>
      <td>Copy types:</td>
      <td>
          <gs-select class="pref-copy-types" mini>
              <option value="text">Text</option>
              <option value="html">HTML</option>
              <option value="text,html">Both</option>
          </gs-select>
      </td>
  </tr>
              </tbody>
          </table>
          <hr />
          <gs-grid gutter>
              <gs-block>
                  <gs-button dialogclose>Cancel</gs-button>
              </gs-block>
              <gs-block>
                  <gs-button class="recopy-button" bg-primary>Recopy</gs-button>
              </gs-block>
          </gs-grid>
      </gs-body>
  </gs-page>
              */
          })
              .replace(/\{\{TAB\}\}/gi, '\t');
  
          // the control elements are found in the "after open" callback.
          //      the reason these variables are defined here is so that
          //      the "before close" callback has access to them for free.
          var copyHeadersControl;
          var copySelectorsControl;
          var copyQuoteCharControl;
          var copyEscapeCharControl;
          var copyQuoteWhenControl;
          var copyCellDelimiterControl;
          var copyRecordDelimiterControl;
          var copyNullControl;
          var copyTypesControl;
  
          GS.openDialogToElement(
              buttonElement,
              templateElement,
              'down',
              function () {
                  var dialog = this;
                  var jsnCopy;
  
                  // we want the top gs-page to have corner rounding
                  dialog.classList.add('gs-table-contextmenu');
  
                  // we need the current copy parameters
                  jsnCopy = getCopyParameters(element);
  
                  // find all of the control elements
                  copyHeadersControl = xtag.query(
                      dialog,
                      '.pref-copy-headers'
                  )[0];
                  copySelectorsControl = xtag.query(
                      dialog,
                      '.pref-copy-selectors'
                  )[0];
                  copyQuoteCharControl = xtag.query(
                      dialog,
                      '.pref-quote-char'
                  )[0];
                  copyEscapeCharControl = xtag.query(
                      dialog,
                      '.pref-escape-char'
                  )[0];
                  copyQuoteWhenControl = xtag.query(
                      dialog,
                      '.pref-copy-quote'
                  )[0];
                  copyCellDelimiterControl = xtag.query(
                      dialog,
                      '.pref-delimiter-cell'
                  )[0];
                  copyRecordDelimiterControl = xtag.query(
                      dialog,
                      '.pref-delimiter-record'
                  )[0];
                  copyNullControl = xtag.query(
                      dialog,
                      '.pref-null-value'
                  )[0];
                  copyTypesControl = xtag.query(
                      dialog,
                      '.pref-copy-types'
                  )[0];
  
                  copyHeadersControl.value = jsnCopy.headerMode;
                  copySelectorsControl.value = jsnCopy.selectorMode;
                  copyQuoteCharControl.value = jsnCopy.quoteChar;
                  copyEscapeCharControl.value = jsnCopy.escapeChar;
                  copyQuoteWhenControl.value = jsnCopy.quoteMode;
                  copyCellDelimiterControl.value = jsnCopy.cellDelimiter;
                  copyRecordDelimiterControl.value = jsnCopy.recordDelimiter;
                  copyNullControl.value = jsnCopy.nullString;
                  copyTypesControl.value = jsnCopy.copyTypes;
  
                  xtag.query(
                      dialog,
                      '.recopy-button'
                  )[0].addEventListener('click', function () {
                      GS.closeDialog(dialog);
  
                      var strCopyHeaders;
                      var strCopySelectors;
                      var strQuoteChar;
                      var strEscapeChar;
                      var strQuoteMode;
                      var strCellDelimiter;
                      var strRecordDelimiter;
                      var strNullValue;
                      var strCopyTypes;
  
                      // gather the control values
                      strCopyHeaders = copyHeadersControl.value;
                      strCopySelectors = copySelectorsControl.value;
                      strQuoteChar = copyQuoteCharControl.value;
                      strEscapeChar = copyEscapeCharControl.value;
                      strQuoteMode = copyQuoteWhenControl.value;
                      strCellDelimiter = copyCellDelimiterControl.value;
                      strRecordDelimiter = copyRecordDelimiterControl.value;
                      strNullValue = copyNullControl.value;
                      strCopyTypes = copyTypesControl.value;
  
                      // save the copy settings
                      element.setAttribute('copy-header', strCopyHeaders);
                      element.setAttribute('copy-selectors', strCopySelectors);
                      element.setAttribute('copy-quote-char', strQuoteChar);
                      element.setAttribute('copy-escape-char', strEscapeChar);
                      element.setAttribute('copy-quote-when', strQuoteMode);
                      element.setAttribute(
                          'copy-delimiter-cell',
                          strCellDelimiter
                      );
                      element.setAttribute(
                          'copy-delimiter-record',
                          strRecordDelimiter
                      );
                      element.setAttribute('copy-null-cell', strNullValue);
                      element.setAttribute('copy-types', strCopyTypes);
  
                      element.internalEvents.forceCopy = true;
                      element.elems.hiddenFocusControl.focus();
                      document.execCommand('copy');
                  });
              }
          );
      }
  
      // we want the user to have access to limit/offset and copy settings
      function openSettingsDialog(element, buttonElement) {
          var templateElement = document.createElement('template');
  
          templateElement.setAttribute('data-max-width', '15em');
          templateElement.setAttribute('no-background', '');
          templateElement.setAttribute('data-overlay-close', 'true');
          templateElement.innerHTML = ml(function () {/*
  <gs-page class="gs-table-contextmenu">
      <gs-body class="gs-table-contextmenu" padded>
          <gs-button dialogclose iconleft remove-bottom
              icon="database"
              class="button-column-width">Data Settings</gs-button>
          <gs-button dialogclose iconleft remove-top
              icon="clipboard"
              class="button-column-width">Clipboard Settings</gs-button>
      </gs-body>
  </gs-page>
              */
          });
  
          GS.openDialogToElement(
              buttonElement,
              templateElement,
              'down',
              function () {
                  var dialog = this;
  
                  // we want the top gs-page to have corner rounding
                  dialog.classList.add('gs-table-contextmenu');
              },
              // event parameter is ignored
              function (ignore, strAnswer) {
                  //var targetElement;
                  //var targetButton;
  
                  //// when you close the dialog by clicking on the
                  ////      overlay, there is no event.
                  //if (event && event.target) {
                  //    targetElement = event.target;
                  //}
  
                  //// when you close the dialog by clicking on the
                  ////      overlay, there is no target.
                  //if (targetElement) {
                  //    // we may need to position a second dialog to a
                  //    //      button, so here we get the button that
                  //    //      was clicked.
                  //    if (targetElement.nodeName === 'GS-BUTTON') {
                  //        targetButton = targetElement;
                  //    } else {
                  //        targetButton = GS.findParentTag(
                  //            targetElement,
                  //            'gs-button'
                  //        );
                  //    }
                  //}
  
                  if (strAnswer === 'Data Settings') {
                      openDataSettingsDialog(element, buttonElement);
                  } else if (strAnswer === 'Clipboard Settings') {
                      openClipboardSettingsDialog(element, buttonElement);
                  }
              }
          );
  
  //
  //Display:
  //    no-record-selector (boolean)
  //    header template (boolean)
  //    insert record template (boolean)
  //    column hide/show
  //    theme (wait, we need to write some themes)
  //
  //Scrolling:
  //    no-x-overscroll (boolean)
  //    no-y-overscroll (boolean)
  //
  
      }
  
  // #############################################################################
  // ############################## EVENT FUNCTIONS ##############################
  // #############################################################################
  
      // ############# FOCUS EVENTS #############
      function unbindFocus(element) {
          element.removeEventListener(
              evt.mousedown,
              element.internalEvents.focusMouseDown
          );
  
          element.elems.dataViewport.removeEventListener(
              'focus',
              element.internalEvents.focusInViewport,
              true
          );
          window.removeEventListener(
              'focus',
              element.internalEvents.focusTracker
          );
          element.removeEventListener(
              'focus',
              element.internalEvents.focusTracker,
              true
          );
          window.removeEventListener(
              'blur',
              element.internalEvents.focusTracker
          );
          window.removeEventListener(
              'focusout',
              element.internalEvents.focusTracker
          );
      }
      function bindFocus(element) {
          element.internalEvents.focusMouseDown = function (event) {
              var blurEventFunction;
              var target = event.target;
              var parentCell;
  
              // when you put a control into a label, if you click on the label:
              //      it focuses the control. sometimes, people use a label
              //      element simply for the padding. we don't want this focus
              //      behaviour if people just want the label for the padding, so
              //      if the target is a label: prevent default
              parentCell = GS.findParentTag(target, 'gs-cell');
              if (
                  parentCell &&
                  parentCell.nodeName === 'GS-CELL' &&
                  target.nodeName === 'LABEL' &&
                  parentCell.children.length === 1 &&
                  parentCell.children[0].nodeName === 'LABEL'
              ) {
                  event.preventDefault();
                  event.stopPropagation();
              }
  
              // if no focusable control was moused on: focus
              //      hiddenFocusControl
              //console.log(document.activeElement);
              //console.log(event.target);
              if (!GS.isElementFocusable(target) && !evt.touchDevice) {
                  focusHiddenControl(element);
  
                  //console.log('FOCUS:', document.activeElement);
                  //setTimeout(function () {
                  //    //console.log('FOCUS:', document.activeElement);
                  //}, 1000);
  
                  // some time after this mousedown event finishes, the
                  //      hidden focus control gets "blur"ed, so we bind it
                  //      to refocus after the "blur" event (only once though,
                  //      we don't want the page to get stuck refocusing the
                  //      hidden focus control)
                  blurEventFunction = function () {
                      focusHiddenControl(element);
                      element.elems.hiddenFocusControl.removeEventListener(
                          'blur',
                          blurEventFunction
                      );
                  };
                  element.elems.hiddenFocusControl.addEventListener(
                      'blur',
                      blurEventFunction
                  );
              }
          };
  
          element.addEventListener(
              evt.mousedown,
              element.internalEvents.focusMouseDown
          );
  
          // sometimes the user will click on a control to deselect one cell
          //      out of multiple selected cells. this causes the focus to be
          //      inside a non-selected cell
          element.internalEvents.focusInViewport = function () {
              var active = document.activeElement;
              var parentCell = GS.findParentTag(active, 'gs-cell');
  
              // if the focused element is inside a GS-CELL element
              if (parentCell && parentCell.nodeName === 'GS-CELL') {
                  // if the GS-CELL is not selected
                  if (!parentCell.hasAttribute('selected')) {
                      // focus hidden control
                      focusHiddenControl(element);
                  }
              }
          };
  
          element.elems.dataViewport.addEventListener(
              'focus',
              element.internalEvents.focusInViewport,
              true
          );
  
          // we want to style the table depending on wheather or not the
          //      focus is inside the gs-table
          element.internalEvents.focusTracker = function () {//event
              var active = document.activeElement;
              var parentTable = GS.findParentElement(active, element);
              var parentCell;
              var parentColumn;
  
              element.internalDisplay.focus.latest = false;
  
              //console.log(active, event.type, parentTable);
              if (
                  parentTable &&
                  parentTable.nodeName === 'GS-TABLE'
              ) {
                  element.classList.add('focus-in');
                  element.classList.remove('focus-out');
  
                  parentCell = GS.findParentTag(active, 'gs-cell');
                  parentColumn = GS.findParentElement(active, '[column]');
  
                  if (!parentColumn || parentColumn.nodeName === 'HTML') {
                      parentColumn = active;
                  }
  
                  // the render function needs to know what element is
                  //      focused so that it can maintain that focus
                  if (parentCell) {
                      element.internalDisplay.focus.column = (
                          parseInt(
                              (
                                  parentCell.getAttribute('data-col-number') ||
                                  parentCell.getAttribute('data-col') ||
                                  ''
                              ),
                              10
                          )
                      );
                      element.internalDisplay.focus.row = (
                          parseInt(
                              (
                                  parentCell.getAttribute('data-row-number') ||
                                  ''
                              ),
                              10
                          )
                      );
                      element.internalDisplay.focus.columnAttribute = (
                          parentColumn.getAttribute('column')
                      );
                      element.internalDisplay.focus.nodeName = (
                          active.nodeName
                      );
                      element.internalDisplay.focus.latest = true;
                  }
              } else {
                  element.classList.add('focus-out');
                  element.classList.remove('focus-in');
              }
          };
  
          window.addEventListener(
              'focus',
              element.internalEvents.focusTracker
          );
          element.addEventListener(
              'focus',
              element.internalEvents.focusTracker,
              true
          );
          window.addEventListener(
              'blur',
              element.internalEvents.focusTracker
          );
          window.addEventListener(
              'focusout',
              element.internalEvents.focusTracker
          );
      }
  
      // ############# SCROLL EVENTS #############
      function unbindScroll(element) {
          // because touch devices don't have scrollbars, we use a different set
          //      of code for scrolling
          if (evt.touchDevice) {
              element.elems.dataViewport.removeEventListener(
                  evt.mousedown,
                  element.internalEvents.scrollDragStartFunction
              );
          } else {
              // I tried "mousewheel", "MozMousePixelScroll" and "DOMMouseScroll"
              element.removeEventListener(
                  'wheel',
                  element.internalEvents.scrollWheelFunction
              );
          }
  
          window.removeEventListener(
              'resize',
              element.internalEvents.scrollResizeFunction
          );
          element.elems.yScrollBar.removeEventListener(
              'scroll',
              element.internalEvents.scrollBarYFunction
          );
          element.elems.xScrollBar.removeEventListener(
              'scroll',
              element.internalEvents.scrollBarXFunction
          );
      }
      function bindScroll(element) {
          // we need to manually move the scrollbar on a scroll event and then we
          //      need to rerender the cells
  
          // because touch devices don't have scrollbars, we use a different set
          //      of code for scrolling
          if (evt.touchDevice) {
              var intStartMouseLeft;
              var intStartMouseTop;
              var intStartScrollLeft;
              var intStartScrollTop;
              var intCurrentMouseLeft;
              var intCurrentMouseTop;
              var intCurrentScrollLeft;
              var intCurrentScrollTop;
              var dragStarted;
  
              element.internalEvents.scrollDragStartFunction = function (event) {
                  var jsnMousePos = GS.mousePosition(event);
                  dragStarted = false;
                  intStartMouseLeft = jsnMousePos.left;
                  intStartMouseTop = jsnMousePos.top;
                  intStartScrollLeft = element.internalScroll.left;
                  intStartScrollTop = element.internalScroll.top;
  
                  event.preventDefault();
                  event.stopPropagation();
  
                  document.body.addEventListener(
                      evt.mousemove,
                      element.internalEvents.scrollDragMoveFunction
                  );
                  document.body.addEventListener(
                      evt.mouseup,
                      element.internalEvents.scrollDragEndFunction
                  );
              };
  
              // on a phone you might want to click without scrolling a
              //      little bit, so we set here a minimum threshold of
              //      distance to before allowing scrolling
              var leftPlay = 10;
              var topPlay = 10;
              element.internalEvents.scrollDragMoveFunction = function (event) {
                  var jsnMousePos;
  
                  if (event.which === 0 && !evt.touchDevice) {
                      event.preventDefault();
                      event.stopPropagation();
                      element.internalEvents.scrollDragEndFunction();
  
                  } else {
                      jsnMousePos = GS.mousePosition(event);
                      intCurrentMouseLeft = jsnMousePos.left;
                      intCurrentMouseTop = jsnMousePos.top;
                      intCurrentScrollLeft = element.internalScroll.left;
                      intCurrentScrollTop = element.internalScroll.top;
  
                      if (
                          dragStarted === false &&
                          (
                              Math.abs(
                                  intCurrentMouseLeft - intStartMouseLeft
                              ) > leftPlay ||
                              Math.abs(
                                  intCurrentMouseTop - intStartMouseTop
                              ) > topPlay
                          )
                      ) {
                          dragStarted = true;
                      }
  
                      if (dragStarted) {
                          event.preventDefault();
                          event.stopPropagation();
  
                          // we need to save the current top/left so that the
                          //      rerender function knows what direction we're
                          //      scrolling
                          element.internalScroll.prevTop =
                                  element.internalScroll.top;
                          element.internalScroll.prevLeft =
                                  element.internalScroll.left;
  
                          // scroll the difference
                          element.internalScroll.left -=
                                  (intCurrentMouseLeft - intStartMouseLeft) +
                                  (intCurrentScrollLeft - intStartScrollLeft);
                          element.internalScroll.top -=
                                  (intCurrentMouseTop - intStartMouseTop) +
                                  (intCurrentScrollTop - intStartScrollTop);
  
                          // we need to round the scroll so that we don't run into
                          //      type issues
                          element.internalScroll.top =
                                  Math.round(element.internalScroll.top);
                          element.internalScroll.left =
                                  Math.round(element.internalScroll.left);
  
                          // we need to prevent overscrolling
                          element.internalScroll.top = Math.min(
                              element.internalScroll.maxTop,
                              element.internalScroll.top
                          );
                          element.internalScroll.left = Math.min(
                              element.internalScroll.maxLeft,
                              element.internalScroll.left
                          );
  
                          // we need to prevent underscrolling
                          element.internalScroll.top = Math.max(
                              0,
                              element.internalScroll.top
                          );
                          element.internalScroll.left = Math.max(
                              0,
                              element.internalScroll.left
                          );
  
                          renderScrollLocation(element);
                      }
                  }
              };
  
              element.internalEvents.scrollDragEndFunction = function () {
                  // elastic scrolling
                  //console.log('elastic scrolling');
                  //renderScrollLocation(element);
  
                  // unbind mousemove and mouseup
                  document.body.removeEventListener(
                      evt.mousemove,
                      element.internalEvents.scrollDragMoveFunction
                  );
                  document.body.removeEventListener(
                      evt.mouseup,
                      element.internalEvents.scrollDragEndFunction
                  );
              };
  
              element.elems.dataViewport.addEventListener(
                  evt.mousedown,
                  element.internalEvents.scrollDragStartFunction
              );
          // desktop scrolling
          } else {
              element.internalEvents.scrollWheelFunction = function (event) {
                  var originalTop;
                  var originalLeft;
                  var jsnScroll;
                  var intDeltaY;
                  var intDeltaX;
                  var intRecordHeight;
  
                  // helper variable to help shorten the code
                  jsnScroll = element.internalScroll;
  
                  // we don't want to intercept overscrolling
                  if (
                      // if we're at the top and we're scrolling up
                      (
                          jsnScroll.top === 0 &&
                          event.deltaY < 0
                      ) ||
                      // or we're at the bottom and we're scrolling down
                      (
                          jsnScroll.top === jsnScroll.maxTop &&
                          event.deltaY > 0
                      ) ||
                      // or we're at the left and we're scrolling left
                      (
                          jsnScroll.left === 0 &&
                          event.deltaX < 0
                      ) ||
                      // or we're at the right and we're scrolling right
                      (
                          jsnScroll.left === jsnScroll.maxLeft &&
                          event.deltaX > 0
                      )
                  ) {
                      // stop execution
                      return;
                  }
  
                  // we need to prevent firefox from scrolling the window, Chrome
                  //      automatically stops the scroll from bubbling up at this
                  //      point
                  event.preventDefault();
  
                  // we need to save the original top and left so that we can have
                  //      the element rerender only if the scroll actually changed
                  originalTop = jsnScroll.top;
                  originalLeft = jsnScroll.left;
  
                  // we used to do smooth scrolling, this is the code you would
                  //      use for that, it increments the scroll by the delta
                  //      amount
                  //// we need to increment the scroll with the event deltas
                  ////      because calculating our own deltas is too much
                  ////      trouble right now
                  //intDeltaY = event.deltaY;
                  //intDeltaX = event.deltaX;
  
                  // because we scroll by the record, we need to find out the
                  //      direction of the scroll and then round to nearest record
                  //      in that direction
                  intDeltaY = Math.round(event.deltaY);
                  intDeltaX = Math.round(event.deltaX);
  
                  intRecordHeight = (
                      (
                          element.internalDisplay.recordHeights[0] ||
                          element.internalDisplay.defaultRecordHeight
                      ) +
                      element.internalDisplay.recordBorderHeight
                  );
  
                  //var intTestOldScrollTop = jsnScroll.top;
                  //var intTestSecondScrollTop;
  
                  // up / down
                  if (intDeltaY !== 0) {
                      jsnScroll.top = roundToNearestMultiple(
                          jsnScroll.top,
                          intRecordHeight
                      );
                      //intTestSecondScrollTop = jsnScroll.top;
                      jsnScroll.top += roundToNearestMultiple(
                          intDeltaY,
                          intRecordHeight
                      );
                  }
                  //jsnScroll.top += intDeltaY;
  
                  // left / right
                  if (intDeltaX !== 0) {
                      jsnScroll.left += intDeltaX;
                  }
  
                  //console.log(
                  //    intTestOldScrollTop,
                  //    intTestSecondScrollTop,
                  //    jsnScroll.top
                  //);
  
                  // we need to save the current top/left so that the rerender
                  //      function knows what direction we're scrolling
                  jsnScroll.prevTop = jsnScroll.top;
                  jsnScroll.prevLeft = jsnScroll.left;
  
                  // we need to round the scroll so that we don't run into
                  //      type issues
                  jsnScroll.top = Math.round(jsnScroll.top);
                  jsnScroll.left = Math.round(jsnScroll.left);
  
                  // we need to prevent overscrolling
                  element.internalScroll.top = Math.min(
                      jsnScroll.maxTop,
                      jsnScroll.top
                  );
                  element.internalScroll.left = Math.min(
                      jsnScroll.maxLeft,
                      jsnScroll.left
                  );
  
                  // we need to prevent underscrolling
                  jsnScroll.top = Math.max(0, jsnScroll.top);
                  jsnScroll.left = Math.max(0, jsnScroll.left);
  
                  // we only need to rerender if the scroll actually changed
                  //console.log('wheel');
                  //console.log('internalTop:   ', element.internalScroll.top);
                  //console.log('originalTop:   ', originalTop);
                  //console.log('internalLeft:  ', element.internalScroll.left);
                  //console.log('originalLeft:  ', originalLeft);
                  if (
                      (jsnScroll.top !== originalTop) ||
                      (jsnScroll.left !== originalLeft)
                  ) {
                      renderScrollLocation(element);
                  }
              };
              // I tried "mousewheel", "MozMousePixelScroll" and "DOMMouseScroll"
              element.addEventListener(
                  'wheel',
                  element.internalEvents.scrollWheelFunction
              );
          }
  
          // we need to update the scrollbar dimensions if the window is resized
          element.internalEvents.scrollResizeFunction = function () {
              renderScrollDimensions(element);
          };
          window.addEventListener(
              'resize',
              element.internalEvents.scrollResizeFunction
          );
  
          // we need to update the scrollbar location from true scrollbar
          //      location to virtual scrollbar location
          element.internalEvents.scrollBarYFunction = function () {
              var intViewportHeight;
              var virtualScrollHeight;
              var trueScrollHeight;
              var trueScrollTop;
  
              var oldVirtualScrollTop;
              var newVirtualScrollTop;
  
              // sometimes, the gs-table triggeres a scrollbar event, so here we
              //      check to make sure the scrollbarY event has not been
              //      cancelled
              if (!element.internalEventCancelled.scrollbarY) {
                  // we need the viewport dimensions because true scroll
                  //      dimensions include the viewport height, which
                  //      messes with the caluculations
                  intViewportHeight = element.elems.dataViewport.clientHeight;
  
                  // we are saving the max scroll dimensions for ease of access
                  virtualScrollHeight = element.internalScroll.maxTop;
  
                  // we need the actual scroll height of the scrollbars because
                  //      we limit their height and that causes a difference we
                  //      need to account for
                  trueScrollHeight = element.elems.yScrollBar.scrollHeight;
                  trueScrollHeight -= intViewportHeight;
  
                  // we are saving the current true scroll location for ease
                  //      of access
                  trueScrollTop = element.elems.yScrollBar.scrollTop;
  
                  // we want to know what direction we scrolled so that we can
                  //      round to the next record in that direction. to do that,
                  //      we're going to hold on to the old virtual scrollTop so
                  //      that we can compare it to the new one.
                  oldVirtualScrollTop = element.internalScroll.top;
                  newVirtualScrollTop = (
                      trueScrollTop * (
                          virtualScrollHeight / trueScrollHeight
                      )
                  );
  
                  //// if we scrolled down, round to the next record down
                  //if (newVirtualScrollTop > oldVirtualScrollTop) {
  
                  //// else, we scrolled up, round to the next record up
                  //} else {
                  //}
  
                  // we need to translate the true top into virtual top for the
                  //      virtual scroll and save to internal location
                  element.internalScroll.top = newVirtualScrollTop;
  
                  // if this event gets triggered while the scrollbar doesn't have
                  //      any room, trueScrollHeight will be 0 which means that
                  //      (virtualScrollHeight / trueScrollHeight)
                  //      would result in NaN (because of the division by 0),
                  //      so, coalesce top to 0
                  element.internalScroll.top = (
                      element.internalScroll.top || 0
                  );
  
                  // we need to round the scroll so that we don't run into
                  //      any type issues
                  element.internalScroll.top =
                          Math.round(element.internalScroll.top);
  
                  // we need to prevent overscrolling
                  element.internalScroll.top = Math.min(
                      element.internalScroll.maxTop,
                      element.internalScroll.top
                  );
  
                  // we need to prevent underscrolling
                  element.internalScroll.top = Math.max(
                      0,
                      element.internalScroll.top
                  );
  
                  // render scroll location
                  renderScrollLocation(element);
              }
  
              // if the scrollbarY was cancelled, we no longer want it to be
              //      cancelled. so, reset it to false
              element.internalEventCancelled.scrollbarY = false;
          };
          element.elems.yScrollBar.addEventListener(
              'scroll',
              element.internalEvents.scrollBarYFunction
          );
  
          // we need to update the scrollbar location from true scrollbar
          //      location to virtual scrollbar location
          element.internalEvents.scrollBarXFunction = function () {
              //console.log('scrollBarXFunction');
              var intViewportWidth;
              var virtualScrollWidth;
              var trueScrollWidth;
              var trueScrollLeft;
  
              // sometimes, the gs-table triggeres a scrollbar event, so here we
              //      check to make sure the scrollbarX event has not been
              //      cancelled
              //console.log(element.internalEventCancelled.scrollbarX);
              if (!element.internalEventCancelled.scrollbarX) {
                  // we need the viewport dimensions because true scroll
                  //      dimensions include the viewport width, which messes
                  //      with the caluculations
                  intViewportWidth = element.elems.dataViewport.clientWidth;
  
                  // we are saving the max scroll dimensions for ease of access
                  virtualScrollWidth = element.internalScroll.maxLeft;
  
                  // we need the actual scroll width of the scrollbars because
                  //      we limit their width and that causes a difference we
                  //      need to account for
                  trueScrollWidth = element.elems.xScrollBar.scrollWidth;
                  trueScrollWidth -= intViewportWidth;
  
                  // we are saving the current true scroll location for ease
                  //      of access
                  trueScrollLeft = element.elems.xScrollBar.scrollLeft;
  
                  // we need to translate the true left into virtual left for the
                  //      virtual scroll and save to internal location
                  element.internalScroll.left = (
                      trueScrollLeft * (
                          virtualScrollWidth / trueScrollWidth
                      )
                  );
  
                  // if this event gets triggered while the scrollbar doesn't have
                  //      any room, trueScrollWidth will be 0 which means that
                  //      (virtualScrollWidth / trueScrollWidth)
                  //      would result in NaN (because of the division by 0),
                  //      so, coalesce left to 0
                  element.internalScroll.left = (
                      element.internalScroll.left || 0
                  );
  
                  // we need to round the scroll so that we don't run into
                  //      any type issues
                  element.internalScroll.left =
                          Math.round(element.internalScroll.left);
  
                  // we need to prevent overscrolling
                  element.internalScroll.left = Math.min(
                      element.internalScroll.maxLeft,
                      element.internalScroll.left
                  );
  
                  // we need to prevent underscrolling
                  element.internalScroll.left = Math.max(
                      0,
                      element.internalScroll.left
                  );
  
                  // render scroll location
                  renderScrollLocation(element);
              }
  
              // if the scrollbarX was cancelled, we no longer want it to be
              //      cancelled. so, reset it to false
              element.internalEventCancelled.scrollbarX = false;
          };
          element.elems.xScrollBar.addEventListener(
              'scroll',
              element.internalEvents.scrollBarXFunction
          );
      }
  
      // ############# SELECTION EVENTS #############
      function unbindSelection(element) {
          if (evt.touchDevice) {
              // ### NEED CODING ###
          } else {
              element.elems.dataContainer.removeEventListener(
                  evt.mousedown,
                  element.internalEvents.selectDragStart
              );
          }
      }
      function bindSelection(element) {
  
          // #####################################################################
          // ############### SELECTION MODIFICATIONS of 2017-04-13 ###############
          // ##################### THIS HAST BEEN COMPLETED! #####################
          // #####################################################################
          //
          // hear ye! we'll be making some real changes to the selection
          //      functionality. this happened because towards the beginning of
          //      this project I made a some bad choices regarding selection and
          //      the insert record.
          //
          //      The bad choices stemmed from not checking the functionality of
          //      other capable datagrids designed by people who know what they're
          //      doing.
          //
          //      Dont panic, I'll e'splain.
          //
          //      Bad choice #1 was to make the insert record stick to the bottom
          //      of the viewport. While this seemed like a good idea because
          //      whenever you want to insert the insert record is right there,
          //      this makes it so that selection of data and/or the insert record
          //      needs to be mutually exclusive or else the selection will appear
          //      non-contiguous in some areas and give the idea that the
          //      selection ends prematurely in other areas.
          //
          //      Bad choice #2 was to make the internal representation of the
          //      selection not resolve the entire selection, instead, it resolves
          //      the data cell selections and has some other, awkward places to
          //      look for other selections. This approach also made it so that if
          //      you only had record selectors selected, some areas of the code
          //      wouldn't be able to tell because no data cells were selected.
          //
          //      To remedy choice #1, I had to modify the getCurrentCellRange
          //      function to make it determine if the insert record would be
          //      visible. After that, I made the full render and the partial
          //      render functions handle the visiblity. This remedied choice #1.
          //
          //      To remedy choice #2, I'm going to replace the -1 values in
          //      the selection range JSON and add some new values. Start and
          //      end points that are on a data cell will still use numbers.
          //      Here is the list of non-number values that will be able to
          //      be used:
          //          for rows:
          //              'header'
          //              'insert'
          //          for columns:
          //              'selector'
          //      For example, selection for a range that starts with the all
          //      selector and ends in the fifth column of the sixth row will
          //      look like this:
          //          {
          //              "start": {
          //                  "row": "header",
          //                  "column": "selector"
          //              },
          //              "end": {
          //                  "row": 5,   // zero-based
          //                  "column": 4 // zero-based
          //              },
          //              "negator": false
          //          }
          //
          //      In the resolved selection, we need to be able to determine
          //      the type of cell as well as it's selection using only one
          //      character. So, we'll use two letters per type, one for
          //      selected and one for unselected. Here are the various types
          //      and their characters:
          //          Type:              Unselected:   Selected:
          //          HEADER CELL        A             B
          //          RECORD CELL        C             D
          //          INSERT CELL        E             F
          //          ALL SELECTOR       G             H
          //          RECORD SELECTOR    I             J
          //          INSERT SELECTOR    K             L
          //
          //      Using our previous example of selection inside a table with
          //      eight records, eight columns, a header and an insert record.
          //      The resolved selection for internal lookup would look like
          //      this:
          //          [
          //              "HBBBBBAAA", // header
          //              "JDDDDDCCC", // data
          //              "JDDDDDCCC", // data
          //              "JDDDDDCCC", // data
          //              "JDDDDDCCC", // data
          //              "JDDDDDCCC", // data
          //              "JDDDDDCCC", // data
          //              "ICCCCCCCC", // data
          //              "ICCCCCCCC", // data
          //              "KEEEEEEEE"  // insert
          //          ]
          //
          //      Just like before, we'll include these:
          //          an array of columns that contain at lease one selected cell
          //              new values to be included:
          //                  'selector'
          //          an array of records that contain at lease one selected cell
          //              new values to be included:
          //                  'header'
          //                  'insert'
          //          the origin record number
          //
          //      Alright, we know what's wrong and what we want to end up with,
          //      how are we going to get they-ah from he-ah?
          //          1) We need to tag any sections of code that utilizes the old
          //                  selection format. The tag will be "OL' SELECTION"
          //          DONE
          //
          //          2) We need to comment out the selection renderer.
          //          DONE
          //
          //          3) We need the mouse events to generate the new format for
          //                  selection range JSON.
          //          DONE
          //
          //          4) We need to generate the new format of resolved
          //                  selection in the selection renderer.
          //          DONE
          //
          //          5) We need to loop through the visible cells and use
          //                  the resolved selection to style all of the
          //                  appropriate cells.
          //          DONE
          //
          //          6) We need to update any behaviour that utilizes the old
          //                  selection format.
          //          DONE
          //
          //          7) We need to make it so that if a paste is divided between
          //                  the insert record and some data records, we need to
          //                  do an update and an insert from that paste.
          //          DONE
          //
          //          8) We need to pat ourselves on the back about 4 times and
          //                  then slap ourselves on the face 4 times for having
          //                  screwed this up in the first place.
          //
          //          9) We need to pat ourselves on the back 4 more times for
          //                  having so thouroughly planned this recovery.
          //
          //          10) Finally, we need to inform papa of our success.
          //
          //          11) We should prolly stop referring to ourselves as two
          //                  seperate beings... My... precious...
          //
          //      This sub-document was authored by Michael.
          //
          // #####################################################################
          // ############### SELECTION MODIFICATIONS of 2017-04-13 ###############
          // ##################### THIS HAST BEEN COMPLETED! #####################
          // #####################################################################
  
  
          // touch devices have a different way to select, so here we bind the
          //      touch-friendly version of cell selection
          if (evt.touchDevice) {
              // ### NEED CODING ###
  
          // on a desktop, we bind this code for cell selection:
          } else {
              // we save a copy of the current ranges so that if the
              //      before_selection event gets prevented, we can revert the
              //      selection
              var selectionRangesCopy;
  
              // we may be altering the only selection range or the last range
              //      if a long list of ranges, so here we store what index in
              //      the selection range array we are editing
              var intCurrentSelectionIndex;
  
              element.internalEvents.selectDragStart = function (event) {
                  var cell;
                  var jsnRange;
                  var newRange;
                  var jsnLocation;
  
                  //var classList;
                  //var intRow;
                  //var intColumn;
  
                  //var bolIsDataCell;
                  //var bolIsAllSelector;
                  //var bolIsHeaderCell;
                  //var bolIsRecordSelector;
                  //var bolIsInsertCell;
                  //var bolIsInsertSelector;
  
                  element.bolFocusHiddenTextarea = false;
  
                  // we need the cell that received the mousedown so that we
                  //      can get it's row/column numbers (and of the case of
                  //      adding a selection, wheather of not it's already
                  //      selected)
                  cell = GS.findParentElement(event.target, 'gs-cell');
  
                  //console.log(cell, (element, event));
                  //console.log(cell);
                  //console.log(element.internalResize.currentlyResizing);
                  //console.log(event.which);
                  //console.log(!cell.hasAttribute('selected'));
  
                  if (
                      // if we found a cell
                      cell.nodeName === 'GS-CELL' &&
                      // and we're not resizing a cell or record right now
                      element.internalResize.currentlyResizing === false &&
                      // and we're not reordering columns right now
                      element.internalReorder.currentlyReordering === false &&
                      // and the user used the left mouse button
                      // or the user right-clicked on a non-selected cell
                      (
                          event.which === 1 ||
                          !cell.hasAttribute('selected')
                      )
                  ) {
                      // we need to let the other code know that we are currently
                      //      selecting
                      element.internalSelection.currentlySelecting = true;
  
                      // we define newRange here so that we can see the structure
                      //      and so that we can modify/use it
                      newRange = {
                          "start": {
                              "row": 0,
                              "column": 0
                          },
                          "end": {
                              "row": 0,
                              "column": 0
                          },
                          "negator": false
                      };
  
                      // save a copy of the current selection range so that we can
                      //      revert back to it if we need to
                      selectionRangesCopy = JSON.parse(
                          JSON.stringify(
                              element.internalSelection.ranges
                          )
                      );
  
                      //// header is attached to first row
                      //// record selector is attached to the first column
                      //// insert record is attached to last row or the header if
                      ////      there is no data
  
                      //// if the selected cell is a header
                      ////      row: 'header'
                      ////      column: cell column
                      //// if the selected cell is a data cell
                      ////      row: cell row
                      ////      column: cell column
                      //// if the selected cell is a record selector
                      ////      row: cell row
                      ////      column: 'selector'
                      //// if the selected cell is the all selector
                      ////      row: 'header'
                      ////      column: 'selector'
                      //// if the selected cell is a insert cell
                      ////      row: 'insert'
                      ////      column: cell column
                      //// if the selected cell is the insert selector
                      ////      row: 'insert'
                      ////      column: 'selector'
                      //intRow = parseInt(
                      //    cell.getAttribute('data-row-number'),
                      //    10
                      //);
                      //intColumn = parseInt(
                      //    cell.getAttribute('data-col-number'),
                      //    10
                      //);
  
                      //// we don't want to recalculate what type of a cell the
                      ////      target cell is, and we want shorter code. so,
                      ////      we'll create shortcut variables
                      //classList = cell.classList;
                      //bolIsDataCell = (
                      //    classList.contains('table-cell')
                      //);
                      //bolIsAllSelector = (
                      //    classList.contains('table-all-selector')
                      //);
                      //bolIsHeaderCell = (
                      //    classList.contains('table-header')
                      //);
                      //bolIsRecordSelector = (
                      //    classList.contains('table-record-selector')
                      //);
                      //bolIsInsertCell = (
                      //    classList.contains('table-insert')
                      //);
                      //bolIsInsertSelector = (
                      //    classList.contains('table-insert-selector')
                      //);
  
                      //if (bolIsDataCell) {
                      //    newRange.start.row = intRow;
                      //    newRange.start.column = intColumn;
                      //} else if (bolIsAllSelector) {
                      //    newRange.start.row = 'header';
                      //    newRange.start.column = 'selector';
                      //} else if (bolIsHeaderCell) {
                      //    newRange.start.row = 'header';
                      //    newRange.start.column = intColumn;
                      //} else if (bolIsRecordSelector) {
                      //    newRange.start.row = intRow;
                      //    newRange.start.column = 'selector';
                      //} else if (bolIsInsertCell) {
                      //    newRange.start.row = 'insert';
                      //    newRange.start.column = intColumn;
                      //} else if (bolIsInsertSelector) {
                      //    newRange.start.row = 'insert';
                      //    newRange.start.column = 'selector';
                      //}
  
                      // find out the cell location based on the mouse event
                      jsnLocation = getCellFromMouseEvent(element, event);
  
                      // replace the range start with the discovered location
                      newRange.start.row = jsnLocation.row;
                      newRange.start.column = jsnLocation.column;
  
                      // the end is the same as the start because we are only on
                      //      the first cell of the selection
                      newRange.end.row = newRange.start.row;
                      newRange.end.column = newRange.start.column;
  
                      //console.log('shiftKey : ', event.shiftKey);
                      //console.log('metaKey  : ', event.metaKey);
                      //console.log('ctrlKey  : ', event.ctrlKey);
  
                      // if the selection starts with no shift, CMD or CTRL
                      //      keys down: we clear all of the previous selections
                      //      and start with an new selection
                      if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
                          // clear all the old ranges and add the new range
                          element.internalSelection.ranges = [newRange];
  
                          // because our new selection is the first in the list,
                          //      the current selection index is 0
                          intCurrentSelectionIndex = 0;
                      } else {
                          // if the shift key is down (and the previous selection
                          //      was not negator selection), we need override the
                          //      previous selection's endpoint, so we'll just set
                          //      the intCurrentSelectionIndex to the index of the
                          //      latest selection
                          if (event.shiftKey) {
                              //console.log('OVER HERE');
                              intCurrentSelectionIndex = (
                                  element.internalSelection.ranges.length - 1
                              );
  
                              // if the previous selection was not a negator
                              if (
                                  element.internalSelection
                                      .ranges[intCurrentSelectionIndex]
                                      .negator === false
                              ) {
                                  // we reset the endpoint of the latest range so
                                  //      that the re-render that's coming up
                                  //      shows the user that they've changed
                                  //      their selection
                                  element.internalSelection
                                      .ranges[intCurrentSelectionIndex]
                                      .end.row = newRange.start.row;
                                  element.internalSelection
                                      .ranges[intCurrentSelectionIndex]
                                      .end.column = newRange.start.column;
  
                              // if the previous selection was a negator
                              //      selection, just add a new selection range
                              } else {
                                  // add the new range to the end of the selection
                                  //      range list
                                  element.internalSelection.ranges.push(newRange);
  
                                  // because we added our new selection to the end
                                  //      of the selection range list, we need to
                                  //      set the intCurrentSelectionIndex to end
                                  //      end of the list
                                  intCurrentSelectionIndex = (
                                      element.internalSelection.ranges.length - 1
                                  );
                              }
  
                              // if the first selection range covers more than one
                              //      cell, focus the hidden textarea
                              jsnRange = element.internalSelection.ranges[0];
                              if (
                                  jsnRange.start.row !== jsnRange.end.row ||
                                  jsnRange.start.column !== jsnRange.end.column
                              ) {
                                  //console.log('Focus, grasshopper');
                                  element.bolFocusHiddenTextarea = true;
                              }
  
                          // else if the CMD of CTRL key is down, we create a new
                          //      selection and append it to the end
                          } else if (event.metaKey || event.ctrlKey) {
                              // if the new selection started on an already
                              //      selected cell, this selection becomes a
                              //      negator range (meaning that every cell in
                              //      it's range gets unselected)
                              if (cell.hasAttribute('selected')) {
                                  newRange.negator = true;
                              }
  
                              // add the new range to the end of the selection
                              //      range list
                              element.internalSelection.ranges.push(newRange);
  
                              // because we added our new selection to the end of
                              //      the selection range list, we need to set the
                              //      intCurrentSelectionIndex to end end of the
                              //      list
                              intCurrentSelectionIndex = (
                                  element.internalSelection.ranges.length - 1
                              );
                          }
                      }
  
                      // we re-render the selection because it has just been
                      //      changed
                      renderSelection(element);
  
                      //console.log(element.internalSelection.ranges);
  
                      // we add mousemove and mouseup events to the body because
                      //      if you're dragging to select and you mousemove off
                      //      of the element: we wan't to continue the selection,
                      //      and if you mouseup off of the element, we still want
                      //      to register that as a mouseup/end of selection
                      if (event.which === 1) {
                          document.body.addEventListener(
                              evt.mousemove,
                              element.internalEvents.selectDragMove
                          );
                          // TODO: firefox doesn't work with this and overflow
                          //      (event.target remains the origin cell)
                          document.body.addEventListener(
                              evt.mouseup,
                              element.internalEvents.selectDragEnd
                          );
  
                      // if the cell was right-clicked, we don't want to listen
                      //      to mouse drag. in fact, in order to have the
                      //      selection recalculate the selection cache in time
                      //      for the context menu we need to end the selection
                      //      now.
                      } else {
                          element.internalEvents.selectDragEnd();
                      }
                  }
              };
  
              element.internalEvents.selectDragMove = function (event) {
                  //var cell;
                  //var classList;
                  //var intRow;
                  //var intColumn;
                  var intOldEndRow;
                  var intOldEndColumn;
                  var currentRange;
  
                  getCellFromMouseEvent(element, event);
  
                  // if mouse is moving but no mouse button is down: finalize
                  //      selection, unbind selectDragMove and unbind
                  //      selectDragEnd
                  if (event.which === 0 && !evt.touchDevice) {
                      element.internalEvents.selectDragEnd();
  
                  } else {
                      // save the cell to a variable so that we can get it's
                      //      row/column
                      //console.log('event.target:', event.target);
                      // cell = GS.findParentElement(event.target, 'gs-cell');
                      // //console.log('cell:', cell);
                      // classList = cell.classList;
  
                      // // extract row/column from cell (if the cell has them)
                      // intRow = parseInt(
                      //     cell.getAttribute('data-row-number'),
                      //     10
                      // );
                      // intColumn = parseInt(
                      //     cell.getAttribute('data-col-number'),
                      //     10
                      // );
  
  
                      // find out the cell location based on the mouse event
                      var jsnLocation = getCellFromMouseEvent(element, event);
  
                      //console.log(cell, intRow, intColumn);
                      // get current selection range for easy access
                      currentRange = (
                          element.internalSelection
                              .ranges[intCurrentSelectionIndex]
                      );
  
                      if (currentRange.start.column === 'selector') {
                          jsnLocation.column = 'selector';
                      }
  
                      // save old row and column so that we can later check if
                      //      a change was actually made (that way we only
                      //      re-render if the selection has changed)
                      intOldEndRow = currentRange.end.row;
                      intOldEndColumn = currentRange.end.column;
  
  
  
                      currentRange.end.row = jsnLocation.row;
                      currentRange.end.column = jsnLocation.column;
                      // // update the endpoint row and column
                      // // these if statments maintain the seperation of
                      // //      insert and non-insert selections and the
                      // //      inclusion of headers/record selectors in
                      // //      the selection
                      // if (classList.contains('table-cell')) {
                      //     currentRange.end.row = intRow;
                      //     currentRange.end.column = intColumn;
  
                      // } else if (classList.contains('table-all-selector')) {
                      //     currentRange.end.row = 'header';
                      //     currentRange.end.column = 'selector';
  
                      // } else if (classList.contains('table-header')) {
                      //     currentRange.end.row = 'header';
                      //     currentRange.end.column = intColumn;
  
                      // } else if (classList.contains('table-record-selector')) {
                      //     currentRange.end.row = intRow;
                      //     currentRange.end.column = 'selector';
  
                      // } else if (classList.contains('table-insert')) {
                      //     currentRange.end.row = 'insert';
                      //     currentRange.end.column = intColumn;
  
                      // } else if (classList.contains('table-insert-selector')) {
                      //     currentRange.end.row = 'insert';
                      //     currentRange.end.column = 'selector';
                      // }
  
                      //console.log(element.internalSelection.insertRecord);
  
                      // prevent text selection if selection is more than one cell
                      if (
                          currentRange.start.row !== currentRange.end.row ||
                          currentRange.start.column !== currentRange.end.column
                      ) {
                          event.preventDefault();
                          event.stopPropagation();
                      }
  
                      //console.log(document.activeElement);
  
                      // focus hidden focus control is not focused
                      //      and
                      //      if the selection just became
                      //          multiple cells with this selection (if selection
                      //          is more than one cell and previous endpoint was
                      //          the same as the starting point)
                      //      or
                      //      if the currently focused element is not a child
                      //          of this gs-table element
                      if (
                          document.activeElement !==
                              element.elems.hiddenFocusControl
                      ) {
                          if (
                              // if the current range encompasses more than one
                              //      cell
                              (
                                  (
                                      currentRange.start.row !==
                                              currentRange.end.row ||
                                      currentRange.start.column !==
                                              currentRange.end.column
                                  ) &&
                                  (
                                      currentRange.start.row ===
                                              intOldEndRow &&
                                      currentRange.start.column ===
                                              intOldEndColumn
                                  )
                              ) ||
                              // if the selection is not inside the gs-table
                              GS.findParentTag(
                                  document.activeElement,
                                  'gs-table'
                              ) !== element ||
                              // if there is more than one selection
                              element.internalSelection.ranges.length > 1
                          ) {
                              focusHiddenControl(element);
                          }
                      }
  
                      //console.log(currentRange.end.row,
                      //              intOldEndRow,
                      //              currentRange.end.column,
                      //              intOldEndColumn);
  
                      // re-render selection if selection ranges have been changed
                      if (
                          currentRange.end.row !== intOldEndRow ||
                          currentRange.end.column !== intOldEndColumn
                      ) {
                          renderSelection(element);
                      }
                  }
              };
              element.internalEvents.selectDragEnd = function (/*event*/) {
                  var beforeEvent;
  
                  // trigger a "before_selection" event so that the page has a
                  //      chance to cancel the selection
                  beforeEvent = GS.triggerEvent(element, 'before_selection');
  
                  // if the user prevents the default on the "before_selection"
                  //      event, revert selection ranges to what they were before
                  //      the latest selection started (and revert wheather or not
                  //      the selection is in the insert record)
                  if (beforeEvent.defaultPrevented) {
                      element.internalSelection.ranges = selectionRangesCopy;
                  }
  
                  // final re-render of the selection so that the selection is
                  //      up to date
                  renderSelection(element);
  
                  // if the "before_selection" event is not prevented, we trigger
                  //      "after_selection" so that the page can run code after a
                  //      selection has been made
                  if (beforeEvent.defaultPrevented) {
                      GS.triggerEvent(element, 'after_selection');
                  }
  
                  // unbind mousemove and mouseup
                  document.body.removeEventListener(
                      evt.mousemove,
                      element.internalEvents.selectDragMove
                  );
                  document.body.removeEventListener(
                      evt.mouseup,
                      element.internalEvents.selectDragEnd
                  );
  
                  // we need to let the other code know that we are no longer
                  //      selecting
                  element.internalSelection.currentlySelecting = false;
  
                  if (element.bolFocusHiddenTextarea) {
                      focusHiddenControl(element);
                      //console.log(document.activeElement);
                  }
              };
  
              element.elems.dataContainer.addEventListener(
                  evt.mousedown,
                  element.internalEvents.selectDragStart
              );
          }
      }
  
      // ############# COLUMN/ROW RESIZE EVENTS #############
      function unbindCellResize(element) {
          if (!evt.touchDevice) {
              element.elems.dataViewport.removeEventListener(
                  evt.mousemove,
                  element.internalEvents.cellResizeStarter
              );
  
              element.elems.handleColumn.removeEventListener(
                  evt.mousedown,
                  element.internalEvents.cellResizeDragStart
              );
              element.elems.handleRecord.removeEventListener(
                  evt.mousedown,
                  element.internalEvents.cellResizeDragStart
              );
  
              element.elems.handleColumn.removeEventListener(
                  'dblclick',
                  element.internalEvents.cellResizeToDefault
              );
              element.elems.handleRecord.removeEventListener(
                  'dblclick',
                  element.internalEvents.cellResizeToDefault
              );
          }
      }
      function bindCellResize(element) {
          var showHandles;
          var setLineToMouse;
  
          // if we are not on a touch device
          if (!evt.touchDevice) {
              // we don't want to show the handles immediately, that'll mean
              //      that if the user moves the mouse across the viewport,
              //      there'll be resize handles popping up and disappearing
              //      rapidly. this effect would look bad and be distracting.
              //      to fix this, we'll throttle the function that detects if
              //      a handle should be show, but not the code that removes
              //      the handle.
              // ### NEED CODING ###
              showHandles = function (event) {
                  if (element.internalResize.showThrottleID !== null) {
                      clearTimeout(element.internalResize.showThrottleID);
                      element.internalResize.showThrottleID = null;
                  }
  
                  element.internalResize.showThrottleID = setTimeout(
                      function () {
                          var intPreviousPoint;
                          var jsnElementPos;
                          var jsnMousePos;
                          var intMouseX;
                          var intMouseY;
  
                          var intPoint;
  
                          var i;
                          var len;
  
                          jsnElementPos = GS.getElementOffset(
                              element.elems.dataViewport
                          );
                          jsnMousePos = GS.mousePosition(event);
  
                          // we need the mouse X to be relative to the
                          //      dataViewport
                          intMouseX = (jsnMousePos.left - jsnElementPos.left);
  
                          // we need the mouse Y to be relative to the
                          //      dataViewport
                          intMouseY = (jsnMousePos.top - jsnElementPos.top);
  
                          //console.log(
                          //    '      intMouseX: ',
                          //    intMouseX
                          //);
                          //console.log(
                          //    '      intMouseY: ',
                          //    intMouseY
                          //);
                          //console.log(
                          //    'selectorVisible: ',
                          //    element.internalDisplay.recordSelectorVisible
                          //);
                          //console.log(
                          //    '  selectorWidth: ',
                          //    element.internalDisplay.recordSelectorWidth
                          //);
                          //console.log(
                          //    '  headerVisible: ',
                          //    element.internalDisplay.headerVisible
                          //);
                          //console.log(
                          //    '   headerHeight: ',
                          //    element.internalDisplay.headerHeight
                          //);
  
                          // see if the mouse collides with a column drag handle
                          //      point
                          element.internalResize.resizeColumn = false;
                          if (
                              element.internalDisplay.recordSelectorVisible &&
                              intMouseY <= (
                                  element.internalDisplay.headerHeight
                              )
                          ) {
                              i = 0;
                              len = element.internalDisplay.columnHandles.length;
                              while (i < len) {
                                  intPoint = (
                                      element.internalDisplay.columnHandles[i]
                                  );
  
                                  // sometimes a column will be hidden, hidden
                                  //      columns have null for their handle
                                  if (intPoint !== null) {
                                      if (Math.abs(intMouseX - intPoint) <= 5) {
                                          // we need to know what column we are
                                          //      resizing, so here we save the
                                          //      index of the column that we
                                          //      found
                                          element.internalResize
                                              .resizeColumnHandleIndex = i;
  
                                          // because we found a column to resize,
                                          //      set the resizeColumn in internal
                                          //      storage to true so that the drag
                                          //      code knows that it's going to
                                          //      resize in the X axis
                                          element.internalResize.resizeColumn = (
                                              true
                                          );
  
                                          // we need to be able to prevent the
                                          //      user from resizing a cell to
                                          //      negative dimensions, so here we
                                          //      decide the origin X (the cell
                                          //      resize code uses, this origin
                                          //      to stop the user)
                                          // if there is a previous handle point,
                                          //      use, that as the origin X
                                          if (intPreviousPoint !== undefined) {
                                              element.internalResize
                                                  .cellOriginX = (
                                                      intPreviousPoint
                                                  );
                                          // else, 0 is the origin X
                                          } else {
                                              element.internalResize
                                                  .cellOriginX = 0;
                                          }
  
                                          // we want the minimum width to be 1
                                          element.internalResize.cellOriginX += 1;
  
                                          break;
                                      }
                                      if (intPoint > intMouseX) {
                                          break;
                                      }
  
                                      intPreviousPoint = intPoint;
                                  }
                                  i += 1;
                              }
                          }
  
                          // see if the mouse collides with a record drag handle
                          //      point
                          element.internalResize.resizeRecord = false;
                          if (
                              element.internalDisplay.headerVisible &&
                              intMouseX <= (
                                  element.internalDisplay.recordSelectorWidth
                              )
                          ) {
                              i = 0;
                              len = element.internalDisplay.recordHandles.length;
                              while (i < len) {
                                  intPoint = (
                                      element.internalDisplay.recordHandles[i]
                                  );
  
                                  if (Math.abs(intMouseY - intPoint) <= 5) {
                                      // we need to know what record we are
                                      //      resizing, so here we save the
                                      //      index of the record that we found
                                      element.internalResize
                                          .resizeRecordHandleIndex = i;
  
                                      // because we found a record to resize, set
                                      //      the resizeRecord in internal storage
                                      //      to true so that the drag code knows
                                      //      that it's going to resize in the Y
                                      //      axis
                                      element.internalResize.resizeRecord = true;
  
                                      // we need to be able to prevent the user
                                      //      from resizing a cell to negative
                                      //      dimensions, so here we decide the
                                      //      origin Y (the cell resize code uses
                                      //      this origin to stop the user)
  
                                      // if we found the insert record, origin is
                                      //      0
                                      if (
                                          i === (len - 1) &&
                                          element.internalDisplay
                                              .insertRecordVisible
                                      ) {
                                          element.internalResize.cellOriginY = (
                                              0
                                          );
  
                                      // if there is a previous handle point, use
                                      //      that as the origin Y
                                      } else if (i > 0) {
                                          element.internalResize.cellOriginY = (
                                              element.internalDisplay
                                                  .recordHandles[i - 1]
                                          );
  
                                      // else, 0 is the origin Y
                                      } else {
                                          element.internalResize.cellOriginY = 0;
                                      }
  
                                      // we want the minimum height to be 1
                                      element.internalResize.cellOriginY += 1;
  
                                      break;
                                  }
                                  if (intPoint > intMouseY) {
                                      break;
                                  }
                                  i += 1;
                              }
                          }
  
                          //console.log(
                          //    element.internalResize.resizeRecordHandleIndex
                          //);
  
                          // append any handles that aren't already in the DOM
  
                          // if the mouse is over a column handle point, add the
                          //      column resize handle
                          if (
                              element.internalResize.resizeColumn &&
                              element.elems.handleColumn.parentNode !==
                                  element.elems.dataViewport
                          ) {
                              // append handle element to the viewport
                              element.elems.dataViewport
                                  .appendChild(element.elems.handleColumn);
                          }
  
                          // if the mouse is over a record handle point, add the
                          //      record resize handle
                          if (
                              element.internalResize.resizeRecord &&
                              element.elems.handleRecord.parentNode !==
                                  element.elems.dataViewport
                          ) {
                              // append handle element to the viewport
                              element.elems.dataViewport
                                  .appendChild(element.elems.handleRecord);
                          }
  
                          // move column handle to correct position
                          if (element.internalResize.resizeColumn) {
                              // move handle to correct position depending on the
                              //      column that was matched
                              element.elems.handleColumn.style.left = (
                                  element.internalDisplay.columnHandles[
                                      element.internalResize
                                          .resizeColumnHandleIndex
                                  ]
                              ) + 'px';
                          }
  
                          // move record handle to correct position
                          if (element.internalResize.resizeRecord) {
                              // move handle to correct position depending on the
                              //      record that was matched
                              element.elems.handleRecord.style.top = (
                                  element.internalDisplay.recordHandles[
                                      element.internalResize
                                          .resizeRecordHandleIndex
                                  ]
                              ) + 'px';
                          }
  
                          // if the mouse is over a column and record handle point
                          if (
                              element.internalResize.resizeColumn &&
                              element.internalResize.resizeRecord
                          ) {
                              // add a four-way arrow cursor
                              element.elems.dataViewport
                                  .classList.add('table-cursor-all-resize');
  
                          // else if the mouse is over a column handle point
                          } else if (element.internalResize.resizeColumn) {
                              // add a two-way horizontal arrow cursor
                              element.elems.dataViewport
                                  .classList.add('table-cursor-col-resize');
  
                          // else if the mouse is over a record handle point
                          } else if (element.internalResize.resizeRecord) {
                              // add a two-way vertical arrow cursor
                              element.elems.dataViewport
                                  .classList.add('table-cursor-row-resize');
                          }
  
                          //console.log('X:' + intMouseX, 'Y:' + intMouseY);
  
                          element.internalResize.showThrottleID = null;
                      },
                      20  // 2 hundredths of a second, this is to prevent a really
                          //      quick selection from accidentally becoming a
                          //      resize because the user unintentionally hovered
                          //      over the resize area
                  );
              };
  
              // we don't want a whole lot of elements for our drag handles, so
              //      instead we'll detect if the mouse is in the correct spot for
              //      a drag, if it is then we'll insert a drag element (so that
              //      we can change the cursor). This also makes it so that we can
              //      do a different cursor for column resizing, row resizing and
              //      column/row resizing.
              // when mouse is 1 or less away pixels away from a cell and/or
              //      record border: insert drag element
              element.internalEvents.cellResizeStarter = function (event) {
                  var strUserAgent = window.navigator.userAgent;
  
                  // this code only needs to run when the mouse is up. we don't
                  //      want to be calculating this every mousemove during a
                  //      cell selection
                  // we also don't want to run this code if we are currently
                  //      resizing cells already
                  // we also don't want to run this code if we are currently
                  //      reordering columns
                  //console.log(
                  //    'test',
                  //    event.which,
                  //    window.navigator.userAgent.indexOf("Edge"),
                  //    event
                  //);
                  if (
                      (
                          (
                              (
                                  strUserAgent.indexOf("Edge") > -1 ||
                                  strUserAgent.indexOf("Firefox") > -1
                              ) &&
                              event.which === 1
                          ) ||
                          (
                              (
                                  strUserAgent.indexOf("Edge") === -1 ||
                                  strUserAgent.indexOf("Firefox") > -1
                              ) &&
                              event.which === 0
                          )
                      ) &&
                      element.internalResize.currentlyResizing !== true &&
                      element.internalResize.currentlyReordering !== true
                  ) {
                      //console.log('lets do it');
                      // remove the column handle
                      if (
                          element.elems.handleColumn.parentNode ===
                              element.elems.dataViewport
                      ) {
                          element.elems.dataViewport
                              .removeChild(element.elems.handleColumn);
                      }
  
                      // remove the record handle
                      if (
                          element.elems.handleRecord.parentNode ===
                              element.elems.dataViewport
                      ) {
                          element.elems.dataViewport
                              .removeChild(element.elems.handleRecord);
                      }
  
                      // clear any classes that affect the cursor (that were
                      //      placed there by the cell resize code)
                      element.elems.dataViewport
                          .classList.remove('table-cursor-all-resize');
                      element.elems.dataViewport
                          .classList.remove('table-cursor-col-resize');
                      element.elems.dataViewport
                          .classList.remove('table-cursor-row-resize');
  
                      // show any handles we're over (THROTTLED FUNCTION)
                      showHandles(event);
                  } else {
                      //console.log('lets NOT do it');
                      // cancel throttled execution of showHandles
                      if (element.internalResize.showThrottleID !== null) {
                          clearTimeout(element.internalResize.showThrottleID);
                          element.internalResize.showThrottleID = null;
                      }
                  }
              };
  
              element.elems.dataViewport.addEventListener(
                  evt.mousemove,
                  element.internalEvents.cellResizeStarter
              );
  
              // when dragging, just show a line where you'll resize to, instead
              //      of changing the size and re-rendering multiple times in a
              //      row
              element.internalEvents.cellResizeDragStart = function () {
                  var recordSelectorVisible;
                  var headerVisible;
                  //var insertRecordVisible;
                  var intColumnHandle;
                  var intRecordHandle;
  
                  // we need to let everything know that we are resizing cells,
                  //      this is used to prevent cell selection during cell
                  //      resize
                  element.internalResize.currentlyResizing = true;
  
                  // there are some things in the drag end code that we only want
                  //      to run if the mouse has moved (and therefore started
                  //      resizing), so here we default the resizeStarted to false
                  //      and after mousemove it'll be set to true
                  element.internalResize.resizeStarted = false;
  
                  // we need to know the record/column indexes at this stage and
                  //      store them internally
  
                  // reset column and row index variables
                  element.internalResize.resizeColumnIndex = null;
                  element.internalResize.resizeRecordIndex = null;
                  element.internalResize.resizingRecordSelectors = false;
                  element.internalResize.resizingHeader = false;
                  element.internalResize.resizingInsert = false;
  
                  // to get the record/column indexes, we need to know what's
                  //      visible
                  recordSelectorVisible = (
                      element.internalDisplay.recordSelectorVisible
                  );
                  headerVisible = (
                      element.internalDisplay.headerVisible
                  );
                  //insertRecordVisible = (
                  //    element.internalDisplay.insertRecordVisible
                  //);
  
                  // if we're resizing a column, get column index or type
                  if (element.internalResize.resizeColumn) {
                      // to get the record/column indexes, we need to know what
                      //      handles we're using
                      intColumnHandle = (
                          element.internalResize.resizeColumnHandleIndex
                      );
  
                      // if the column handle was the first one and the record
                      //      selector is visible, we need to update the record
                      //      selector width
                      if (
                          intColumnHandle === 0 &&
                          recordSelectorVisible === true
                      ) {
                          element.internalResize.resizingRecordSelectors = true;
  
                      // else, we are updating a column width
                      } else {
                          element.internalResize.resizeColumnIndex = (
                              // to get the column number, start with the handle
                              //      index
                              intColumnHandle +
                              // the handle index is relative to the visible
                              //      column range, so add the fromColumn of the
                              //      current range
                              element.internalDisplay.currentRange.fromColumn
                          ) - (
                              // if the record selector is visible, the column
                              //      handle index is going to be offset by one
                              //      because there is a handle to resize the
                              //      record selectors
                              recordSelectorVisible
                                  ? 1
                                  : 0
                          );
                      }
                  }
  
                  // if we're resizing a record, get record index or type
                  if (element.internalResize.resizeRecord) {
                      // to get the record/column indexes, we need to know what
                      //      handles we're using
                      intRecordHandle = (
                          element.internalResize.resizeRecordHandleIndex
                      );
  
                      // if the record handle was the first one and the header
                      //      is visible, we need to update the header height
                      if (intRecordHandle === 0 && headerVisible === true) {
                          element.internalResize.resizingHeader = true;
                      }
                      //// if the record handle was the last one and the insert
                      ////      record is visible, we need to update the insert
                      ////      record height
                      //} else if (
                      //    intRecordHandle === (
                      //        element.internalDisplay.recordHandles.length - 1
                      //    ) &&
                      //    insertRecordVisible === true
                      //) {
                      //    element.internalResize.resizingInsert = true;
                      //
                      //} else {
                      //    element.internalResize.resizeRecordIndex = (
                      //        // to get the record number, start with the handle
                      //        //      index
                      //        intRecordHandle +
                      //        // the handle index is relative to the visible
                      //        //      record range, so add the fromRecord of the
                      //        //      current range
                      //        element.internalDisplay.currentRange.fromRecord
                      //    ) - (
                      //        // if the header is visible, the column
                      //        //      handle index is going to be offset by one
                      //        //      because there is a handle to resize the
                      //        //      header
                      //        headerVisible
                      //            ? 1
                      //            : 0
                      //    );
                      //}
                  }
  
                  // save original scroll location so that if the viewport is
                  //      scrolled during a resize, we can do an accurate resize
                  element.internalResize.scrollOriginTop = (
                      element.internalScroll.displayTop
                  );
                  element.internalResize.scrollOriginLeft = (
                      element.internalScroll.displayLeft
                  );
  
                  //console.log(
                  //    element.internalResize.resizeColumnIndex,
                  //    element.internalResize.resizeRecordIndex,
                  //    element.internalResize.resizingRecordSelectors,
                  //    element.internalResize.resizingHeader,
                  //    element.internalResize.resizingInsert
                  //);
  
                  // we need to bind the mousemove and mouseup functionality to
                  //      the body so that we can still use the mouse events even
                  //      if the mouse is no longer over the gs-table
                  document.body.addEventListener(
                      evt.mousemove,
                      element.internalEvents.cellResizeDragMove
                  );
                  document.body.addEventListener(
                      evt.mouseup,
                      element.internalEvents.cellResizeDragEnd
                  );
              };
  
              // there are multiple places where we want to update the position of
              //      the resize lines
              setLineToMouse = function (event) {
                  var jsnMousePos;
                  var jsnElementPos;
                  var intMouseX;
                  var intMouseY;
                  var viewportWidth;
                  var viewportHeight;
                  var cellOriginX;
                  var cellOriginY;
                  var intMaxColWidth;
                  var intMaxRowHeight;
                  var intMinColWidth;
  
                  var intOriginScrollTop;
                  var intOriginScrollLeft;
                  var intCurrentScrollTop;
                  var intCurrentScrollLeft;
  
                  var intNewWidth;
                  var intNewHeight;
                  var intNewX;
                  var intNewY;
  
                  var intTopBoundery;
  
                  // we need to know the origin and current scroll location in
                  //      order to accurately place the resize handle
                  intOriginScrollTop = (
                      element.internalResize.scrollOriginTop
                  );
                  intOriginScrollLeft = (
                      element.internalResize.scrollOriginLeft
                  );
                  intCurrentScrollTop = (
                      element.internalScroll.displayTop
                  );
                  intCurrentScrollLeft = (
                      element.internalScroll.displayLeft
                  );
  
                  // we need the mouse position and the element position
                  jsnMousePos = GS.mousePosition(event);
                  jsnElementPos = GS.getElementOffset(
                      element.elems.dataViewport
                  );
  
                  // we need to show the user where they'll be resizing to.
                  //      so, move the column resize handle to where the
                  //      mouse is.
                  if (element.internalResize.resizeColumn) {
                      // because we've started the resize, we want the column
                      //      handle to become visible. we'll add the "active"
                      //      class.
                      element.elems.handleColumn.classList.add('active');
  
                      // we need the mouse X to be relative to the dataViewport
                      intMouseX = (jsnMousePos.left - jsnElementPos.left);
  
                      // we need to know the maximum column width
                      intMaxColWidth = (
                          element.internalDisplay.maxColumnWidth
                      );
  
                      // we need to know the minimum column width
                      intMinColWidth = (
                          element.internalDisplay.minColumnWidths[
                              element.internalResize.resizeColumnIndex
                          ]
                      );
  
                      // we need to know the original X of the column we're
                      //      resizing
                      cellOriginX = element.internalResize.cellOriginX;
  
                      // we need to know the viewport width
                      viewportWidth = element.elems.dataViewport.clientWidth;
  
                      // we need to calculate the distance from the original X
                      //      to the new X and then move the new X to an
                      //      appropriate location
  
                      // we need a width variable separate from the mouse, this'll
                      //      contain the new width and will be adjusted to
                      //      prevent width issues
                      intNewWidth = (
                          // the new true X
                          (
                              intMouseX +
                              intCurrentScrollLeft
                          ) -
                          // subtracted by the old true X
                          (
                              cellOriginX +
                              intOriginScrollLeft
                          )
                      );
  
                      //console.log(
                      //    cellOriginX, // relative to viewport and old scroll
                      //    intMouseX, // relative to viewport
                      //    intOriginScrollLeft, // old scroll
                      //    intCurrentScrollLeft, // current scroll
                      //    intNewWidth
                      //);
  
                      // prevent width from going negative the user can't see
                      //      it and shouldn't be able to resize to it
                      if (intNewWidth < 0) {
                          intNewWidth = 0;
                      }
  
                      // prevent width from going past the max width of the
                      //      viewport the scrolling always keeps the column
                      //      left to the left side of the viewport, so we
                      //      dont want to make the column bigger than the
                      //      viewport
                      if (intNewWidth > (viewportWidth - 10)) {
                          intNewWidth = (viewportWidth - 10);
                      }
  
                      // prevent column from going wider than max column width
                      if (intNewWidth > intMaxColWidth) {
                          intNewWidth = intMaxColWidth;
                      }
  
                      // prevent column from being thinner than 10px
                      if (intNewWidth < 10) {
                          intNewWidth = 10;
                      }
  
                      // prevent column from being thinner minimum column width
                      if (intNewWidth < intMinColWidth) {
                          intNewWidth = intMinColWidth;
                      }
  
                      // determine new handle X from new width
                      intNewX = (
                          // the new right side
                          (
                              cellOriginX +
                              intOriginScrollLeft +
                              intNewWidth
                          ) -
                          // subtracted by the new scrollLeft
                          (
                              intCurrentScrollLeft
                          )
                      );
  
                      // refresh handle location
                      element.elems.handleColumn.style.left = (intNewX) + 'px';
  
                      // save the last X so that the mouseup code doesn't need
                      //      to figure that out
                      element.internalResize.lastX = intNewX;
  
                      // save the last width so that we don't have to recalculate
                      //      it when the user let's go of the mouse
                      element.internalResize.lastWidth = intNewWidth;
                  }
  
                  // we need to show the user where they'll be resizing to.
                  //      so, move the record resize handle to where the
                  //      mouse is.
                  if (element.internalResize.resizeRecord) {
                      // because we've started the resize, we want the record
                      //      handle to become visible. we'll add the "active"
                      //      class.
                      element.elems.handleRecord.classList.add('active');
  
                      // we need the mouse Y to be relative to the dataViewport
                      intMouseY = (jsnMousePos.top - jsnElementPos.top);
  
                      // we need to know the maximum record height
                      intMaxRowHeight = (
                          element.internalDisplay.maxRecordHeight
                      );
  
                      // we need to know the original Y of the record we're
                      //      resizing
                      cellOriginY = element.internalResize.cellOriginY;
  
                      // we need to know the viewport height
                      viewportHeight = element.elems.dataViewport.clientHeight;
  
                      // we need to calculate the distance from the original Y
                      //      to the new Y and then move the new Y to an
                      //      appropriate location
  
                      // we need a height variable separate from the mouse,
                      //      this'll contain the new height and will be
                      //      adjusted to prevent height issues
                      if (element.internalResize.resizingInsert) {
                          intNewHeight = (
                              viewportHeight -
                              intMouseY
                          );
  
                      } else {
                          intNewHeight = (
                              // the new true Y
                              (
                                  intMouseY +
                                  intCurrentScrollTop
                              ) -
                              // subtracted by the old true Y
                              (
                                  cellOriginY +
                                  intOriginScrollTop
                              )
                          );
                      }
  
                      //console.log(
                      //    cellOriginY, // relative to viewport and old scroll
                      //    intMouseY, // relative to viewport
                      //    intOriginScrollTop, // old scroll
                      //    intCurrentScrollTop, // current scroll
                      //    intNewHeight
                      //);
  
                      // prevent Y from going past 0,0 on the viewport
                      // the user can't see it and shouldn't be resize to it
                      if (intNewHeight < 0) {
                          intNewHeight = 0;
                      }
  
                      // prevent Y from going past the max Y of the viewport
                      // the user can't see it and shouldn't be resize to it
                      intTopBoundery = (
                          viewportHeight - (
                              element.internalScrollOffsets.top + 10
                          )
                      );
  
                      if (intNewHeight > intTopBoundery) {
                          intNewHeight = intTopBoundery;
                      }
  
                      // if we're not resizing the insert record
                      // prevent record from going taller than max record height
                      if (
                          !element.internalResize.resizingInsert &&
                          intNewHeight > intMaxRowHeight
                      ) {
                          intNewHeight = intMaxRowHeight;
                      }
  
                      // the user can't resize a record to less than 10px height
                      if (intNewHeight < 10) {
                          intNewHeight = 10;
                      }
  
                      // determine new handle Y from new height
                      if (element.internalResize.resizingInsert) {
                          //console.log(
                          //    intNewHeight,
                          //    viewportHeight,
                          //    intMaxRowHeight
                          //);
                          intNewY = (
                              viewportHeight -
                              intNewHeight
                          );
  
                      } else {
                          intNewY = (
                              // the new right side
                              (
                                  cellOriginY +
                                  intOriginScrollTop +
                                  intNewHeight
                              ) -
                              // subtracted by the new scrollLeft
                              (
                                  intCurrentScrollTop
                              )
                          );
                      }
  
                      element.elems.handleRecord.style.top = (intNewY) + 'px';
  
                      // save the last Y so that the mouseup code doesn't need
                      //      to figure that out
                      element.internalResize.lastY = intNewY;
  
                      // save the last height so that we don't have to recalculate
                      //      it when the user let's go of the mouse
                      element.internalResize.lastHeight = intNewHeight;
                  }
              };
  
              element.internalEvents.cellResizeDragMove = function (event) {
                  var jsnMousePos;
                  var jsnElementPos;
                  var bolScrollTop;
                  var bolScrollLeft;
                  var bolScrollRight;
                  var bolScrollBottom;
                  //var intViewportWidth;
                  //var intViewportHeight;
                  var colIndex;
                  var rowIndex;
                  var jsnRange;
                  var strScrollDirection;
  
                  // if the mouse moves off of the screen and then is moused up,
                  //      we wont know it. so, if the mouse is up (and we're not
                  //      on a touch device): preventDefault, stopPropagation and
                  //      end the drag session
                  if (event.which === 0 && !evt.touchDevice) {
                      event.preventDefault();
                      event.stopPropagation();
                      element.internalEvents.cellResizeDragEnd();
  
                  } else {
                      // the resize has started, update resizeStarted to true so
                      //      that the drag end code knows that a change will be
                      //      made
                      element.internalResize.resizeStarted = true;
  
                      // we need to know the mouse position and the position of
                      //      the gs-table so that we can do calculations relative
                      //      to the gs-table element
                      jsnMousePos = GS.mousePosition(event);
                      jsnElementPos = GS.getElementOffset(
                          element.elems.dataViewport
                      );
  
                      //// convenience variables
                      //intViewportWidth = element.elems.dataViewport.clientWidth;
                      //intViewportHeight = (
                      //    element.elems.dataViewport.clientHeight
                      //);
  
                      // we need to know the column and/or row
                      //      number we are resizing from
                      colIndex = element.internalResize.resizeColumnIndex;
                      rowIndex = element.internalResize.resizeRecordIndex;
  
                      // we need to know the current visible range of cells
                      jsnRange = (
                          element.internalDisplay.currentRange
                      );
  
                      // find out what directions to scroll
                      bolScrollTop = (
                          jsnMousePos.top < (
                              // the mouse position is relative to the window
                              //      so we need to account for the left
                              //      offset of the gs-table element
                              jsnElementPos.top +
                              // anything we stick to the left cannot be ordered
                              //      to, so start scrolling at the right side of
                              //      the left offset
                              element.internalScrollOffsets.top
                          )
                      );
                      bolScrollLeft = (
                          jsnMousePos.left < (
                              // the mouse position is relative to the window
                              //      so we need to account for the left
                              //      offset of the gs-table element
                              jsnElementPos.left +
                              // anything we stick to the left cannot be ordered
                              //      to, so start scrolling at the right side of
                              //      the left offset
                              element.internalScrollOffsets.left
                          )
                      );
                      bolScrollRight = (
                          jsnMousePos.left > (
                              (
                                  // the mouse position is relative to the window
                                  //      so we need to account for the left
                                  //      offset of the gs-table element
                                  jsnElementPos.left +
                                  // we want the right side so we need to take
                                  //      into account the width of the gs-table
                                  element.elems.dataViewport.clientWidth
                              ) -
                              // anything we stick to the right cannot be ordered
                              //      to, so start scrolling at the beginning of
                              //      the right offset
                              element.internalScrollOffsets.right
                          )
                      );
                      bolScrollBottom = (
                          jsnMousePos.top > (
                              (
                                  // the mouse position is relative to the window
                                  //      so we need to account for the top
                                  //      offset of the gs-table element
                                  jsnElementPos.top +
                                  // we want the bottom side so we need to take
                                  //      into account the height of the gs-table
                                  element.elems.dataViewport.clientHeight
                              ) -
                              // anything we stick to the bottom cannot be resized
                              //      past, so start scrolling at the beginning of
                              //      the bottom offset
                              element.internalScrollOffsets.bottom
                          )
                      );
  
                      // you can't scroll vertically when you're not
                      //      resizing a record
                      if (!element.internalResize.resizeRecord) {
                          bolScrollTop = false;
                          bolScrollBottom = false;
                      }
  
                      // you can't scroll horizontally when you're not
                      //      resizing a column
                      if (!element.internalResize.resizeColumn) {
                          bolScrollLeft = false;
                          bolScrollRight = false;
                      }
  
                      // you can't scroll horizontally when you're
                      //      resizing the record selectors
                      if (element.internalResize.resizingRecordSelectors) {
                          bolScrollLeft = false;
                          bolScrollRight = false;
                      }
  
                      // you can't scroll vertically when you're
                      //      resizing the header or the insert record
                      if (
                          element.internalResize.resizingHeader ||
                          element.internalResize.resizingInsert
                      ) {
                          bolScrollTop = false;
                          bolScrollBottom = false;
                      }
  
                      // if we are scrolling up and the initial
                      //      record is the last visible record
                      //      (or second last)
                      if (
                          bolScrollTop &&
                          rowIndex === jsnRange.toRecord
                      ) {
                          bolScrollTop = false;
                      }
  
                      // if we're scrolling left and the initial
                      //      column is the last visible column
                      if (
                          bolScrollLeft &&
                          colIndex === jsnRange.toColumn
                      ) {
                          bolScrollLeft = false;
                      }
  
                      // if we're scrolling down and the initial
                      //      record is the first visible record
                      if (
                          bolScrollBottom &&
                          rowIndex === jsnRange.fromRecord
                      ) {
                          bolScrollBottom = false;
                      }
  
                      // if we're scrolling to the right and the
                      //      initial column is the first visible
                      //      column
                      if (
                          bolScrollRight &&
                          colIndex === jsnRange.fromColumn
                      ) {
                          bolScrollRight = false;
                      }
  
                      //console.log(
                      //    'X:' + jsnMousePos.left,
                      //    'Y:' + jsnMousePos.top,
                      //    bolScrollTop,
                      //    bolScrollLeft,
                      //    bolScrollRight,
                      //    bolScrollBottom
                      //);
  
                      // if the mouse is to the side of the viewport and scrolling
                      //      hasn't been started already: we want to start
                      //      scrolling on a timer
                      if (
                          (
                              bolScrollTop ||
                              bolScrollLeft ||
                              bolScrollRight ||
                              bolScrollBottom
                          ) &&
                          !element.internalScroll.dragScrolling
                      ) {
                          // start scroll
                          dragScrollStart(
                              element,
                              // drag move callback
                              function () {
                                  var bolOldScrollTop;
                                  var bolOldScrollLeft;
                                  var bolOldScrollBottom;
                                  var bolOldScrollRight;
  
                                  // the scroll direction could be changed
                                  //      anytime, we need to make sure we're
                                  //      up to date
                                  strScrollDirection = (
                                      element.internalScroll
                                          .dragScrollingDirection
                                  );
                                  bolScrollTop = (
                                      strScrollDirection.indexOf('top') !== -1
                                  );
                                  bolScrollLeft = (
                                      strScrollDirection.indexOf('left') !== -1
                                  );
                                  bolScrollBottom = (
                                      strScrollDirection.indexOf('bottom') !== -1
                                  );
                                  bolScrollRight = (
                                      strScrollDirection.indexOf('right') !== -1
                                  );
  
                                  // we want to know if a scroll direction was
                                  //      changed, so we'll save the old scroll
                                  //      booleans
                                  bolOldScrollTop = bolScrollTop;
                                  bolOldScrollLeft = bolScrollLeft;
                                  bolOldScrollBottom = bolScrollBottom;
                                  bolOldScrollRight = bolScrollRight;
  
                                  // we need the user to see where the column or
                                  //      row will be resized to
                                  setLineToMouse(event);
  
                                  // we need to know the current visible range
                                  //      of cells
                                  jsnRange = (
                                      element.internalDisplay.currentRange
                                  );
  
                                  //console.log(
                                  //    bolScrollTop,
                                  //    rowIndex,
                                  //    jsnRange.toRecord
                                  //);
                                  //console.log(
                                  //    bolScrollLeft,
                                  //    colIndex,
                                  //    jsnRange.toColumn
                                  //);
                                  //console.log(
                                  //    bolScrollBottom,
                                  //    rowIndex,
                                  //    jsnRange.fromRecord
                                  //);
                                  //console.log(
                                  //    bolScrollRight,
                                  //    colIndex,
                                  //    jsnRange.fromColumn
                                  //);
  
                                  // if we are scrolling up and the initial
                                  //      record is the last visible record
                                  //      (or second last)
                                  if (
                                      bolScrollTop &&
                                      rowIndex === jsnRange.toRecord
                                  ) {
                                      bolScrollTop = false;
                                  }
  
                                  // if we're scrolling left and the initial
                                  //      column is the last visible column
                                  if (
                                      bolScrollLeft &&
                                      colIndex === jsnRange.toColumn
                                  ) {
                                      bolScrollLeft = false;
                                  }
  
                                  // if we're scrolling down and the initial
                                  //      record is the first visible record
                                  if (
                                      bolScrollBottom &&
                                      rowIndex === jsnRange.fromRecord
                                  ) {
                                      bolScrollBottom = false;
                                  }
  
                                  // if we're scrolling to the right and the
                                  //      initial column is the first visible
                                  //      column
                                  if (
                                      bolScrollRight &&
                                      colIndex === jsnRange.fromColumn
                                  ) {
                                      bolScrollRight = false;
                                  }
  
                                 //console.log(
                                 //    'bolScrollTop: ' + bolScrollTop
                                 //);
                                 //console.log(
                                 //    'bolScrollLeft: ' + bolScrollLeft
                                 //);
                                 //console.log(
                                 //    'bolScrollBottom: ' + bolScrollBottom
                                 //);
                                 //console.log(
                                 //    'bolScrollRight: ' + bolScrollRight
                                 //);
  
                                  // if a scroll direction was stopped
                                  if (
                                      bolScrollTop !== bolOldScrollTop ||
                                      bolScrollLeft !== bolOldScrollLeft ||
                                      bolScrollBottom !== bolOldScrollBottom ||
                                      bolScrollRight !== bolOldScrollRight
                                  ) {
                                      // if there are any scroll directions left,
                                      //      restart scrolling in that direction
                                      if (
                                          bolScrollTop ||
                                          bolScrollLeft ||
                                          bolScrollRight ||
                                          bolScrollBottom
                                      ) {
                                          // reset scrolling direction
                                          element.internalScroll
                                              .dragScrollingDirection = (
                                                  (
                                                      bolScrollTop
                                                          ? 'top'
                                                          : ''
                                                  ) +
                                                  (
                                                      bolScrollLeft
                                                          ? 'left'
                                                          : ''
                                                  ) +
                                                  (
                                                      bolScrollRight
                                                          ? 'right'
                                                          : ''
                                                  ) +
                                                  (
                                                      bolScrollBottom
                                                          ? 'bottom'
                                                          : ''
                                                  )
                                              );
                                      } else {
                                          //console.log('RESIZE SCROLL STOPPED');
                                          dragScrollEnd(element);
                                      }
                                  }
  
                                  //element.internalResize.lastY
                                  //element.internalResize.lastX
                                  //element.internalResize.lastWidth
                                  //element.internalResize.lastHeight
                                  //dragScrollEnd(element);
                              },
                              (
                                  (
                                      bolScrollTop
                                          ? 'top'
                                          : ''
                                  ) +
                                  (
                                      bolScrollLeft
                                          ? 'left'
                                          : ''
                                  ) +
                                  (
                                      bolScrollRight
                                          ? 'right'
                                          : ''
                                  ) +
                                  (
                                      bolScrollBottom
                                          ? 'bottom'
                                          : ''
                                  )
                              )
                          );
  
                      // else if the scrolling has started and there are
                      //      directions we want to scroll
                      } else if (
                          element.internalScroll.dragScrolling &&
                          (
                              bolScrollTop ||
                              bolScrollLeft ||
                              bolScrollRight ||
                              bolScrollBottom
                          )
                      ) {
                          strScrollDirection = (
                              element.internalScroll.dragScrollingDirection
                          );
  
                          // if there is a direction that we want to scroll but
                          //      aren't scrolling right now, we need to add that
                          //      direction to the scroll direction
                          if (
                              bolScrollTop &&
                              strScrollDirection.indexOf('top') === -1
                          ) {
                              strScrollDirection += 'top';
                          }
                          if (
                              bolScrollLeft &&
                              strScrollDirection.indexOf('left') === -1
                          ) {
                              strScrollDirection += 'left';
                          }
                          if (
                              bolScrollRight &&
                              strScrollDirection.indexOf('right') === -1
                          ) {
                              strScrollDirection += 'right';
                          }
                          if (
                              bolScrollBottom &&
                              strScrollDirection.indexOf('bottom') === -1
                          ) {
                              strScrollDirection += 'bottom';
                          }
  
                          //console.log(
                          //    '1***',
                          //    strScrollDirection,
                          //    element.internalScroll.dragScrollingDirection
                          //);
  
                          // if we added a scroll direction, update the internal
                          //      storage
                          if (
                              strScrollDirection !==
                                  element.internalScroll.dragScrollingDirection
                          ) {
                              //console.log(
                              //    '2***',
                              //    strScrollDirection,
                              //    element.internalScroll.dragScrollingDirection
                              //);
                              element.internalScroll.dragScrollingDirection = (
                                  strScrollDirection
                              );
                          }
  
                          //console.log(
                          //    '3***',
                          //    strScrollDirection,
                          //    element.internalScroll.dragScrollingDirection
                          //);
  
                      // else if the mouse is NOT to the side of the viewport and
                      //      the scrolling has been started: we want to stop
                      //      scrolling
                      } else if (
                          !bolScrollTop &&
                          !bolScrollLeft &&
                          !bolScrollRight &&
                          !bolScrollBottom &&
                          element.internalScroll.dragScrolling
                      ) {
                          // stop scroll
                          dragScrollEnd(element);
                      }
  
                      // we need the user to see where the column or row will be
                      //      resized to
                      setLineToMouse(event);
  
                      //console.log('X:' + intMouseX, 'Y:' + intMouseY);
                  }
              };
  
              element.internalEvents.cellResizeDragEnd = function () {
                  var intNew;
                  var intIndex;
                  var i;
                  var len;
                  var arrRecordHeights;
                  var arrSelectedColumns;
                  var arrColumnWidths;
                  var arrColumns;
  
  
                  var colsToResize = [];
                  var selectedBroken = false;
                  //console.log(arrSelectedColumns);
                  //console.log(
                  //    element.internalSelection.rows[0]
                  //    , ', header'
                  //);
                  if (element.internalSelection.rows[0] ===
                      'header'
                  ) {
                      //console.log(
                      //    element.internalSelection.ranges.length
                      //    , ', > 0'
                     // );
                      if (element.internalSelection.ranges.length
                          > 0
                      ) {
                          var jsnFirstRange = (
                              element.internalSelection.ranges[0]
                          );
                          var intSelectionLength;
                          var strStartColumn = jsnFirstRange.start.column;
                          var strEndColumn = jsnFirstRange.end.column;
                          var intStartColumn = parseInt(
                              (
                                  strStartColumn === 'selector'
                                      ? 0
                                      : strStartColumn
                              ),
                              10
                          );
                          var intEndColumn = parseInt(
                              (
                                  strEndColumn === 'selector'
                                      ? 0
                                      : strEndColumn
                              ),
                              10
                          );
  
                          if (jsnFirstRange.start.row === 'header') {
                              if (
                                  strStartColumn === 'selector' &&
                                  strEndColumn === 'selector'
                              ) {
                                  intSelectionLength = (
                                      element.internalSelection.columns.length - 2
                                  );
                              } else if (intStartColumn > intEndColumn) {
                                  selectedBroken = true;
                                  intSelectionLength = (
                                      (intStartColumn + 1) - intEndColumn
                                  );
                              } else {
                                  selectedBroken = false;
                                  intSelectionLength = (
                                      (intEndColumn + 1) - intStartColumn
                                  );
                              }
                              if (intSelectionLength === 0) {
                                  intSelectionLength = 1;
                              }
  
                              i = 0;
                              while (i < intSelectionLength) {
                                  if (selectedBroken) {
                                      colsToResize.push(
                                          i + intEndColumn
                                      );
                                  } else {
                                      colsToResize.push(
                                          i + intStartColumn
                                      );
                                  }
  
                                  i += 1;
                              }
                          }
                      }
  
                  }
                  // nunzio commented this out on 2017-08-21
                  //      because it was causing the datasheet
                  //      to resize the selected columns even
                  //      though the resized column was not selected
                  // colsToResize.push(element.internalResize.resizeColumnIndex);
  
                  //console.log(colsToResize);
  
                  // if scrolling is running, stop it because we are done with
                  //      the mouse part of the resize action
                  if (element.internalScroll.dragScrolling) {
                      dragScrollEnd(element);
                  }
  
                  // because we've ended the resize, we want the column
                  //      handle to become invisible. we'll remove the
                  //      "active" class.
                  element.elems.handleColumn.classList.remove('active');
  
                  // because we've ended the resize, we want the record
                  //      handle to become invisible. we'll remove the
                  //      "active" class.
                  element.elems.handleRecord.classList.remove('active');
  
                  // if the column resize handle exists and was moved:
                  //      apply column resize
                  if (
                      element.internalResize.resizeColumn &&
                      element.internalResize.resizeStarted
                  ) {
                      // calculate the new width based on the origin X and the
                      //      last X the mouse was at
                      intNew = (element.internalResize.lastWidth);
  
                      // if we're resizing the record selector column
                      if (element.internalResize.resizingRecordSelectors) {
                          element.internalDisplay.recordSelectorWidth = intNew;
  
                      // else, we are updating a column width
                      } else {
                          // get the index of the column that was resized
                          intIndex = (
                              element.internalResize.resizeColumnIndex
                          );
  
                          // we need to know the selected columns so that we can
                          //      check to see if the resized column was selected
                          // convenience variable
                  // // arrSelectedColumns = element.internalSelection.columns;
                          // // arrSelectedColumns = (
                          // //     arrSelectedColumns.slice(
                          // //         arrSelectedColumns[0] === 'selector'
                          // //             ? 1
                          // //             : 0
                          // //     )
                          // // );
  
                          // convenience variable
                          arrColumnWidths = (
                              element.internalDisplay.columnWidths
                          );
                          //console.log(colsToResize);
                          // if the column we resized was seleced, resize any
                          //      columns that are selected and connected to it
                          if (colsToResize.indexOf(intIndex) > -1) {
                              arrColumns = (
                                  getConnectedSelectedColumns(element, intIndex)
                              );
  
                              i = 0;
                              len = colsToResize.length;
                              while (i < len) {
                                  arrColumnWidths[colsToResize[i]] = intNew;
                                  //[arrColumns[i]] = intNew;
  
                                  i += 1;
                              }
                          } else {
                              // set new width
                              arrColumnWidths[intIndex] = intNew;
                          }
                      }
                  }
  
                  // if the record resize handle exists and was moved:
                  //      apply record resize
                  if (
                      element.internalResize.resizeRecord &&
                      element.internalResize.resizeStarted
                  ) {
                      // calculate the new height based on the origin Y and the
                      //      last Y the mouse was at
                      intNew = (element.internalResize.lastHeight);
  
                      // if we're resizing the header
                      if (element.internalResize.resizingHeader) {
                          element.internalDisplay.headerHeight = intNew;
  
                      //// if we're resizing the insert record
                      //} else if (element.internalResize.resizingInsert) {
                      //    element.internalDisplay.insertRecordHeight = intNew;
  
                      // else, resizing a regular row
                      } else {
                          // resize all records
                          arrRecordHeights = (
                              element.internalDisplay.recordHeights
                          );
                          i = 0;
                          len = arrRecordHeights.length;
                          while (i < len) {
                              arrRecordHeights[i] = intNew;
                              i += 1;
                          }
  
                          if (element.internalDisplay.insertRecordVisible) {
                              element.internalDisplay.insertRecordHeight = intNew;
                          }
                      }
                  }
  
                  // if a handle drag occured:
                  if (element.internalResize.resizeStarted) {
                      // re-render so that the user can see the cells in their
                      //      new sizes
                      // we re-render the scroll dimensions because the cell
                      //      resize might affect the scroll width or height
                      renderScrollDimensions(element);
                  }
  
                  // we need to let everything know that we are no longer
                  //      resizing cells
                  element.internalResize.currentlyResizing = false;
  
                  // unbind mousemove and mouseup
                  document.body.removeEventListener(
                      evt.mousemove,
                      element.internalEvents.cellResizeDragMove
                  );
                  document.body.removeEventListener(
                      evt.mouseup,
                      element.internalEvents.cellResizeDragEnd
                  );
              };
  
              // bind the same drag start to the record and column elements so
              //      that if either one is mousedown'ed on, the cell resize
              //      starts
              element.elems.handleColumn.addEventListener(
                  evt.mousedown,
                  element.internalEvents.cellResizeDragStart
              );
              element.elems.handleRecord.addEventListener(
                  evt.mousedown,
                  element.internalEvents.cellResizeDragStart
              );
  
              // we want to resize the selected records/columns back to their
              //      default sizes if the handle is double-clicked
              element.internalEvents.cellResizeToDefault = function () {
                  //var intIndex;
                  var intNew;
                  var i;
                  var len;
                  var arrRecordHeights;
                  var arrSelectedColumns;
                  //var arrColumnWidths;
                  //var arrColumns;
  
                  // we need to be able to resize all selected records/columns,
                  //      if the handle you double click touches a selected
                  //      cell: resize all selected cells to default
                  // ### NEED CODING ###
  
                  // if the column resize handle exists: apply column resize
                  if (element.internalResize.resizeColumn) {
                      // if the column handle was the first one and the record
                      //      selector is visible, we need to update the record
                      //      selector width
                      if (element.internalResize.resizingRecordSelectors) {
                          element.internalDisplay.recordSelectorWidth = (
                              element.internalDisplay.defaultRecordSelectorWidth
                          );
  
                      // else, we are updating a column width
                      } else {
                          //// get the index of the column that was resized
                          //intIndex = (
                          //    element.internalResize.resizeColumnIndex
                          //);
  
                          // we need to know the selected columns so that we can
                          //      check to see if the resized column was selected
                          // convenience variable
                          arrSelectedColumns = element.internalSelection.columns;
                          arrSelectedColumns = (
                              arrSelectedColumns.slice(
                                  arrSelectedColumns[0] === 'selector'
                                      ? 1
                                      : 0
                              )
                          );
  
                          var colsToResize = [];
                          var selectedBroken = false;
                          var jsnFirstRange;
                          var strStartColumn;
                          var strEndColumn;
                          var intStartColumn;
                          var intEndColumn;
                          var intSelectionLength;
  
                          if (element.internalSelection.rows[0] ===
                              'header'
                          ) {
                              if (
                                  element.internalSelection.ranges.length > 0
                              ) {
                                  jsnFirstRange = (
                                      element.internalSelection.ranges[0]
                                  );
                                  strStartColumn = jsnFirstRange.start.column;
                                  strEndColumn = jsnFirstRange.end.column;
                                  intStartColumn = (
                                      parseInt(
                                          (
                                              strStartColumn === 'selector'
                                                  ? 0
                                                  : strStartColumn
                                          ),
                                          10
                                      )
                                  );
                                  intEndColumn = (
                                      parseInt(
                                          (
                                              strEndColumn === 'selector'
                                                  ? 0
                                                  : strEndColumn
                                          ),
                                          10
                                      )
                                  );
  
                                  if (jsnFirstRange.start.row === 'header') {
                                      if (
                                          strStartColumn === 'selector' &&
                                          strEndColumn === 'selector'
                                      ) {
                                          intSelectionLength = (
                                              element.internalSelection
                                                  .columns
                                                  .length - 2
                                          );
                                      } else if (intStartColumn > intEndColumn) {
                                          selectedBroken = true;
                                          intSelectionLength = (
                                              (intStartColumn + 1) - intEndColumn
                                          );
                                      } else {
                                          selectedBroken = false;
                                          intSelectionLength = (
                                              (intEndColumn + 1) - intStartColumn
                                          );
                                      }
                                      if (intSelectionLength === 0) {
                                          intSelectionLength = 1;
                                      }
  
                                      i = 0;
                                      while (i < intSelectionLength) {
                                          if (selectedBroken) {
                                              colsToResize.push(
                                                  i + intEndColumn
                                              );
                                          } else {
                                              colsToResize.push(
                                                  i + intStartColumn
                                              );
                                          }
  
                                          i += 1;
                                      }
                                  }
                              }
                          }
                          // commented by nunzio on 2017-08-21
                          //      Same reason as in cellResizeDragEnd
                          //colsToResize.push(
                          //    element.internalResize.resizeColumnIndex
                          //);
  
                          //console.log(colsToResize);
                          if (colsToResize.indexOf(
                              element.internalResize.resizeColumnIndex
                          ) > 0) {
                              resizeColumnsToContent(element, colsToResize);
                          } else {
                              resizeColumnsToContent(element, [
                                  element.internalResize.resizeColumnIndex
                              ]);
                          }
  
  
  
                          //// convenience variable
                          //arrColumnWidths = (
                          //    element.internalDisplay.columnWidths
                          //);
  
                          //// if the column we resized was seleced, resize any
                          ////      columns that are selected and connected to it
                          //if (arrSelectedColumns.indexOf(intIndex) > -1) {
                          //    arrColumns = (
                          //        getConnectedSelectedColumns(element, intIndex)
                          //    );
  
                          //    i = 0;
                          //    len = arrColumns.length;
                          //    while (i < len) {
                          //        arrColumnWidths[arrColumns[i]] = (
                          //            element.internalDisplay
                          //                .defaultColumnWidths[arrColumns[i]]
                          //        );
                          //        i += 1;
                          //    }
                          //} else {
                          //    // set new width
                          //    arrColumnWidths[intIndex] = (
                          //        element.internalDisplay
                          //            .defaultColumnWidths[intIndex]
                          //    );
                          //}
                      }
                  }
  
                  // if the record resize handle exists: apply record resize
                  if (element.internalResize.resizeRecord) {
                      // if we double-clicked the header
                      if (element.internalResize.resizingHeader) {
                          element.internalDisplay.headerHeight = (
                              element.internalDisplay.defaultHeaderHeight
                          );
  
                      //// if we double-clicked the insert record
                      //} else if (element.internalResize.resizingInsert) {
                      //    element.internalDisplay.insertRecordHeight = (
                      //        element.internalDisplay.defaultInsertRecordHeight
                      //    );
  
                      } else {
                          // resize all records
                          intNew = (
                              element.internalDisplay.defaultRecordHeight
                          );
                          arrRecordHeights = (
                              element.internalDisplay.recordHeights
                          );
                          i = 0;
                          len = arrRecordHeights.length;
                          while (i < len) {
                              arrRecordHeights[i] = intNew;
                              i += 1;
                          }
  
                          if (element.internalDisplay.insertRecordVisible) {
                              element.internalDisplay.insertRecordHeight = (
                                  element.internalDisplay
                                      .defaultInsertRecordHeight
                              );
                          }
                      }
                  }
  
                  // remove the handles from the viewport because a partial render
                  //      doesn't remove them
                  if (element.internalResize.resizeColumn) {
                      element.elems.dataViewport.removeChild(
                          element.elems.handleColumn
                      );
                  }
                  if (element.internalResize.resizeRecord) {
                      element.elems.dataViewport.removeChild(
                          element.elems.handleRecord
                      );
                  }
  
                  // re-render so that the user can see the cells in their new
                  //      sizes
                  // we re-render the scroll dimensions because the cell resize
                  //      might affect the scroll width or height
                  renderScrollDimensions(element);
              };
  
              // bind the same resize to default to the record and column handles
              //      so that if either one is double-clicked on, the cell resize
              //      is triggered
              element.elems.handleColumn.addEventListener(
                  'dblclick',
                  element.internalEvents.cellResizeToDefault
              );
              element.elems.handleRecord.addEventListener(
                  'dblclick',
                  element.internalEvents.cellResizeToDefault
              );
          }
      }
  
      // ############# COLUMN REORDER EVENTS #############
      function unbindColumnReorder(element) {
          if (!evt.touchDevice) {
              element.elems.dataViewport.removeEventListener(
                  'mousedown',
                  element.internalEvents.columnReorderDragStart
              );
          }
      }
      function bindColumnReorder(element) {
          var setLineToMouse;
  
          if (!evt.touchDevice) {
              // we want to take the mouse position and add a line to the closest
              //      column line, we do this on mousedown and on mousemove, so
              //      we'll create a function to handle that
              setLineToMouse = function (event) {
                  var jsnMousePos;
                  var jsnElementPos;
                  var arrColumnHandles;
                  var intMouse;
                  var intPrevHandle;
                  var intCurrentHandle;
                  var intPrevIndex;
                  var intCurrentIndex;
                  var intHandleIndex;
                  var intInsertionIndex;
                  var i;
                  var len;
  
                  // we need the mouse position
                  jsnMousePos = GS.mousePosition(event);
  
                  // we need the element position because the mouse position is
                  //      not relative to element
                  jsnElementPos = GS.getElementOffset(
                      element.elems.dataViewport
                  );
  
                  // we need the locations where a column can be moved to
                  arrColumnHandles = (
                      element.internalDisplay.columnHandles
                  );
  
                  // we need the mouse left position relative to the gs-table
                  intMouse = (
                      jsnMousePos.left - jsnElementPos.left
                  );
  
                  // we need to find the correct insertion points
                  if (
                      element.internalScroll.dragScrolling &&
                      element.internalScroll.dragScrollingDirection === 'left'
                  ) {
                      // get first non-null handle
                      i = 0;
                      len = arrColumnHandles.length;
                      while (i < len) {
                          if (arrColumnHandles[i] !== null) {
                              intHandleIndex = i;
                              break;
                          }
                          i += 1;
                      }
  
                  } else if (
                      element.internalScroll.dragScrolling &&
                      element.internalScroll.dragScrollingDirection === 'left'
                  ) {
                      // get last non-null handle
                      i = (arrColumnHandles.length - 1);
                      while (i >= 0) {
                          if (arrColumnHandles[i] !== null) {
                              intHandleIndex = i;
                              break;
                          }
                          i -= 1;
                      }
  
                  } else {
                      // we need to find out what handle the mouse is closest to
                      //      BEWARE, hidden columns have null as their handle.
                      //      we need to work around null column handles
                      intPrevHandle = null;
                      intCurrentHandle = null;
                      intPrevIndex = null;
                      intCurrentIndex = null;
                      intHandleIndex = null;
                      i = 0;
                      len = arrColumnHandles.length;
                      while (i < len) {
                          if (arrColumnHandles[i] !== null) {
                              intCurrentHandle = arrColumnHandles[i];
                              intCurrentIndex = i;
                          }
  
                          if (
                              intPrevHandle !== null &&
                              intCurrentHandle !== null
                          ) {
                              if (
                                  intMouse >= intPrevHandle &&
                                  intMouse <= intCurrentHandle
                              ) {
                                  if (
                                      // if the mouse is closer to the right
                                      (intCurrentHandle - intMouse) <
                                          (intMouse - intPrevHandle)
                                  ) {
                                      intHandleIndex = intCurrentIndex;
  
                                  // else, the handle is the left handle
                                  } else {
                                      intHandleIndex = intPrevIndex;
                                  }
                              } else if (i === (len - 1)) {
                                  if (intMouse >= intCurrentHandle) {
                                      intHandleIndex = intCurrentIndex;
                                  } else {
                                      intHandleIndex = intPrevIndex;
                                  }
                              }
                          } else if (
                              intCurrentHandle !== null &&
                              intMouse <= intCurrentHandle
                          ) {
                              intHandleIndex = intCurrentIndex;
                          }
  
                          if (intHandleIndex !== null) {
                              break;
                          }
  
                          if (intCurrentHandle !== null) {
                              intPrevHandle = intCurrentHandle;
                              intPrevIndex = intCurrentIndex;
                          }
  
                          i += 1;
                      }
                  }
                  //console.log(
                  //    intMouse,
                  //    intPrevHandle,
                  //    intPrevIndex,
                  //    intCurrentHandle,
                  //    intCurrentIndex,
                  //    intHandleIndex,
                  //    element.internalDisplay.currentRange.fromColumn
                  //);
  
                  // the handle list only contains the visible column
                  //      list so, we have to add the first visible
                  //      column's number to the handle index
                  intInsertionIndex = (
                      intHandleIndex +
                      element.internalDisplay.currentRange.fromColumn
                  );
  
                  //console.log(
                  //    intScroll,
                  //    intMouse,
                  //    intViewportWidth,
                  //    intHandleIndex,
                  //    intInsertionIndex
                  //);
  
                  // sometimes, this function will be called while the reorder
                  //      indicator is not in the DOM, if it isn't, append it to
                  //      the dataViewport
                  if (
                      element.elems.handleReorder.parentNode !==
                          element.elems.dataViewport
                  ) {
                      element.elems.dataViewport.appendChild(
                          element.elems.handleReorder
                      );
                  }
  
                  // we need to update the position of the line
                  element.elems.handleReorder.style.left = (
                      (
                          arrColumnHandles[intHandleIndex]
                      ) + 'px'
                  );
  
                  // we need to keep track of the drop location
                  element.internalReorder.dropLocation = intInsertionIndex;
              };
  
              // when dragging, just show a line where you'll resize to, instead
              //      of changing the size and re-rendering multiple times in a
              //      row
              element.internalEvents.columnReorderDragStart = function (event) {
                  var target;
                  var parentCell;
                  var intColNumber;
                  var arrCurrentColumns;
  
                  // we only want to reorder if the drag originates from a header
                  //      cell that is selected
                  target = event.target;
                  if (parentCell && parentCell.nodeName !== 'GS-CELL') {
                      parentCell = GS.findParentElement(target, 'gs-cell');
                  } else {
                      parentCell = target;
                  }
  
                  if (
                      parentCell &&
                      parentCell.nodeName === 'GS-CELL' &&
                      parentCell.classList.contains('table-header') &&
                      parentCell.hasAttribute('selected') &&
                      // only reorder when the left mouse button is down
                      event.which === 1
                  ) {
                      // we need to let everything know that we are reordering,
                      //      this is used to prevent cell selection during column
                      //      reorder
                      element.internalReorder.currentlyReordering = true;
  
                      // there are some things in the drag end code that we only
                      //      want to run if the mouse has moved (and therefore
                      //      started reordering), so here we default the
                      //      reorderStarted to false and after mousemove it'll
                      //      be set to true
                      element.internalReorder.reorderStarted = false;
  
                      // we need to know what columns we're dragging, so we'll
                      //      take the column number and grab any column numbers
                      //      that are contiguous
  
                      // get number of the column we selected
                      intColNumber = parseInt(
                          parentCell.getAttribute('data-col-number'),
                          10
                      );
                      //console.log('column', intColNumber);
  
                      // clear current columns array so that we can start fresh
                      arrCurrentColumns = (
                          getConnectedSelectedColumns(element, intColNumber)
                      );
  
                      //console.log(arrSelection, arrCurrentColumns);
  
                      // we want the drag move and drag end functions to know what
                      //      columns are being reordered, so we'll save the array
                      //      to the internal storage
                      element.internalReorder.currentColumns = arrCurrentColumns;
  
                      // we want to know what column was the column that the user
                      //      initiated the drag on
                      element.internalReorder.originColumn = intColNumber;
  
                      // we want to know if a drop location was chosen, so we'll
                      //      clear out the old drop location and that way all
                      //      we'll have to do is test for null
                      element.internalReorder.dropLocation = null;
  
                      // sometimes, the user has other columns selected, let's
                      //      reset the selection to be the columns the user is
                      //      reordering
                      element.internalSelection.ranges = [
                          {
                              "start": {
                                  "row": "header",
                                  "column": arrCurrentColumns[0]
                              },
                              "end": {
                                  "row": "header",
                                  "column": arrCurrentColumns[
                                      arrCurrentColumns.length - 1
                                  ]
                              },
                              "negator": false
                          }
                      ];
  
                      // re-render the select to show the user the change
                      renderSelection(element);
  
                      // we need the user to see where the column will be dropped
                      setLineToMouse(event);
  
                      // we need to bind the mousemove and mouseup functionality
                      //      to the body so that we can still use the mouse
                      //      events even if the mouse is no longer over the
                      //      gs-table
                      document.body.addEventListener(
                          evt.mousemove,
                          element.internalEvents.columnReorderDragMove
                      );
                      document.body.addEventListener(
                          evt.mouseup,
                          element.internalEvents.columnReorderDragEnd
                      );
                  }
              };
  
              element.internalEvents.columnReorderDragMove = function (event) {
                  var jsnMousePos;
                  var jsnElementPos;
                  var bolScrollLeft;
                  var bolScrollRight;
  
                  // if the mouse moves off of the screen and then is moused up,
                  //      we wont know it. so, if the mouse is up (and we're not
                  //      on a touch device): preventDefault, stopPropagation and
                  //      end the drag session
                  if (event.which === 0 && !evt.touchDevice) {
                      event.preventDefault();
                      event.stopPropagation();
                      element.internalEvents.columnReorderDragEnd();
  
                  } else {
                      // the resize has started, update resizeStarted to true so
                      //      that the drag end code knows that a change will be
                      //      made
                      element.internalReorder.reorderStarted = true;
  
                      // we need to know the mouse position and the position of
                      //      the gs-table so that we can do calculations relative
                      //      to the gs-table element
                      jsnMousePos = GS.mousePosition(event);
                      jsnElementPos = GS.getElementOffset(
                          element.elems.dataViewport
                      );
  
                      // find out what directions to scroll
                      bolScrollLeft = (
                          jsnMousePos.left < (
                              // the mouse position is relative to the window
                              //      so we need to account for the left
                              //      offset of the gs-table element
                              jsnElementPos.left +
                              // anything we stick to the left cannot be ordered
                              //      to, so start scrolling at the right side of
                              //      the left offset
                              element.internalScrollOffsets.left
                          )
                      );
                      bolScrollRight = (
                          jsnMousePos.left > (
                              (
                                  // the mouse position is relative to the window
                                  //      so we need to account for the left
                                  //      offset of the gs-table element
                                  jsnElementPos.left +
                                  // we want the right side so we need to take
                                  //      into account the width of the gs-table
                                  element.elems.dataViewport.clientWidth
                              ) -
                              // anything we stick to the right cannot be ordered
                              //      to, so start scrolling at the beginning of
                              //      the right offset
                              element.internalScrollOffsets.right
                          )
                      );
  
                      //console.log(
                      //    'X:' + intMouseX,
                      //    bolScrollLeft,
                      //    bolScrollRight
                      //);
  
                      // if the mouse is to the side of the viewport and scrolling
                      //      hasn't been started already: we want to start
                      //      scrolling on a timer
                      if (
                          (bolScrollLeft || bolScrollRight) &&
                          !element.internalScroll.dragScrolling
                      ) {
                          // start scroll
                          dragScrollStart(
                              element,
                              // drag move callback
                              function () {
                                  // we need the user to see where the
                                  //      column will be dropped
                                  setLineToMouse(event);
                              },
                              (
                                  bolScrollLeft
                                      ? 'left'
                                      : 'right'
                              )
                          );
  
                      // else if the mouse is NOT to the side of the viewport and
                      //      the scrolling has been started: we want to stop
                      //      scrolling
                      } else if (
                          !bolScrollLeft &&
                          !bolScrollRight &&
                          element.internalScroll.dragScrolling
                      ) {
                          // stop scroll
                          dragScrollEnd(element);
                      }
  
                      // we need the user to see where the column will be dropped
                      setLineToMouse(event);
                  }
              };
  
              element.internalEvents.columnReorderDragEnd = function () {
                  var arrOrderCols;
                  var intDropIndex;
                  var headerTemplate;
                  var recordTemplate;
                  var insertTemplate;
                  var arrOldHeaderTemplate;
                  var arrOldRecordTemplate;
                  var arrOldInsertTemplate;
                  var arrOldPlainText;
                  var arrOldDataCol;
                  var arrOldColWidths;
                  var arrOldDefaultColWidths;
                  var arrOldCopyHeaders;
                  var arrOldCopyCol;
                  var strNewHeaderTemplate;
                  var strNewRecordTemplate;
                  var strNewInsertTemplate;
                  var arrNewPlainText;
                  var arrNewDataCol;
                  var arrNewColWidths;
                  var arrNewDefaultColWidths;
                  var arrNewCopyHeaders;
                  var arrNewCopyCol;
  
                  var i;
                  var len;
                  var intSeqIndex;
                  var unmovedColumns;
                  var pullIndex;
  
                  var index;
                  var strSort;
                  var strColumn;
                  var strOldSortOrder;
                  var strNewSortOrder;
  
                  // when reordering columns, we put a line into the viewport to
                  //      indicate where the columns will be put. so, we need to
                  //      remove the line
                  if (
                      element.elems.handleReorder.parentNode ===
                          element.elems.dataViewport
                  ) {
                      element.elems.dataViewport.removeChild(
                          element.elems.handleReorder
                      );
                  }
  
                  // if scrolling is running, stop it because we are done with
                  //      the mouse part of the reorder action
                  if (element.internalScroll.dragScrolling) {
                      dragScrollEnd(element);
                  }
  
                  // save drop index to a variable for convenience
                  intDropIndex = (
                      element.internalReorder.dropLocation
                  );
  
                  // we need to know what columns we are moving to the
                  //      drop index
                  arrOrderCols = (
                      element.internalReorder.currentColumns
                  );
  
                  // if the user clicks instead of dragging, we'll select the
                  //      column
                  if (!element.internalReorder.reorderStarted) {
                      element.internalSelection.ranges = [
                          {
                              "start": {
                                  // reorder functionality assumes the presence of
                                  //      headers
                                  "row": "header",
                                  "column": element.internalReorder.originColumn
                              },
                              "end": {
                                  // reorder functionality assumes the presence of
                                  //      headers
                                  "row": "header",
                                  "column": element.internalReorder.originColumn
                              },
                              "negator": false
                          }
                      ];
                      renderSelection(element);
                  }
  
                  //console.log(
                  //    'should we reorder?',
                  //    element.internalReorder.reorderStarted,
                  //    intDropIndex,
                  //    arrOrderCols,
                  //    arrOrderCols.length,
                  //    element.internalDisplay.columnWidths.length
                  //);
                  if (
                      // if a drag occurred
                      element.internalReorder.reorderStarted &&
                      // and the drop index is not null, undefined or NaN
                      intDropIndex !== null &&
                      intDropIndex !== undefined &&
                      !isNaN(intDropIndex) &&
                      // and there are columns to order
                      arrOrderCols.length > 0 &&
                      // and the drop index is not past the max
                      intDropIndex <= (
                          element.internalDisplay.columnWidths.length
                      ) &&
                      // and the drop index is not at any of the indexes
                      //      the order columns are located at
                      arrOrderCols.indexOf(intDropIndex) === -1 &&
                      // and the drop index is not at the right side of
                      //      the last column in the order column list
                      arrOrderCols.indexOf(intDropIndex - 1) === -1
                  ) {
                      // gotta reorder the templates, widths, and everything
                      //      else that we store about display columns
  
                      // here's the list of items to sort:
                      //      element.internalTemplates
                      //          header               <- element template
                      //          record               <- element template
                      //          insertRecord         <- element template
                      //      element.internalDisplay
                      //          columnPlainTextNames <- array
                      //          dataColumnName       <- array
                      //          columnWidths         <- array
                      //          defaultColumnWidths  <- array
                      //      element.internalClip
                      //          headerList           <- array
                      //          columnList           <- array
  
  
                      // we need to reorder the templates, in order to do
                      //      this we'll need access to their elements. the
                      //      templates are stored as strings and so we must
                      //      create template elements to put the content in
                      // put the template HTML into the template elements so
                      //      that we have access to the elements
  
                      if (element.internalTemplates.header) {
                          headerTemplate = document.createElement('template');
                          headerTemplate.innerHTML = (
                              element.internalTemplates.header
                          );
                          arrOldHeaderTemplate = (
                              xtag.query(headerTemplate.content, 'gs-cell')
                          );
                      }
  
                      if (element.internalTemplates.originalRecord) {
                          recordTemplate = document.createElement('template');
                          recordTemplate.innerHTML = (
                              element.internalTemplates.originalRecord
                          );
                          arrOldRecordTemplate = (
                              xtag.query(recordTemplate.content, 'gs-cell')
                          );
                      }
  
                      if (element.internalTemplates.insertRecord) {
                          insertTemplate = document.createElement('template');
                          insertTemplate.innerHTML = (
                              element.internalTemplates.insertRecord
                          );
                          arrOldInsertTemplate = (
                              xtag.query(insertTemplate.content, 'gs-cell')
                          );
                      }
  
                      // gather column arrays for easy access
                      arrOldPlainText = (
                          element.internalDisplay.columnPlainTextNames
                      );
                      arrOldDataCol = (
                          element.internalDisplay.dataColumnName
                      );
                      arrOldColWidths = (
                          element.internalDisplay.columnWidths
                      );
                      arrOldDefaultColWidths = (
                          element.internalDisplay.defaultColumnWidths
                      );
  
                      if (
                          element.internalClip.headerList &&
                          element.internalClip.headerList.length > 0
                      ) {
                          arrOldCopyHeaders = (
                              element.internalClip.headerList
                          );
                      }
  
                      if (
                          element.internalClip.columnList &&
                          element.internalClip.columnList.length > 0
                      ) {
                          arrOldCopyCol = (
                              element.internalClip.columnList
                          );
                      }
  
                      // create new arrays to hold the sorted lists
                      strNewHeaderTemplate = '';
                      strNewRecordTemplate = '';
                      strNewInsertTemplate = '';
                      arrNewPlainText = [];
                      arrNewDataCol = [];
                      arrNewColWidths = [];
                      arrNewDefaultColWidths = [];
                      arrNewCopyHeaders = [];
                      arrNewCopyCol = [];
  
                      // now begins the sort
  
                      // because all of the display column arrays must be the same
                      //      length, we can use one loop for all of the arrays
  
                      // we're going to loop through the column arrays and build
                      //      up the new, sorted arrays/strings
  
                      //console.log('##########################################');
                      //console.log('##########################################');
                      //console.log('##########################################');
                      //console.log('old header:    ', arrOldHeaderTemplate);
                      //console.log('old record:    ', arrOldRecordTemplate);
                      //console.log('old insert:    ', arrOldInsertTemplate);
                      //console.log('old plainTXT:  ', arrOldPlainText);
                      //console.log('old dataName:  ', arrOldDataCol);
                      //console.log('old width:     ', arrOldColWidths);
                      //console.log('old def width: ', arrOldDefaultColWidths);
                      //console.log('##########################################');
                      //console.log('##########################################');
                      //console.log('##########################################');
  
                      // we need a sequential number that is not tied to "i"
                      intSeqIndex = 0;
  
                      // we need a consumable column list so that we'll know we've
                      //      moved everything once the column list is empty
                      unmovedColumns = arrOrderCols.slice(0);
  
                      i = 0;
                      len = arrOldColWidths.length;
                      while (i < len) {
                          // because we are sorting by appending elements from
                          //      various points in the old array to the end of
                          //      the new arrays/strings, we need to determine
                          //      what index we are pulling from the old arrays.
                          //      this index will not be sequential like "i" will
                          //      be.
                          // there are two possibilities:
                          //      we sort the columns to the left
                          //      we sort the columns to the right
                          // in the case of a left sort:
                          //      we need to be sequential until we reach the drop
                          //      index, in which case we need to read the indexes
                          //      of the arrOrderCols array sequentially and then
                          //      we go back to where we left off until we reach
                          //      the first arrOrderCols value, in which case we
                          //      need to jump to the column after the last column
                          //      in arrOrderCols and continue until we reach the
                          //      end
                          // in the case of a right sort:
                          //      we need to be sequential until we reach the
                          //      first column in arrOrderCols, in which case we
                          //      skip to the column after the last column in
                          //      arrOrderCols and continue from there until we
                          //      reach the drop index, in which case we need to
                          //      read the indexes of the arrOrderCols array
                          //      sequentially and then we go back to where we
                          //      left off until we reach the end
  
                          //console.log(
                          //    '1***',
                          //    intSeqIndex,
                          //    intDropIndex,
                          //    unmovedColumns,
                          //    arrOrderCols
                          //);
                          // if we have reached the drop index and there
                          //      are order columns left
                          if (
                              intSeqIndex === intDropIndex &&
                              unmovedColumns.length > 0
                          ) {
                              //console.log('2.1*');
                              // grab and remove first order column index
                              pullIndex = unmovedColumns.shift();
  
                          // if we have reached the first column of
                          //      arrOrderCols
                          } else if (intSeqIndex === arrOrderCols[0]) {
                              //console.log('2.2*');
                              intSeqIndex += (arrOrderCols.length);
                              pullIndex = intSeqIndex;
                              intSeqIndex += 1;
  
                          // else, continue through column list
                          } else {
                              //console.log('2.3*');
                              pullIndex = intSeqIndex;
                              intSeqIndex += 1;
                          }
                          //console.log('3***', pullIndex);
  
                          // make the append to the new arrays/strings
                          if (arrOldHeaderTemplate) {
                              strNewHeaderTemplate += (
                                  arrOldHeaderTemplate[pullIndex].outerHTML
                              );
                          }
                          if (arrOldRecordTemplate) {
                              strNewRecordTemplate += (
                                  arrOldRecordTemplate[pullIndex].outerHTML
                              );
                          }
                          if (arrOldInsertTemplate) {
                              strNewInsertTemplate += (
                                  arrOldInsertTemplate[pullIndex].outerHTML
                              );
                          }
                          arrNewPlainText.push(
                              arrOldPlainText[pullIndex]
                          );
                          arrNewDataCol.push(
                              arrOldDataCol[pullIndex]
                          );
                          arrNewColWidths.push(
                              arrOldColWidths[pullIndex]
                          );
                          arrNewDefaultColWidths.push(
                              arrOldDefaultColWidths[pullIndex]
                          );
                          arrNewCopyHeaders.push(
                              arrOldCopyHeaders[pullIndex]
                          );
                          arrNewCopyCol.push(
                              arrOldCopyCol[pullIndex]
                          );
  
                          i += 1;
                      }
  
                      // there's a lot of stuff that has to happen, so we need a
                      //      lot of logging
                      //console.log('##########################################');
                      //console.log('##########################################');
                      //console.log('##########################################');
                      //console.log(
                      //    'reorder columns:',
                      //    arrOrderCols
                      //);
                      //console.log(
                      //    'to location:',
                      //    intDropIndex,
                      //    '(resolved location: ' + intResolvedDropIndex + ')'
                      //);
                      //console.log('##########################################');
                      //console.log('##########################################');
                      //console.log('##########################################');
                      //console.log('old header:    ', arrOldHeaderTemplate);
                      //console.log('new header:    ', strNewHeaderTemplate);
  
                      //console.log('old record:    ', arrOldRecordTemplate);
                      //console.log('new record:    ', strNewRecordTemplate);
  
                      //console.log('old insert:    ', arrOldInsertTemplate);
                      //console.log('new insert:    ', strNewInsertTemplate);
  
                      //console.log('old plainTXT:  ', arrOldPlainText);
                      //console.log('new plainTXT:  ', arrNewPlainText);
  
                      //console.log('old dataName:  ', arrOldDataCol);
                      //console.log('new dataName:  ', arrNewDataCol);
  
                      //console.log('old width:     ', arrOldColWidths);
                      //console.log('new width:     ', arrNewColWidths);
  
                      //console.log('old def width: ', arrOldDefaultColWidths);
                      //console.log('new def width: ', arrNewDefaultColWidths);
                      //console.log('##########################################');
                      //console.log('##########################################');
                      //console.log('##########################################');
  
                      // we need to update the column numbers inside the templates
                      //      to account for the sort, the column numbers are
                      //      important for partial re-render
                      if (arrOldHeaderTemplate) {
                          headerTemplate.innerHTML = strNewHeaderTemplate;
                          templateCellAddColumnNumber(headerTemplate);
                          strNewHeaderTemplate = headerTemplate.innerHTML;
  
                          // save the new header template so that the render
                          //      function uses it
                          element.internalTemplates.header = (
                              strNewHeaderTemplate
                          );
                      }
  
                      if (arrOldRecordTemplate) {
                          recordTemplate.innerHTML = strNewRecordTemplate;
                          templateCellAddColumnNumber(recordTemplate);
                          strNewRecordTemplate = recordTemplate.innerHTML;
  
                          // let's save the original record template text so
                          //      that we can modify it in the future
                          element.internalTemplates.originalRecord = (
                              strNewRecordTemplate
                          );
  
                          // save the new record template so that the render
                          //      function uses it
                          // we're going run the record template through a
                          //      function to turn all of the "column"
                          //      attributes into "value" attributes with
                          //      the proper templating
                          element.internalTemplates.record = (
                              GS.templateHideSubTemplates(
                                  strNewRecordTemplate,
                                  false // not a TR element
                              )
                          );
                      }
  
                      if (arrOldInsertTemplate) {
                          insertTemplate.innerHTML = strNewInsertTemplate;
                          templateCellAddColumnNumber(insertTemplate);
                          strNewInsertTemplate = insertTemplate.innerHTML;
  
                          // save the new insert template so that the render
                          //      function uses it
                          element.internalTemplates.insertRecord = (
                              strNewInsertTemplate
                          );
                      }
  
                      // save column arrays to internal storage
                      element.internalDisplay.columnPlainTextNames = (
                          arrNewPlainText
                      );
                      element.internalDisplay.dataColumnName = (
                          arrNewDataCol
                      );
                      element.internalDisplay.columnWidths = (
                          arrNewColWidths
                      );
                      element.internalDisplay.defaultColumnWidths = (
                          arrNewDefaultColWidths
                      );
                      if (arrOldCopyHeaders) {
                          element.internalClip.headerList = (
                              arrNewCopyHeaders
                          );
                      }
                      if (arrOldCopyCol) {
                          element.internalClip.columnList = (
                              arrNewCopyCol
                          );
                      }
  
                      // adjust selection to new column locations
                      // ### NEED CODING ###
                      // temp, clear select
                      element.internalSelection.ranges = [];
  
                      // sometimes, the user has sorted some columns. in this
                      //      case, we need to refresh the table
  
                      // here, we construct two strings representing the old
                      //      and new sort column orders, that way we can compare
                      //      them and refresh of they are different
                      strOldSortOrder = '';
                      strNewSortOrder = '';
                      i = 0;
                      len = arrOldDataCol.length;
                      while (i < len) {
                          if (arrOldDataCol[i]) {
                              strColumn = arrOldDataCol[i];
  
                              index = (
                                  element.internalData.columnNames.indexOf(
                                      strColumn
                                  )
                              );
  
                              strSort = element.internalData.columnOrders[index];
  
                              if (index > -1 && strSort !== 'neutral') {
                                  strOldSortOrder += strColumn;
                              }
                          }
                          if (arrNewDataCol[i]) {
                              strColumn = arrNewDataCol[i];
  
                              index = (
                                  element.internalData.columnNames.indexOf(
                                      strColumn
                                  )
                              );
  
                              strSort = element.internalData.columnOrders[index];
  
                              if (index > -1 && strSort !== 'neutral') {
                                  strNewSortOrder += strColumn;
                              }
                          }
                          i += 1;
                      }
  
                      //console.log(
                      //    '"' + strOldSortOrder + '"',
                      //    '"' + strNewSortOrder + '"'
                      //);
  
                      if (strOldSortOrder !== strNewSortOrder) {
                          dataSELECT(element);
  
                      // else, we can just re-render
                      } else {
                          // re-render so that the user can see the cells in their
                          //      new order
                          element.internalDisplay.fullRenderRequired = true;
                          renderScrollDimensions(element);
                      }
                  }
  
                  // we need to let everything know that we are no longer
                  //      reordering columns
                  element.internalReorder.currentlyReordering = false;
  
                  // unbind mousemove and mouseup
                  document.body.removeEventListener(
                      evt.mousemove,
                      element.internalEvents.columnReorderDragMove
                  );
                  document.body.removeEventListener(
                      evt.mouseup,
                      element.internalEvents.columnReorderDragEnd
                  );
              };
  
              // bind the same drag start to the record and column elements so
              //      that if either one is mousedown'ed on, the cell resize
              //      starts
              element.elems.dataViewport.addEventListener(
                  'mousedown',
                  element.internalEvents.columnReorderDragStart
              );
          }
      }
  
      // ############# UPDATE EVENTS #############
      function unbindUpdate(element) {
          element.removeEventListener(
              'change',
              element.internalEvents.cellUpdate
          );
  
          element.elems.dataViewport.removeEventListener(
              'click',
              element.internalEvents.updateDialog
          );
      }
      function bindUpdate(element) {
          element.internalEvents.cellUpdate = function (event) {
              var target;
              var columnElement;
              var cellElement;
              var newValue;
              var strColumn;
              var intRecord;
  
              // get event target and put it in a variable for clarity
              target = event.target;
  
              // we need the element (possibly a parent of "target") that has a
              //      "column" attribute so that we can get the name of the
              //      column that needs to be updated (if the "target" is the
              //      element with the "column" attribute: "findParentElement"
              //      will simply return the "target" as the result)
              columnElement = GS.findParentElement(target, '[column]');
  
              // we need the gs-cell parent so that we can verify that the change
              //      emanated from an updatable cell
              cellElement = GS.findParentElement(columnElement, 'gs-cell');
  
              // verify that this "columnElement" is an actual child of this
              //      gs-table and that it's an updatable cell and not an insert
              //      cell
              if (
                  GS.findParentElement(columnElement, 'gs-table') === element &&
                  cellElement.classList.contains('table-cell')
              ) {
                  // if we found a "column" element, we'll try to find a value and
                  //      then attempt an update call
                  if (columnElement) {
                      // if the "columnElement" has a "value" accessor we'll use
                      //      that to get the value
                      if (
                          columnElement.value !== null &&
                          columnElement.value !== undefined
                      ) {
                          newValue = columnElement.value;
  
                      // else if the "target" has a "value" accessor we'll use
                      //      that to get the value
                      } else if (
                          target.value !== null &&
                          target.value !== undefined
                      ) {
                          newValue = target.value;
  
                      // else if the "columnElement" has a "checked" accessor
                      //      we'll use that to get the value
                      } else if (
                          columnElement.checked !== null &&
                          columnElement.checked !== undefined
                      ) {
                          newValue = columnElement.checked;
  
                      // else if the "target" has a "checked" accessor we'll use
                      //      that to get the value
                      } else if (
                          target.checked !== null &&
                          target.checked !== undefined
                      ) {
                          newValue = target.checked;
  
                      // else: throw an error for the developer
                      } else {
                          throw 'GS-TABLE Error: Found an element with a ' +
                                  '"column" attribute, but could not find a ' +
                                  'value. Please make sure that when a ' +
                                  '"change" event is fired either the event ' +
                                  'target or the "column" element has a ' +
                                  '"value" or "checked" accessor.';
                      }
  
                      // get parent column name and record number and
                      //      store them in variables for clarity
                      strColumn = columnElement.getAttribute('column');
                      intRecord = parseInt(
                          cellElement.getAttribute('data-row-number'),
                          10
                      );
  
                      //console.log('strColumn:', strColumn);
                      //console.log('intRecord:', intRecord);
                      //console.log('newValue:', newValue);
  
                      // call the update function
                      dataUPDATE(element, 'single-cell', {
                          "data": {
                              "columnName": strColumn,
                              "recordNumber": intRecord,
                              "newValue": newValue
                          },
                          "updateConfirmed": true
                      });
                  }
              }
          };
  
          element.addEventListener(
              'change',
              element.internalEvents.cellUpdate
          );
  
          // sometimes, the user needs to be able to update multiple columns
          //      at once. or they just want to see the record in a more
          //      focused way, with more room. so, we open the update dialog
          //      when an update dialog button is clicked.
          element.internalEvents.updateDialog = function (event) {
              var target = event.target;
              var arrCol;
              var intRow;
              var strRow;
              var arrRow;
              var jsnRow;
              var i;
              var len;
              var strNullString;
              var templateFunc;
              var strHTML;
              var templateElement;
  
              if (target.classList.contains('table-multi-update-button')) {
                  // we want the null string to be configurable, so we'll read the
                  //      "null-string" attribute to get the null string
                  // if the "null-string" attribute is present, use the contents
                  //      or coalesce to empty string
                  if (element.hasAttribute('null-string')) {
                      strNullString = element.getAttribute('null-string') || '';
  
                  // else, null string is left up to the encoding function
                  } else {
                      strNullString = undefined;
                  }
  
                  // we need to know the column names
                  arrCol = element.internalData.columnNames;
  
                  // we need to get the record
                  intRow = parseInt(
                      target.parentNode.getAttribute('data-row-number'),
                      10
                  );
  
                  strRow = element.internalData.records[intRow];
  
                  // convert the record to our normal "row" and "arrRow"
                  // decode values in the column array and build up the json
                  arrRow = strRow.split('\t');
                  jsnRow = {};
                  i = 0;
                  len = arrCol.length;
                  while (i < len) {
                      arrRow[i] = (
                          GS.decodeFromTabDelimited(
                              arrRow[i],
                              strNullString
                          )
                      );
                      jsnRow[arrCol[i]] = arrRow[i];
  
                      i += 1;
                  }
  
                  //console.log('intRow:', intRow);
                  //console.log('strRow:', strRow);
                  //console.log('arrRow:', arrRow);
                  //console.log('jsnRow:', jsnRow);
  
                  // template the updateDialog with the record
                  templateFunc = doT.template(
                      '{{ ' +
                          'var row_number = jo.index + 1;' +
                          'var qs = jo.qs;' +
                          'var row = jo.row;' +
                          'var arrRow = jo.arrRow;' +
                          'var i = jo.index;' +
                          'var len = jo.len;' +
                      '}}' +
                      element.internalTemplates.updateDialog.templateHTML
                  );
  
                  // template with JSON
                  strHTML = templateFunc({
                      'qs': GS.qryToJSON(GS.getQueryString()),
                      'row': jsnRow,
                      'arrRow': arrRow,
                      'index': intRow,
                      'len': element.internalData.records.length
                  });
  
                  // because we prevent templating into other element's
                  //      templates (the ones with a "src" attribute) by
                  //      "hiding" (by replacing them with a random token
                  //      and storing the token-template relationship)
                  //      them, we have to "show" them (by replacing the
                  //      token with the original template strings) at
                  //      this step
                  strHTML = GS.templateShowSubTemplates(
                      strHTML,
                      element.internalTemplates.updateDialog
                  );
  
                  // generate dialog
                  templateElement = document.createElement('template');
  
                  templateElement.innerHTML = ml(function () {/*
  <gs-page>
      <gs-header>
          <center><h3>Update</h3></center>
      </gs-header>
      <gs-body padded>
          {{HTML}}
      </gs-body>
      <gs-footer>
          <gs-grid gutter>
              <gs-block>
                  <gs-button dialogclose>Cancel</gs-button>
              </gs-block>
              <gs-block>
                  <gs-button id="gs-table-update-record" bg-primary>
                      Save
                  </gs-button>
              </gs-block>
          </gs-grid>
      </gs-footer>
  </gs-page>
                  */}).replace(/\{\{HTML\}\}/gi, strHTML);
  
                  // open the dialog
                  GS.openDialog(templateElement, function () {
                      var dialog = this;
                      var saveButtonClick;
                      var afterUpdateFunc;
  
                      saveButtonClick = function () {
                          var arrElement;
                          var elem_i;
                          var elem_len;
                          var elem;
                          var arrColumns;
                          var arrValues;
                          var parentSRCElement;
                          var strOldValue;
                          var strNewValue;
  
                          // when the save button is clicked, we need to check
                          //      every field to find out what changes have been
                          //      made
                          arrElement = xtag.query(dialog, '[column]');
                          arrColumns = [];
                          arrValues = [];
                          elem_i = 0;
                          elem_len = arrElement.length;
                          while (elem_i < elem_len) {
                              elem = arrElement[elem_i];
  
                              parentSRCElement = GS.findParentElement(
                                  elem,
                                  '[src]'
                              );
  
                              if (
                                  !parentSRCElement ||
                                  parentSRCElement.nodeName === 'HTML' ||
                                  parentSRCElement.nodeName === 'BODY'
                              ) {
                                  strOldValue = jsnRow[
                                      elem.getAttribute('column')
                                  ];
                                  strNewValue = elem.value;
  
                                  if (strNewValue !== strOldValue) {
                                      arrColumns.push(
                                          elem.getAttribute('column')
                                      );
                                      arrValues.push(
                                          GS.encodeForTabDelimited(
                                              strNewValue,
                                              strNullString
                                          )
                                      );
                                  }
                              }
  
                              elem_i += 1;
                          }
  
                          if (arrColumns.length > 0) {
                              afterUpdateFunc = function () {
                                  GS.closeDialog(dialog, 'Ok');
                                  element.removeEventListener(
                                      'after_update',
                                      afterUpdateFunc
                                  );
                              };
  
                              element.addEventListener(
                                  'after_update',
                                  afterUpdateFunc
                              );
  
                              dataUPDATE(element, 'cell-range', {
                                  "data": {
                                      "columns": arrColumns,
                                      "records": [intRow],
                                      "values": [arrValues.join('\t')]
                                  },
                                  "updateConfirmed": false
                              });
                          }
                      };
  
                      document.getElementById('gs-table-update-record')
                              .addEventListener('click', saveButtonClick);
                  });
              }
          };
  
          element.elems.dataViewport.addEventListener(
              'click',
              element.internalEvents.updateDialog
          );
      }
  
      // ############# INSERT EVENTS #############
      function unbindInsert(element) {
          element.elems.dataViewport.removeEventListener(
              'keydown',
              element.internalEvents.insertRecordReturn
          );
          element.elems.dataViewport.removeEventListener(
              'change',
              element.internalEvents.insertRecordValueRetain
          );
          element.elems.dataViewport.removeEventListener(
              'keyup',
              element.internalEvents.insertRecordValueRetain
          );
      }
      function bindInsert(element) {
          // we only want to insert a new record if the user presses "return"
          element.internalEvents.insertRecordReturn = function (event) {
              var parentCell = GS.findParentTag(event.target, 'gs-cell');
              var keyCode = (event.keyCode || event.which);
  
              // we only want return to insert if the return occured inside
              //      an insert cell
              if (
                  parentCell.classList.contains('table-insert') &&
                  keyCode === 13
              ) {
                  dataINSERT(element, 'single-record', {
                      "data": {
                          "values": (
                              element
                                  .internalData
                                  .insertRecord
                          ),
                          "columns": (
                              element
                                  .internalData
                                  .insertRecordRetainedColumns
                          ),
                          "addin": getInsertAddin(element)
                      },
                      "insertConfirmed": true
                  });
  
                  // we clear the retained values and columns here because
                  //      if the user decides to override the insert with
                  //      their own thing, we don't want to still be showing
                  //      the old values.
                  element.internalData.insertRecord = {};
                  element.internalData.insertRecordRetainedColumns = [];
  
                  // re-render so that the insert controls clear out in the DOM
                  element.internalDisplay.fullRenderRequired = true;
                  renderLocation(element);
                  //element.goToLine('last');
              }
          };
  
          element.elems.dataViewport.addEventListener(
              'keydown',
              element.internalEvents.insertRecordReturn
          );
  
          // we want to be able to fill in some insert cells, scroll away,
          //      scroll back, and not lose the values that have been typed in
          // this event code saves the value of the target internally so that
          //      when we re-template the insert record on scroll, we can get
          //      the values back
          element.internalEvents.insertRecordValueRetain = function (event) {
              var target = event.target;
              var parentCell = GS.findParentTag(target, 'gs-cell');
              var parentColumn = GS.findParentElement(target, '[column]');
              var strColumn = parentColumn.getAttribute('column');
              var strValue = target.value;
  
              // we only want to retain the values of insert cells, so only do so
              //      if the parent cell has the insert cell class and has a
              //      [column=""] defined
              if (
                  parentCell.classList.contains('table-insert') &&
                  strColumn
              ) {
                  if (strValue) {
                      // retain the value in the internalData
                      element.internalData.insertRecord[strColumn] = strValue;
  
                      // some insert fields may be changed twice before an insert,
                      //      so only add the column name to the changed columns
                      //      list if that column name isn't already in the list
                      if (
                          element
                              .internalData
                              .insertRecordRetainedColumns
                              .indexOf(strColumn) === -1
                      ) {
                          element
                              .internalData
                              .insertRecordRetainedColumns
                              .push(strColumn);
                      }
                  // if the user clears out a field that was previously
                  //      retained, we want to remove that value from the
                  //      retained list
                  } else if (
                      !strValue &&
                      element
                          .internalData
                          .insertRecordRetainedColumns
                          .indexOf(strColumn) > -1
                  ) {
                      element
                          .internalData
                          .insertRecord[strColumn] = undefined;
                      element
                          .internalData
                          .insertRecordRetainedColumns
                          .splice(
                              element
                                  .internalData
                                  .insertRecordRetainedColumns
                                  .indexOf(strColumn)
                          );
                  }
              }
          };
  
          element.elems.dataViewport.addEventListener(
              'change',
              element.internalEvents.insertRecordValueRetain
          );
          element.elems.dataViewport.addEventListener(
              'keyup',
              element.internalEvents.insertRecordValueRetain
          );
      }
  
      // ############# HUD EVENTS #############
      function unbindHUD(element) {
  
      }
      function bindHUD(element) {
  
      }
  
      // ############# KEY EVENTS #############
      function unbindKey(element) {
          element.removeEventListener(
              'keydown',
              element.internalEvents.keyDown
          );
      }
      function bindKey(element) {
          element.internalEvents.keyDown = function (event) {
              var keyCode = (event.keyCode || event.which);
              var bolCMDorCTRL = (event.ctrlKey || event.metaKey);
              var bolShift = (event.shiftKey);
              var active = document.activeElement;
              var activeValue = document.activeElement.value;
  
              var jsnRange;
              var intOldRecord;
              var intOldColumn;
              var intNewRecord;
              var intNewColumn;
  
              var intMaxColumn;
              var intMaxRecord;
              var intMinColumn;
              var intMinRecord;
  
              var jsnCursorPos;
              var intCursorPos;
              var bolFullSelection;
              var bolCursorAtFirst;
              var bolCursorAtTop;
              var bolCursorAtLast;
              var bolCursorAtBottom;
  
              var bolMaintainSelection;
              var bolMoveSelectedToTop;
              var intSpaceToTraverse;
              var intHeight;
              var i;
              var len;
  
              var beforeEvent;
              var selectionCopy;
  
              // if the keydown took place inside the hidden focus control
              if (active === element.elems.hiddenFocusControl) {
                  if (
                      keyCode === 8 || // backspace
                      keyCode === 46   // forward delete
                  ) {
                      deleteSelectedRecords(element);
  
                  // if you hit return in the hidden focus control, select all
                  //      text inside the control that is the origin field of the
                  //      latest selection
                  } else if (keyCode === 13) {
                      focusIntoSelectedCell(element);
  
                  // if you hit CMD/CTRL-A, select all
                  } else if (bolCMDorCTRL && keyCode === 65) {
                      // we need functions to give the top-right and bottom-left
                      //      corners, this use case would be simplified and would
                      //      work no matter how musch data or header/selector and
                      //      would help fix a couple other unreliable areas in
                      //      this element
                      // ### NEED CODING ###
                      len = element.internalData.records.length;
                      element.internalSelection.ranges = [
                          {
                              "start": {
                                  "row": (
                                      element.internalDisplay.headerVisible
                                          ? 'header'
                                          : 0
                                  ),
                                  "column": (
                                      element.internalDisplay
                                          .recordSelectorVisible
                                              ? 'selector'
                                              : 0
                                  )
                              },
                              "end": {
                                  "row": (
                                      len > 0
                                          ? (len - 1)
                                          : 'header'
                                  ),
                                  "column": (
                                      element.internalDisplay
                                          .columnWidths.length - 1
                                  )
                              },
                              "negator": false
                          }
                      ];
                      renderSelection(element);
                  }
              }
  
              // these keys will be listened for if the focus is in a control or
              //      in the hidden focus control. all of these keys will be
              //      overridden no matter the target. if you have a control that
              //      uses one of these keys or key combos and you don't want the
              //      gs-table to intercept it: stop propagation and/or prevent
              //      default when you hear the event inside your element
              if (
                  (
                      keyCode === 38 ||
                      keyCode === 39 ||
                      keyCode === 40 ||
                      keyCode === 37 ||
                      keyCode === 33 ||
                      keyCode === 34 ||
                      keyCode === 36 ||
                      keyCode === 35 ||
                      keyCode === 9
                  ) &&
                  !event.defaultPrevented
              ) {
                  // if the focused element is an input or textarea, get the text
                  //      selection so that we can calculate if an arrow key
                  //      escapes the field
                  if (
                      (
                          active.nodeName === 'INPUT' ||
                          active.nodeName === 'TEXTAREA'
                      ) &&
                      active !== element.elems.hiddenFocusControl
                  ) {
                      jsnCursorPos = GS.getInputSelection(active);
  
                  // else, assume full selection. this can happen if the focused
                  //      field is (for example) a checkbox
                  } else {
                      jsnCursorPos = {
                          'start': 0,
                          'end': activeValue.length
                      };
                  }
  
                  // shortcut variable for wheather or not all the text is
                  //      selected
                  bolFullSelection = (
                      jsnCursorPos.start === 0 &&
                      jsnCursorPos.end === activeValue.length
                  );
  
                  // if we don't have a full selection and the selection is one
                  //      character position, create some shortcut variables so
                  //      that we know if the cursor is at a particular extreme.
                  if (
                      jsnCursorPos &&
                      !bolFullSelection &&
                      jsnCursorPos.start === jsnCursorPos.end
                  ) {
                      intCursorPos = jsnCursorPos.start;
                      bolCursorAtFirst = (
                          intCursorPos === 0
                      );
                      bolCursorAtTop = (
                          (
                              intCursorPos < (
                                  activeValue.indexOf('\n') === -1
                                      ? activeValue.length + 1
                                      : activeValue.indexOf('\n') + 1
                              )
                          ) ||
                          (
                              intCursorPos === 0
                          )
                      );
                      bolCursorAtLast = (
                          intCursorPos === activeValue.length
                      );
                      bolCursorAtBottom = (
                          intCursorPos > activeValue.lastIndexOf('\n')
                      );
                  }
  
                  // save the latest selection range's endpoint
                  jsnRange = element.internalSelection.ranges[
                      element.internalSelection.ranges.length - 1
                  ];
  
                  // if there is a selection range, save it's endpoint
                  if (jsnRange) {
                      intOldRecord = jsnRange.end.row;
                      intOldColumn = jsnRange.end.column;
  
                      if (intOldRecord === 'header') {
                          intOldRecord = -1;
                      } else if (intOldRecord === 'insert') {
                          intOldRecord = element.internalData.records.length;
                      }
  
                      if (intOldColumn === 'selector') {
                          intOldColumn = -1;
                      }
  
                  // else, assume the endpoint is the first cell
                  // this occurs when you tab into a gs-table that has no
                  //      focusable fields and press a navigation key
                  } else {
                      intOldRecord = 0;
                      intOldColumn = 0;
                  }
  
                  // determine max column and max record and save as a shortcut
                  intMaxColumn = (
                      // commented because the record selection is -1, not 0,
                      //      this means that the max column stays the same
                      //      regardless of record selectors or not.
                      //element.internalDisplay.recordSelectorVisible
                      //    ? element.internalDisplay.columnWidths.length
                      //    :
                      element.internalDisplay.columnWidths.length - 1
                  );
                  intMaxRecord = (
                      element.internalDisplay.insertRecordVisible
                          ? element.internalData.records.length
                          : element.internalData.records.length - 1
                  );
  
                  // determine min column and min record and save as a shortcut
                  intMinColumn = (
                      element.internalDisplay.recordSelectorVisible
                          ? -1
                          : 0
                  );
                  intMinRecord = (
                      element.internalDisplay.headerVisible
                          ? -1
                          : 0
                  );
  
                  // here we waterfall to determine the new selection row and
                  //      column. you can't arrow from records to insert record
                  //      except under a special case (no shift, no command,
                  //      arrow down from last record)
                  // -1 in intNewRecord means header record
                  // -1 in intNewColumn means record selector column
  
  
                  // "home" -- first cell of record
                  if (keyCode === 36) {
                      // after moving the selection into a single cell, the
                      //      text selection is overridden because of the
                      //      keyup event. so, here we preventDefault and
                      //      stopPropagation to prevent the keyup from
                      //      occuring.
                      event.preventDefault();
                      event.stopPropagation();
  
                      // go to first cell
                      intNewRecord = intOldRecord;
                      intNewColumn = intMinColumn;
  
                  // "end" -- last cell of record
                  } else if (keyCode === 35) {
                      // after moving the selection into a single cell, the
                      //      text selection is overridden because of the
                      //      keyup event. so, here we preventDefault and
                      //      stopPropagation to prevent the keyup from
                      //      occuring.
                      event.preventDefault();
                      event.stopPropagation();
  
                      intNewRecord = intOldRecord;
                      intNewColumn = intMaxColumn;
  
                  // "up arrow"
                  } else if (keyCode === 38) {
                      if (bolFullSelection || bolCursorAtTop) {
                          // after moving the selection into a single cell, the
                          //      text selection is overridden because of the
                          //      keyup event. so, here we preventDefault and
                          //      stopPropagation to prevent the keyup from
                          //      occuring.
                          event.preventDefault();
                          event.stopPropagation();
  
                          // if CMD or CTRL is held down: move to extreme
                          if (bolCMDorCTRL) {
                              intNewRecord = intMinRecord;
                              intNewColumn = intOldColumn;
  
                          // else, move to next immediate cell
                          } else if (intOldRecord > intMinRecord) {
                              intNewRecord = (intOldRecord - 1);
                              intNewColumn = intOldColumn;
                          }
                      }
  
                  // "right arrow"
                  } else if (keyCode === 39) {
                      if (bolFullSelection || bolCursorAtLast) {
                          // after moving the selection into a single cell, the
                          //      text selection is overridden because of the
                          //      keyup event. so, here we preventDefault and
                          //      stopPropagation to prevent the keyup from
                          //      occuring.
                          event.preventDefault();
                          event.stopPropagation();
  
                          // if CMD or CTRL is held down: move to extreme
                          if (bolCMDorCTRL) {
                              intNewRecord = intOldRecord;
                              intNewColumn = intMaxColumn;
  
                          // else if we are at the right-most cell of the record
                          //      and we are not at the bottom-most record:
                          //      move to next record, first cell
                          } else if (
                              intOldColumn === intMaxColumn &&
                              intOldRecord < intMaxRecord
                          ) {
                              intNewRecord = (intOldRecord + 1);
                              intNewColumn = intMinColumn;
  
                          // else, move to next immediate cell
                          } else if (intOldColumn < intMaxColumn) {
                              intNewRecord = intOldRecord;
                              intNewColumn = (intOldColumn + 1);
                          }
                      }
  
                  // "down arrow"
                  } else if (keyCode === 40) {
                      if (bolFullSelection || bolCursorAtBottom) {
                          // after moving the selection into a single cell, the
                          //      text selection is overridden because of the
                          //      keyup event. so, here we preventDefault and
                          //      stopPropagation to prevent the keyup from
                          //      occuring.
                          event.preventDefault();
                          event.stopPropagation();
  
                          // if CMD or CTRL is held down: move to extreme
                          if (bolCMDorCTRL) {
                              intNewRecord = intMaxRecord;
                              intNewColumn = intOldColumn;
  
                          // else, move to next immediate cell
                          } else if (intOldRecord < intMaxRecord) {
                              intNewRecord = (intOldRecord + 1);
                              intNewColumn = intOldColumn;
                          }
                      }
  
                  // "left arrow"
                  } else if (keyCode === 37) {
                      if (bolFullSelection || bolCursorAtFirst) {
                          // after moving the selection into a single cell, the
                          //      text selection is overridden because of the
                          //      keyup event. so, here we preventDefault and
                          //      stopPropagation to prevent the keyup from
                          //      occuring.
                          event.preventDefault();
                          event.stopPropagation();
  
                          // if CMD or CTRL is held down: move to extreme
                          if (bolCMDorCTRL) {
                              intNewRecord = intOldRecord;
                              intNewColumn = intMinColumn;
  
                          // else if we are at the left-most cell of the record
                          //      and we are not at the top-most record:
                          //      move to previous record, last cell
                          } else if (
                              intOldColumn === intMinColumn &&
                              intOldRecord > intMinRecord
                          ) {
                              intNewRecord = (intOldRecord - 1);
                              intNewColumn = intMaxColumn;
  
                          // else, move to next immediate cell
                          } else if (intOldColumn > intMinColumn) {
                              intNewRecord = intOldRecord;
                              intNewColumn = (intOldColumn - 1);
                          }
                      }
  
                  // "page up"
                  } else if (keyCode === 33) {
                      // after moving the selection into a single cell, the
                      //      text selection is overridden because of the
                      //      keyup event. so, here we preventDefault and
                      //      stopPropagation to prevent the keyup from
                      //      occuring.
                      event.preventDefault();
                      event.stopPropagation();
  
                      // move to a cell approx one page up
                      intSpaceToTraverse = (
                          element.elems.dataViewport.clientHeight - (
                              element.internalScrollOffsets.top +
                              element.internalScrollOffsets.bottom
                          )
                      );
                      i = (
                          element.internalDisplay.currentRange.fromRecord
                          //intOldRecord
                      );
                      while (i >= -1) {
                          intHeight = (
                              element.internalDisplay.recordHeights[i]
                          );
  
                          intSpaceToTraverse -= intHeight;
  
                          // if we've run into the header (of the first
                          //      record), select the highest we can
                          if (i === intMinRecord) {
                              intNewRecord = i;
                              break;
                          }
                          // if we've found a record a page up, select the
                          //      record that is partially hidden by scroll
                          if (intSpaceToTraverse < 0) {
                              intNewRecord = i;
                              break;
                          }
                          i -= 1;
                      }
  
                      // if we found a record: choose a column
                      if (intNewRecord !== undefined) {
                          // if shift is held down, maintain the old column
                          if (bolShift) {
                              intNewColumn = intOldColumn;
  
                          // else, select the whole record by choosing the
                          //      record selector (or select first cell)
                          } else {
                              intNewColumn = intMinColumn;
                          }
                      }
  
                      // we want page up/down to scroll the selected record to the
                      //      top of the viewport, so here we set a boolean
                      //      variable to tell the code below (which is where the
                      //      selection and scrolling happens) to scroll the
                      //      selected cell to the top
                      bolMoveSelectedToTop = true;
  
                  // "page down"
                  } else if (keyCode === 34) {
                      // after moving the selection into a single cell, the
                      //      text selection is overridden because of the
                      //      keyup event. so, here we preventDefault and
                      //      stopPropagation to prevent the keyup from
                      //      occuring.
                      event.preventDefault();
                      event.stopPropagation();
  
                      // move to a cell approx one page down
                      intSpaceToTraverse = (
                          element.elems.dataViewport.clientHeight - (
                              element.internalScrollOffsets.top +
                              element.internalScrollOffsets.bottom
                          )
                      );
  
                      i = (
                          element.internalDisplay.currentRange.fromRecord
                          //intOldRecord
                      );
                      len = (intMaxRecord + 1);
                      while (i < len) {
                          if (i === -1) {
                              intHeight = (
                                  element.internalDisplay.headerHeight
                              );
                          } else {
                              intHeight = (
                                  element.internalDisplay.recordHeights[i]
                              );
                          }
  
                          intSpaceToTraverse -= intHeight;
  
                          // if we've reached the bottom, select the last record
                          if (i === intMaxRecord) {
                              intNewRecord = i;
                              break;
                          }
                          // if we've found a record a page down, select the
                          //      record that is partially hidden by scroll
                          if (intSpaceToTraverse < 0) {
                              intNewRecord = i - 1;
                              break;
                          }
                          i += 1;
                      }
  
                      // if we found a record: choose a column
                      if (intNewRecord !== undefined) {
                          // if shift is held down, maintain the old column
                          if (bolShift) {
                              intNewColumn = intOldColumn;
  
                          // else, select the whole record by choosing the
                          //      record selector
                          } else {
                              intNewColumn = intMinColumn;
                          }
                      }
  
                      // we want page up/down to scroll the selected record to the
                      //      top of the viewport, so here we set a boolean
                      //      variable to tell the code below (which is where the
                      //      selection and scrolling happens) to scroll the
                      //      selected cell to the top
                      bolMoveSelectedToTop = true;
  
                  // "tab" next cell in reading order
                  } else if (keyCode === 9) {
                      // we need to be able to handle shift-tab because some users
                      //      know how to use shift-tab and would expect it from
                      //      any key-navigable interface
                      if (bolShift) {
                          // we need to be able to tab out of the gs-table if the
                          //      user presses tab while the first cell is the
                          //      selection anchor that we are moving from
                          // So, if the anchor point is at the first cell: do
                          //      nothing, this means that the event won't be
                          //      prevented and therefore will do what the browser
                          //      naturally want's it to do
                          // else, we want to move the selection to the previous
                          //      field in reading order
                          if (
                              intOldRecord !== intMinColumn ||
                              intOldColumn !== intMinRecord
                          ) {
                              // after moving the selection into a single cell,
                              //      the text selection is overridden because of
                              //      the keyup event. so, here we preventDefault
                              //      and stopPropagation to prevent the keyup
                              //      from occuring.
                              event.preventDefault();
                              event.stopPropagation();
  
                              // if we are at the min column:
                              //      go to the max column and the previous record
                              if (intOldColumn === intMinColumn) {
                                  intNewRecord = (intOldRecord - 1);
                                  intNewColumn = intMaxColumn;
  
                              // else, go to previous column
                              } else {
                                  intNewRecord = intOldRecord;
                                  intNewColumn = intOldColumn - 1;
                              }
                          }
  
                      // we need to handle standard tab as well
                      } else {
                          // we need to be able to tab out of the gs-table if the
                          //      user presses tab while the last cell is the
                          //      selection anchor that we are moving from
                          // So, if the anchor point is at the last cell: do
                          //      nothing, this means that the event won't be
                          //      prevented and therefore will do what the browser
                          //      naturally want's it to do
                          // else, we want to move the selection to the previous
                          //      field in reading order
                          if (
                              intOldRecord !== intMaxColumn ||
                              intOldColumn !== intMaxRecord
                          ) {
                              // after moving the selection into a single cell,
                              //      the text selection is overridden because of
                              //      the keyup event. so, here we preventDefault
                              //      and stopPropagation to prevent the keyup
                              //      from occuring.
                              event.preventDefault();
                              event.stopPropagation();
  
                              // if we are at the max column:
                              //      go to the min column and the next record
                              if (intOldColumn === intMaxColumn) {
                                  intNewRecord = (intOldRecord + 1);
                                  intNewColumn = intMinColumn;
  
                              // else, go to next column
                              } else {
                                  intNewRecord = intOldRecord;
                                  intNewColumn = intOldColumn + 1;
                              }
                          }
                      }
                  }
  
                  // if we found a place to put the selection anchor point
                  if (intNewRecord !== undefined && intNewColumn !== undefined) {
                      //console.log('intOldRecord:', intOldRecord);
                      //console.log('intOldColumn:', intOldColumn);
                      //console.log('intNewRecord:', intNewRecord);
                      //console.log('intNewColumn:', intNewColumn);
                      //console.log('intMinRecord:', intMinRecord);
                      //console.log('intMinColumn:', intMinColumn);
                      //console.log('intMaxRecord:', intMaxRecord);
                      //console.log('intMaxColumn:', intMaxColumn);
  
                      // we don't want to stay focused on the original control
                      focusHiddenControl(element);
  
                      // we're going to do multiple if statements that test if the
                      //      previous selections will be maintained, so here
                      //      we'll save a shortcut variable
                      bolMaintainSelection = (
                          // shift is down
                          bolShift &&
                          // there is an old selection
                          jsnRange &&
                          // the key wasn't tab
                          keyCode !== 9
                      );
  
                      // if the user cancels the selection, we need to be able
                      //      to go back to the previous selection. so, here
                      //      we save a backup
                      selectionCopy = getSelectionCopy(element);
  
                      // when the before_selection event is triggered, we want the
                      //      gs-table to have the current selection available.
                      //      so we'll make the changes to the selection and then
                      //      trigger before_selection.
  
                      // convert the new record and column to special values
                      //      (if needed)
                      var intHeaderIndex;
                      var intSelectorIndex;
                      var intInsertIndex;
                      var newRecord;
                      var newColumn;
  
                      intHeaderIndex = -1;
                      intSelectorIndex = -1;
                      intInsertIndex = (element.internalData.records.length);
  
                      if (intNewRecord === intHeaderIndex) {
                          newRecord = 'header';
                      } else if (intNewRecord === intInsertIndex) {
                          newRecord = 'insert';
                      } else {
                          newRecord = intNewRecord;
                      }
  
                      //console.log(
                      //    newRecord,
                      //    intNewRecord,
                      //    intHeaderIndex,
                      //    intInsertIndex
                      //);
  
                      if (intNewColumn === intSelectorIndex) {
                          newColumn = 'selector';
                      } else {
                          newColumn = intNewColumn;
                      }
  
                      // if we're going to maintain selections
                      if (bolMaintainSelection) {
                          // maintain old selections and modify the most
                          //      recent one's endpoint
                          jsnRange.end.row = newRecord;
                          jsnRange.end.column = newColumn;
  
                      // else, set selection to only that cell
                      } else {
                          jsnRange = {
                              "start": {
                                  "row": newRecord,
                                  "column": newColumn
                              },
                              "end": {
                                  "row": newRecord,
                                  "column": newColumn
                              },
                              "negator": false
                          };
                          element.internalSelection.ranges = [jsnRange];
                      }
  
                      // trigger a "before_selection" event so that the page has a
                      //      chance to cancel the selection
                      beforeEvent = GS.triggerEvent(element, 'before_selection');
  
                      // if the user prevents the default on the
                      //      "before_selection" event, revert selection ranges
                      //      to what they were before the latest selection
                      //      started (and revert wheather or not the selection
                      //      is in the insert record)
                      if (beforeEvent.defaultPrevented) {
                          element.internalSelection.ranges = (
                              selectionCopy.ranges
                          );
                          return;
                      }
  
                      // if the before_selection event wasn't cancelled, we run
                      //      this code below
  
                      // sometimes, the focus is lost. so, focus the
                      //      hiddenFocusControl so that we can always listen for
                      //      keypresses
                      focusHiddenControl(element);
  
                      // sometimes we want to move the selected endpoint to the
                      //      top of the viewport, if that's what we want, send
                      //      the 'top' mode into the scrollSelectionIntoView
                      //      function
                      if (bolMoveSelectedToTop) {
                          // scroll selection into view and re-render
                          scrollSelectionIntoView(element, 'top');
  
                      } else {
                          // scroll selection into view and re-render
                          scrollSelectionIntoView(element);
                      }
  
                      // if we're not going to maintain old selections (which
                      //      also means that only one cell will be selected)
                      //      and we're not selecting a header or record selector
                      if (
                          !bolMaintainSelection &&
                          intNewRecord > -1 &&
                          intNewColumn > -1
                      ) {
                          // we want the user to be able to start typing and fill
                          //      the cell, so focus into the cell and select all
                          //      text if possible
                          focusIntoSelectedCell(element);
                      }
  
                      // if the "before_selection" event is not prevented, we
                      //      trigger "after_selection" so that the page can run
                      //      code after a selection has been made
                      if (beforeEvent.defaultPrevented) {
                          GS.triggerEvent(element, 'after_selection');
                      }
                  }
              }
          };
  
          element.addEventListener(
              'keydown',
              element.internalEvents.keyDown
          );
      }
  
      // ############# COPY EVENTS #############
      function unbindCopy(element) {
          element.removeEventListener(
              'copy',
              element.internalEvents.copySelection
          );
      }
      function bindCopy(element) {
          element.internalEvents.copySelection = function (event) {
              var jsnCopyString;
              var focusedElement;
              var arrCopyType = (element.getAttribute('copy-types') || 'text,html').split(',');
              var i;
              var len;
              var beforeCopyEvent = GS.triggerEvent(element, 'before_copy', {
                  forceCopy: element.internalEvents.forceCopy
              });
              element.internalEvents.forceCopy = false;
  
              i = 0;
              len = arrCopyType.length;
              while (i < len) {
                  arrCopyType[i] = arrCopyType[i].toLowerCase();
                  i += 1;
              }
  
              if (beforeCopyEvent.defaultPrevented) {
                  event.preventDefault(event);
  
              } else {
                  // saving the currently focused element for easy/quick access
                  focusedElement = document.activeElement;
  
                  // if the focus is on the hidden focus control of if the text
                  //      selection of the currently focused element is not
                  //      selecting multiple characters
                  if (
                      focusedElement.classList.contains('hidden-focus-control') ||
                      focusedElement.selectionStart ===
                      focusedElement.selectionEnd
                  ) {
                      console.time('copy');
  
                      // because copying a large amount of data takes time, add a
                      //      loader to let the user know we're copying,
                      //      just in case
                      addLoader(element, 'copy-loader', 'Copying Data...');
  
                      // focus the hidden focus control and select all of it's
                      //      text so that Firefox will allow us to override
                      //      the clipboard
                      focusedElement = element.elems.hiddenFocusControl;
                      focusedElement.focus();
  
                      GS.setInputSelection(
                          focusedElement,
                          0,
                          focusedElement.value.length
                      );
  
                      // we want to override the text and HTML mime type
                      //      clipboards, so we get the copy text for both types
                      jsnCopyString = getCopyStrings(element);
                      // override clipboard (prevent event default if we are
                      //      successful)
                      if (arrCopyType.indexOf('text') > -1 &&
                          handleClipboardData(event, jsnCopyString.text, 'text')) {
                          event.preventDefault(event);
                      }
                      if (arrCopyType.indexOf('html') > -1 &&
                          handleClipboardData(event, jsnCopyString.html, 'html')) {
                          event.preventDefault(event);
                      }
  
                      // remove copying loader
                      removeLoader(element, 'copy-loader', 'Data Copied');
  
                      console.timeEnd('copy');
                  }
              }
          };
  
          element.addEventListener(
              'copy',
              element.internalEvents.copySelection
          );
      }
  
      // ############# PASTE EVENTS #############
      function unbindPaste(element) {
          element.removeEventListener(
              'paste',
              element.internalEvents.pasteSelection
          );
      }
      function bindPaste(element) {
          element.internalEvents.pasteSelection = function (event) {
              // we dont want to interfere with pasting inside a cell, so only
              //      use this paste event if the focused element is the
              //      hiddenFocusControl
              if (document.activeElement === element.elems.hiddenFocusControl) {
                  // prevent default so that the hiddenFocusControl's value
                  //      doesn't get overridden by the paste
                  event.preventDefault();
                  usePasteEvent(element, event);
              }
          };
  
          element.addEventListener(
              'paste',
              element.internalEvents.pasteSelection
          );
      }
  
      // ############# CUT EVENTS #############
      function unbindCut(element) {
          element.removeEventListener(
              'cut',
              element.internalEvents.cutSelection
          );
      }
      function bindCut(element) {
          element.internalEvents.cutSelection = function () {
              // we dont want to interfere with cutting inside a cell, so only
              //      use this cut event if the focused element is the
              //      hiddenFocusControl
              if (document.activeElement === element.elems.hiddenFocusControl) {
                  // prevent default so that the hiddenFocusControl's value
                  //      doesn't get overridden by the paste
                  event.preventDefault();
  
                  // let the user know that we don't support cut
                  addLoader(element, 'cut-warn', 'Cut is not supported');
                  removeLoader(element, 'cut-warn', 'Cut is not supported');
              }
          };
  
          element.addEventListener(
              'cut',
              element.internalEvents.cutSelection
          );
      }
  
      // ############# CONTEXTMENU EVENTS #############
      function unbindContextMenu(element) {
          element.elems.dataViewport.removeEventListener(
              'contextmenu',
              element.internalEvents.columnContextMenu
          );
      }
      function bindContextMenu(element) {
          element.internalEvents.columnContextMenu = function (event) {
              var target = event.target;
              var parentCell = GS.findParentTag(target, 'gs-cell');
  
              var templateElement;
              var strCellType;
              var bolRange;
              var arrDataColumns;
              var arrSelectedColumns;
              var bolFilterUnique;
              var bolFilterSelection;
              var bolColumnWidths;
              var bolHideAndShow;
              var bolSort;
  
              var intRecord;
              var intColumn;
              var strDataValue;
              var strControlValue;
              var strColumn;
              var columnElement;
              var focusElement;
              var jsnSelection;
              var strSelection;
  
              var i;
              var len;
              //var index;
              var strHTML;
  
              // there are multiple different contextmenus
              //      one for header cells
              //          column hide/show
              //          column sort
              //          unique list filter
              //      one for data cells
              //          column hide/show
              //          column sort
              //          selection filter
              //      one for calculated cells
              //          column hide/show
              //      one for insert cells
              //          column hide/show
              //          column sort
              //
              // overall, there are a few modules that we need to toggle
              //      unique list filter
              //      selection filter
              //      column hide/show
              //      column sort
              //
              // if your selection spans between the header and data:
              //      column hide/show
              //      column sort
              //
              // if your selection is a range containing data cells
              //      column hide/show
              //      column sort
              //
              // if your selection is a range with only calculated cells
              //      column hide/show
  
              // get parent gs-cell element
              parentCell = target;
              if (target.nodeName !== 'GS-CELL') {
                  parentCell = GS.findParentTag(target, 'gs-cell');
              }
  
              // if the right-clicked cell is a data cell, header
              //      cell or insert cell
              if (
                  parentCell &&
                  parentCell.nodeName === 'GS-CELL' &&
                  (
                      parentCell.classList.contains('table-cell') ||
                      parentCell.classList.contains('table-header') ||
                      parentCell.classList.contains('table-insert')
                  )
              ) {
                  // we need to find out what type of cell we right-clicked on
                  if (parentCell.classList.contains('table-cell')) {
                      strCellType = 'data';
  
                  } else if (parentCell.classList.contains('table-header')) {
                      strCellType = 'header';
  
                  } else if (parentCell.classList.contains('table-insert')) {
                      strCellType = 'insert';
                  }
  
                  // we need to know the selected column list
                  arrSelectedColumns = (
                      element.internalSelection.columns
                  );
                  if (arrSelectedColumns[0] === 'selector') {
                      arrSelectedColumns.shift();
                  }
  
                  // we need to know if more than one cell is selected
                  bolRange = (
                      arrSelectedColumns.length > 1 ||
                      element.internalSelection.rows.length > 1
                  );
  
                  // we need to know the data columns within the selected range
                  arrDataColumns = getSelectedDataColumns(element);
  
                  // if we have one data cell selected and it is associated
                  //      with a data column, we need to know the value of the
                  //      cell
                  if (
                      strCellType === 'data' &&
                      !bolRange &&
                      arrDataColumns.length === 1
                  ) {
                      // we need to know the record number
                      intRecord = parseInt(
                          parentCell.getAttribute('data-row-number'),
                          10
                      );
  
                      // we need to know what record we're working with
                      intColumn = parseInt(
                          parentCell.getAttribute('data-col-number'),
                          10
                      );
  
                      // now that we associate display columns and their data
                      //      columns, we can get the value even if there's no
                      //      columnElement, but we do need a column number
                      strColumn = (
                          element.internalDisplay.dataColumnName[intColumn]
                      );
  
                      // we need to extract the cell value from the data
                      strDataValue = getCell(
                          element,
                          strColumn,
                          intRecord,
                          // cell value should be decoded from tab delimited
                          true,
                          // we need to know if we're dealing with NULL
                          'gsTAbleINTERNALNULLSTRING'
                      );
  
                      // we wan't to get the text selection of current cell,
                      //      so we need the column element
                      columnElement = xtag.query(parentCell, '[column]')[0];
  
                      // we can't get the text selection if there's no column
                      //      element or there's no value
                      if (
                          columnElement &&
                          strDataValue !== 'gsTAbleINTERNALNULLSTRING'
                      ) {
                          // we need to get the input or textarea (if there
                          //      is one) that'll contain the text selection
                          // sometimes, the developer will use an input or
                          //      textarea element as the column element, in
                          //      that case the column element is the focus
                          //      element
                          if (
                              // if the column element is an input[type="text"]
                              (
                                  columnElement.nodeName === 'INPUT' &&
                                  columnElement.getAttribute('type') === 'text'
                              ) ||
                              // or if the column element is a textarea
                              columnElement.nodeName === 'TEXTAREA'
                          ) {
                              focusElement = columnElement;
  
                          // else, we need to search inside the column element
                          //      for the focus element
                          } else {
                              focusElement = xtag.query(
                                  columnElement,
                                  'input[type="text"], textarea'
                              )[0];
                          }
  
                          // if strValue matches columnElement's value, use
                          //      the text selection (if availible) of the
                          //      columnElement's control and substring the
                          //      strValue
                          if (
                              focusElement &&
                              focusElement.value === strDataValue
                          ) {
                              strControlValue = focusElement.value;
                              jsnSelection = GS.getInputSelection(focusElement);
  
                              strSelection = strControlValue.substring(
                                  jsnSelection.start,
                                  jsnSelection.end
                              );
  
                              //console.log('substring', strSelection);
                          }
                      }
                  }
  
                  // innocent until proven guilty
                  bolFilterUnique = true;
                  bolFilterSelection = true;
                  bolColumnWidths = true;
                  bolHideAndShow = true;
                  bolSort = true;
  
                  // no unique value filter list
                  if (
                      //// if the cell is not a header cell
                      //strCellType !== 'header' ||
                      //// or isn't the only column selected
                      //arrSelectedColumns.length !== 1 ||
                      //// or isn't a data column
                      //arrDataColumns.length !== 1
                      true // <-- filter unique is for the column dropdown
                  ) {
                      bolFilterUnique = false;
                  }
  
                  // no filter by selection
                  if (
                      // if the cell is not a data cell
                      strCellType !== 'data' ||
                      // or multiple cells are selected
                      bolRange ||
                      // or isn't the only column selected
                      arrSelectedColumns.length !== 1 ||
                      // or isn't a data column
                      arrDataColumns.length !== 1
                  ) {
                      bolFilterSelection = false;
                  }
  
                  // right now, we always want the option of column widths
                  if (false) {
                      bolColumnWidths = false;
                  }
  
                  // right now, we always want the option of show and hide
                  if (false) {
                      bolHideAndShow = false;
                  }
  
                  // if there are no data columns in the current selection, we
                  //      want no sorting options
                  if (arrDataColumns.length === 0) {
                      bolSort = false;
                  }
  
                  // helps to debug
                  //console.log('arrSelectedColumns: ', arrSelectedColumns);
                  //console.log('arrDataColumns: ', arrDataColumns);
                  //console.log('bolFilterUnique: ', bolFilterUnique);
                  //console.log('bolFilterSelection: ', bolFilterSelection);
                  //console.log('bolHideAndShow: ', bolHideAndShow);
                  //console.log('bolSort: ', bolSort);
  
                  // assemble the HTML
                  strHTML = '';
  
                  if (bolSort) {
                      strHTML += (
                          strHTML
                              ? '<hr />'
                              : ''
                      );
                      strHTML += (
                          '<div class="context-menu-header">Sorting:</div>' +
                          '<div class="context-menu-indent">' +
                          '    <gs-button dialogclose remove-bottom' +
                          '                iconleft icon="sort-alpha-asc"' +
                          '                class="button-sort-asc">' +
                          '        Sort A to Z' +
                          '    </gs-button>' +
                          '    <gs-button dialogclose remove-all' +
                          '                iconleft icon="sort-alpha-desc"' +
                          '                class="button-sort-desc">' +
                          '        Sort Z to A' +
                          '    </gs-button>' +
                          '    <gs-button dialogclose remove-top' +
                          '                iconleft icon="trash-o"' +
                          '                class="button-sort-clear">' +
                          '        Clear Sort' +
                          '    </gs-button>' +
                          '</div>'
                      );
                  }
  
                  if (bolHideAndShow) {
                      strHTML += (
                          strHTML
                              ? '<hr />'
                              : ''
                      );
                      strHTML += (
                          '<div class="context-menu-header">' +
                          'Hide/Unhide Columns:' +
                          '</div>' +
                          '<div class="context-menu-indent">' +
                          '    <gs-button dialogclose remove-bottom' +
                          '                iconleft icon="eye-slash"' +
                          '                class="button-column-hide">' +
                          '        Hide Column(s)' +
                          '    </gs-button>' +
                          '    <gs-button dialogclose remove-top' +
                          '                iconleft icon="eye"' +
                          '                class="button-column-unhide">' +
                          '        Unhide Columns' +
                          '    </gs-button>' +
                          '</div>'
                      );
                  }
  
                  // ### NEED CODING ###
                  if (bolColumnWidths) {
                      strHTML += (
                          strHTML
                              ? '<hr />'
                              : ''
                      );
                      strHTML += (
                          '<div class="context-menu-header">Column Width:</div>' +
                          '<div class="context-menu-indent">' +
                          '    <gs-button dialogclose remove-bottom' +
                          '                iconleft icon="text-width"' +
                          '                class="button-column-width">' +
                          '        Fit To Header' +
                          '    </gs-button>' +
                          '    <gs-button dialogclose remove-top' +
                          '                iconleft icon="text-width"' +
                          '                class="button-column-width">' +
                          '        Fit To Content' +
                          '    </gs-button>' +
                          '</div>'
                      );
                  }
  
                  if (bolFilterSelection) {
                      strHTML += (
                          strHTML
                              ? '<hr />'
                              : ''
                      );
                      strHTML += (
                          '<div class="context-menu-header">Filtering:</div>' +
                          '<div class="context-menu-indent">' +
                          '    <gs-button dialogclose remove-bottom' +
                          '                iconleft icon="filter"' +
                          '                class="button-filter-include">' +
                          '        Filter By Selection' +
                          '    </gs-button>' +
                          '    <gs-button dialogclose remove-all' +
                          '                iconleft icon="filter"' +
                          '                class="button-filter-exclude">' +
                          '        Filter Excluding Selection' +
                          '    </gs-button>' +
                          '    <gs-button dialogclose remove-all' +
                          '                iconleft icon="search"' +
                          '                class="button-filter-text">' +
                          '        Text Filters' +
                          '    </gs-button>' +
                          '    <gs-button dialogclose remove-all' +
                          '                iconleft icon="toggle-off"' +
                          '                class="button-filter-toggle">' +
                          '        Toggle Filters' +
                          '    </gs-button>' +
                          '    <gs-button dialogclose remove-top' +
                          '                iconleft icon="trash-o"' +
                          '                class="button-filter-clear">' +
                          '        Clear Filters' +
                          '    </gs-button>' +
                          '</div>'
                      );
                  }
  
                  // ### NEED CODING ###
                  if (bolFilterUnique) {
                      strHTML += (
                          strHTML
                              ? '<hr />'
                              : ''
                      );
                      strHTML += '<div class="gs-table-unique-value-list"></div>';
                  }
  
                  // create dialog template
                  templateElement = document.createElement('template');
                  templateElement.setAttribute('data-max-width', '15em');
                  templateElement.setAttribute('data-overlay-close', 'true');
                  templateElement.setAttribute('no-focus-lock', 'true');
                  templateElement.setAttribute('no-background', '');
                  templateElement.innerHTML = (
                      '<gs-page gs-dynamic class="gs-table-contextmenu">' +
                      '    <gs-body padded>' +
                      '        ' + strHTML +
                      '    </gs-body>' +
                      '</gs-page>'
                  );
  
                  // if we're going to open the dialog, we need to prevent
                  //      the OS contextmenu
                  event.preventDefault();
  
                  // we want the context menu to be placed at a particular
                  //      X/Y, so we'll stick a temporary element in to
                  //      position to
                  var jsnMousePos = GS.mousePosition(event);
                  var jsnElementPos = GS.getElementOffset(
                      element.elems.root
                  );
  
                  element.elems.pixel.style.left = (
                      (
                          (
                              jsnMousePos.left -
                              jsnElementPos.left
                          ) +
                          (
                              GS.emToPx(document.body, 15) /
                              2
                          )
                      ) +
                      'px'
                  );
                  element.elems.pixel.style.top = (
                      (
                          jsnMousePos.top -
                          jsnElementPos.top
                      ) +
                      'px'
                  );
                  element.elems.pixel.style.bottom = '';
                  element.elems.pixel.style.right = '';
                  // element.elems.dataViewport.appendChild(
                  //     element.elems.pixel
                  // );
  
                  // open dialog
                  GS.openDialogToElement(
                      element.elems.pixel,
                      templateElement,
                      'down',
                      function () {
                          var dialog = this;
                          var filterToggleButton;
                          var strStatus;
  
                          // we want the top gs-page to have corner rounding
                          dialog.classList.add('gs-table-contextmenu');
  
                          // we want the "toggle filter" button to reflect
                          //      the current status of the column filter
                          //      on/off
                          if (bolFilterSelection) {
                              filterToggleButton = xtag.query(
                                  dialog,
                                  '.button-filter-toggle'
                              )[0];
  
                              strStatus = (
                                  element.internalData
                                      .columnFilterStatuses[arrDataColumns[0]]
                              );
  
                              if (strStatus === 'on') {
                                  filterToggleButton.textContent = (
                                      'Toggle Filters Off'
                                  );
                                  filterToggleButton.setAttribute(
                                      'icon',
                                      'toggle-on'
                                  );
                              } else {
                                  filterToggleButton.textContent = (
                                      'Toggle Filters On'
                                  );
                                  filterToggleButton.setAttribute(
                                      'icon',
                                      'toggle-off'
                                  );
                              }
                          }
                      },
                      function (event, strAnswer) {
                          var dialog = this;
                          var targetElement;
                          var buttonElement;
  
                          var strWhere;
                          var strValue;
  
                          var strNewSort;
  
                          var col_i;
                          var col_len;
  
                          // when you close the dialog by clicking on the
                          //      overlay, there is no event.
                          if (event && event.target) {
                              targetElement = event.target;
                          }
  
                          // when you close the dialog by clicking on the
                          //      overlay, there is no target.
                          if (targetElement) {
                              // we may need to position a second dialog to a
                              //      button, so here we get the button that
                              //      was clicked.
                              if (targetElement.nodeName === 'GS-BUTTON') {
                                  buttonElement = targetElement;
                              } else {
                                  buttonElement = GS.findParentTag(
                                      targetElement,
                                      'gs-button'
                                  );
                              }
                          }
  
                          //console.log(event, buttonElement, targetElement);
  
                          // there's extra whitespace around the answer
                          strAnswer = strAnswer.trim();
  
                          //console.log(
                          //    parentCell,
                          //    buttonElement,
                          //    strAnswer,
                          //    arrDataColumns,
                          //    strColumn
                          //);
  
                          if (
                              strAnswer === 'Sort A to Z' ||
                              strAnswer === 'Sort Z to A' ||
                              strAnswer === 'Clear Sort'
                          ) {
                              if (strAnswer === 'Sort A to Z') {
                                  strNewSort = 'asc';
                              } else if (strAnswer === 'Sort Z to A') {
                                  strNewSort = 'desc';
                              } else if (strAnswer === 'Clear Sort') {
                                  strNewSort = 'neutral';
                              }
  
                              col_i = 0;
                              col_len = arrDataColumns.length;
                              while (col_i < col_len) {
                                  element.internalData.columnOrders[
                                      arrDataColumns[col_i]
                                  ] = strNewSort;
  
                                  col_i += 1;
                              }
  
                              dataSELECT(element);
  
                          } else if (strAnswer === 'Fit To Header') {
                              resizeColumnsToHeader(element, arrSelectedColumns);
  
                          } else if (strAnswer === 'Fit To Content') {
                              var colsToResize = [];
                              //console.log(arrSelectedColumns);
                              if (element.internalSelection.rows[0] ===
                                  'header'
                              ) {
                                  var jsnFirstRange = (
                                      element.internalSelection.ranges[0]
                                  );
                                  var intSelectionLength;
                                  if (
                                      jsnFirstRange &&
                                      jsnFirstRange.start.row === 'header'
                                  ) {
                                      intSelectionLength = (
                                          jsnFirstRange.end.column -
                                          jsnFirstRange.start.column + 1
                                      );
  
                                      i = 0;
                                      while (i < intSelectionLength) {
                                          colsToResize.push(
                                              i + jsnFirstRange.start.column
                                          );
  
                                          i += 1;
                                      }
                                  }
  
                              } else {
                                  //no headers selected: resize the column
                                  //  that was clicked
                                  colsToResize = arrSelectedColumns;
                              }
                              //console.log(colsToResize);
                              resizeColumnsToContent(element, arrSelectedColumns);
  
                          } else if (strAnswer === 'Hide Column(s)') {
                              i = 0;
                              len = arrSelectedColumns.length;
                              while (i < len) {
                                  // we don't want to hide the record selector
                                  if (arrSelectedColumns[i] >= 0) {
                                      // hide the column by making it zero
                                      //      width
                                      element.internalDisplay.columnWidths[
                                          arrSelectedColumns[i]
                                      ] = 0;
                                  }
  
                                  i += 1;
                              }
  
                              // partial re-render might not know how to
                              //      remove columns in the middle of the
                              //      viewport
                              element.internalDisplay.fullRenderRequired = true;
                              renderLocation(element);
  
                          } else if (strAnswer === 'Unhide Columns') {
                              openColumnHideDialog(
                                  element,
                                  buttonElement,
                                  // before dialog close callback
                                  function (strAnswer) {
                                      // if the unhide dialog wasn't cancelled,
                                      //      close the contextmenu
                                      if (strAnswer !== 'Cancel') {
                                          GS.closeDialog(dialog, 'Force');
                                      }
                                  }
                              );
                              event.preventDefault();
  
                          } else if (strAnswer === 'Filter By Selection') {
                              strValue = (strSelection || strDataValue);
  
                              // sometimes the user want's to filter for nulls
                              if (strValue === 'gsTAbleINTERNALNULLSTRING') {
                                  strWhere = (strColumn + ' IS NULL');
                              } else {
                                  strWhere = (
                                      'CAST(' +
                                          strColumn + ' AS ' +
                                          GS.database.type.text +
                                      ') = $$' + strValue + '$$'
                                  );
                              }
  
                              element.internalData
                                  .columnFilters[arrDataColumns[0]].push(
                                      {
                                          "text": strWhere,
                                          "name": 'equals "' + strValue + '"'
                                      }
                                  );
  
                              dataSELECT(element);
  
                          } else if (
                              strAnswer === 'Filter Excluding Selection'
                          ) {
                              strValue = (strSelection || strDataValue);
  
                              // sometimes the user want's to filter out nulls
                              if (strValue === 'gsTAbleINTERNALNULLSTRING') {
                                  strWhere = (strColumn + ' IS NOT NULL');
                              } else {
                                  strWhere = (
                                      'CAST(' +
                                          strColumn + ' AS ' +
                                          GS.database.type.text +
                                      ') != $$' + strValue + '$$'
                                  );
                              }
  
                              element.internalData
                                  .columnFilters[arrDataColumns[0]].push(
                                      {
                                          "text": strWhere,
                                          "name": "doesn't equal " +
                                                  "\"" + strValue + "\""
                                      }
                                  );
  
                              dataSELECT(element);
  
                          } else if (strAnswer === 'Text Filters') {
                              strValue = (strSelection || strDataValue);
  
                              element.internalEvents.textFilterContextMenu(
                                  buttonElement,
                                  arrDataColumns[0],
                                  strColumn,
                                  strValue,
                                  // before dialog close callback
                                  function (strAnswer) {
                                      // if the unhide dialog wasn't cancelled,
                                      //      close the contextmenu
                                      if (strAnswer !== 'Cancel') {
                                          GS.closeDialog(dialog, 'Force');
                                      }
                                  }
                              );
  
                              event.preventDefault();
  
                          } else if (strAnswer === 'Toggle Filters On') {
                              element.internalData.columnFilterStatuses[
                                  arrDataColumns[0]
                              ] = (
                                  'on'
                              );
  
                              dataSELECT(element);
  
                          } else if (strAnswer === 'Toggle Filters Off') {
                              element.internalData.columnFilterStatuses[
                                  arrDataColumns[0]
                              ] = (
                                  'off'
                              );
  
                              dataSELECT(element);
  
                          } else if (strAnswer === 'Clear Filters') {
                              element.internalData.columnFilters[
                                  arrDataColumns[0]
                              ] = [];
                              element.internalData.columnListFilters[
                                  arrDataColumns[0]
                              ] = {};
  
                              dataSELECT(element);
                          }
  
                          // we're done with the pixel element
                          // if (element.elems.pixel.parentNode ===
                          //      element.elems.dataViewport) {
                          //     element.elems.dataViewport.removeChild(
                          //         element.elems.pixel
                          //     );
                          // }
                      }
                  );
              }
          };
  
          element.internalEvents.textFilterContextMenu = function (
              buttonElement,
              columnIndex,
              strColumn,
              strValue,
              callback
          ) {
              var templateElement;
  
              // we want a function specifically for contextmenus,
              //      however, currently we dont have one so we'll
              //      use the GS.openDialogToElement function
              templateElement = document.createElement('template');
              templateElement.setAttribute('data-max-width', '17em');
              templateElement.setAttribute('no-background', '');
              templateElement.setAttribute('data-overlay-close', 'true');
              templateElement.innerHTML = ml(function () {/*
                  <gs-page gs-dynamic class="gs-table-contextmenu">
                      <gs-body padded>
                          <center>
                              <i>Check each filter you want to apply.</i><br />
                              <i>
                                  Matching values must pass every<br />
                                  filter you choose.
                              </i>
                          </center>
                          <table>
                              <tbody>
                                  <tr class="fltr-row fltr-eq">
                                      <td>
                                          <gs-checkbox remove-all mini>
                                              &nbsp;Equals</gs-checkbox>
                                      </td>
                                      <td><gs-text mini></gs-text></td>
                                  </tr>
                                  <tr class="fltr-row fltrn-eq">
                                      <td>
                                          <gs-checkbox remove-all mini>
                                              &nbsp;Doesn't Equal</gs-checkbox>
                                      </td>
                                      <td><gs-text mini></gs-text></td>
                                  </tr>
                                  <tr class="fltr-row fltr-contain">
                                      <td>
                                          <gs-checkbox remove-all mini>
                                              &nbsp;Contains</gs-checkbox>
                                      </td>
                                      <td><gs-text mini></gs-text></td>
                                  </tr>
                                  <tr class="fltr-row fltrn-contain">
                                      <td>
                                          <gs-checkbox remove-all mini>
                                              &nbsp;Doesn't Contain</gs-checkbox>
                                      </td>
                                      <td><gs-text mini></gs-text></td>
                                  </tr>
                                  <tr class="fltr-row fltr-starts">
                                      <td>
                                          <gs-checkbox remove-all mini>
                                              &nbsp;Starts With</gs-checkbox>
                                      </td>
                                      <td><gs-text mini></gs-text></td>
                                  </tr>
                                  <tr class="fltr-row fltr-ends">
                                      <td>
                                          <gs-checkbox remove-all mini>
                                              &nbsp;Ends With</gs-checkbox>
                                      </td>
                                      <td><gs-text mini></gs-text></td>
                                  </tr>
                              </tbody>
                          </table>
  
                          <!--
                          <gs-checkbox remove-bottom>
                              &nbsp;Equals
                          </gs-checkbox>
                          <gs-checkbox remove-all>
                              &nbsp;Doesn't Equal
                          </gs-checkbox>
                          <gs-checkbox remove-all>
                              &nbsp;Contains
                          </gs-checkbox>
                          <gs-checkbox remove-all>
                              &nbsp;Doesn't Contain
                          </gs-checkbox>
                          <gs-checkbox remove-all>
                              &nbsp;Starts With
                          </gs-checkbox>
                          <gs-checkbox remove-top>
                              &nbsp;Ends With
                          </gs-checkbox>
                          -->
                      </gs-body>
                      <gs-footer>
                          <gs-grid gutter>
                              <gs-block>
                                  <gs-button dialogclose>
                                      Cancel
                                  </gs-button>
                              </gs-block>
                              <gs-block>
                                  <gs-button dialogclose bg-primary>
                                      Apply
                                  </gs-button>
                              </gs-block>
                          </gs-grid>
                      </gs-footer>
                  </gs-page>
              */
              });
  
              GS.openDialogToElement(
                  buttonElement,
                  templateElement,
                  'right',
                  function () {
                      var dialog = this;
                      var arrElements;
                      var i;
                      var len;
  
                      // we want save the user a little time, so we'll pre-fill
                      //      the filter value text control
                      arrElements = xtag.query(dialog, '.fltr-row gs-text');
                      i = 0;
                      len = arrElements.length;
                      while (i < len) {
                          arrElements[i].value = strValue;
  
                          i += 1;
                      }
  
                      //fltr-row fltr-eq
                      //fltr-row fltr-not-eq
                      //fltr-row fltr-contain
                      //fltr-row fltr-not-contain
                      //fltr-row fltr-starts
                      //fltr-row fltr-ends
                  },
                  // event parameter ignored
                  function (ignore, strAnswer) {
                      var dialog = this;
                      var arrRows;
                      var rowClass;
                      var checkElement;
                      var valueElement;
                      var strWhere;
                      var strName;
                      var strWhereValue;
                      var i;
                      var len;
  
                      // there's extra whitespace around the answer
                      strAnswer = strAnswer.trim();
  
                      if (strAnswer === 'Apply') {
                          arrRows = xtag.query(dialog, '.fltr-row');
                          i = 0;
                          len = arrRows.length;
                          while (i < len) {
                              checkElement = (
                                  arrRows[i].children[0].children[0]
                              );
                              valueElement = (
                                  arrRows[i].children[1].children[0]
                              );
                              strWhereValue = valueElement.value;
  
                              // try to save some room in the code,
                              //      shortcut variable
                              rowClass = arrRows[i].classList;
  
                              strWhere = '';
                              if (checkElement.value === 'true') {
                                  if (rowClass.contains('fltr-eq')) {
                                      strWhere = 'CAST(' +
                                              strColumn + ' AS ' +
                                              GS.database.type.text +
                                              ') ' +
                                              '= $$' + strWhereValue + '$$';
                                      strName = 'equals "' + strWhereValue + '"';
  
                                  } else if (rowClass.contains('fltrn-eq')) {
                                      strWhere = 'CAST(' +
                                              strColumn + ' AS ' +
                                              GS.database.type.text +
                                              ') ' +
                                              '!= $$' + strWhereValue + '$$';
                                      strName = 'doesn\'t equal ' +
                                              '"' + strWhereValue + '"';
  
                                  } else if (rowClass.contains('fltr-contain')) {
                                      strWhere = 'CAST(' +
                                              strColumn + ' AS ' +
                                              GS.database.type.text +
                                              ') ' +
                                              'LIKE $$%' + strWhereValue + '%$$';
                                      strName = 'contains ' +
                                              '"' + strWhereValue + '"';
  
                                  } else if (rowClass.contains('fltrn-contain')) {
                                      strWhere = 'CAST(' +
                                              strColumn + ' AS ' +
                                              GS.database.type.text +
                                              ') ' +
                                              'NOT LIKE ' +
                                              '$$%' + strWhereValue + '%$$';
                                      strName = 'doesn\'t ' +
                                              '"' + strWhereValue + '"';
  
                                  } else if (rowClass.contains('fltr-starts')) {
                                      strWhere = 'CAST(' +
                                              strColumn + ' AS ' +
                                              GS.database.type.text +
                                              ') ' +
                                              'LIKE $$' + strWhereValue + '%$$';
                                      strName = 'starts with ' +
                                              '"' + strWhereValue + '"';
  
                                  } else if (rowClass.contains('fltr-ends')) {
                                      strWhere = 'CAST(' +
                                              strColumn + ' AS ' +
                                              GS.database.type.text +
                                              ') ' +
                                              'LIKE $$%' + strWhereValue + '$$';
                                      strName = 'ends ' +
                                              '"' + strWhereValue + '"';
                                  }
                              }
  
                              // if we create a where clause
                              if (strWhere) {
                                  element
                                      .internalData
                                      .columnFilters[columnIndex]
                                      .push(
                                          {"text": strWhere, "name": strName}
                                      );
                              }
  
                              i += 1;
                          }
  
                          dataSELECT(element);
                      }
  
                      if (callback) {
                          callback(strAnswer);
                      }
                  }
              );
          };
  
          element.internalEvents.advancedFilterContextMenu = function (
              //parentCell,
              //buttonElement,
              //strAnswer,
              //columnIndex,
              //strColumn,
              //strValue
          ) {
              // version 2
              // ### NEED CODING ### (VERSION 2)
          };
  
          element.elems.dataViewport.addEventListener(
              'contextmenu',
              element.internalEvents.columnContextMenu
          );
      }
  
      // ############# COLUMN DROPDOWN EVENTS #############
      function unbindColumnDropdown(element) {
          element.removeEventListener(
              'click',
              element.internalEvents.columnDropDown
          );
      }
      function bindColumnDropdown(element) {
          element.internalEvents.columnDropDown = function (event) {
              var target = event.target;
              var parentCell;
              var templateElement;
              var columnNumber;
              var strColumn;
              var columnIndex;
              var strHTML;
              var jsnMousePos;
              var jsnElementPos;
              var intMouseX;
              var intMouseY;
  
              if (target.classList.contains('header-button')) {
                  // we need the mouse position and the element position
                  jsnMousePos = GS.mousePosition(event);
                  jsnElementPos = GS.getElementOffset(
                      element.elems.root
                  );
  
                  // we need the mouse X to be relative to the root element
                  intMouseX = (jsnMousePos.left - jsnElementPos.left);
  
                  // we need the mouse Y to be relative to the root element
                  intMouseY = (jsnMousePos.top - jsnElementPos.top);
  
                  // move the pixel element to where the mouse is so that we can
                  //      position the dialog to it
                  element.elems.pixel.style.left = (intMouseX + 'px');
                  element.elems.pixel.style.top = (intMouseY + 'px');
  
                  // we need the parent cell to get the display column number
                  parentCell = GS.findParentTag(target, 'gs-cell');
  
                  // we need the display column number to get the data column name
                  columnNumber = (
                      parseInt(
                          parentCell.getAttribute('data-col-number'),
                          10
                      )
                  );
  
                  // we need to know what data column we're dealing with so that
                  //      we can get the data column index
                  strColumn = (
                      element.internalDisplay.dataColumnName[columnNumber]
                  );
  
                  // we need to know what data column index we're dealing with
                  //      so that we can apply the sorts and filters
                  columnIndex = (
                      element.internalData.columnNames.indexOf(strColumn)
                  );
  
                  // build up menu html
                  strHTML = '';
  
                  //
                  strHTML += (
                      '<gs-button dialogclose remove-bottom' +
                      '            iconleft icon="sort-alpha-asc"' +
                      '            class="button-sort-asc">' +
                      '    Sort A to Z' +
                      '</gs-button>'
                  );
  
                  strHTML += (
                      '<gs-button dialogclose remove-all' +
                      '            iconleft icon="sort-alpha-desc"' +
                      '            class="button-sort-desc">' +
                      '    Sort Z to A' +
                      '</gs-button>'
                  );
  
                  strHTML += (
                      '<gs-button dialogclose remove-top' +
                      '            iconleft icon="trash-o"' +
                      '            class="button-sort-clear">' +
                      '    Clear Sort' +
                      '</gs-button>'
                  );
  
                  strHTML += (
                      '<div class="gs-table-unique-filter-container" hidden>' +
                      '    <hr />' +
                      '    <small><i>Filter By Selection:</i></small>' +
                      '    <div class="gs-table-unique-value-list"></div>' +
                      '    <div class="gs-table-unique-value-list-toolbar">' +
                      (
                          '<gs-button dialogclose remove-right ' +
                                      'inline>Cancel</gs-button>' +
                          '<gs-button dialogclose remove-left ' +
                                      'inline bg-primary>Ok</gs-button>'
                      ) +
                      '    </div>' +
                      '</div>'
                  );
  
                  strHTML += '<hr />';
  
                  strHTML += (
                      '<gs-button dialogclose' +
                      '            iconleft icon="trash-o"' +
                      '            class="button-sort-clear">' +
                      '    Clear Filters' +
                      '</gs-button>'
                  );
  
                  templateElement = document.createElement('template');
                  templateElement.setAttribute('data-max-width', '17em');
                  templateElement.setAttribute('data-overlay-close', 'true');
                  templateElement.setAttribute('no-background', '');
                  templateElement.innerHTML = (
                      '<gs-page gs-dynamic class="gs-table-contextmenu">' +
                      '    <gs-body padded>' +
                      '        ' + strHTML +
                      '    </gs-body>' +
                      '</gs-page>'
                  );
  
                  // open the dialog
                  GS.openDialogToElement(
                      element.elems.pixel,
                      // element.elems.pixel replaced target.parentNode because
                      //      when the dataviewport rerendered, the element we
                      //      were positioning to disappeared. so, we'll use the
                      //      pixel because we can count on that.
                      templateElement,
                      'down',
                      function () {
                          var dialog = this;
  
                          var uniqueFilterElement = xtag.query(
                              dialog,
                              '.gs-table-unique-filter-container'
                          )[0];
                          var valueListElement = xtag.query(
                              dialog,
                              '.gs-table-unique-value-list'
                          )[0];
  
                          // we want users to be able to choose from a list
                          //      of unique values for the column they chose
                          if (
                              uniqueFilterElement &&
                              valueListElement
                          ) {
                              // we need to get the unique value list
                              dataSELECTcolumnUnique(
                                  element,
                                  uniqueFilterElement,
                                  valueListElement,
                                  strColumn
                              );
                          }
                      },
                      // event variable ignored
                      function (ignore, strAnswer) {
                          var dialog = this;
                          var tableElement;
                          var valueListElement = xtag.query(
                              dialog,
                              '.gs-table-unique-value-list'
                          )[0];
                          var arrRecords;
                          var arrIncluded;
                          var arrExcluded;
                          var strValue;
                          var bolBlanks;
                          var i;
                          var len;
  
                          // there is extra whitespace on the answer
                          strAnswer = strAnswer.trim();
  
                          // if there is a unique value filter list
                          tableElement = valueListElement.children[0];
                          if (
                              tableElement &&
                              tableElement.nodeName === 'GS-TABLE'
                          ) {
                              // if the user chose to commit their choices for
                              //      the table filter
                              if (strAnswer === 'Ok') {
                                  // if there are any checked/unchecked values, we
                                  //      need to save the changes
                                  // because the filter list can get long, we want
                                  //      to make sure we create the smallest
                                  //      where clause possible. to do this,
                                  //      if there are fewer checked items:
                                  //          column = checked items
                                  //      else (there are fewer unchecked items):
                                  //          column != unchecked items
                                  // chances are, the user will only include or
                                  //      exclude a small number of items, there
                                  //      could be a speed problem if the user
                                  //      goes and unchecks ~half of the items in
                                  //      a column with thousands of unique
                                  //      values. but if the user does that,
                                  //      there is something wrong with the
                                  //      user's workflow, give the poor person
                                  //      a search screen for cryin' out loud.
                                  arrRecords = tableElement.internalData.records;
                                  arrIncluded = [];
                                  arrExcluded = [];
                                  i = 1; // we want to skip over the "Select All"
                                         //      record
                                  len = arrRecords.length;
                                  while (i < len) {
                                      strValue = (
                                          arrRecords[i].substring(
                                              arrRecords[i]
                                                  .lastIndexOf('\t') + 1
                                          )
                                      );
  
                                      // we treat the blanks value different
                                      if (strValue === '(blanks)') {
                                          bolBlanks = (arrRecords[i][0] === '-');
  
                                      } else {
                                          // if this record is unchecked
                                          if (arrRecords[i][0] === '0') {
                                              arrExcluded.push(strValue);
  
                                          // else, this record is checked
                                          } else {
                                              arrIncluded.push(strValue);
                                          }
                                      }
  
                                      i += 1;
                                  }
  
                                  // default the column filter object to an empty
                                  //      state
                                  if (
                                      !element.internalData
                                          .columnListFilters[columnIndex]
                                  ) {
                                      element.internalData.columnListFilters[
                                          columnIndex
                                      ] = {};
                                  }
  
                                  // if inclusion would result in a smaller where
                                  if (arrIncluded.length < arrExcluded.length) {
                                      element.internalData.columnListFilters[
                                          columnIndex
                                      ].type = 'inclusion';
  
                                      element.internalData.columnListFilters[
                                          columnIndex
                                      ].values = (
                                          arrIncluded
                                      );
  
                                  // else, use exclusion where clause
                                  } else if (arrExcluded.length > 0) {
                                      element.internalData.columnListFilters[
                                          columnIndex
                                      ].type = 'exclusion';
  
                                      element.internalData.columnListFilters[
                                          columnIndex
                                      ].values = (
                                          arrExcluded
                                      );
                                  } else {
                                      element.internalData.columnListFilters[
                                          columnIndex
                                      ].type = 'exclusion';
  
                                      element.internalData.columnListFilters[
                                          columnIndex
                                      ].values = (
                                          []
                                      );
                                  }
  
                                  element.internalData
                                      .columnListFilters[columnIndex]
                                      .blanks = (bolBlanks || false);
  
                                  // we don't want to delay Garbage Collection,
                                  //      empty out the arrays and any unused
                                  //      data will become like so much digital
                                  //      nothingness.
                                  arrRecords = [];
                                  arrExcluded = [];
                                  arrIncluded = [];
  
                                  // get the new data
                                  dataSELECT(element);
                              }
  
                              // after this callback, the dialog is closed. this
                              //      causes a window resize event. we don't want
                              //      the window event from affecting the table
                              //      after it's been removed from the DOM. so,
                              //      we destroy the element before the gs-table
                              //      is removed.
                              tableElement.destroy();
                          }
  
                          // waterfall to commit changes
                          if (strAnswer === 'Sort A to Z') {
                              element.internalData
                                  .columnOrders[columnIndex] = 'asc';
                              dataSELECT(element);
  
                          } else if (strAnswer === 'Sort Z to A') {
                              element.internalData
                                  .columnOrders[columnIndex] = 'desc';
                              dataSELECT(element);
  
                          } else if (strAnswer === 'Clear Sort') {
                              element.internalData
                                  .columnOrders[columnIndex] = 'neutral';
                              dataSELECT(element);
  
                          } else if (strAnswer === 'Clear Filters') {
                              element.internalData
                                  .columnFilters[columnIndex] = [];
                              element.internalData
                                  .columnListFilters[columnIndex] = {};
                              dataSELECT(element);
                          }
                      }
                  );
              }
          };
  
          element.addEventListener(
              'click',
              element.internalEvents.columnDropDown
          );
      }
  
      // ############# DEVELOPER EVENTS #############
      function unbindDeveloper(element) {
          element.removeEventListener(
              evt.mousedown,
              element.internalEvents.developerMouseDown
          );
      }
      function bindDeveloper(element) {
          element.internalEvents.developerMouseDown = function (event) {
              var bolCMDorCTRL = (event.ctrlKey || event.metaKey);
              var bolShift = (event.shiftKey);
              var strHTML;
              var arrAttr;
              var jsnAttr;
              var i;
              var len;
  
              if (bolCMDorCTRL && bolShift) {
                  event.preventDefault();
                  event.stopPropagation();
  
                  strHTML = '';
                  arrAttr = element.attributes;
                  i = 0;
                  len = arrAttr.length;
                  while (i < len) {
                      jsnAttr = arrAttr[i];
  
                      strHTML += (
                          '<b>Attribute "' + encodeHTML(jsnAttr.name) + '":</b>' +
                          '<pre>' + encodeHTML(jsnAttr.value) + '</pre>'
                      );
  
                      i += 1;
                  }
  
                  GS.msgbox('Developer Info', strHTML, ['Ok']);
              }
          };
  
          element.addEventListener(
              evt.mousedown,
              element.internalEvents.developerMouseDown
          );
      }
  
      // ############# VISIBILITY POLLING #############
      function unbindVisibilityPolling(element) {
          clearInterval(element.internalTimerIDs.visibilityIntervalID);
      }
      function bindVisibilityPolling(element) {
          element.internalTimerIDs.visibilityIntervalID = setInterval(
              function () {
                  var jsnCache;
                  var intWidth;
                  var intHeight;
                  var intFontSize;
  
                  jsnCache = element.internalPollingCache;
                  intWidth = element.clientWidth;
                  intHeight = element.clientHeight;
                  intFontSize = element.elems.fontSizeDetector.clientWidth;
  
                  if (
                      jsnCache.elementWidth !== intWidth ||
                      jsnCache.elementHeight !== intHeight ||
                      jsnCache.fontSize !== intFontSize
                  ) {
                      //console.log('test');
                      renderScrollDimensions(element);
                      GS.triggerEvent(window, 'resize');
                  }
  
                  jsnCache.elementWidth = intWidth;
                  jsnCache.elementHeight = intHeight;
                  jsnCache.fontSize = intFontSize;
              },
              75
          );
      }
  
  
      // ############# HIGH LEVEL BINDING #############
      function unbindElement(element) {
          unbindFocus(element);
          unbindScroll(element);
          unbindSelection(element);
          unbindCellResize(element);
          unbindColumnReorder(element);
          unbindUpdate(element);
          unbindInsert(element);
          unbindKey(element);
          unbindHUD(element);
          unbindCopy(element);
          unbindPaste(element);
          unbindContextMenu(element);
          unbindColumnDropdown(element);
          unbindCut(element);
          unbindDeveloper(element);
          unbindVisibilityPolling(element);
      }
      function bindElement(element) {
          bindFocus(element);
          bindScroll(element);
          bindSelection(element);
          bindCellResize(element);
          bindColumnReorder(element);
          bindUpdate(element);
          bindInsert(element);
          bindKey(element);
          bindHUD(element);
          bindCopy(element);
          bindPaste(element);
          bindContextMenu(element);
          bindColumnDropdown(element);
          bindCut(element);
          bindDeveloper(element);
          bindVisibilityPolling(element);
      }
  
  // #############################################################################
  // ############################## XTAG DEFINITION ##############################
  // #############################################################################
  
      function elementInserted(element) {
          // if "created"/"inserted" are not suspended: run inserted code
          if (
              !element.hasAttribute('suspend-created') &&
              !element.hasAttribute('suspend-inserted')
          ) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
  
                  resolveElementAttributes(element);
                  prepareElement(element);
                  siphonElement(element);
                  renderHUD(element);
                  bindElement(element);
                  createWebWorker(element);
                  //dataSELECT(element);
                  GS.triggerEvent(element, 'initialized');
              }
          }
      }
  
      xtag.register('gs-table', {
  
  // #############################################################################
  // ############################# ELEMENT LIFECYCLE #############################
  // #############################################################################
  
          lifecycle: {
              'created': function () {},
  
              'inserted': function () {
                  elementInserted(this);
              },
  
              'removed': function () {
                  this.destroy();
              },
  
              'attributeChanged': function (strAttrName) {//, oldValue, newValue
                  var element = this;
  
                  // if suspend attribute: run inserted event
                  if (
                      strAttrName === 'suspend-created' ||
                      strAttrName === 'suspend-inserted'
                  ) {
                      elementInserted(element);
  
                  // if the element is not suspended: handle attribute changes
                  } else if (
                      !element.hasAttribute('suspend-created') &&
                      !element.hasAttribute('suspend-inserted')
                  ) {
                      if (strAttrName === 'value' && element.root) {
                          element.refresh();
                      }
                  }
              }
          },
  
  // #############################################################################
  // ############################# ELEMENT ACCESSORS #############################
  // #############################################################################
  
          accessors: {
              'selection': {
                  'get': function () {
                      return this.internalSelection.ranges;
                  }
              },
              'selectedColumns': {
                  'get': function () {
                      return this.internalSelection.columns;
                  }
              },
              'selectedRecords': {
                  'get': function () {
                      return this.internalSelection.rows;
                  }
              },
              'data': {
                  'get': function () {
                      return {
                          "columns": this.internalData.columnNames,
                          "types": this.internalData.columnTypes,
                          "records": this.internalData.records
                      };
                  }
              },
              'value': {
                  'get': function () {
                      return this.getAttribute('value');
                  },
                  'set': function (newValue) {
                      this.setAttribute('value', newValue);
                  }
              }
          },
  
  // #############################################################################
  // ############################## ELEMENT METHODS ##############################
  // #############################################################################
  
          methods: {
              'destroy': function () {
                  var element = this;
  
                  // sometimes, the gs-table gets destroyed multiple times.
                  //      we don't want to cause any errors when this happens.
                  if (element.elems.dataViewport) {
                      // prevent the element from recieving any events
                      unbindElement(element);
  
                      // destroy the web worker, if there is one
                      if (element.internalWorker.worker) {
                          element.internalWorker.worker.terminate();
                      }
  
                      // this is the fastest way to destroy all of the data
                      element.internalData = {};
                      element.internalScrollOffsets = {};
                      element.internalEvents = {};
                      element.internalEventCancelled = {};
                      element.internalScroll = {};
                      element.internalTimerIDs = {};
                      element.internalTemplates = {};
                      element.internalDisplay = {};
                      element.internalSelection = {};
                      element.internalClip = {};
                      element.internalWorker = {};
                      element.internalLoaders = {};
                      element.internalResize = {};
                      element.internalReorder = {};
  
                      // destroy element store
                      element.elems = {};
  
                      // empty innerHTML
                      element.innerHTML = '';
                  }
              },
              'refresh': function () {
                  dataSELECT(this);
              },
              'selectData': function () {
                  dataSELECT(this);
              },
              'insertData': function (jsnInsert) {
                  dataINSERT(this, jsnInsert);
              },
              'updateData': function (jsnUpdate) {
                  dataUPDATE(this, jsnUpdate);
              },
              'deleteData': function (jsnDeleteData) {
                  dataDELETE(this, jsnDeleteData);
              },
              'render': function () {
                  renderScrollDimensions(this);
              },
              'toggleFullContainer': function (container, target) {
                  var element = this;
                  var containerElement;
  
                  containerElement = document.getElementById(container);
  
                  if (element.classList.contains('absolute')) {
                      GS.triggerEvent(element, 'closeFullContainer');
                      element.classList.remove('absolute');
                      containerElement.classList.remove('relative');
                      target.setAttribute('icon', 'expand');
                  } else {
                      GS.triggerEvent(element, 'openFullContainer');
                      element.classList.add('absolute');
                      containerElement.classList.add('relative');
                      target.setAttribute('icon', 'compress');
                  }
  
                  renderScrollDimensions(element);
              },
              'openFullContainer': function (container, target) {
                  var element = this;
                  var containerElement;
  
                  containerElement = document.getElementById(container);
  
                  if (!element.classList.contains('absolute')) {
                      GS.triggerEvent(element, 'openFullContainer');
                      element.classList.add('absolute');
                      containerElement.classList.add('relative');
                      target.setAttribute('icon', 'compress');
                  }
  
                  renderScrollDimensions(element);
              },
              'closeFullContainer': function (container, target) {
                  var element = this;
                  var containerElement;
  
                  containerElement = document.getElementById(container);
  
                  if (element.classList.contains('absolute')) {
                      GS.triggerEvent(element, 'closeFullContainer');
                      element.classList.remove('absolute');
                      containerElement.classList.remove('relative');
                      target.setAttribute('icon', 'expand');
                  }
  
                  renderScrollDimensions(element);
              },
              //'scrollToColumn': function (columnNumber) {
              //},
              //'scrollToRow': function (rowNumber) {
              //},
              //'scrollToCell': function (rowNumber, columnNumber) {
              //},
              'deleteSelected': function () {
                  deleteSelectedRecords(this);
              },
              'clearFilter': function () {
                  var filter_i;
                  var filter_len;
  
                  filter_i = 0;
                  filter_len = this.internalData.columnFilters.length;
                  while (filter_i < filter_len) {
                      this.internalData.columnFilters[filter_i] = [];
                      this.internalData.columnListFilters[filter_i] = {};
  
                      filter_i += 1;
                  }
  
                  // refresh the table
                  dataSELECT(this);
              },
              'toggleFullscreen': function (target) {
                  var element = this;
  
                  // using a class like this doesn't work on iOS (other things
                  //      z-index over it), we need to move the element to the
                  //      last element in the body and then apply the class.
                  // ### NEED CODING ###
                  if (element.classList.contains('table-fullscreen')) {
                      GS.triggerEvent(element, 'closeFullScreen');
                      element.classList.remove('table-fullscreen');
  
                      if (target.getAttribute('icon') === 'close') {
                          target.setAttribute('icon', 'arrows-alt');
                      }
                  } else {
                      GS.triggerEvent(element, 'openFullscreen');
                      element.classList.add('table-fullscreen');
  
                      if (target.getAttribute('icon') === 'arrows-alt') {
                          target.setAttribute('icon', 'close');
                      }
                  }
                  renderScrollDimensions(element);
              },
              'openFullscreen': function (target) {
                  var element = this;
  
                  if (!element.classList.contains('table-fullscreen')) {
                      GS.triggerEvent(element, 'openFullscreen');
                      element.classList.add('table-fullscreen');
                      if (target.getAttribute('icon') === 'arrows-alt') {
                          target.setAttribute('icon', 'close');
                      }
                  }
                  renderScrollDimensions(element);
              },
              'closeFullscreen': function (target) {
                  var element = this;
  
                  if (element.classList.contains('table-fullscreen')) {
                      GS.triggerEvent(element, 'closeFullScreen');
                      element.classList.remove('table-fullscreen');
      
                      if (target.getAttribute('icon') === 'close') {
                          target.setAttribute('icon', 'arrows-alt');
                      }
                  }
                  renderScrollDimensions(element);
              },
              'openPrefs': function (target) {
                  openSettingsDialog(this, target);
              },
              'sort': function (action) {
                  var strNewSort;
                  if (action === 'asc') {
                      strNewSort = 'asc';
                  } else if (action === 'desc') {
                      strNewSort = 'desc';
                  } else if (action === 'clear') {
                      strNewSort = 'neutral';
                  } else {
                      strNewSort = 'neutral';
                  }
  
                  // we need the column orderby array
                  var arrColumnOrders = (
                      this.internalData.columnOrders
                  );
  
                  // loop through each selected data column and set the orderby
                  var arrDataColumns = getSelectedDataColumns(this);
                  var i = 0;
                  var len = arrDataColumns.length;
                  while (i < len) {
                      arrColumnOrders[
                          arrDataColumns[i]
                      ] = strNewSort;
  
                      i += 1;
                  }
  
                  // refresh the table
                  dataSELECT(this);
              },
              'openInsertDialog': function () {
                  openInsertDialog(this);
              },
              'goToLine': function (action) {
                  var intCurrentRecord = (
                      this.internalSelection.originRecord || 0
                  );
                  var intMaxRecord = (
                      this.internalData.records.length - 1
                  );
                  var intMinColumn = (
                      this.internalDisplay.recordSelectorVisible
                          ? -1
                          : 0
                  );
  
                  if (action === 'insert') {
                      scrollCellIntoView(this, 'insert', '0', 'top');
                  } else {
                      // set current record based on which button was clicked
                      if (action === 'first') {
                          intCurrentRecord = 0;
                      } else if (action === 'previous') {
                          intCurrentRecord -= 1;
                      } else if (action === 'next') {
                          intCurrentRecord += 1;
                      } else if (action === 'plusten') {
                          intCurrentRecord += 10;
                      } else if (action === 'minusten') {
                          intCurrentRecord -= 10;
                      } else if (action === 'last') {
                          intCurrentRecord = intMaxRecord;
                      } else if (typeof action === 'number') {
                          intCurrentRecord = action - 1;
                      } else {
                          intCurrentRecord = parseInt(action, 10) - 1;
                      }
  
                      //if the new record is past the last record:
                      //      go to last record
                      if (intCurrentRecord > intMaxRecord) {
                          intCurrentRecord = intMaxRecord;
                      }
  
                      // if the new record is a negative number:
                      //      go to first record
                      if (intCurrentRecord < 0) {
                          intCurrentRecord = 0;
                      }
  
                      // if there are no records, clear new record
                      if (intMaxRecord === -1) {
                          intCurrentRecord = undefined;
                      }
                      // override all current ranges to select the new record
                      if (intCurrentRecord !== undefined) {
                          this.internalSelection.ranges = [
                              {
                                  "start": {
                                      "row": intCurrentRecord,
                                      "column": intMinColumn
                                  },
                                  "end": {
                                      "row": intCurrentRecord,
                                      "column": intMinColumn
                                  },
                                  "negator": false
                              }
                          ];
                      } else {
                          this.internalSelection.ranges = [];
                      }
                      // render selection and scroll into view
                      renderSelection(this);
                      scrollSelectionIntoView(this, 'top');
                  }
              },
              'clearSelection': function () {
                  var element = this;
  
                  // empty selection array
                  element.internalSelection.ranges = [];
  
                  // re-render selection
                  renderSelection(element);
              },
              'addSelectionRange': function (
                  fromRow,
                  fromColumn,
                  toRow,
                  toColumn,
                  bolNegate
              ) {
                  var element = this;
  
                  // bolNegate must be true or false, default to false
                  if (
                      bolNegate === undefined ||
                      typeof bolNegate !== 'boolean'
                  ) {
                      bolNegate = false;
                  }
  
                  // create range JSON and append to selections
                  element.internalSelection.ranges.push({
                      "start": {
                          "row": fromRow,
                          "column": fromColumn
                      },
                      "end": {
                          "row": toRow,
                          "column": toColumn
                      },
                      "negator": false
                  });
  
                  // re-render selection
                  renderSelection(element);
              },
              'getCopyStrings': function () {
                  return getCopyStrings(this);
              },
              'paste': function (strPasteString) {
                  usePasteString(this, strPasteString);
              },
              'resizeAllColumns': function () {
                  var element = this;
                  var arrIndexes = [];
                  var i;
                  var len;
  
                  i = 0;
                  len = element.internalDisplay.columnPlainTextNames.length;
                  while (i < len) {
                      arrIndexes.push(i);
                      i += 1;
                  }
  
                  resizeColumnsToContent(element, arrIndexes);
              },
              'addFilter': function (filterColumn, filterType, filterValue) {
                  var element = this;
                  var columnIndex;
                  var strWhere;
                  var strName;
  
                  // filterType must be one of these values: (defaults to equals)
                  //      'contains', 'notcontains',
                  //      'starts', 'notstarts',
                  //      'ends', 'notends',
                  //      'equals', 'notequals',
                  //      'greaterthan', 'notgreaterthan',
                  //      'lessthan', 'notlessthan'
                  if (
                      !(/^(contains|starts|ends)$/gi).test(filterType) &&
                      !(/^(equals|greaterthan|lessthan)$/gi).test(filterType) &&
                      !(/^(notcontains|notstarts|notends)$/gi).test(filterType) &&
                      !(/^(notequals|notgreaterthan)$/gi).test(filterType) &&
                      !(/^(notlessthan)$/gi).test(filterType)
                  ) {
                      throw 'GS-TABLE Error: invalid filter type given to ' +
                              'ELEMENT.addFilter(filterColumn, filterType, ' +
                              'filterValue). Given filter type was ' +
                              '"' + filterType + '", must be "contains", ' +
                              '"starts", "ends", "equals", "greaterthan", ' +
                              '"lessthan", "notcontains", "notstarts", ' +
                              '"notends", "notequals", "notgreaterthan" ' +
                              'or "notlessthan".';
                  }
  
                  // we want to use the filterType in an if statement, let's
                  //      lowercase it to make comparisons easier
                  filterType = filterType.toLowerCase();
  
                  // filterValue must not be empty: error if nothing provided
                  if (filterValue === undefined) {
                      throw 'GS-TABLE Error: no filter value given to ' +
                              'ELEMENT.addFilter(filterColumn, filterType, ' +
                              'filterValue)';
                  }
  
                  // if value provided: cast to JS string to prevent type issues
                  filterValue = filterValue.toString();
  
                  // equals (TEXT)
                  if (filterType === 'equals') {
                      strWhere = 'CAST(' +
                              filterColumn + ' AS ' +
                              GS.database.type.text +
                              ') ' +
                              '= $$' + filterValue + '$$';
                      strName = 'equals' +
                              ' "' + filterValue + '"';
  
                  // not equals (TEXT)
                  } else if (filterType === 'notequals') {
                      strWhere = 'CAST(' +
                              filterColumn + ' AS ' +
                              GS.database.type.text +
                              ') ' +
                              '!= $$' + filterValue + '$$';
                      strName = 'doesn\'t equal' +
                              ' "' + filterValue + '"';
  
                  // contains (TEXT)
                  } else if (filterType === 'contains') {
                      strWhere = 'CAST(' +
                              filterColumn + ' AS ' +
                              GS.database.type.text +
                              ') ' +
                              'LIKE $$%' + filterValue + '%$$';
                      strName = 'contains' +
                              ' "' + filterValue + '"';
  
                  // doesn't contain (TEXT)
                  } else if (filterType === 'notcontains') {
                      strWhere = 'CAST(' +
                              filterColumn + ' AS ' +
                              GS.database.type.text +
                              ') ' +
                              'NOT LIKE ' +
                              '$$%' + filterValue + '%$$';
                      strName = 'doesn\'t contain' +
                              ' "' + filterValue + '"';
  
                  // starts with (TEXT)
                  } else if (filterType === 'starts') {
                      strWhere = 'CAST(' +
                              filterColumn + ' AS ' +
                              GS.database.type.text +
                              ') ' +
                              'LIKE $$' + filterValue + '%$$';
                      strName = 'starts with' +
                              ' "' + filterValue + '"';
  
                  // doesn't start with (TEXT)
                  } else if (filterType === 'notstarts') {
                      strWhere = 'CAST(' +
                              filterColumn + ' AS ' +
                              GS.database.type.text +
                              ') ' +
                              'NOT LIKE $$' + filterValue + '%$$';
                      strName = '' +
                              ' "' + filterValue + '"';
  
                  // ends with (TEXT)
                  } else if (filterType === 'ends') {
                      strWhere = 'CAST(' +
                              filterColumn + ' AS ' +
                              GS.database.type.text +
                              ') ' +
                              'LIKE $$%' + filterValue + '$$';
                      strName = 'ends with' +
                              ' "' + filterValue + '"';
  
                  // doesn't end with (TEXT)
                  } else if (filterType === 'notends') {
                      strWhere = 'CAST(' +
                              filterColumn + ' AS ' +
                              GS.database.type.text +
                              ') ' +
                              'NOT LIKE $$%' + filterValue + '$$';
                      strName = 'doesn\'t end with' +
                              ' "' + filterValue + '"';
  
                  // greaterthan (INTEGER/NUMERIC)
                  } else if (filterType === 'greaterthan') {
                      strWhere = (
                          filterColumn + ' > ' + filterValue
                      );
                      strName = 'greater than' +
                              ' "' + filterValue + '"';
  
                  // not greaterthan (INTEGER/NUMERIC)
                  } else if (filterType === 'notgreaterthan') {
                      strWhere = (
                          filterColumn + ' <= ' + filterValue
                      );
                      strName = 'not greater than' +
                              ' "' + filterValue + '"';
  
                  // lessthan (INTEGER/NUMERIC)
                  } else if (filterType === 'lessthan') {
                      strWhere = (
                          filterColumn + ' < ' + filterValue
                      );
                      strName = 'less than' +
                              ' "' + filterValue + '"';
  
                  // not lessthan (INTEGER/NUMERIC)
                  } else if (filterType === 'notlessthan') {
                      strWhere = (
                          filterColumn + ' >= ' + filterValue
                      );
                      strName = 'not less than' +
                              ' "' + filterValue + '"';
                  }
  
                  // turn the updated column name into a column index so that
                  //      we can fetch the old data from the data
                  columnIndex = (
                      element.internalData.columnNames.indexOf(filterColumn)
                  );
  
                  // if we were able to create a where, push it to the filter
                  //      list
                  if (strWhere) {
                      element.internalData
                          .columnFilters[columnIndex].push(
                              {
                                  "text": strWhere,
                                  "name": strName
                              }
                          );
  
                      // master, why didn't you refresh the table after a where
                      //      was created?
                      // young grasshopper, you must think of the developer who
                      //      will use this table, what if he were to add three
                      //      filters, one right after the other? in order to
                      //      prevent speed issues we must make him refresh the
                      //      table.
  
                  // else, warn about invalid where
                  } else {
                      console.warn('GS-TABLE Warning: Unable to create where' +
                              'clause.\n' +
                              'Here are the parameters that failed:\n' +
                              '\tfilterColumn:   "' + filterColumn + '"\n' +
                              '\tfilterType:     "' + filterType + '"\n' +
                              '\tfilterValue:    "' + filterValue + '"');
                  }
              }
          }
      });
  });
  //global GS, window, document, registerDesignSnippet, designRegisterElement, addProp, encodeHTML, setOrRemoveTextAttribute, setOrRemoveBooleanAttribute, addFlexProps
  
  window.addEventListener('design-register-element', function () {
  
      registerDesignSnippet('<gs-text>', '<gs-text>', 'gs-text column="${1:name}"></gs-text>');
      registerDesignSnippet('<gs-text> With Label', '<gs-text>',
              'label for="${1:text-insert-last_name}">${2:Last Name}:</label>\n' +
              '<gs-text id="${1:text-insert-last_name}" column="${3:last_name}"></gs-text>');
  
      designRegisterElement('gs-text', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-text.html');
  
      window.designElementProperty_GSTEXT = function (selectedElement) {
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
  
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
  
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
  
          addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
          });
  
          //console.log(selectedElement.hasAttribute('mini'));
  
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
  
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // TABINDEX attribute
          addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
          });
  
          addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
          });
  
          addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
          });
  
          addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
          });
  
          addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
          });
  
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility', true,
                  '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                  '    <option value="">Visible</option>' +
                  '    <option value="hidden">Invisible</option>' +
                  '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                  '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                  '    <option value="hide-on-phone">Invisible at phone size</option>' +
                  '    <option value="show-on-desktop">Visible at desktop size</option>' +
                  '    <option value="show-on-tablet">Visible at tablet size</option>' +
                  '    <option value="show-on-phone">Visible at phone size</option>' +
                  '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
  
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
  
              return selectedElement;
          });
  
          // DISABLED attribute
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
          
          addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
          });
  
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
  
      // re-target change event from control to element
      function changeFunction(event) {
          event.preventDefault();
          event.stopPropagation();
          event.stopImmediatePropagation();
  
          event.target.parentNode.syncGetters();//iphone sometimes doesn't do a key like with time wheels
  
          GS.triggerEvent(event.target.parentNode, 'change');
  
          return false;
      }
  
      // re-target focus event from control to element
      function focusFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'focus');
          event.target.parentNode.classList.add('focus');
      }
  
      // re-target blur event from control to element
      function blurFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'blur');
          event.target.parentNode.classList.remove('focus');
      }
  
      // mouseout, remove hover class
      function mouseoutFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseout);
          event.target.parentNode.classList.remove('hover');
      }
  
      // mouseover, add hover class
      function mouseoverFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseover);
          event.target.parentNode.classList.add('hover');
      }
  
      //function createPushReplacePopHandler(element) {
      //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
  
      //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.value = GS.qryGetVal(strQueryString, strQSCol);
      //    }
      //}
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          arrAttr = element.attributes;
          i = 0;
          len = arrAttr.length;
          while (i < len) {
              jsnAttr = arrAttr[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function createPushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  if (strQSValue !== '' || !element.getAttribute('value')) {
                      element.value = strQSValue;
                  }
              } else {
                  element.value = strQSValue;
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
  
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              // if the value was set before the "created" lifecycle code runs: set attribute
              //      (discovered when trying to set a value of a date control in the after_open of a dialog)
              //      ("delete" keyword added because of firefox)
              if (element.value) {
                  element.setAttribute('value', element.value);
                  delete element.value;
                  //element.value = null;
              }
          }
      }
  
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
  
                  //var strQSValue;
  
                  // handle control
                  element.handleContents();
  
                  // fill control
                  element.syncView();
  
                  // bind/handle query string
                  if (element.getAttribute('qs')) {
                      //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
  
                      //if (strQSValue !== '' || !element.getAttribute('value')) {
                      //    element.value = strQSValue;
                      //}
                      createPushReplacePopHandler(element);
                      window.addEventListener('pushstate', function () {
                          createPushReplacePopHandler(element);
                      });
                      window.addEventListener('replacestate', function () {
                          createPushReplacePopHandler(element);
                      });
                      window.addEventListener('popstate', function () {
                          createPushReplacePopHandler(element);
                      });
                  }
  
                  // if this element is empty when it is inserted: initalize
                  if (element.innerHTML.trim() === '') {
                      // handle control
                      element.handleContents();
  
                      // fill control
                      element.syncView();
                  }
              }
          }
      }
  
      xtag.register('gs-text', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
  
              inserted: function () {
                  elementInserted(this);
              },
  
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  var element = this;
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(element);
                      elementInserted(element);
  
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(element);
  
                  } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                      var currentValue;
  
                      if (strAttrName === 'disabled' || strAttrName === 'readonly') {
                          // handle control
                          element.handleContents();
  
                          // fill control
                          element.syncView();
  
                      } else if (strAttrName === 'value' && element.initalized) {
                          //if (element.hasAttribute('disabled')) {
                          //    currentValue = element.innerHTML;
                          //} else {
                              currentValue = element.control.value;
                          //}
  
                          // if there is a difference between the new value in the
                          //      attribute and the valued in the front end: refresh the front end
                          if (newValue !== currentValue) {
                              element.syncView();
                          }
                      }
                  }
              }
          },
          events: {
              // on keydown and keyup sync the value attribute and the control value
              'keydown': function (event) {
                  var element = this;
                  if (!element.hasAttribute('readonly') && !element.hasAttribute('disabled')) {
                      //if (element.hasAttribute('disabled') && event.keyCode !== 9) {
                      //    event.preventDefault();
                      //    event.stopPropagation();
                      //} else {
                          element.syncGetters();
                      //}
                  }
              },
              'keyup': function () {
                  var element = this;
                  if (!element.hasAttribute('readonly') && !element.hasAttribute('disabled')) {
                      element.syncGetters();
                  }
              }
          },
          accessors: {
              value: {
                  // get value straight from the input
                  get: function () {
                      return this.getAttribute('value');
                  },
  
                  // set the value of the input and set the value attribute
                  set: function (strNewValue) {
                      this.setAttribute('value', strNewValue);
                  }
              }
          },
          methods: {
              focus: function () {
                  var element = this;
                  if (element.control) {
                      element.control.focus();
                  }
              },
  
              handleContents: function () {
                  var element = this;
                  var arrPassThroughAttributes = [
                          'placeholder', 'name', 'maxlength', 'autocorrect',
                          'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                          'readonly', 'disabled'
                      ];
                  var i;
                  var len;
  
                  // if the gs-text element has a tabindex: save the tabindex and remove the attribute
                  if (element.hasAttribute('tabindex')) {
                      element.savedTabIndex = element.getAttribute('tabindex');
                      element.removeAttribute('tabindex');
                  }
  
                  // if the gs-text doesn't have a disabled attribute: use an input element
                  // if (!element.hasAttribute('disabled')) {
                      // add control input and save it to a variable for later use
                      element.innerHTML = '<input class="control" gs-dynamic type="' + (element.getAttribute('type') || 'text') + '" />';
                      element.control = element.children[0];
  
                      // bind event re-targeting functions
                      element.control.removeEventListener('change', changeFunction);
                      element.control.addEventListener('change', changeFunction);
  
                      element.control.removeEventListener('focus', focusFunction);
                      element.control.addEventListener('focus', focusFunction);
  
                      element.control.removeEventListener('blur', blurFunction);
                      element.control.addEventListener('blur', blurFunction);
  
                      element.control.removeEventListener(evt.mouseout, mouseoutFunction);
                      element.control.addEventListener(evt.mouseout, mouseoutFunction);
                      
                      element.control.removeEventListener(evt.mouseout, mouseoverFunction);
                      element.control.addEventListener(evt.mouseover, mouseoverFunction);
                      
                      // copy passthrough attributes to control
                      i = 0;
                      len = arrPassThroughAttributes.length;
                      while (i < len) {
                          if (element.hasAttribute(arrPassThroughAttributes[i])) {
                              if (arrPassThroughAttributes[i] === 'disabled') {
                                  element.control.setAttribute(
                                      'readonly',
                                      element.getAttribute(arrPassThroughAttributes[i]) || ''
                                  );
                              } else {
                                  element.control.setAttribute(
                                      arrPassThroughAttributes[i],
                                      element.getAttribute(arrPassThroughAttributes[i]) || ''
                                  );
                              }
                          }
                          i += 1;
                      }
  
                      // if we saved a tabindex: apply the tabindex to the control
                      if (element.savedTabIndex !== undefined && element.savedTabIndex !== null) {
                          element.control.setAttribute('tabindex', element.savedTabIndex);
                      }
  
                  // else if the gs-text is disabled: clear the control variable and empty the gs-text
                  // } else {
                  //     element.control = undefined;
                  //     element.innerHTML = '';
                  // }
              },
  
              syncView: function () {
                  var element = this;
                  //if (element.hasAttribute('disabled')) {
                  //    element.textContent = element.getAttribute('value') || element.getAttribute('placeholder');
                  //} else {
                      element.control.value = element.getAttribute('value') || '';
                  //}
                  element.initalized = true;
              },
  
              syncGetters: function () {
                  this.setAttribute('value', this.control.value);
              }
          }
      });
  });window.addEventListener('design-register-element', function () {
  
      registerDesignSnippet('<gs-time>', '<gs-time>', 'gs-time column="${1:name}"></gs-time>');
      registerDesignSnippet('<gs-time> With Label', '<gs-time>', 'label for="${1:time-insert-start_time}">${2:Start Time}:</label>\n' +
                                                                 '<gs-time id="${1:time-insert-start_time}" column="${3:start_time}"></gs-time>');
  
      designRegisterElement('gs-time', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-time.html');
  
      window.designElementProperty_GSTIME = function(selectedElement) {
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
  
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
  
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
  
          addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
          });
  
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
  
          addProp('Time Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-picker')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-picker', (this.value === 'true'), false);
          });
  
          addProp('Non-Empty', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('non-empty')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'non-empty', (this.value === 'true'), true);
          });
  
          addProp('Now Button', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-now-button')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-now-button', (this.value === 'true'), false);
          });
  
          addProp('Display Format', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('format') || '') + '" mini>' +
                                      '<option value="">Regular (1:30 PM)</option>' +
                                      '<option value="military">Military (13:30)</option>' +
                                  '</gs-select>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'format', this.value);
          });
  
          addProp('Output Format', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('output-format') || '') + '" mini>' +
                                      '<option value="">Regular (1:30 PM)</option>' +
                                      '<option value="military">Military (13:30)</option>' +
                                  '</gs-select>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'output-format', this.value);
          });
  
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // TABINDEX attribute
          addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
          });
  
          addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
          });
  
          addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
          });
  
          addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
          });
  
          addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
  
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
  
              return selectedElement;
          });
  
          // DISABLED attribute
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
  
          // READONLY attribute
          addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
          });
  
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
  
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      var currentErrorControl;
  
      window.addEventListener('focus', function (event) {
          if (currentErrorControl && event.target !== currentErrorControl.control) {
              currentErrorControl.control.focus();
              if (currentErrorControl.control) {
                  GS.setInputSelection(currentErrorControl.control, 0, currentErrorControl.control.value.length);
              }
          }
  
          if (currentErrorControl && currentErrorControl.control && currentErrorControl.control.value) {
              currentErrorControl = '';
          }
      });
  
      //x attributes:
      //x      placeholder:   copy to control element
      //x      disabled:      copy to control element
      //x      tabindex:      move to control element
      //x      qs:            fill value from querystring, update value as querystring changes
      //x      non-empty:     prevent leaving the field if value is empty, console warn if value starts as empty
      //x      format:        affects value translation when filling control
      //x      no-now-button: affects dropdown html and "n" key
      //x      value:         affects control value
      //x      no-picker:     affects innerHTML because it removes the picker button
  
      //x accessors:
      //x      value:     returns text value
      //x      dateValue: returns value as a date object
      //x      state:     returns text representation of state: "open" or "closed"
  
      //x methods:
      //x      open:   opens popup
      //x      close:  closes popup
      //x      toggle: toggles open and closed methods
  
      //x events:
      //x      picker button click: runs "toggle" method
      //x      control keydown:
      //x          up arrow:    next minute
      //x          down arrow:  previous minute
      //x          left arrow:  previous minute
      //x          right arrow: next minute
      //x          "c":         clear (if allowed)
      //x          "n":         now (if allowed)
  
      //x dropdown behaviours:
      //x      if from control to bottom is too small and from control to top is too small: dialog
      //x      else if window width < 400px: dialog
      //x      else if window height < 550px: dialog
      //x      else:
      //x          if from control to bottom has enough room: popup below
      //x          else: popup above
  
      // #####################################################################################
      // ################################## EVENT RETARGETING ################################
      // #####################################################################################
  
      // re-target change event from control to element
      function changeFunction(event) {
          event.preventDefault();
          event.stopPropagation();
  
          event.target.parentNode.setAttribute('value', event.target.value);
          //console.log('this is a test', event.target);
          handleChange(event.target.parentNode);
      }
  
      // re-target focus event from control to element
      function focusFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'focus');
          event.target.parentNode.classList.add('focus');
      }
  
      // re-target blur event from control to element
      function blurFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'blur');
          event.target.parentNode.classList.remove('focus');
      }
  
      // mouseout, remove hover class
      function mouseoutFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseout);
          event.target.parentNode.classList.remove('hover');
      }
  
      // mouseover, add hover class
      function mouseoverFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseover);
          event.target.parentNode.classList.add('hover');
      }
  
  
      // #####################################################################################
      // ####################################### CONTROL #####################################
      // #####################################################################################
  
      function refreshControl(element) {
          var i, len, arrPassThroughAttributes, strHTML;
  
          // clear out HTML
          element.innerHTML = '';
  
          // clear out element variables
          element.control = '';
          element.button = '';
  
          // if we are not disabled:
          if (!element.hasAttribute('disabled')) {
              // build HTML
              strHTML = '<input class="control" gs-dynamic type="text" />';
              if (!element.hasAttribute('no-picker')) {
                  strHTML += '<gs-button class="time-picker-button" gs-dynamic inline icononly icon="clock-o" no-focus></gs-button>';
              }
  
              // set control HTML
              element.innerHTML = strHTML;
  
              // fill element variables
              element.control = element.children[0];
              element.button = element.children[1];
  
              // handle passthrough attributes
              arrPassThroughAttributes = [
                  'placeholder', 'name', 'maxlength', 'autocorrect',
                  'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                  'readonly'
              ];
  
              i = 0;
              len = arrPassThroughAttributes.length;
              while (i < len) {
                  if (element.hasAttribute(arrPassThroughAttributes[i])) {
                      element.control.setAttribute(
                          arrPassThroughAttributes[i],
                          element.getAttribute(arrPassThroughAttributes[i]) || ''
                      );
                  }
                  i += 1;
              }
  
              // move tabindex
              if (element.hasAttribute('tabindex')) {
                  element.oldTabIndex = element.getAttribute('tabindex');
                  element.removeAttribute('tabindex');
              }
  
              if (element.oldTabIndex) {
                  element.control.tabIndex = element.oldTabIndex;
              }
  
              // bind control retargeting
              element.control.removeEventListener('change', changeFunction);
              element.control.addEventListener('change', changeFunction);
  
              element.control.removeEventListener('focus', focusFunction);
              element.control.addEventListener('focus', focusFunction);
  
              element.control.removeEventListener('blur', blurFunction);
              element.control.addEventListener('blur', blurFunction);
  
              element.control.removeEventListener(evt.mouseout, mouseoutFunction);
              element.control.addEventListener(evt.mouseout, mouseoutFunction);
  
              element.control.removeEventListener(evt.mouseover, mouseoverFunction);
              element.control.addEventListener(evt.mouseover, mouseoverFunction);
          }
  
          // display value
          setValueDisplay(element, element.getAttribute('value'));
      }
  
      function handleChange(element) {
          element.close();
          if (handleNonEmpty(element) && element.lastChangeValue !== element.getAttribute('value')) {
              GS.triggerEvent(element, 'change');
              element.lastChangeValue = element.getAttribute('value');
          }
      }
  
      function handleNonEmpty(element) {
          var bolAllClear = true;
  
          if (element.hasAttribute('non-empty') && !element.getAttribute('value')) {
              bolAllClear = false;
              currentErrorControl = element;
              alert('Error: Invalid Time. Please input a time.');
              element.open();
          }
  
          return bolAllClear;
      }
  
  
      // #####################################################################################
      // ######################################## VALUE ######################################
      // #####################################################################################
  
      // translate inputed value to a format that is allowed. no seconds as of yet, defaults to AM
      function translateValue(strFormat, newValue) {
          var translatedValue;
          var valueDate;
          var strHour;
          var strMinute;
          var strPeriod;
          var arrParts;
          var intHours;
  
          // coalesce value
          newValue = newValue || '';
          //console.log('newValue >' + newValue + '<');
  
          // if value is a string: parse
          if (typeof newValue === 'string') {
              // input types:
              //      "1530"          => "15:30"
              //      "0330"          => "03:30"
              //      "3:30"          => "3:30"
              //      "3:30PM"        => "3:30 PM" (all cases/variations of PM/AM) ('a', 'p', 'am', 'pm', 'Am', 'Pm', 'AM', 'PM')
              //      "330"           => "3:30"
              //      "3"             => "3:00"
              //      "12"            => "12:00"
              //      "12PM"          => "12:00 PM" (all cases/variations of PM/AM) ('a', 'p', 'am', 'pm', 'Am', 'Pm', 'AM', 'PM')
              //      "12:30:12 PM"   => "12:30 PM" (no seconds as of yet)
              //      "123012"        => "12:30" (no seconds as of yet)
  
              // extract period
              strPeriod = (newValue.match(/pm|am|a|p/gi) || [''])[0].toLowerCase();
              newValue  = newValue.replace(/[^0-9:]/gi, '');
  
              //console.log('before strPeriod>' + strPeriod + '<');
              if (strPeriod) {
                  strPeriod = (strPeriod[0] === 'a' ? 'AM' : 'PM');
              }
              //console.log('after strPeriod>' + strPeriod + '<');
  
              if (newValue) {
                  // if there are colon(s): split on colons
                  if ((/:/).test(newValue)) {
                      arrParts = newValue.split(':');
  
                      strHour = arrParts[0];
                      strMinute = GS.leftPad(arrParts[1], '0', 2);
  
                      // if hour is greater than 12: subtract 12 and set period to PM
                      if (parseInt(strHour, 10) > 12) {
                          strHour = parseInt(strHour, 10) - 12;
                          strPeriod = 'PM';
                          //console.log('set strPeriod to PM');
                      }
  
                  // else (if there are just numbers)
                  } else {
                      newValue = newValue.substring(0, 4);
  
                      // if the new value is 3 or 4 characters long: last 2 are minute and the rest is hour
                      if (newValue.length >= 3) {
                          strMinute = newValue.substring(newValue.length - 2);
                          strHour = newValue.substring(0, newValue.length - 2);
  
                          // if hour is greater than 12: subtract 12 and set period to PM
                          if (parseInt(strHour, 10) > 12) {
                              strHour = parseInt(strHour, 10) - 12;
                              strPeriod = 'PM';
                              //console.log('set strPeriod to PM');
                          }
  
                      // else:
                      } else {
                          newValue = parseInt(newValue, 10);
  
                          // if (format is military AND number > 24) OR (format isn't military AND number > 12): newValue is minute
                          if ((strFormat === 'military') && newValue > 24 || (strFormat !== 'military') && newValue > 12) {
                              strHour = '12';
                              strMinute = String(newValue);
                          } else {
                              strHour = String(newValue);
                              strMinute = '00';
                          }
                      }
                  }
              }
  
              if (strHour && strMinute) {
                  if (!strPeriod) {
                      //console.log('strHour>' + strHour + '<');
                      //console.log('parseInt(strHour, 10)>' + parseInt(strHour, 10) + '<');
                      if (parseInt(strHour, 10) >= 12) {
                      //if (parseInt(strHour, 10) < 6 || parseInt(strHour, 10) === 12) {//Who did this? -Joseph
                          strPeriod = 'PM';
                          //console.log('set strPeriod to PM');
                      } else {
                          strPeriod = 'AM';
                          //console.log('set strPeriod to AM');
                      }
                  }
                  valueDate = new Date('1/1/1111 ' + strHour + ':' + strMinute + ' ' + strPeriod);
              }
          // else: just copy date object
          } else {
              valueDate = new Date(newValue);
          }
  
          //console.log(strHour, strMinute, strPeriod);
  
          // if we have enough data to make a value
          if (valueDate) {
              // output types:
              //      regular time:  "3:30 PM"
              //      military time: "15:30"
  
              if (strFormat === 'military') {
                  translatedValue = GS.leftPad(valueDate.getHours(), '0', 2) + ':' +
                                    GS.leftPad(valueDate.getMinutes(), '0', 2);
              } else {
                  intHours = valueDate.getHours();
  
                  if (intHours >= 12) {
                      intHours = intHours - 12;
                  }
                  if (intHours === 0) {
                      intHours = 12;
                  }
  
                  translatedValue = intHours + ':' +
                                    GS.leftPad(valueDate.getMinutes(), '0', 2) + ' ' +
                                    (valueDate.getHours() >= 12 ? 'PM' : 'AM');
              }
          } else {
              translatedValue = '';
          }
  
          return translatedValue;
      }
  
      function setValueDisplay(element, newValue) {
          var translatedOutputValue = translateValue((element.getAttribute('output-format') === 'military' ? 'military' : 'regular'), newValue);
          var translatedDisplayValue = translateValue((element.getAttribute('format') === 'military' ? 'military' : 'regular'), newValue);
  
          element.setAttribute('value', translatedOutputValue);
  
          if (!element.hasAttribute('disabled')) {
              element.control.value = translatedDisplayValue;
          } else {
              element.textContent = translatedDisplayValue || element.getAttribute('placeholder') || '';
          }
  
          if (element.innerState === 'open') {
              refreshPickerValue(element);
          }
      }
  
      function refreshPickerValue(element) {
          var arrElements;
          var strTranslatedValue;
          var dteTranslatedValue;
          var i;
          var len;
          var intHours;
  
          if (element.innerState === 'open') {
              strTranslatedValue = translateValue((element.getAttribute('format') === 'military' ? 'military' : 'regular'), element.getAttribute('value'));
              dteTranslatedValue = new Date('1/1/1111 ' + strTranslatedValue);
  
              element.pickerModalControlElement.setAttribute('value', strTranslatedValue);
  
              arrElements = xtag.query(element.pickerContainerElement, '.selected');
  
              i = 0;
              len = arrElements.length;
              while (i < len) {
                  arrElements[i].classList.remove('selected');
                  i += 1;
              }
  
  
              intHours = dteTranslatedValue.getHours();
  
              if (intHours >= 12) {
                  intHours = intHours - 12;
              }
              if (intHours === 0) {
                  intHours = 12;
              }
  
              xtag.query(element.pickerContainerElement,
                  '.clock-hour[data-value="' + intHours + '"]')[0].classList.add('selected');
              xtag.query(element.pickerContainerElement,
                  '.clock-minute[data-value="' + (Math.floor(dteTranslatedValue.getMinutes() / 5) * 5) + '"]')[0].classList.add('selected');
              xtag.query(element.pickerContainerElement,
                  '.clock-period-switch.' + (dteTranslatedValue.getHours() >= 12 ? 'pm' : 'am'))[0].classList.add('selected');
          }
      }
  
  
      // #####################################################################################
      // ##################################### QUERYSTRING ###################################
      // #####################################################################################
  
      function handleQS(element) {
          var strQSValue;
  
          if (!element.qsEventFunction) {
              element.qsEventFunction = function () {
                  pushReplacePopHandler(element);
              };
          }
  
          window.removeEventListener('pushstate',    element.qsEventFunction);
          window.removeEventListener('replacestate', element.qsEventFunction);
          window.removeEventListener('popstate',     element.qsEventFunction);
  
          // handle "qs" attribute
          if (element.getAttribute('qs')) {
              //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
  
              //if (strQSValue !== '' || !element.getAttribute('value')) {
              //    element.setAttribute('value', strQSValue);
              //}
              pushReplacePopHandler(element);
              window.addEventListener('pushstate',    element.qsEventFunction);
              window.addEventListener('replacestate', element.qsEventFunction);
              window.addEventListener('popstate',     element.qsEventFunction);
          }
      }
  
  
      //function pushReplacePopHandler(element) {
      //    var strQueryString = GS.getQueryString();
      //    var strQSCol = element.getAttribute('qs');
  
      //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
      //    }
      //}
  
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          i = 0;
          len = element.attributes.length;
          arrAttr = element.attributes;
          while (i < len) {
              jsnAttr = element.attributes[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  if (strQSValue !== '' || !element.getAttribute('value')) {
                      element.setAttribute('value', strQSValue);
                  }
              } else {
                  element.value = strQSValue;
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
  
  
      // #####################################################################################
      // ###################################### LIFECYCLE ####################################
      // #####################################################################################
  
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              // if the value was set before the "created" lifecycle code runs: set attribute
              //      (discovered when trying to set a value of a date control in the after_open of a dialog)
              //      ("delete" keyword added because of firefox)
              if (element.value) {
                  element.setAttribute('value', element.value);
                  delete element.value;
              }
          }
      }
  
      //
      function elementInserted(element) {
          console.warn('GS-TIME WARNING: this element is deprecated, please use the gs-datetime instead.');
          var now;
          var strQSValue;
  
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.innerState = 'closed';
                  element.internal = {};
                  saveDefaultAttributes(element);
  
                  // if value attribute = now: set value attribute to the current time
                  if (element.getAttribute('value') === 'now') {
                      now = new Date();
  
                      if (now.getHours() > 12) {
                          now = GS.leftPad(now.getHours() - 12, '0', 2) + ':' + GS.leftPad(now.getMinutes(), '0', 2) + ' PM';
                      } else {
                          now = GS.leftPad(now.getHours(), '0', 2) + ':' + GS.leftPad(now.getMinutes(), '0', 2) + ' AM';
                      }
  
                      element.setAttribute('value', now);
                  }
  
                  element.inserted = true;
  
                  refreshControl(element);
  
                  if (element.getAttribute('qs')) {
                      handleQS(element);
                  }
  
                  element.lastChangeValue = element.getAttribute('value');
  
                  if (element.hasAttribute('non-empty') && !element.getAttribute('value')) {
                      console.warn('gs-time Warning: No value provided on "non-empty" gs-time control. Defaulting to "12:00 PM". Please provide a default value.');
                      element.setAttribute('value', '12:00 PM');
                  }
              }
          }
      }
  
  
      // ######################################################################################
      // ##################################### REGISTRATION ###################################
      // ######################################################################################
  
      xtag.register('gs-time', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
  
              inserted: function () {
                  elementInserted(this);
              },
  
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  var element = this;
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(element);
                      elementInserted(element);
  
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(element);
  
                  } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                      if (strAttrName === 'placeholder' ||
                          strAttrName === 'disabled' ||
                          strAttrName === 'format' ||
                          strAttrName === 'no-picker' ||
                          strAttrName === 'tabindex') {
                          refreshControl(element);
  
                      } else if (strAttrName === 'qs') {
                          handleQS(element);
  
                      } else if (strAttrName === 'value' && element.inserted) {// && this.control
                          setValueDisplay(element, newValue);
                      }
                  }
              }
          },
          events: {
              'click': function (event) {
                  var element = this;
                  if (event.target === element.button) {
                      element.toggle();
                  }
              },
              'keydown:': function (event) {
                  var element = this;
                  var intKeyCode = (event.keyCode || event.which);
                  var newControlValue;
  
                  if (!element.hasAttribute('no-keys') && !element.hasAttribute('readonly')) {
                      if (element.getAttribute('value') && (intKeyCode === 38 || intKeyCode === 39 || intKeyCode === 40 || intKeyCode === 37)) {
                          newControlValue = new Date('1/1/1111 ' + element.getAttribute('value'));
                          event.preventDefault();
                          event.stopPropagation();
  
                          // up arrow:    next minute
                          // right arrow: next minute
                          if (intKeyCode === 38 || intKeyCode === 39) {
                              newControlValue = newControlValue.setMinutes(newControlValue.getMinutes() + 1);
  
                          // down arrow: previous minute
                          // left arrow: previous minute
                          } else if (intKeyCode === 40 || intKeyCode === 37) {
                              newControlValue = newControlValue.setMinutes(newControlValue.getMinutes() - 1);
                          }
                      }
  
                      // "c": clear (if allowed)
                      if (intKeyCode === 67 && !event.ctrlKey && !event.metaKey && !element.hasAttribute('non-empty')) {
                          newControlValue = '';
                          event.preventDefault();
                          event.stopPropagation();
  
                      // "n": now (if allowed)
                      } else if (intKeyCode === 78 && !event.ctrlKey && !event.metaKey && !element.hasAttribute('no-now-button')) {
                          newControlValue = new Date();
                          event.preventDefault();
                          event.stopPropagation();
                      }
  
                      if (newControlValue !== undefined) {
                          setValueDisplay(element, newControlValue);
                          GS.setInputSelection(element.control, 0, element.control.value.length);
                      }
  
                      if (intKeyCode === 13) {
                          handleNonEmpty(element);
                      }
                  }
              },
              'focusout': function (event) {
                  var element = this;
                  if (element.innerState === 'open') {
                      element.close();
                  } else {
                      handleChange(element);
                  }
              }
          },
          accessors: {
              value: {
                  get: function () {
                      // return this.getAttribute('value');
                      if (!this.getAttribute('value') || this.getAttribute('value').trim() === '') {
                          return 'NULL';
                      } else {
                          return this.getAttribute('value');
                      }
                  },
                  set: function (newValue) {
                      this.setAttribute('value', newValue);
                  }
              },
              dateValue: {
                  get: function () {
                      return new Date('1/1/1111 ' + this.getAttribute('value'));
                  },
                  set: function (newValue) {
                      setValueDisplay(this, newValue);
                  }
              },
              state: {
                  get: function () {
                      return this.innerState;
                  },
                  set: function (newValue) {
                      var element = this;
                      if (newValue === 'open') {
                          element.open();
                      } else {
                          element.close();
                      }
                  }
              }
          },
          methods: {
              focus: function () {
                  this.control.focus();
              },
  
              open: function () {
                  var element = this;
                  var pickerContainerElement;
                  var overlayElement;
                  var pickerElement;
                  var handleLook;
                  var strHTML;
  
                  if (element.innerState === 'closed') {
                      element.innerState = 'open';
                      element.lastClosedValue = element.getAttribute('value');
  
                      // if we are not on a touch device: focus control
                      if (!evt.touchDevice) {
                          element.control.focus();
                          GS.setInputSelection(element.control, 0, element.control.value.length);
  
                      } else {
                          //this.control.focus()
                          //this.control.blur();
                      }
  
                      // create picker elements
                      pickerContainerElement = document.createElement('div');
                      pickerContainerElement.classList.add('gs-time-time-picker-container');
  
                      overlayElement = document.createElement('div');
                      overlayElement.classList.add('gs-time-time-picker-overlay');
  
                      pickerElement = document.createElement('div');
                      pickerElement.classList.add('gs-time-time-picker');
  
                      // save picker container
                      element.pickerContainerElement = pickerContainerElement;
  
                      // append picker elements
                      pickerContainerElement.appendChild(overlayElement);
                      pickerContainerElement.appendChild(pickerElement);
  
                      document.body.appendChild(pickerContainerElement);
  
                      // fill picker popup
                      strHTML = ml(function () {/*
                          <div class="time-modal-control-container" flex-horizontal>
                              <gs-text class="time-modal-control" flex></gs-text>
                              <gs-button class="modal-done">Done</gs-button>
                          </div>
                          <div class="time-inner-container">
                              <div class="time-top-toolbar">
                                  <div flex-horizontal align-bottom>
                                      <gs-button class="decrement-time" icononly icon="arrow-left"></gs-button>
                                      <div flex></div>
                                      <gs-button class="increment-time" icononly icon="arrow-right"></gs-button>
                                  </div>
                              </div>
                              <div class="gs-time-clock-container" prevent-text-selection>
                                  <div class="gs-time-bezel">
                                      <div class="clock-face-layer layer-1">
                                          <div class="clock-line" style="top: 0%;"><div class="clock-button clock-hour" data-value="12"><span class="content">12</span></div></div><div class="clock-line" style="top: 5.9%;"><div class="clock-split" style="width: 45.25%;
  left: 4.5%;"><div class="clock-button clock-hour" data-value="11"><span class="content">11</span></div></div><div class="clock-split" style="width: 45.25%;
  left: 46.75%;"><div class="clock-button clock-hour" data-value="1">&nbsp;<span class="content">1</span></div></div></div><div class="clock-line" style="top: 22.5%;"><div class="clock-split" style="width: 22%;
  left: 0%;"><div class="clock-button clock-hour" data-value="10"><span class="content">10</span></div></div><div class="clock-split" style="width: 22%;
  left: 78%;"><div class="clock-button clock-hour" data-value="2">&nbsp;<span class="content">2</span></div></div></div><div class="clock-line" style="top: 45.3%;"><div class="clock-split" style="width: 14%;
  left: 0%;"><div class="clock-button clock-hour" data-value="9"><span class="content">9</span>&nbsp;</div></div><div class="clock-split" style="width: 14%;
  left: 86%;"><div class="clock-button clock-hour" data-value="3">&nbsp;<span class="content">3</span></div></div></div><div class="clock-line" style="top: 67.8%;"><div class="clock-split" style="width: 22%;
  left: 0%;"><div class="clock-button clock-hour" data-value="8"><span class="content">8</span>&nbsp;</div></div><div class="clock-split" style="width: 22%;
  left: 78%"><div class="clock-button clock-hour" data-value="4">&nbsp;<span class="content">4</span></div></div></div><div class="clock-line" style="top: 83.5%;"><div class="clock-split" style="width: 45.25%;
  left: 4.5%;"><div class="clock-button clock-hour" data-value="7"><span class="content">7</span>&nbsp;</div></div><div class="clock-split" style="width: 45.25%;
  left: 46.75%;"><div class="clock-button clock-hour" data-value="5">&nbsp;<span class="content">5</span></div></div></div><div class="clock-line" style="top: 90%;"><div class="clock-button clock-hour" data-value="6"><span class="content">6</span></div></div>
                                      </div>
                                      <div class="clock-face-layer layer-2">
                                          <div class="clock-line" style="top: 0%;"><div class="clock-button clock-minute" data-value="0"><span class="content">00</span></div></div>
                                          <div class="clock-line" style="top: 5.9%;"><div class="clock-split" style="width: 45.25%;
  left: 4.5%;"><div class="clock-button clock-minute" data-value="55"><span class="content">55</span></div></div><div class="clock-split" style="width: 45.25%;
  left: 49.75%;"><div class="clock-button clock-minute" data-value="5"><span class="content">05</span></div></div></div>
                                          <div class="clock-line" style="top: 22.5%;"><div class="clock-split" style="width: 22%;
  left: 0%;"><div class="clock-button clock-minute" data-value="50"><span class="content">50</span></div></div><div class="clock-split" style="width: 22%;
  left: 78%;"><div class="clock-button clock-minute" data-value="10"><span class="content">10</span></div></div></div>
                                          <div class="clock-line" style="top: 45.3%;"><div class="clock-split" style="width: 16%;
  left: 0%;"><div class="clock-button clock-minute" data-value="45"><span class="content">45</span></div></div><div class="clock-split" style="width: 16%;
  left: 84%;"><div class="clock-button clock-minute" data-value="15"><span class="content">15</span></div></div></div>
                                          <div class="clock-line" style="top: 67.8%;"><div class="clock-split" style="width: 22%;
  left: 0%;"><div class="clock-button clock-minute" data-value="40"><span class="content">40</span></div></div><div class="clock-split" style="width: 22%;
  left: 78%;"><div class="clock-button clock-minute" data-value="20"><span class="content">20</span></div></div></div>
                                          <div class="clock-line" style="top: 83.5%;"><div class="clock-split" style="width: 45.25%;
  left: 4.5%;"><div class="clock-button clock-minute" data-value="35"><span class="content">35</span></div></div><div class="clock-split" style="width: 45.25%;
  left: 49.75%;"><div class="clock-button clock-minute" data-value="25"><span class="content">25</span></div></div></div>
                                          <div class="clock-line" style="top: 90%;"><div class="clock-button clock-minute" data-value="30"><span class="content">30</span></div></div>
                                          <div class="clock-center"><div class="clock-period-switch am"><span class="content">AM</span></div><div class="clock-period-switch pm"><span class="content">PM</span></div></div>
                                      </div>
                                  </div>
                              </div>
                          </div>
                      */});
  
                      strHTML += '<div class="time-bottom-toolbar">' +
                                      '<div flex-horizontal align-top>';
  
                      if (!element.hasAttribute('no-now-button')) {
                          strHTML += '<gs-button class="now-time">Now</gs-button>';
                      }
  
                      strHTML += '<gs-button class="done" flex>Done</gs-button>';
  
                      if (!element.hasAttribute('non-empty')) {
                          strHTML += '<gs-button class="clear-time">Clear</gs-button>';
                      }
  
                      strHTML +=      '</div>' +
                                  '</div>';
  
                      pickerElement.innerHTML = strHTML;
  
                      // save picker control
                      element.pickerModalControlElement = xtag.query(pickerContainerElement, '.time-modal-control')[0];
  
                      // set picker value
                      refreshPickerValue(element);
  
                      // bind picker control change
                      element.pickerModalControlElement.addEventListener('change', function (event) {
                          setValueDisplay(element, this.value);
                      });
  
                      // bind picker control keydown
                      element.pickerModalControlElement.addEventListener('keydown', function (event) {
                          if ((event.keyCode || event.which) === 13) {
                              element.close();
                          }
                      });
  
                      // bind picker click
                      pickerElement.addEventListener('mousedown', function (event) {
                          if (!evt.touchDevice) {
                              event.preventDefault();
                              event.stopPropagation();
                          }
                      });
  
                      //console.log('0***', pickerElement);
                      pickerElement.addEventListener('click', function (event) {
                          var target = event.target, arrElements, i, len, newValue;
  
                          //console.log('1***', newValue);
  
                          if (target.classList.contains('content')) {
                              target = target.parentNode;
                          }
  
                          if (target.classList.contains('clock-button') || target.classList.contains('clock-period-switch')) {
                              if (target.classList.contains('clock-hour')) {
                                  arrElements = xtag.query(pickerElement, '.clock-hour');
                              }
                              if (target.classList.contains('clock-minute')) {
                                  arrElements = xtag.query(pickerElement, '.clock-minute');
                              }
                              if (target.classList.contains('clock-period-switch')) {
                                  arrElements = xtag.query(pickerElement, '.clock-period-switch');
                              }
  
                              for (i = 0, len = arrElements.length; i < len; i += 1) {
                                  arrElements[i].classList.remove('selected');
                              }
  
                              target.classList.add('selected');
  
                              arrElements = xtag.query(pickerElement, '.selected');
                              if (arrElements.length === 3) {
                                  newValue = arrElements[0].textContent + ':' +
                                             arrElements[1].textContent + ' ' +
                                             arrElements[2].textContent;
                              }
                          }
  
                          if (target.classList.contains('increment-time') && element.getAttribute('value')) {
                              newValue = new Date('1/1/1111 ' + element.getAttribute('value'));
                              newValue = newValue.setMinutes(newValue.getMinutes() + 1);
                          } else if (target.classList.contains('decrement-time') && element.getAttribute('value')) {
                              newValue = new Date('1/1/1111 ' + element.getAttribute('value'));
                              newValue = newValue.setMinutes(newValue.getMinutes() - 1);
                          } else if (target.classList.contains('now-time')) {
                              newValue = new Date();
                          } else if (target.classList.contains('clear-time')) {
                              newValue = '';
                          } else if (target.classList.contains('modal-done') || target.classList.contains('done')) {
                              element.close();
                          }
  
                          //console.log('2***', newValue);
                          if (newValue !== undefined) {
                              setValueDisplay(element, newValue);
                              //console.log('3***', element, element.getAttribute('value'), element.value);
  
                              if (!evt.touchDevice) {
                                  GS.setInputSelection(element.control, 0, element.control.value.length);
                              }
                          }
                      });
  
                      // handle/bind positioning and look
                      handleLook = function () {
                          var positionData, intPopupHeight, intPopupWidth;
  
                          if (pickerContainerElement.parentNode !== document.body) {
                              window.removeEventListener('resize', handleLook);
                              window.removeEventListener('orientationchange', handleLook);
                              return;
                          }
  
                          // clear current styles
                          pickerElement.style.top = '';
                          pickerElement.style.left = '';
                          pickerElement.style.marginTop = '';
                          pickerContainerElement.classList.remove('modal');
  
                          // get position/size data
                          positionData = GS.getElementPositionData(element);
                          intPopupHeight = pickerElement.offsetHeight;
                          intPopupWidth = pickerElement.offsetWidth;
  
                          // if from control to bottom is too small and from control to top is too small
                          //      OR window width < 400px: dialog
                          //      OR window height < 550px: dialog
                          if ((positionData.intRoomAbove < intPopupHeight && positionData.intRoomBelow < intPopupHeight) ||
                              window.innerWidth < 400 ||
                              window.innerHeight < 550) {
                              // dialog mode
                              pickerElement.style.marginTop = '1em';
                              pickerContainerElement.classList.add('modal');
  
                          } else {
                              // if from control to bottom has enough room: popup below
                              if (positionData.intRoomBelow > intPopupHeight) {
                                  pickerElement.style.top  = (positionData.objElementOffset.top + positionData.intElementHeight) + 'px';
  
                              // else: popup above
                              } else {
                                  pickerElement.style.top  = (positionData.objElementOffset.top - intPopupHeight) + 'px';
                              }
  
                              pickerElement.style.left =
                                  ((positionData.objElementOffset.left + positionData.intElementWidth) - intPopupWidth) + 'px';
                          }
                      };
  
                      handleLook();
  
                      window.addEventListener('resize', handleLook);
                      window.addEventListener('orientationchange', handleLook);
                  }
              },
  
              close: function () {
                  var element = this;
  
                  if (element.innerState === 'open') {
                      element.innerState = 'closed';
                      //console.trace('closed', element.pickerContainerElement);
                      if (element.pickerContainerElement) {
                          document.body.removeChild(element.pickerContainerElement);
                          element.pickerContainerElement = '';
                      }
  
                      if (element.getAttribute('value') !== element.lastClosedValue) {
                          handleChange(element);
                      } else if (!element.getAttribute('value')) {
                          handleNonEmpty(element);
                      }
                  }
              },
  
              toggle: function () {
                  if (this.innerState === 'open') {
                      this.close();
                  } else {
                      this.open();
                  }
              }
          }
      });
  });/*jslint white:true browser:true this:true*/
  /*global window,GS,document,xtag,designRegisterElement,registerDesignSnippet,addProp,encodeHTML,setOrRemoveTextAttribute,setOrRemoveBooleanAttribute,addFlexProps*/
  
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      registerDesignSnippet('<gs-timestamp>', '<gs-timestamp>', 'gs-timestamp date-format="${0:isodate}" time-format=${1}></gs-timestamp>');
      
      designRegisterElement('gs-timestamp', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-timestamp.html');
      
      window.designElementProperty_GSTIMESTAMP = function (selectedElement) {    
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
          
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
          
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
          
          addProp('Date Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('date-placeholder') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'date-placeholder', this.value);
          });
          
          addProp('Time Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('time-placeholder') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'time-placeholder', this.value);
          });
          
          addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
          });
          
          addProp('Date Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-date-picker')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-date-picker', (this.value === 'true'), false);
          });
          
          addProp('Date Format', true, '<gs-combo class="target" value="' + encodeHTML(selectedElement.getAttribute('date-format') || '') + '" mini>' + 
                          ml(function () {/*<template>
                                              <table>
                                                  <tbody>
                                                      <tr value="">
                                                          <td hidden>Default</td>
                                                          <td><center>Default<br /> (01/01/2015)</center></td>
                                                      </tr>
                                                      <tr value="shortdate">
                                                          <td hidden>shortdate</td>
                                                          <td><center>shortdate<br /> (1/1/15)</center></td>
                                                      </tr>
                                                      <tr value="mediumdate">
                                                          <td hidden>mediumdate</td>
                                                          <td><center>mediumdate<br /> (Jan 1, 2015)</center></td>
                                                      </tr>
                                                      <tr value="longdate">
                                                          <td hidden>longdate</td>
                                                          <td><center>longdate<br /> (January 1, 2015)</center></td>
                                                      </tr>
                                                      <tr value="fulldate">
                                                          <td hidden>fulldate</td>
                                                          <td><center>fulldate<br /> (Thursday, January 1, 2015)</center></td>
                                                      </tr>
                                                      <tr value="isodate">
                                                          <td hidden>isodate</td>
                                                          <td><center>isodate<br /> (2015-01-01)</center></td>
                                                      </tr>
                                                      <tr value="isodatetime">
                                                          <td hidden>isodatetime</td>
                                                          <td><center>isodatetime<br /> (2015-01-01T00:00:00)</center></td>
                                                      </tr>
                                                  </tbody>
                                              </table>
                                          </template>
                                      </gs-combo>
                                  */}), function () {
              return setOrRemoveTextAttribute(selectedElement, 'date-format', this.value);
          });
  
          addProp('Time Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-time-picker')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'no-time-picker', (this.value === 'true'), false);
          });
  
          addProp('Time Display Format', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('time-format') || '') + '" mini>' +
                                      '<option value="">Regular (1:30 PM)</option>' +
                                      '<option value="military">Military (13:30)</option>' +
                                  '</gs-select>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'time-format', this.value);
          });
  
          addProp('Time Non-Empty', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('time-non-empty')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'time-non-empty', (this.value === 'true'), true);
          });
  
          addProp('Time Now Button', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('time-no-now-button')) + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'time-no-now-button', (this.value === 'true'), false);
          });
          
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
          
          addProp('Date Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('date-tabindex') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'date-tabindex', this.value);
          });
          
          addProp('Time Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('time-tabindex') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'time-tabindex', this.value);
          });
          
          addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
          });
          
          addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
          });
          
          addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
          });
          
          addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
          });
          
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
          if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
          if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
          if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
          if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
          if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
          if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
          
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          // DISABLED attribute
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
  
          // READONLY attribute
          addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
          });
          
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
          
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol && strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else if (strQSCol && GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  if (strQSValue !== '' || !element.getAttribute('value')) {
                      element.setAttribute('value', strQSValue);
                  }
              } else {
                  element.value = strQSValue;
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
  
      // for a given element, copy the control values with the value attribute
      function syncView(element) {
          var strDateValue = element.dateControl.value + ' ' + (element.timeControl.value === 'NULL' ? '00:00' : element.timeControl.value);
          var dateValue = new Date(strDateValue);
          var newValue = dateValue.getFullYear() + '-' + (dateValue.getMonth() + 1) + '-' + dateValue.getDate() + ' ' + dateValue.getHours() + ':' + dateValue.getMinutes();
          
          //console.log(element.dateControl.value);
          //console.log(element.timeControl.value === 'NULL' ? '00:00' : element.timeControl.value);
          //console.log(strDateValue);
          //console.log(dateValue);
          //console.log(newValue);
          
          element.setAttribute('value', newValue);
      }
      
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          i = 0;
          len = element.attributes.length;
          arrAttr = element.attributes;
          while (i < len) {
              jsnAttr = element.attributes[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      // re-target focus event from control to element
      function focusFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'focus');
          event.target.parentNode.classList.add('focus');
      }
  
      // re-target blur event from control to element
      function blurFunction(event) {
          GS.triggerEvent(event.target.parentNode, 'blur');
          event.target.parentNode.classList.remove('focus');
      }
  
      // mouseout, remove hover class
      function mouseoutFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseout);
          event.target.parentNode.classList.remove('hover');
      }
  
      // mouseover, add hover class
      function mouseoverFunction(event) {
          GS.triggerEvent(event.target.parentNode, evt.mouseover);
          event.target.parentNode.classList.add('hover');
      }
      
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
              // if the value was set before the "created" lifecycle code runs: set attribute
              //      (discovered when trying to set a value of a date control in the after_open of a dialog)
              //      ("delete" keyword added because of firefox)
              if (element.value && new Date(element.value).getTime()) {
                  element.setAttribute('value', element.value);
                  delete element.value;
                  //element.value = undefined;
                  //element.value = null;
              }
          }
      }
      
      function elementInserted(element) {
          var dateValue = '';
          var timeValue = '';
          
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
                  
                  if (element.hasAttribute('value')) {
                      var arrValue = element.getAttribute('value').split(' ');
                      dateValue = new Date(arrValue[0] + ' 00:00:00');    // adding an empty time causes the date to not be iso format
                                                                          // this makes the browser choose the local timezone instead of GMT
                      timeValue = arrValue[1];
                  }
                  
                  element.dateControl = document.createElement('gs-date');
                  element.timeControl = document.createElement('gs-time');
                  
                  var arrPassthrough = ['mini', 'autocorrect', 'autocapitalize', 'autocomplete', 'spellcheck', 'disabled', 'readonly'];
                  var arrDatePassthrough = ['date-placeholder', 'no-date-picker', 'date-format', 'date-tabindex'];
                  var arrTimePassthrough = ['time-placeholder', 'no-time-picker', 'time-format', 'time-non-empty', 'time-no-now-button', 'time-tabindex'];
                  var i;
                  var len;
                  
                  for (i = 0, len = arrPassthrough.length; i < len; i += 1) {
                      if (element.hasAttribute(arrPassthrough[i])) {
                          element.dateControl.setAttribute(arrPassthrough[i], '');
                          element.timeControl.setAttribute(arrPassthrough[i], '');
                      }
                  }
                  for (i = 0, len = arrDatePassthrough.length; i < len; i += 1) {
                      if (element.hasAttribute(arrDatePassthrough[i])) {
                          element.dateControl.setAttribute(arrDatePassthrough[i].replace(/date\-/g, ''), element.getAttribute(arrDatePassthrough[i]) || '');
                      }
                  }
                  for (i = 0, len = arrTimePassthrough.length; i < len; i += 1) {
                      if (element.hasAttribute(arrTimePassthrough[i])) {
                          element.timeControl.setAttribute(arrTimePassthrough[i].replace(/time\-/g, ''), element.getAttribute(arrTimePassthrough[i]) || '');
                      }
                  }
                  
                  element.dateControl.value = dateValue;
                  element.timeControl.value = timeValue;
                  
                  element.dateControl.setAttribute('flex', '');
                  element.timeControl.setAttribute('flex', '');
                  
                  element.dateControl.setAttribute('gs-dynamic', '');
                  element.timeControl.setAttribute('gs-dynamic', '');
                  
                  element.dateControl.addEventListener('focus', focusFunction);
                  element.timeControl.addEventListener('focus', focusFunction);
  
                  element.dateControl.addEventListener('blur', blurFunction);
                  element.timeControl.addEventListener('blur', blurFunction);
  
                  element.dateControl.addEventListener(evt.mouseout, mouseoutFunction);
                  element.timeControl.addEventListener(evt.mouseout, mouseoutFunction);
                  
                  element.dateControl.addEventListener(evt.mouseover, mouseoverFunction);
                  element.timeControl.addEventListener(evt.mouseover, mouseoverFunction);
                  
                  element.dateControl.addEventListener('change', function (event) {
                      syncView(element);
                      event.stopPropagation();
                      GS.triggerEvent(element, 'change');
                  });
                  element.timeControl.addEventListener('change', function (event) {
                      syncView(element);
                      event.stopPropagation();
                      GS.triggerEvent(element, 'change');
                  });
                  
                  //console.log(element.dateControl);
                  //console.log(element.timeControl);
                  
                  element.appendChild(element.dateControl);
                  element.appendChild(element.timeControl);
                  
                  //console.log(element.children);
                  
                  pushReplacePopHandler(element);
                  window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                  window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                  window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
              }
          }
      }
      
      xtag.register('gs-timestamp', {
          lifecycle: {
              created: function () {
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  var dateValue = '';
                  var timeValue = '';
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      if (strAttrName === 'value') {
                          if (newValue !== null) {
                              var arrValue = newValue.split(' ');
                              dateValue = new Date(arrValue[0]);
                              timeValue = arrValue[1];
                              
                              this.dateControl.value = dateValue;
                              this.timeControl.value = timeValue;
                          } else {
                              this.dateControl.value = null;
                              this.timeControl.value = null;
                          }
                      }
                  }
              }
          },
          events: {},
          accessors: {
              value: {
                  get: function () {
                      return this.getAttribute('value');
                  },
                  
                  set: function (newValue) {
                      this.setAttribute('value', newValue);
                  }
              }
          },
          methods: {
          }
      });
  });
  window.addEventListener('design-register-element', function () {
      
      registerDesignSnippet('<gs-toggle>', '<gs-toggle>', 'gs-toggle column="${1}">${2}</gs-toggle>');
      
      designRegisterElement('gs-toggle', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-buttons-toggle.html');
      
      window.designElementProperty_GSTOGGLE = function(selectedElement) {
          addProp('Icon', true, '<div flex-horizontal>' +
                                '     <gs-text id="prop-icon-input" class="target" value="' + (selectedElement.getAttribute('icon') || '') + '" mini flex></gs-text>' +
                                '     <gs-button id="prop-icon-picker-button" mini icononly icon="list"></gs-button>' +
                                '     <style>#prop-icon-picker-button:after {font-size: 1em;}</style>' +
                                '</div>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'icon', this.value, false);
          });
          
          document.getElementById('prop-icon-picker-button').addEventListener('click', function () {
              var i, len, html, arrIcons = GS.iconList(), strName, templateElement;
              
              for (i = 0, len = arrIcons.length, html = ''; i < len; i += 1) {
                  strName = arrIcons[i].name;
                  html += '<gs-block>' +
                              '<gs-button iconleft icon="' + strName + '" dialogclose>' + strName + '</gs-button>' +
                          '</gs-block>';
              }
              
              templateElement = document.createElement('template');
              templateElement.setAttribute('data-max-width', '1100px');
              
              templateElement.innerHTML = ml(function () {/*
                  <gs-page>
                      <gs-header><center><h3>Choose An Icon</h3></center></gs-header>
                      <gs-body padded>
                          <gs-grid widths="1,1,1,1" reflow-at="767px">{{HTML}}</gs-grid>
                      </gs-body>
                      <gs-footer><gs-button dialogclose>Cancel</gs-button></gs-footer>
                  </gs-page>
              */}).replace('{{HTML}}', html);
              
              GS.openDialog(templateElement, '', function (event, strAnswer) {
                  var propInput = document.getElementById('prop-icon-input');
                  
                  if (strAnswer !== 'Cancel') {
                      propInput.value = strAnswer;
                      GS.triggerEvent(propInput, 'change');
                  }
              });
          });
          
          if (selectedElement.getAttribute('icon') ||
              selectedElement.hasAttribute('iconleft') ||
              selectedElement.hasAttribute('iconright') ||
              selectedElement.hasAttribute('icontop') ||
              selectedElement.hasAttribute('iconbottom') ||
              selectedElement.hasAttribute('icononly') ||
              selectedElement.hasAttribute('iconrotateright') ||
              selectedElement.hasAttribute('iconrotatedown') ||
              selectedElement.hasAttribute('iconrotateleft')) {
              // iconleft
              // iconright
              // icontop
              // iconbottom
              // icononly
                     if (selectedElement.hasAttribute('iconleft'))   { strIconPos = 'iconleft';
              } else if (selectedElement.hasAttribute('iconright'))  { strIconPos = 'iconright';
              } else if (selectedElement.hasAttribute('icontop'))    { strIconPos = 'icontop';
              } else if (selectedElement.hasAttribute('iconbottom')) { strIconPos = 'iconbottom';
              } else if (selectedElement.hasAttribute('icononly'))   { strIconPos = 'icononly';
              } else { strIconPos = ''; }
              
              addProp('Icon Position', true, '<gs-select class="target" value="' + strIconPos + '" mini>' +
                                                  '   <option value="">Default</option>' +
                                                  '   <option value="iconleft">Left</option>' +
                                                  '   <option value="iconright">Right</option>' +
                                                  '   <option value="icontop">Top</option>' +
                                                  '   <option value="iconbottom">Bottom</option>' +
                                                  '   <option value="icononly">Icononly</option>' +
                                                  '</gs-select>', function () {
                  selectedElement.removeAttribute('iconleft');
                  selectedElement.removeAttribute('iconright');
                  selectedElement.removeAttribute('icontop');
                  selectedElement.removeAttribute('iconbottom');
                  selectedElement.removeAttribute('icononly');
                  
                  if (this.value) {
                      selectedElement.setAttribute(this.value, '');
                  }
                  
                  return selectedElement;
              });
              
              // None
              // 90 degrees  (iconrotateright)
              // 180 degrees (iconrotatedown)
              // 270 degrees (iconrotateleft)
              
                     if (selectedElement.hasAttribute('iconrotateright')) { strIconRotation = 'iconrotateright';
              } else if (selectedElement.hasAttribute('iconrotatedown'))  { strIconRotation = 'iconrotatedown';
              } else if (selectedElement.hasAttribute('iconrotateleft'))  { strIconRotation = 'iconrotateleft';
              } else { strIconRotation = ''; }
  
              addProp('Icon&nbsp;Rotation', true, '<gs-select class="target" value="' + strIconRotation + '" mini>' +
                                                  '   <option value="">None</option>' +
                                                  '   <option value="iconrotateright">90 degrees</option>' +
                                                  '   <option value="iconrotatedown">180 degrees</option>' +
                                                  '   <option value="iconrotateleft">270 degrees</option>' +
                                                  '</gs-select>', function () {
                  selectedElement.removeAttribute('iconrotateright');
                  selectedElement.removeAttribute('iconrotatedown');
                  selectedElement.removeAttribute('iconrotateleft');
  
                  if (this.value) {
                      selectedElement.setAttribute(this.value, '');
                  }
  
                  return selectedElement;
              });
          }
  
          // TITLE attribute
          addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
          });
  
          // TABINDEX attribute
          addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
          });
  
          // visibility attributes
          var strVisibilityAttribute = '';
          if (selectedElement.hasAttribute('hidden')) {
              strVisibilityAttribute = 'hidden';
          }
          if (selectedElement.hasAttribute('hide-on-desktop')) {
              strVisibilityAttribute = 'hide-on-desktop';
          }
          if (selectedElement.hasAttribute('hide-on-tablet')) {
              strVisibilityAttribute = 'hide-on-tablet';
          }
          if (selectedElement.hasAttribute('hide-on-phone')) {
              strVisibilityAttribute = 'hide-on-phone';
          }
          if (selectedElement.hasAttribute('show-on-desktop')) {
              strVisibilityAttribute = 'show-on-desktop';
          }
          if (selectedElement.hasAttribute('show-on-tablet')) {
              strVisibilityAttribute = 'show-on-tablet';
          }
          if (selectedElement.hasAttribute('show-on-phone')) {
              strVisibilityAttribute = 'show-on-phone';
          }
  
          addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                          '<option value="">Visible</option>' +
                                          '<option value="hidden">Invisible</option>' +
                                          '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                          '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                          '<option value="hide-on-phone">Invisible at phone size</option>' +
                                          '<option value="show-on-desktop">Visible at desktop size</option>' +
                                          '<option value="show-on-tablet">Visible at tablet size</option>' +
                                          '<option value="show-on-phone">Visible at phone size</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('hidden');
              selectedElement.removeAttribute('hide-on-desktop');
              selectedElement.removeAttribute('hide-on-tablet');
              selectedElement.removeAttribute('hide-on-phone');
              selectedElement.removeAttribute('show-on-desktop');
              selectedElement.removeAttribute('show-on-tablet');
              selectedElement.removeAttribute('show-on-phone');
              
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
              
              return selectedElement;
          });
          
          // DISABLED attribute
          addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
          });
  
          // Font Color attributes
          strFontAttribute = '';
          if (selectedElement.hasAttribute('txt-primary'))  { strFontAttribute = 'txt-primary'; }
          if (selectedElement.hasAttribute('txt-success'))  { strFontAttribute = 'txt-success'; }
          if (selectedElement.hasAttribute('txt-info'))     { strFontAttribute = 'txt-info'; }
          if (selectedElement.hasAttribute('txt-warning'))  { strFontAttribute = 'txt-warning'; }
          if (selectedElement.hasAttribute('txt-danger'))   { strFontAttribute = 'txt-danger'; }
  
          addProp('Font Color', true, '<gs-select class="target" value="' + strFontAttribute + '" mini>' +
                                          '<option value="">Default</option>' +
                                          '<option value="txt-primary">Primary</option>' +
                                          '<option value="txt-success">Success</option>' +
                                          '<option value="txt-info">Info</option>' +
                                          '<option value="txt-warning">Warning</option>' +
                                          '<option value="txt-danger">Danger</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('txt-primary');
              selectedElement.removeAttribute('txt-success');
              selectedElement.removeAttribute('txt-info');
              selectedElement.removeAttribute('txt-warning');
              selectedElement.removeAttribute('txt-danger');
  
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
  
              return selectedElement;
          });
  
          // Background Color attributes
          strBackgroundAttribute = '';
          if (selectedElement.hasAttribute('bg-primary'))  { strBackgroundAttribute = 'bg-primary'; }
          if (selectedElement.hasAttribute('bg-success'))  { strBackgroundAttribute = 'bg-success'; }
          if (selectedElement.hasAttribute('bg-info'))     { strBackgroundAttribute = 'bg-info'; }
          if (selectedElement.hasAttribute('bg-warning'))  { strBackgroundAttribute = 'bg-warning'; }
          if (selectedElement.hasAttribute('bg-danger'))   { strBackgroundAttribute = 'bg-danger'; }
  
          addProp('Background Color', true, '<gs-select class="target" value="' + strBackgroundAttribute + '" mini>' +
                                          '<option value="">Default</option>' +
                                          '<option value="bg-primary">Primary</option>' +
                                          '<option value="bg-success">Success</option>' +
                                          '<option value="bg-info">Info</option>' +
                                          '<option value="bg-warning">Warning</option>' +
                                          '<option value="bg-danger">Danger</option>' +
                                      '</gs-select>', function () {
              selectedElement.removeAttribute('bg-primary');
              selectedElement.removeAttribute('bg-success');
              selectedElement.removeAttribute('bg-info');
              selectedElement.removeAttribute('bg-warning');
              selectedElement.removeAttribute('bg-danger');
  
              if (this.value) {
                  selectedElement.setAttribute(this.value, '');
              }
  
              return selectedElement;
          });
  
          addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
          });
  
          addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
          });
  
          addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
              return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
          });
  
          // SUSPEND-CREATED attribute
          addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
          });
  
          // SUSPEND-INSERTED attribute
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
  
          addProp('Corners', true,   '<div class="target">' +
                                          '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                      selectedElement.hasAttribute('remove-top') ||
                                                                      selectedElement.hasAttribute('remove-left') ||
                                                                      selectedElement.hasAttribute('remove-top-left'))).toString() +
                                                  '" remove-right remove-bottom id="round-top-left-corner________" inline></gs-checkbox>' +
  
                                          '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                      selectedElement.hasAttribute('remove-top') ||
                                                                      selectedElement.hasAttribute('remove-right') ||
                                                                      selectedElement.hasAttribute('remove-top-right'))).toString() +
                                                  '" remove-left remove-bottom id="round-top-right-corner________" inline></gs-checkbox><br />' +
  
                                          '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                      selectedElement.hasAttribute('remove-bottom') ||
                                                                      selectedElement.hasAttribute('remove-left') ||
                                                                      selectedElement.hasAttribute('remove-bottom-left'))).toString() +
                                                  '" remove-right remove-top id="round-bottom-left-corner________" inline></gs-checkbox>' +
  
                                          '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                      selectedElement.hasAttribute('remove-bottom') ||
                                                                      selectedElement.hasAttribute('remove-right') ||
                                                                      selectedElement.hasAttribute('remove-bottom-right'))).toString() +
                                                  '" remove-left remove-top id="round-bottom-right-corner________" inline></gs-checkbox>' +
                                      '</div>', function () {
              var topLeft =     document.getElementById('round-top-left-corner________').value === 'true',
                  topRight =    document.getElementById('round-top-right-corner________').value === 'true',
                  bottomLeft =  document.getElementById('round-bottom-left-corner________').value === 'true',
                  bottomRight = document.getElementById('round-bottom-right-corner________').value === 'true',
                  arrStrAttr = [], i, len;
  
              selectedElement.removeAttribute('remove-all');
              selectedElement.removeAttribute('remove-top');
              selectedElement.removeAttribute('remove-bottom');
              selectedElement.removeAttribute('remove-left');
              selectedElement.removeAttribute('remove-right');
              selectedElement.removeAttribute('remove-top-left');
              selectedElement.removeAttribute('remove-top-right');
              selectedElement.removeAttribute('remove-bottom-left');
              selectedElement.removeAttribute('remove-bottom-right');
  
              if (!topLeft && !topRight && !bottomLeft && !bottomRight) {
                  arrStrAttr.push('remove-all');
              } else if (!topLeft && !topRight) {
                  arrStrAttr.push('remove-top');
              } else if (!bottomLeft && !bottomRight) {
                  arrStrAttr.push('remove-bottom');
              } else if (!topLeft && !bottomLeft) {
                  arrStrAttr.push('remove-left');
              } else if (!topRight && !bottomRight) {
                  arrStrAttr.push('remove-right');
              }
  
              if (!topLeft && !bottomLeft && arrStrAttr[0] !== 'remove-all') {
                  arrStrAttr.push('remove-left');
              } else if (!topLeft && topRight) {
                  arrStrAttr.push('remove-top-left');
              } else if (!bottomLeft && bottomRight) {
                  arrStrAttr.push('remove-bottom-left');
              }
  
              if (!topRight && !bottomRight && arrStrAttr[0] !== 'remove-all') {
                  arrStrAttr.push('remove-right');
              } else if (topLeft && !topRight) {
                  arrStrAttr.push('remove-top-right');
              } else if (bottomLeft && !bottomRight) {
                  arrStrAttr.push('remove-bottom-right');
              }
  
              for (i = 0, len = arrStrAttr.length; i < len; i += 1) {
                  selectedElement.setAttribute(arrStrAttr[i], '');
              }
  
              return selectedElement;
          });
  
          //addFlexContainerProps(selectedElement);
          addFlexProps(selectedElement);
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
  
      //function pushReplacePopHandler(element) {
      //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
      //
      //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
      //        element.value = GS.qryGetVal(strQueryString, strQSCol);
      //    }
      //}
      function saveDefaultAttributes(element) {
          var i;
          var len;
          var arrAttr;
          var jsnAttr;
  
          // we need a place to store the attributes
          element.internal.defaultAttributes = {};
  
          // loop through attributes and store them in the internal defaultAttributes object
          arrAttr = element.attributes;
          i = 0;
          len = arrAttr.length;
          while (i < len) {
              jsnAttr = arrAttr[i];
  
              element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
  
              i += 1;
          }
      }
  
      function pushReplacePopHandler(element) {
          var i;
          var len;
          var strQS = GS.getQueryString();
          var strQSCol = element.getAttribute('qs');
          var strQSValue;
          var strQSAttr;
          var arrQSParts;
          var arrAttrParts;
          var strOperator;
  
          if (strQSCol.indexOf('=') !== -1) {
              arrAttrParts = strQSCol.split(',');
              i = 0;
              len = arrAttrParts.length;
              while (i < len) {
                  strQSCol = arrAttrParts[i];
  
                  if (strQSCol.indexOf('!=') !== -1) {
                      strOperator = '!=';
                      arrQSParts = strQSCol.split('!=');
                  } else {
                      strOperator = '=';
                      arrQSParts = strQSCol.split('=');
                  }
  
                  strQSCol = arrQSParts[0];
                  strQSAttr = arrQSParts[1] || arrQSParts[0];
  
                  // if the key is not present or we've got the negator: go to the attribute's default or remove it
                  if (strOperator === '!=') {
                      // if the key is not present: add the attribute
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          element.setAttribute(strQSAttr, '');
                      // else: remove the attribute
                      } else {
                          element.removeAttribute(strQSAttr);
                      }
                  } else {
                      // if the key is not present: go to the attribute's default or remove it
                      if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                          if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                              element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                          } else {
                              element.removeAttribute(strQSAttr);
                          }
                      // else: set attribute to exact text from QS
                      } else {
                          element.setAttribute(strQSAttr, (
                              GS.qryGetVal(strQS, strQSCol) ||
                              element.internal.defaultAttributes[strQSAttr] ||
                              ''
                          ));
                      }
                  }
                  i += 1;
              }
          } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
              strQSValue = GS.qryGetVal(strQS, strQSCol);
  
              if (element.internal.bolQSFirstRun !== true) {
                  if (strQSValue !== '' || !element.getAttribute('value')) {
                      element.setAttribute('value', strQSValue);
                  }
              } else {
                  element.value = strQSValue;
              }
          }
  
          element.internal.bolQSFirstRun = true;
      }
  
      // dont do anything that modifies the element here
      function elementCreated(element) {
          // if "created" hasn't been suspended: run created code
          if (!element.hasAttribute('suspend-created')) {
  
          }
      }
  
      //
      function elementInserted(element) {
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  element.internal = {};
                  saveDefaultAttributes(element);
  
                  if (!evt.touchDevice) {
                      element.addEventListener(evt.mousedown, function (event) {
                          element.classList.add('down');
                      });
                      
                      element.addEventListener(evt.mouseout, function (event) {
                          element.classList.remove('down');
                          element.classList.remove('hover');
                      });
                      
                      element.addEventListener(evt.mouseover, function (event) {
                          element.classList.remove('down');
                          element.classList.add('hover');
                      });
                      
                      element.addEventListener('keydown', function (event) {
                          if (!element.hasAttribute('disabled') && !element.classList.contains('down') &&
                              (event.keyCode === 13 || event.keyCode === 32)) {
                              
                              element.classList.add('down');
                          }
                      });
                      
                      element.addEventListener('keyup', function (event) {
                          // if we are not disabled and we pressed return (13) or space (32): trigger click
                          if (!element.hasAttribute('disabled') && element.classList.contains('down') &&
                              (event.keyCode === 13 || event.keyCode === 32)) {
                              GS.triggerEvent(element, 'click');
                          }
                      });
                  }
                  
  
                  // add a tabindex to allow focus
                  if (!element.hasAttribute('tabindex')) {
                      element.tabIndex = 0;
                  }
  
                  if (typeof element.getAttribute('value') === 'string') {
                      if (element.getAttribute('value') === 'true' || element.getAttribute('value') === '-1') {
                          element.setAttribute('selected', '');
                      }
                  }
  
                  // handle "qs" attribute
                  if (element.getAttribute('qs')) {
                      //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                      //if (strQSValue !== '' || !element.getAttribute('value')) {
                      //    element.value = strQSValue;
                      //}
                      pushReplacePopHandler(element);
                      window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                      window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                      window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                  }
              }
          }
      }
      
      xtag.register('gs-toggle', {
          lifecycle: {
              created: function () {
                  // if the value was set before the "created" lifecycle code runs: set attribute
                  //      (discovered when trying to set a value of a date control in the after_open of a dialog)
                  //      ("delete" keyword added because of firefox)
                  if (this.value) {
                      this.setAttribute('value', this.value);
                      delete this.value;
                      //this.value = null;
                  }
                  
                  elementCreated(this);
              },
              
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-created" has been removed: run created and inserted code
                  if (strAttrName === 'suspend-created' && newValue === null) {
                      elementCreated(this);
                      elementInserted(this);
                      
                  // if "suspend-inserted" has been removed: run inserted code
                  } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      // attribute code
                  }
              }
          },
          events: {
              'click': function (event) {
                  if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      this.classList.remove('down');
                      
                      if (this.hasAttribute('selected')) {
                          this.removeAttribute('selected');
                          
                          if (this.getAttribute('value') === 'true') {
                              this.setAttribute('value', 'false');
                          } else if (this.getAttribute('value') === '-1') {
                              this.setAttribute('value', '0');
                          }
                          
                      } else {
                          this.setAttribute('selected', '');
                          
                          if (this.getAttribute('value') === 'false') {
                              this.setAttribute('value', 'true');
                          } else if (this.getAttribute('value') === '0') {
                              this.setAttribute('value', '-1');
                          }
                      }
                      
                      xtag.fireEvent(this, 'change', {
                          bubbles: true,
                          cancelable: true
                      });
                  }
              }
          },
          accessors: {
              'value': {
                  'get': function () {
                      return this.hasAttribute('selected'); //this.classList.contains('down');
                  },
                  
                  'set': function (newValue) {
                      if (newValue === true || newValue === 'true') {
                          this.setAttribute('selected', '');
                      } else {
                          this.removeAttribute('selected');
                      }
                  }
              },
              
              'textValue': {
                  'get': function () {
                      return this.hasAttribute('selected') ? 'YES' : 'NO';
                  },
                  
                  'set': function (newValue) {
                      if (newValue === true || newValue === 'true' || newValue === 'YES') {
                          this.setAttribute('selected', '');
                      } else {
                          this.removeAttribute('selected');
                      }
                  }
              }
          },
          methods: {
              
          }
      });
  });
  window.addEventListener('design-register-element', function () {
      'use strict';
      
      //registerDesignSnippet('<gs-checkbox>', '<gs-checkbox>', 'gs-checkbox value="0" column="${1:ready_to_ship}">${2}</gs-checkbox>');
      
      designRegisterElement('gs-tutorial', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-tutorial.html');
      
      window.designElementProperty_GSTUTORIAL = function (selectedElement) {
          addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
              return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
          });
      };
  });
  
  document.addEventListener('DOMContentLoaded', function () {
      'use strict';
      
      function closeCurrentPopup(element) {
          var popupElement = element.currentPopup;
          
          // run before-close code if there is any
          if (popupElement.strBeforeClose) {
              new Function(popupElement.strBeforeClose).apply(element);
          }
          
          // remove overlay if there is one
          if (popupElement.relatedOverlay) {
              document.body.removeChild(popupElement.relatedOverlay);
          }
          
          // remove popup element
          document.body.removeChild(popupElement);
      }
      
      function openPopup(element, templateElement, intTemplateNumber, intNumberOfTemplates) {
          var strTargetSelector = (templateElement.getAttribute('target') || '')
            , strDirectionRequest = (templateElement.getAttribute('direction') || 'down')
            , intMaxWidthAttribute = parseInt((templateElement.getAttribute('max-width') || '9999999'), 10)
            , strBeforeOpen = templateElement.getAttribute('before-open')
            , strBeforeClose = templateElement.getAttribute('before-close')
            , strHTML, arrElements, elementTarget, arrTests, popupElement, overlayElement, arrowElement
            , positionHandlingFunction, buttonElement, i, len;
          
          // make the template a copy so that we can alter it safely
          templateElement = templateElement.cloneNode(true);
          
          // run before-open code if there is any
          if (strBeforeOpen) {
              new Function(strBeforeOpen).apply(element);
          }
          
          // get html from template
          strHTML = (templateElement.innerHTML || '');
          
          // add next, previous and skip buttons
          
          // if first and only
          if (intTemplateNumber === 1 && intNumberOfTemplates === 1) {
              strHTML += ml(function () {/*
                              <div class="popup-control-bar">
                                  <gs-button class="button-close" inline icononly icon="times"></gs-button>
                              </div>
                          */});
          // if first
          } else if (intTemplateNumber === 1 && intNumberOfTemplates > 1) {
              strHTML += ml(function () {/*
                              <div class="popup-control-bar">
                                  <gs-button class="button-right" inline icononly icon="arrow-right" remove-left></gs-button>
                                  <gs-button class="button-close" inline icononly icon="times" remove-right></gs-button>
                              </div>
                          */});
          // if middle
          } else if (intTemplateNumber > 1 && intNumberOfTemplates > intTemplateNumber) {
              strHTML += ml(function () {/*
                              <div class="popup-control-bar">
                                  <gs-button class="button-right" inline icononly icon="arrow-right" remove-left></gs-button>
                                  <gs-button class="button-close" inline icononly icon="times" remove-all></gs-button>
                                  <gs-button class="button-left" inline icononly icon="arrow-left" remove-right></gs-button>
                              </div>
                          */});
          // if last
          } else { //if (intNumberOfTemplates === intTemplateNumber) {
              strHTML += ml(function () {/*
                              <div class="popup-control-bar">
                                  <gs-button class="button-close" inline icononly icon="times" remove-left></gs-button>
                                  <gs-button class="button-left" inline icononly icon="arrow-left" remove-right></gs-button>
                              </div>
                          */});
          }
          
          // if a selector was provided: get the instruction target
          if (strTargetSelector) {
              try {
                  arrElements = xtag.toArray(document.querySelectorAll(strTargetSelector));
              } catch (e) {}
              
              arrElements = arrElements || [];
              
              if (arrElements.length > 1) {
                  console.warn('gs-tutorial Warning: More than one element matched with selector \'' + strTargetSelector + '\'.');
              }
              
              if (arrElements.length === 0) {
                  console.warn('gs-tutorial Warning: No elements matched with selector \'' + strTargetSelector + '\'.');
                  
              } else {
                  elementTarget = arrElements[0];
              }
          }
          
          // make strDirectionRequest lowercase
          strDirectionRequest.toLowerCase();
          
          // if the direction does not match any valid direction: set direction to down and warn
          if (!strDirectionRequest.match(/^up$|^down$|^left$|^right$/)) {
              console.warn('gs-tutorial Warning: ' +
                                  'Direction \'' + strDirectionRequest + '\' not recognized. ' +
                                  'Please use \'up\', \'down\', \'left\', \'right\'. Defaulting to \'down\'.');
              strDirectionRequest = 'down';
          }
          
          // order of tests depending direction request
          if (strDirectionRequest === 'up') { // up: up, down, left, right, full
              arrTests = ['up', 'down', 'left', 'right'];
              
          } else if (strDirectionRequest === 'down') { // down: down, up, left, right, full
              arrTests = ['down', 'up', 'left', 'right'];
              
          } else if (strDirectionRequest === 'left') { // left: left, right, down, up, full
              arrTests = ['left', 'right', 'down', 'up'];
              
          } else if (strDirectionRequest === 'right') { // right: right, left, down, up, full
              arrTests = ['right', 'left', 'down', 'up'];
          }
          
          // create popup, overlay and arrow
          popupElement = document.createElement('gs-tutorial-popup');
          
          overlayElement = document.createElement('gs-tutorial-overlay');
          
          arrowElement = document.createElement('div');
          arrowElement.classList.add('connection-arrow');
          
          // append overlay then the popup so that they can have the same z-index and the popup will be over the overlay
          //      the reason why all of the overlays and all of the popups need the same z-index is because say for example
          //      the overlays had a z-index of '1' and the popups had a z-index of '2' if we had two popups open and the
          //      first one was bigger than the second one than you would be able to see the first popup without an overlay
          //      in from of it and potentially you would be able to interact with the first popup without dealing with the
          //      second popup.
          document.body.appendChild(overlayElement);
          document.body.appendChild(popupElement);
          
          // link the popup to it's overlay so that when we close the popup we can also remove the popup overlay
          popupElement.relatedOverlay = overlayElement;
          
          // link the popup to it's before-close so that before we close the popup we can run any code inside the before-close
          popupElement.strBeforeClose = strBeforeClose;
          
          // fill popup
          popupElement.innerHTML = strHTML;
          popupElement.appendChild(arrowElement);
          
          // bind next, previous and skip buttons
          buttonElement = xtag.query(popupElement, '.popup-control-bar > .button-left')[0];
          if (buttonElement) {
              buttonElement.addEventListener('click', function () {
                  element.backward();
              });
          }
          
          buttonElement = xtag.query(popupElement, '.popup-control-bar > .button-close')[0];
          if (buttonElement) {
              buttonElement.addEventListener('click', function () {
                  element.end();
              });
          }
          
          buttonElement = xtag.query(popupElement, '.popup-control-bar > .button-right')[0];
          if (buttonElement) {
              buttonElement.addEventListener('click', function () {
                  element.forward();
              });
          }
          
          // bind the overlay
          overlayElement.addEventListener('click', function () {
              element.forward();
          });
          
          // create a positioning function: this is so that we can refresh the popup's position from several different events
          positionHandlingFunction = function () {
              var intTemp, intMaxWidth, intMaxHeight, intResolvedWidth, intResolvedHeight
                , jsnPositionData, strResolvedDirection, intPopupMidPoint, intElementMidPoint
                , intMargin = 10, intArrow = 5, intPopupTop, intPopupLeft, intArrowLeft, intArrowTop;
              
              // if the dialog is not in the DOM: unbind and skip the contents of the function using return
              if (popupElement.parentNode !== document.body) {
                  window.removeEventListener('resize', positionHandlingFunction);
                  window.removeEventListener('orientationchange', positionHandlingFunction);
                  return;
              }
              
              // save scroll numbers
              popupElement.oldScrollTop = popupElement.scrollTop;
              popupElement.oldScrollLeft = popupElement.scrollLeft;
              
              // clear arrow direction
              popupElement.classList.remove('up');
              popupElement.classList.remove('down');
              popupElement.classList.remove('left');
              popupElement.classList.remove('right');
              
              // clear popup and arrow css
              popupElement.setAttribute('style', '');
              arrowElement.setAttribute('style', '');
              
              // find the closest balance of width and height (using the window width as a max width)
              if ((popupElement.offsetHeight + popupElement.offsetWidth) < 300) {
                  intTemp = 300;
              } else {
                  intTemp = ((popupElement.offsetHeight + popupElement.offsetWidth) / 2);
              }
              intMaxWidth = (intTemp < window.innerWidth ? intTemp : window.innerWidth - (intMargin * 2));
              
              if (intMaxWidth > intMaxWidthAttribute) {
                  intMaxWidth = intMaxWidthAttribute;
              }
              
              // find the maximum height (must be less than half on touch devices and less than a third on everything else)
              if (evt.touchDevice) {
                  intMaxHeight = Math.floor(window.innerHeight / 2) - (intMargin * 2);
                  
              } else {
                  intMaxHeight = Math.floor(window.innerHeight / 3) - (intMargin * 2);
              }
              
              // apply calculated max dimensions
              popupElement.style.maxWidth = intMaxWidth + 'px';
              popupElement.style.maxHeight = intMaxHeight + 'px';
              
              // get resolved dimensions
              intResolvedWidth = popupElement.offsetWidth;
              intResolvedHeight = popupElement.offsetHeight;
              
              // if there is a target: run through tests
              if (elementTarget) {
                  // get target position data
                  jsnPositionData = GS.getElementPositionData(elementTarget);
                  
                  //console.log(intResolvedHeight,
                  //            intResolvedWidth,
                  //            jsnPositionData.intRoomAbove,
                  //            jsnPositionData.intRoomBelow,
                  //            jsnPositionData.intRoomLeft,
                  //            jsnPositionData.intRoomRight);
                  
                  // up: compare room above to popup resolved height
                  //      pass: display
                  //      fail: next test
                  for (i = 0, len = arrTests.length; i < len; i += 1) {
                      if ((arrTests[i] ===    'up' && (intResolvedHeight + intMargin + intArrow) <= jsnPositionData.intRoomAbove) ||
                          (arrTests[i] ===  'down' && (intResolvedHeight + intMargin + intArrow) <= jsnPositionData.intRoomBelow) ||
                          (arrTests[i] ===  'left' && ( intResolvedWidth + intMargin + intArrow) <= jsnPositionData.intRoomLeft) ||
                          (arrTests[i] === 'right' && ( intResolvedWidth + intMargin + intArrow) <= jsnPositionData.intRoomRight)) {
                          strResolvedDirection = arrTests[i];
                          break;
                      }
                  }
                  
                  // if we could not resolve to a particular direction: position in the middle
                  strResolvedDirection = strResolvedDirection || 'middle';
                  
              // else: center on screen
              } else {
                  strResolvedDirection = 'middle';
              }
              
              //console.log(strDirectionRequest, strResolvedDirection);
              
              // if up or down: get as close to horizontally centered on the element as possible
              if (strResolvedDirection === 'up' || strResolvedDirection === 'down') {
                  intElementMidPoint = (jsnPositionData.intElementLeft + (jsnPositionData.intElementWidth / 2));
                  intPopupMidPoint = (intResolvedWidth / 2);
                  //console.log(intElementMidPoint, jsnPositionData.left, jsnPositionData.intElementWidth);
                  
                  // if centered goes past intMargin of the left edge of the screen: go to intMargin from the bottom
                  if (intElementMidPoint - intPopupMidPoint < intMargin) {
                      intPopupLeft = intMargin;
                      
                      //console.log('1***', intMargin);
                      
                  // else if centered goes past intMargin of the right edge of the screen: go to intMargin less than the width of the viewport
                  } else if (intElementMidPoint + intPopupMidPoint > window.innerWidth - intMargin) {
                      intPopupLeft = ((window.innerWidth - intResolvedWidth) - intMargin);
                      //console.log('2***', window.innerWidth, intResolvedWidth, intMargin);
                      
                  // else centered does not go past intMargin of either edge of the screen: center
                  } else {
                      intPopupLeft = (intElementMidPoint - intPopupMidPoint);
                      //console.log('3***', intElementMidPoint, intPopupMidPoint, (intElementMidPoint - intPopupMidPoint) + 'px');
                  }
                  
                  // move the arrow to be pointing at the midopoint of the target
                  intArrowLeft = (intElementMidPoint - intPopupLeft);
                  
                  // if the midpoint of the target is really close the left of the screen: add extreme-left class to the popup
                  //console.log(intElementMidPoint, intMargin, intArrow);
                  if (intElementMidPoint <= (intMargin + Math.round(intArrow / 2) + 5)) {
                      popupElement.classList.add('extreme-left');
                  }
                  
                  // if the midpoint of the target is really close the right of the screen: add extreme-right class to the popup
                  //console.log(intElementMidPoint, window.innerWidth, intMargin, Math.round(intArrow / 2));
                  if (intElementMidPoint >= (((window.innerWidth - intMargin) - Math.round(intArrow / 2)) - 5)) {
                      popupElement.classList.add('extreme-right');
                  }
                  
              // else if left or right: get as close to vertically centered next to the element as possible
              } else if (strResolvedDirection === 'left' || strResolvedDirection === 'right') {
                  intElementMidPoint = (jsnPositionData.intElementTop + (jsnPositionData.intElementHeight / 2));
                  intPopupMidPoint = (intResolvedHeight / 2);
                  
                  //console.log('0***', intElementMidPoint, intPopupMidPoint, window.innerHeight, intMargin, intDialogResolvedHeight);
                  
                  // if centered goes past intMargin of the top edge of the screen: go to intMargin from the bottom
                  if (intElementMidPoint - intPopupMidPoint < intMargin) {
                      intPopupTop = intMargin;
                      //console.log('1***', intMargin);
                      
                  // else if centered goes past intMargin of the bottom edge of the screen: go to intMargin less than the height of the viewport
                  } else if (intElementMidPoint + intPopupMidPoint > window.innerHeight - intMargin) {
                      intPopupTop = ((window.innerHeight - intResolvedHeight) - intMargin);
                      //console.log('2***', window.innerHeight, intResolvedHeight, intMargin);
                      
                  // else centered does not go past intMargin of either edge of the screen: center
                  } else {
                      intPopupTop = (intElementMidPoint - intPopupMidPoint);
                      //console.log('3***', intElementMidPoint, intPopupMidPoint, (intElementMidPoint - intPopupMidPoint) + 'px');
                  }
                  
                  intArrowTop = (intElementMidPoint - intPopupTop);
                  
                  // if the midpoint of the target is really close the left of the screen: add extreme-left class to the popup
                  if (intElementMidPoint <= (intMargin + Math.round(intArrow / 2) + 5)) {
                      popupElement.classList.add('extreme-up');
                  }
                  
                  // if the midpoint of the target is really close the right of the screen: add extreme-right class to the popup
                  if (intElementMidPoint >= (((window.innerHeight - intMargin) - Math.round(intArrow / 2)) - 5)) {
                      popupElement.classList.add('extreme-down');
                  }
                  
              // else full: use dialog logic to get width and height and center both vertically and horizontally
              } else {
                  intPopupTop = (window.innerHeight / 2) - (intResolvedHeight / 2);
                  intPopupLeft = (window.innerWidth / 2) - (intResolvedWidth / 2);
              }
              
              // if direction is up: connect the bottom of the dialog to the top of the element
              if (strResolvedDirection === 'up') {
                  intPopupTop = (jsnPositionData.intElementTop - intResolvedHeight) - intArrow;
                  
              // if direction is down: connect the top of the dialog to the bottom of the element
              } else if (strResolvedDirection === 'down') {
                  intPopupTop = (jsnPositionData.intElementTop + jsnPositionData.intElementHeight) + intArrow;
                  
              // if direction is left: connect the right of the dialog to the left of the element
              } else if (strResolvedDirection === 'left') {
                  intPopupLeft = (jsnPositionData.intElementLeft - intResolvedWidth) - intArrow;
                  
              // if direction is right: connect the left of the dialog to the right of the element
              } else if (strResolvedDirection === 'right') {
                  intPopupLeft = (jsnPositionData.intElementLeft + jsnPositionData.intElementWidth) + intArrow;
              }
              
              // prevent the dialog from vertically going outside the viewport
              if (intPopupTop + intResolvedWidth > window.innerHeight) {
                  intPopupTop -= (intPopupTop + intResolvedWidth) - window.innerHeight;
              }
              
              // prevent the dialog from horizontally going outside the viewport
              if (intPopupLeft + intResolvedWidth > window.innerWidth) {
                  intPopupLeft -= (intPopupLeft + intResolvedWidth) - window.innerWidth;
              }
              
              // apply CSS to the popup
              //console.log(intPopupTop, intPopupLeft);
              popupElement.style.top  = intPopupTop + 'px';
              popupElement.style.left = intPopupLeft + 'px';
              
              // handle arrow
              if (strResolvedDirection !== 'middle') {
                  popupElement.classList.add(strResolvedDirection);
                  
                  // apply CSS to the arrow
                  if (intArrowLeft) {
                      arrowElement.style.left = intArrowLeft + 'px';
                  }
                  if (intArrowTop) {
                      arrowElement.style.top = intArrowTop + 'px';
                  }
              }
          };
          
          // run position handling function and bind to run it every window resize or re-orientation
          positionHandlingFunction();
          window.addEventListener('resize', positionHandlingFunction);
          window.addEventListener('orientationchange', positionHandlingFunction);
          
          element.currentPopup = popupElement;
      }
      
      
      // this runs code on the first inserted lifecycle call
      function elementInserted(element) {
          
          // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
          if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
              // if this is the first time inserted has been run: continue
              if (!element.inserted) {
                  element.inserted = true;
                  
              }
          }
      }
      
      xtag.register('gs-tutorial', {
          lifecycle: {
              inserted: function () {
                  elementInserted(this);
              },
              
              attributeChanged: function (strAttrName, oldValue, newValue) {
                  // if "suspend-inserted" or "suspend-created" has been removed: run inserted code
                  if ((strAttrName === 'suspend-created' || strAttrName === 'suspend-created') && newValue === null) {
                      elementInserted(this);
                      
                  } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                      // attribute code
                  }
              }
          },
          events: {},
          accessors: {},
          methods: {
              'start': function () {
                  var strBeforeStart = this.getAttribute('before-start'),
                      arrElement = xtag.queryChildren(this, 'template');
                  
                  // if there are no templates: warning
                  if (arrElement.length === 0) {
                      console.warn('gs-tutorial Warning: No popup templates provided.' +
                                      ' Please consult the documention if you need info on how to use the gs-tutorial element.');
                      
                  // if there are non-template children: warning
                  } else if (this.children.length !== arrElement.length) {
                      console.warn('gs-tutorial Warning: Invalid element' + ((this.children.length - arrElement.length) === 1 ? '' : 's') + '.' +
                                      ' The gs-tutorial element only accepts template elements for it\'s children.');
                  }
                  
                  // read first template
                  this.currentIndex = 0;
                  if (arrElement[this.currentIndex]) {
                      if (strBeforeStart) {
                          new Function(strBeforeStart).apply(this);
                      }
                      
                      openPopup(this, arrElement[this.currentIndex], (this.currentIndex + 1), arrElement.length);
                  }
              },
              
              'end': function () {
                  var strBeforeEnd = this.getAttribute('before-end');
                  
                  if (strBeforeEnd) {
                      new Function(strBeforeEnd).apply(this);
                  }
                  
                  if (this.currentPopup) {
                      closeCurrentPopup(this);
                  }
              },
              
              'forward': function () {
                  var arrElement = xtag.queryChildren(this, 'template');
                  
                  this.currentIndex += 1;
                  if (arrElement[this.currentIndex]) {
                      if (this.currentPopup) {
                          closeCurrentPopup(this);
                      }
                      
                      openPopup(this, arrElement[this.currentIndex], (this.currentIndex + 1), arrElement.length);
                  } else {
                      this.end();
                  }
              },
              
              'backward': function () {
                  var arrElement = xtag.queryChildren(this, 'template');
                  
                  if (this.currentPopup) {
                      closeCurrentPopup(this);
                  }
                  
                  this.currentIndex -= 1;
                  if (arrElement[this.currentIndex]) {
                      if (this.currentPopup) {
                          closeCurrentPopup(this);
                      }
                      
                      openPopup(this, arrElement[this.currentIndex], (this.currentIndex + 1), arrElement.length);
                  }
              },
              
              'reposition': function () {
                  
              }
          }
      });
  });