//jslint white:true
/**
    
    ######## BEFORE UPDATING DATA-HANDLING CODE OR USING THE COALESCE OPERATOR: ######## ~michael
    don't use the pipe-pipe "||" coalesce operator when handling data because if a zero comes to the coalesce (and it is a number 0 and not a string "0") it will be evaluated as false and thus coalesce to the next operand. Whenever you use this operator: be careful of what will be evaluated.
    
    To see this in action run this in your console:
    
    console.log( true      || 'test' );  // logs:  true  (expected)
    console.log( false     || 'test' );  // logs: 'test' (expected)

    console.log( null      || 'test' );  // logs: 'test' (expected)
    console.log( undefined || 'test' );  // logs: 'test' (expected)

    console.log( '1'       || 'test' );  // logs: '1'    (expected)
    console.log(  1        || 'test' );  // logs:  1     (expected)
    console.log( '0'       || 'test' );  // logs: '0'    (expected)
    console.log(  0        || 'test' );  // logs: 'test' (OH NO!!)
    
    here is another demonstration:
    
    console.log( Boolean(true)      );
    console.log( Boolean(false)     );
    console.log( Boolean(null)      );
    console.log( Boolean(undefined) );
    console.log( Boolean('1')       );
    console.log( Boolean( 1)        );
    console.log( Boolean('0')       );
    console.log( Boolean( 0)        ); // zero evaluates to false
    
    
    ######## BEFORE UPDATING FASTCLICK: ######## ~michael
    fastclick (around line 254) has some code added (by michael) to add a feature to fastclick, bring this code to any new version
    
    it also has (around line 123) some code added to an if statement added by joseph:
        if (deviceIsAndroid || deviceIsIOS) {
    as opposed to:
        if (deviceIsAndroid) {
    
    
    ######## BEFORE UPDATING X-TAGS: ######## ~michael
    make sure you include the polyfills and make sure that there isn't still a duplicated block of code in the source, if there is remove it, here is how to find out:
    
    do a find in textedit for: "scope.upgradeDocumentTree = nop;" (excluding the quotes of course)
    AND var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE
    
    remove the whole block of code surrounding the second match (it might be the first match but I think it is the second match)
    
    
    ######## ELEMENT REGISTRATION: ######## ~michael
    When registering a custom element:
        1) register it after the "DOMContentLoaded" event has fired. Doing this prevents an issue that we ran into where in some cases (I believe when greyspots.js is cached and you are on yosemite is one case) some elements would be cut off and would disappear.
        2) Use the "methods" for public functions only, private functions should be kept in the "DOMContentLoaded" function. By keeping the functions in there it makes it so that the code for that element is the only code that can run those functions and it prevents these functions for cluttering public namespaces.
        3) Use "'use strict';" from the beginning. If you don't start out with it you might introduce strict mode errors that you don't even know about. Then one day you might decide to put "'use strict';" in there and errors you didn't know about will appear. Some errors might appear when you first move it over and some errors might be disvovered by your users because you didn't test every little feature of the element.
    
    An example:
    
    document.addEventListener('DOMContentLoaded', function () {
        'use strict';
        
        // ### private functions go here ###
        function foobar() {
            // do stuff to "element" here (gs-new-element is the only element that can run this function)
        }
        
        xtag.register('gs-new-element', {
            lifecycle: {
                'created': function () {
                    
                }
            },
            events: {},
            accessors: {},
            methods: {
                // ### public functions go here ###
            }
        });
    });
    
    ######## PSEUDO ELEMENT WARNING: ######## ~michael
    In firefox I ran into an issue where the undo history of controls in a gs-form (with the attribute "save-while-typing") was being erased. Turns out the issue was caused by a CSS pseudo-element. I was using a pseudo-element for a little box attached to the form to tell the user if the form was waiting to save or saving. By changing the pseudo-element to a real element that I add and remove with Javascript the issue was fixed.
    
    If you want to use a pseudo-element: make sure it doesn't affect the undo history of elements that are children of the element that the pseudo-element is attached to. This issue could have been fixed by now.
    
    
    
    ######## TEMPLATE SHIM: ######## ~michael
    The template polyfill has been changed, DO NOT UPDATE. It is for old browsers, and old browsers don't change so there is should be no need for the polyfill to change.
    
*//**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// minimal template polyfill
if (typeof HTMLTemplateElement === 'undefined') {
  (function() {

    var TEMPLATE_TAG = 'template';

    var contentDoc = document.implementation.createHTMLDocument('template');

    /**
      Provides a minimal shim for the <template> element.
    */
    HTMLTemplateElement = function() {};
    HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);

    /**
      The `decorate` method moves element children to the template's `content`.
      NOTE: there is no support for dynamically adding elements to templates.
    */
    HTMLTemplateElement.decorate = function(template) {
        if (!template.content) {
            template.content = template.ownerDocument.createDocumentFragment();
        }
        var child;
        while (child = template.firstChild) {
            template.content.appendChild(child);
        }
        
        if (!template.content.children) {
            Object.defineProperty(template.content, 'children', {
                get: function() {
                    'use strict';
                    var arrChildren = [], i, len, childNodes = this.childNodes;
                    
                    for (i = 0, len = childNodes.length; i < len; i += 1) {
                        if (childNodes[i].nodeType !== 3) {
                            arrChildren.push(childNodes[i]);
                        }
                    }
                    
                    return arrChildren;
                },
                configurable: true
            });
        }
        
        //HTMLTemplateElement.bootstrap(template.content);
        
        //console.log(template.content);
        
        // add innerHTML to template
        Object.defineProperty(template, 'innerHTML', {
            get: function() {
                var o = '', fragment = this.content.cloneNode(true);//,
                    //templates = xtag.toArray(fragment.querySelectorAll(TEMPLATE_TAG)), i, l;
                
                //for (i = 0, l = templates.length; i < l; i += 1) {
                //    templates[i].outerHTML = templates[i].outerHTML;
                //    console.log(templates[i].outerHTML);
                //}
                
                for (var e = fragment.firstChild; e; e = e.nextSibling) {
                    o += e.outerHTML || escapeData(e.data);
                }
                
                //console.log(o);
                
                return o;
            },
            set: function(text) {
                contentDoc.body.innerHTML = text;
                
                while (this.content.firstChild) {
                    this.content.removeChild(this.content.firstChild);
                }
                while (contentDoc.body.firstChild) {
                    this.content.appendChild(contentDoc.body.firstChild);
                }
                //HTMLTemplateElement.bootstrap(this.content);
            },
            configurable: true
            //writable: true
        });
      
        // add outerHTML to template
        Object.defineProperty(template, 'outerHTML', {
            get: function () {
                var openTagText, arrAttr, i, len, innerHTML = this.innerHTML;
                
                arrAttr = this.attributes;
                
                for (i = 0, len = arrAttr.length, openTagText = '<template'; i < len; i += 1) { // >
                    openTagText += ' ' + arrAttr[i].nodeName + '="' + encodeHTML(arrAttr[i].value) + '"';
                }
                
                return openTagText + '>' + innerHTML + '</template>';
            },
            configurable: true
            //writable: true
        });
    };

    /**
      The `bootstrap` method is called automatically and "fixes" all
      <template> elements in the document referenced by the `doc` argument.
    */
    HTMLTemplateElement.bootstrap = function(doc) {
        var templates = doc.querySelectorAll(TEMPLATE_TAG), i, l, t;
        
        for (i = 0, l = templates.length, t; (i < l) && (t = templates[i]); i += 1) {
            if (!GS.findParentTag(t, 'template') && GS.findParentTag(t, 'html')) {
                HTMLTemplateElement.decorate(t);
            }
        }
    };

    // auto-bootstrapping for main document
    window.addEventListener('DOMContentLoaded', function() {
      HTMLTemplateElement.bootstrap(document);
    });

    // Patch document.createElement to ensure newly created templates have content
    var createElement = document.createElement;
    document.createElement = function() {
      'use strict';
      var el = createElement.apply(document, arguments);
      if (el.localName == 'template') {
        HTMLTemplateElement.decorate(el);
      }
      return el;
    };

    var escapeDataRegExp = /[&\u00A0<>]/g;

    function escapeReplace(c) {
      switch (c) {
        case '&':
          return '&amp;';
        case '<':
          return '&lt;';
        case '>':
          return '&gt;';
        case '\u00A0':
          return '&nbsp;';
      }
    }

    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  })();
}// Use the following link, THEN uncheck "minify", THEN click build, THEN click download. 

/* http://x-tags.org/download?byob=,x-tag-core,x-tag-pseudo-outer,WeakMap,MutationObserver,domtokenlist-polyfill,customelements-polyfill */ 
window.Platform = {};

var logFlags = {};

(function() {
    if (typeof window.Element === "undefined" || "classList" in document.documentElement) return;
    var prototype = Array.prototype, indexOf = prototype.indexOf, slice = prototype.slice, push = prototype.push, splice = prototype.splice, join = prototype.join;
    function DOMTokenList(el) {
        this._element = el;
        if (el.className != this._classCache) {
            this._classCache = el.className;
            if (!this._classCache) return;
            var classes = this._classCache.replace(/^\s+|\s+$/g, "").split(/\s+/), i;
            for (i = 0; i < classes.length; i++) {
                push.call(this, classes[i]);
            }
        }
    }
    function setToClassName(el, classes) {
        el.className = classes.join(" ");
    }
    DOMTokenList.prototype = {
        add: function(token) {
            if (this.contains(token)) return;
            push.call(this, token);
            setToClassName(this._element, slice.call(this, 0));
        },
        contains: function(token) {
            return indexOf.call(this, token) !== -1;
        },
        item: function(index) {
            return this[index] || null;
        },
        remove: function(token) {
            var i = indexOf.call(this, token);
            if (i === -1) {
                return;
            }
            splice.call(this, i, 1);
            setToClassName(this._element, slice.call(this, 0));
        },
        toString: function() {
            return join.call(this, " ");
        },
        toggle: function(token) {
            if (indexOf.call(this, token) === -1) {
                this.add(token);
            } else {
                this.remove(token);
            }
        }
    };
    window.DOMTokenList = DOMTokenList;
    function defineElementGetter(obj, prop, getter) {
        if (Object.defineProperty) {
            Object.defineProperty(obj, prop, {
                get: getter
            });
        } else {
            obj.__defineGetter__(prop, getter);
        }
    }
    defineElementGetter(Element.prototype, "classList", function() {
        return new DOMTokenList(this);
    });
})();

if (typeof WeakMap === "undefined") {
    (function() {
        var defineProperty = Object.defineProperty;
        var counter = Date.now() % 1e9;
        var WeakMap = function() {
            this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
        };
        WeakMap.prototype = {
            set: function(key, value) {
                var entry = key[this.name];
                if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
                    value: [ key, value ],
                    writable: true
                });
            },
            get: function(key) {
                var entry;
                return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
            },
            "delete": function(key) {
                this.set(key, undefined);
            }
        };
        window.WeakMap = WeakMap;
    })();
}

(function(global) {
    var registrationsTable = new WeakMap();
    var setImmediate = window.msSetImmediate;
    if (!setImmediate) {
        var setImmediateQueue = [];
        var sentinel = String(Math.random());
        window.addEventListener("message", function(e) {
            if (e.data === sentinel) {
                var queue = setImmediateQueue;
                setImmediateQueue = [];
                queue.forEach(function(func) {
                    func();
                });
            }
        });
        setImmediate = function(func) {
            setImmediateQueue.push(func);
            window.postMessage(sentinel, "*");
        };
    }
    var isScheduled = false;
    var scheduledObservers = [];
    function scheduleCallback(observer) {
        scheduledObservers.push(observer);
        if (!isScheduled) {
            isScheduled = true;
            setImmediate(dispatchCallbacks);
        }
    }
    function wrapIfNeeded(node) {
        return  node;
    }
    function dispatchCallbacks() {
        isScheduled = false;
        var observers = scheduledObservers;
        scheduledObservers = [];
        observers.sort(function(o1, o2) {
            return o1.uid_ - o2.uid_;
        });
        var anyNonEmpty = false;
        observers.forEach(function(observer) {
            var queue = observer.takeRecords();
            removeTransientObserversFor(observer);
            if (queue.length) {
                observer.callback_(queue, observer);
                anyNonEmpty = true;
            }
        });
        if (anyNonEmpty) dispatchCallbacks();
    }
    function removeTransientObserversFor(observer) {
        observer.nodes_.forEach(function(node) {
            var registrations = registrationsTable.get(node);
            if (!registrations) return;
            registrations.forEach(function(registration) {
                if (registration.observer === observer) registration.removeTransientObservers();
            });
        });
    }
    function forEachAncestorAndObserverEnqueueRecord(target, callback) {
        for (var node = target; node; node = node.parentNode) {
            var registrations = registrationsTable.get(node);
            if (registrations) {
                for (var j = 0; j < registrations.length; j++) {
                    var registration = registrations[j];
                    var options = registration.options;
                    if (node !== target && !options.subtree) continue;
                    var record = callback(options);
                    if (record) registration.enqueue(record);
                }
            }
        }
    }
    var uidCounter = 0;
    function JsMutationObserver(callback) {
        this.callback_ = callback;
        this.nodes_ = [];
        this.records_ = [];
        this.uid_ = ++uidCounter;
    }
    JsMutationObserver.prototype = {
        observe: function(target, options) {
            target = wrapIfNeeded(target);
            if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
                throw new SyntaxError();
            }
            var registrations = registrationsTable.get(target);
            if (!registrations) registrationsTable.set(target, registrations = []);
            var registration;
            for (var i = 0; i < registrations.length; i++) {
                if (registrations[i].observer === this) {
                    registration = registrations[i];
                    registration.removeListeners();
                    registration.options = options;
                    break;
                }
            }
            if (!registration) {
                registration = new Registration(this, target, options);
                registrations.push(registration);
                this.nodes_.push(target);
            }
            registration.addListeners();
        },
        disconnect: function() {
            this.nodes_.forEach(function(node) {
                var registrations = registrationsTable.get(node);
                for (var i = 0; i < registrations.length; i++) {
                    var registration = registrations[i];
                    if (registration.observer === this) {
                        registration.removeListeners();
                        registrations.splice(i, 1);
                        break;
                    }
                }
            }, this);
            this.records_ = [];
        },
        takeRecords: function() {
            var copyOfRecords = this.records_;
            this.records_ = [];
            return copyOfRecords;
        }
    };
    function MutationRecord(type, target) {
        this.type = type;
        this.target = target;
        this.addedNodes = [];
        this.removedNodes = [];
        this.previousSibling = null;
        this.nextSibling = null;
        this.attributeName = null;
        this.attributeNamespace = null;
        this.oldValue = null;
    }
    function copyMutationRecord(original) {
        var record = new MutationRecord(original.type, original.target);
        record.addedNodes = original.addedNodes.slice();
        record.removedNodes = original.removedNodes.slice();
        record.previousSibling = original.previousSibling;
        record.nextSibling = original.nextSibling;
        record.attributeName = original.attributeName;
        record.attributeNamespace = original.attributeNamespace;
        record.oldValue = original.oldValue;
        return record;
    }
    var currentRecord, recordWithOldValue;
    function getRecord(type, target) {
        return currentRecord = new MutationRecord(type, target);
    }
    function getRecordWithOldValue(oldValue) {
        if (recordWithOldValue) return recordWithOldValue;
        recordWithOldValue = copyMutationRecord(currentRecord);
        recordWithOldValue.oldValue = oldValue;
        return recordWithOldValue;
    }
    function clearRecords() {
        currentRecord = recordWithOldValue = undefined;
    }
    function recordRepresentsCurrentMutation(record) {
        return record === recordWithOldValue || record === currentRecord;
    }
    function selectRecord(lastRecord, newRecord) {
        if (lastRecord === newRecord) return lastRecord;
        if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
        return null;
    }
    function Registration(observer, target, options) {
        this.observer = observer;
        this.target = target;
        this.options = options;
        this.transientObservedNodes = [];
    }
    Registration.prototype = {
        enqueue: function(record) {
            var records = this.observer.records_;
            var length = records.length;
            if (records.length > 0) {
                var lastRecord = records[length - 1];
                var recordToReplaceLast = selectRecord(lastRecord, record);
                if (recordToReplaceLast) {
                    records[length - 1] = recordToReplaceLast;
                    return;
                }
            } else {
                scheduleCallback(this.observer);
            }
            records[length] = record;
        },
        addListeners: function() {
            this.addListeners_(this.target);
        },
        addListeners_: function(node) {
            var options = this.options;
            if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
            if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
            if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
            if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
        },
        removeListeners: function() {
            this.removeListeners_(this.target);
        },
        removeListeners_: function(node) {
            var options = this.options;
            if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
            if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
            if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
            if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
        },
        addTransientObserver: function(node) {
            if (node === this.target) return;
            this.addListeners_(node);
            this.transientObservedNodes.push(node);
            var registrations = registrationsTable.get(node);
            if (!registrations) registrationsTable.set(node, registrations = []);
            registrations.push(this);
        },
        removeTransientObservers: function() {
            var transientObservedNodes = this.transientObservedNodes;
            this.transientObservedNodes = [];
            transientObservedNodes.forEach(function(node) {
                this.removeListeners_(node);
                var registrations = registrationsTable.get(node);
                for (var i = 0; i < registrations.length; i++) {
                    if (registrations[i] === this) {
                        registrations.splice(i, 1);
                        break;
                    }
                }
            }, this);
        },
        handleEvent: function(e) {
            e.stopImmediatePropagation();
            switch (e.type) {
              case "DOMAttrModified":
                var name = e.attrName;
                var namespace = e.relatedNode.namespaceURI;
                var target = e.target;
                var record = new getRecord("attributes", target);
                record.attributeName = name;
                record.attributeNamespace = namespace;
                var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
                forEachAncestorAndObserverEnqueueRecord(target, function(options) {
                    if (!options.attributes) return;
                    if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
                        return;
                    }
                    if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
                    return record;
                });
                break;

              case "DOMCharacterDataModified":
                var target = e.target;
                var record = getRecord("characterData", target);
                var oldValue = e.prevValue;
                forEachAncestorAndObserverEnqueueRecord(target, function(options) {
                    if (!options.characterData) return;
                    if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
                    return record;
                });
                break;

              case "DOMNodeRemoved":
                this.addTransientObserver(e.target);

              case "DOMNodeInserted":
                var target = e.relatedNode;
                var changedNode = e.target;
                var addedNodes, removedNodes;
                if (e.type === "DOMNodeInserted") {
                    addedNodes = [ changedNode ];
                    removedNodes = [];
                } else {
                    addedNodes = [];
                    removedNodes = [ changedNode ];
                }
                var previousSibling = changedNode.previousSibling;
                var nextSibling = changedNode.nextSibling;
                var record = getRecord("childList", target);
                record.addedNodes = addedNodes;
                record.removedNodes = removedNodes;
                record.previousSibling = previousSibling;
                record.nextSibling = nextSibling;
                forEachAncestorAndObserverEnqueueRecord(target, function(options) {
                    if (!options.childList) return;
                    return record;
                });
            }
            clearRecords();
        }
    };
    global.JsMutationObserver = JsMutationObserver;
    if (!global.MutationObserver) global.MutationObserver = JsMutationObserver;
})(this);

(function(scope) {
    if (!scope) {
        scope = window.CustomElements = {
            flags: {}
        };
    }
    var flags = scope.flags;
    var hasNative = Boolean(document.registerElement);
    var useNative = !flags.register && hasNative;
    if (useNative) {
        var nop = function() {};
        scope.registry = {};
        scope.upgradeElement = nop;
        scope.watchShadow = nop;
        scope.upgrade = nop;
        scope.upgradeAll = nop;
        scope.upgradeSubtree = nop;
        scope.observeDocument = nop;
        scope.upgradeDocument = nop;
        scope.upgradeDocumentTree = nop;
        scope.takeRecords = nop;
        scope.reservedTagList = [];
    } else {
        function register(name, options) {
            var definition = options || {};
            if (!name) {
                throw new Error("document.registerElement: first argument `name` must not be empty");
            }
            if (name.indexOf("-") < 0) {
                throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '" + String(name) + "'.");
            }
            if (isReservedTag(name)) {
                throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '" + String(name) + "'. The type name is invalid.");
            }
            if (getRegisteredDefinition(name)) {
                throw new Error("DuplicateDefinitionError: a type with name '" + String(name) + "' is already registered");
            }
            if (!definition.prototype) {
                throw new Error("Options missing required prototype property");
            }
            definition.__name = name.toLowerCase();
            definition.lifecycle = definition.lifecycle || {};
            definition.ancestry = ancestry(definition.extends);
            resolveTagName(definition);
            resolvePrototypeChain(definition);
            overrideAttributeApi(definition.prototype);
            registerDefinition(definition.__name, definition);
            definition.ctor = generateConstructor(definition);
            definition.ctor.prototype = definition.prototype;
            definition.prototype.constructor = definition.ctor;
            if (scope.ready) {
                scope.upgradeDocumentTree(document);
            }
            return definition.ctor;
        }
        function isReservedTag(name) {
            for (var i = 0; i < reservedTagList.length; i++) {
                if (name === reservedTagList[i]) {
                    return true;
                }
            }
        }
        var reservedTagList = [ "annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph" ];
        function ancestry(extnds) {
            var extendee = getRegisteredDefinition(extnds);
            if (extendee) {
                return ancestry(extendee.extends).concat([ extendee ]);
            }
            return [];
        }
        function resolveTagName(definition) {
            var baseTag = definition.extends;
            for (var i = 0, a; a = definition.ancestry[i]; i++) {
                baseTag = a.is && a.tag;
            }
            definition.tag = baseTag || definition.__name;
            if (baseTag) {
                definition.is = definition.__name;
            }
        }
        function resolvePrototypeChain(definition) {
            if (!Object.__proto__) {
                var nativePrototype = HTMLElement.prototype;
                if (definition.is) {
                    var inst = document.createElement(definition.tag);
                    var expectedPrototype = Object.getPrototypeOf(inst);
                    if (expectedPrototype === definition.prototype) {
                        nativePrototype = expectedPrototype;
                    }
                }
                var proto = definition.prototype, ancestor;
                while (proto && proto !== nativePrototype) {
                    ancestor = Object.getPrototypeOf(proto);
                    proto.__proto__ = ancestor;
                    proto = ancestor;
                }
                definition.native = nativePrototype;
            }
        }
        function instantiate(definition) {
            return upgrade(domCreateElement(definition.tag), definition);
        }
        function upgrade(element, definition) {
            if (definition.is) {
                element.setAttribute("is", definition.is);
            }
            implement(element, definition);
            element.__upgraded__ = true;
            created(element);
            scope.insertedNode(element);
            scope.upgradeSubtree(element);
            return element;
        }
        function implement(element, definition) {
            if (Object.__proto__) {
                element.__proto__ = definition.prototype;
            } else {
                customMixin(element, definition.prototype, definition.native);
                element.__proto__ = definition.prototype;
            }
        }
        function customMixin(inTarget, inSrc, inNative) {
            var used = {};
            var p = inSrc;
            while (p !== inNative && p !== HTMLElement.prototype) {
                var keys = Object.getOwnPropertyNames(p);
                for (var i = 0, k; k = keys[i]; i++) {
                    if (!used[k]) {
                        Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));
                        used[k] = 1;
                    }
                }
                p = Object.getPrototypeOf(p);
            }
        }
        function created(element) {
            if (element.createdCallback) {
                element.createdCallback();
            }
        }
        function overrideAttributeApi(prototype) {
            if (prototype.setAttribute._polyfilled) {
                return;
            }
            var setAttribute = prototype.setAttribute;
            prototype.setAttribute = function(name, value) {
                changeAttribute.call(this, name, value, setAttribute);
            };
            var removeAttribute = prototype.removeAttribute;
            prototype.removeAttribute = function(name) {
                changeAttribute.call(this, name, null, removeAttribute);
            };
            prototype.setAttribute._polyfilled = true;
        }
        function changeAttribute(name, value, operation) {
            name = name.toLowerCase();
            var oldValue = this.getAttribute(name);
            operation.apply(this, arguments);
            var newValue = this.getAttribute(name);
            if (this.attributeChangedCallback && newValue !== oldValue) {
                this.attributeChangedCallback(name, oldValue, newValue);
            }
        }
        var registry = {};
        function getRegisteredDefinition(name) {
            if (name) {
                return registry[name.toLowerCase()];
            }
        }
        function registerDefinition(name, definition) {
            registry[name] = definition;
        }
        function generateConstructor(definition) {
            return function() {
                return instantiate(definition);
            };
        }
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        function createElementNS(namespace, tag, typeExtension) {
            if (namespace === HTML_NAMESPACE) {
                return createElement(tag, typeExtension);
            } else {
                return domCreateElementNS(namespace, tag);
            }
        }
        function createElement(tag, typeExtension) {
            var definition = getRegisteredDefinition(typeExtension || tag);
            if (definition) {
                if (tag == definition.tag && typeExtension == definition.is) {
                    return new definition.ctor();
                }
                if (!typeExtension && !definition.is) {
                    return new definition.ctor();
                }
            }
            if (typeExtension) {
                var element = createElement(tag);
                element.setAttribute("is", typeExtension);
                return element;
            }
            var element = domCreateElement(tag);
            if (tag.indexOf("-") >= 0) {
                implement(element, HTMLElement);
            }
            return element;
        }
        function upgradeElement(element) {
            if (!element.__upgraded__ && element.nodeType === Node.ELEMENT_NODE) {
                var is = element.getAttribute("is");
                var definition = getRegisteredDefinition(is || element.localName);
                if (definition) {
                    if (is && definition.tag == element.localName) {
                        return upgrade(element, definition);
                    } else if (!is && !definition.extends) {
                        return upgrade(element, definition);
                    }
                }
            }
        }
        function cloneNode(deep) {
            var n = domCloneNode.call(this, deep);
            scope.upgradeAll(n);
            return n;
        }
        var domCreateElement = document.createElement.bind(document);
        var domCreateElementNS = document.createElementNS.bind(document);
        var domCloneNode = Node.prototype.cloneNode;
        document.registerElement = register;
        document.createElement = createElement;
        document.createElementNS = createElementNS;
        Node.prototype.cloneNode = cloneNode;
        scope.registry = registry;
        scope.upgrade = upgradeElement;
    }
    var isInstance;
    if (!Object.__proto__ && !useNative) {
        isInstance = function(obj, ctor) {
            var p = obj;
            while (p) {
                if (p === ctor.prototype) {
                    return true;
                }
                p = p.__proto__;
            }
            return false;
        };
    } else {
        isInstance = function(obj, base) {
            return obj instanceof base;
        };
    }
    scope.instanceof = isInstance;
    scope.reservedTagList = reservedTagList;
    document.register = document.registerElement;
    scope.hasNative = hasNative;
    scope.useNative = useNative;
})(window.CustomElements);

(function(scope) {
    var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
    var parser = {
        selectors: [ "link[rel=" + IMPORT_LINK_TYPE + "]" ],
        map: {
            link: "parseLink"
        },
        parse: function(inDocument) {
            if (!inDocument.__parsed) {
                inDocument.__parsed = true;
                var elts = inDocument.querySelectorAll(parser.selectors);
                forEach(elts, function(e) {
                    parser[parser.map[e.localName]](e);
                });
                CustomElements.upgradeDocument(inDocument);
                CustomElements.observeDocument(inDocument);
            }
        },
        parseLink: function(linkElt) {
            if (isDocumentLink(linkElt)) {
                this.parseImport(linkElt);
            }
        },
        parseImport: function(linkElt) {
            if (linkElt.import) {
                parser.parse(linkElt.import);
            }
        }
    };
    function isDocumentLink(inElt) {
        return inElt.localName === "link" && inElt.getAttribute("rel") === IMPORT_LINK_TYPE;
    }
    var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
    scope.parser = parser;
    scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;
})(window.CustomElements);

(function(scope) {
    function bootstrap() {
        CustomElements.parser.parse(document);
        CustomElements.upgradeDocument(document);
        if (window.HTMLImports) {
            HTMLImports.__importsParsingHook = function(elt) {
                CustomElements.parser.parse(elt.import);
            };
        }
        CustomElements.ready = true;
        setTimeout(function() {
            CustomElements.readyTime = Date.now();
            if (window.HTMLImports) {
                CustomElements.elapsed = CustomElements.readyTime - HTMLImports.readyTime;
            }
            document.dispatchEvent(new CustomEvent("WebComponentsReady", {
                bubbles: true
            }));
        });
    }
    if (typeof window.CustomEvent !== "function") {
        window.CustomEvent = function(inType, params) {
            params = params || {};
            var e = document.createEvent("CustomEvent");
            e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
            return e;
        };
        window.CustomEvent.prototype = window.Event.prototype;
    }
    if (document.readyState === "complete" || scope.flags.eager) {
        bootstrap();
    } else if (document.readyState === "interactive" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {
        bootstrap();
    } else {
        var loadEvent = window.HTMLImports && !HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
        window.addEventListener(loadEvent, bootstrap);
    }
})(window.CustomElements);

(function() {
    var win = window, doc = document, container = doc.createElement("div"), noop = function() {}, trueop = function() {
        return true;
    }, regexPseudoSplit = /([\w-]+(?:\([^\)]+\))?)/g, regexPseudoReplace = /(\w*)(?:\(([^\)]*)\))?/, regexDigits = /(\d+)/g, keypseudo = {
        action: function(pseudo, event) {
            return pseudo.value.match(regexDigits).indexOf(String(event.keyCode)) > -1 == (pseudo.name == "keypass") || null;
        }
    }, prefix = function() {
        var styles = win.getComputedStyle(doc.documentElement, ""), pre = (Array.prototype.slice.call(styles).join("").match(/-(moz|webkit|ms)-/) || styles.OLink === "" && [ "", "o" ])[1];
        return {
            dom: pre == "ms" ? "MS" : pre,
            lowercase: pre,
            css: "-" + pre + "-",
            js: pre == "ms" ? pre : pre[0].toUpperCase() + pre.substr(1)
        };
    }(), matchSelector = Element.prototype.matchesSelector || Element.prototype[prefix.lowercase + "MatchesSelector"], mutation = win.MutationObserver || win[prefix.js + "MutationObserver"];
    var typeCache = {}, typeString = typeCache.toString, typeRegexp = /\s([a-zA-Z]+)/;
    function typeOf(obj) {
        var type = typeString.call(obj);
        return typeCache[type] || (typeCache[type] = type.match(typeRegexp)[1].toLowerCase());
    }
    function clone(item, type) {
        var fn = clone[type || typeOf(item)];
        return fn ? fn(item) : item;
    }
    clone.object = function(src) {
        var obj = {};
        for (var key in src) obj[key] = clone(src[key]);
        return obj;
    };
    clone.array = function(src) {
        var i = src.length, array = new Array(i);
        while (i--) array[i] = clone(src[i]);
        return array;
    };
    var unsliceable = [ "undefined", "null", "number", "boolean", "string", "function" ];
    function toArray(obj) {
        return unsliceable.indexOf(typeOf(obj)) == -1 ? Array.prototype.slice.call(obj, 0) : [ obj ];
    }
    var str = "";
    function query(element, selector) {
        if (!element || !selector) {
            console.trace(element, selector);
        }
        
        return (selector || str).length ? toArray(element.querySelectorAll(selector)) : [];
    }
    function parseMutations(element, mutations) {
        var diff = {
            added: [],
            removed: []
        };
        mutations.forEach(function(record) {
            record._mutation = true;
            for (var z in diff) {
                var type = element._records[z == "added" ? "inserted" : "removed"], nodes = record[z + "Nodes"], length = nodes.length;
                for (var i = 0; i < length && diff[z].indexOf(nodes[i]) == -1; i++) {
                    diff[z].push(nodes[i]);
                    type.forEach(function(fn) {
                        fn(nodes[i], record);
                    });
                }
            }
        });
    }
    function mergeOne(source, key, current) {
        var type = typeOf(current);
        if (type == "object" && typeOf(source[key]) == "object") xtag.merge(source[key], current); else source[key] = clone(current, type);
        return source;
    }
    function wrapMixin(tag, key, pseudo, value, original) {
        var fn = original[key];
        if (!(key in original)) {
            original[key + (pseudo.match(":mixins") ? "" : ":mixins")] = value;
        } else if (typeof original[key] == "function") {
            if (!fn.__mixins__) fn.__mixins__ = [];
            fn.__mixins__.push(xtag.applyPseudos(pseudo, value, tag.pseudos));
        }
    }
    var uniqueMixinCount = 0;
    function mergeMixin(tag, mixin, original, mix) {
        if (mix) {
            var uniques = {};
            for (var z in original) uniques[z.split(":")[0]] = z;
            for (z in mixin) {
                wrapMixin(tag, uniques[z.split(":")[0]] || z, z, mixin[z], original);
            }
        } else {
            for (var zz in mixin) {
                original[zz + ":__mixin__(" + uniqueMixinCount++ + ")"] = xtag.applyPseudos(zz, mixin[zz], tag.pseudos);
            }
        }
    }
    function applyMixins(tag) {
        tag.mixins.forEach(function(name) {
            var mixin = xtag.mixins[name];
            for (var type in mixin) {
                var item = mixin[type], original = tag[type];
                if (!original) tag[type] = item; else {
                    switch (type) {
                      case "accessors":
                      case "prototype":
                        for (var z in item) {
                            if (!original[z]) original[z] = item[z]; else mergeMixin(tag, item[z], original[z], true);
                        }
                        break;

                      default:
                        mergeMixin(tag, item, original, type != "events");
                    }
                }
            }
        });
        return tag;
    }
    function delegateAction(pseudo, event) {
        var match, target = event.target;
        if (!target.tagName) return null;
        if (xtag.matchSelector(target, pseudo.value)) match = target; else if (xtag.matchSelector(target, pseudo.value + " *")) {
            var parent = target.parentNode;
            while (!match) {
                if (xtag.matchSelector(parent, pseudo.value)) match = parent;
                parent = parent.parentNode;
            }
        }
        return match ? pseudo.listener = pseudo.listener.bind(match) : null;
    }
    function touchFilter(event) {
        if (event.type.match("touch")) {
            event.target.__touched__ = true;
        } else if (event.target.__touched__ && event.type.match("mouse")) {
            delete event.target.__touched__;
            return;
        }
        return true;
    }
    function createFlowEvent(type) {
        var flow = type == "over";
        return {
            attach: "OverflowEvent" in win ? "overflowchanged" : [],
            condition: function(event, custom) {
                event.flow = type;
                return event.type == type + "flow" || event.orient === 0 && event.horizontalOverflow == flow || event.orient == 1 && event.verticalOverflow == flow || event.orient == 2 && event.horizontalOverflow == flow && event.verticalOverflow == flow;
            }
        };
    }
    function writeProperty(key, event, base, desc) {
        if (desc) event[key] = base[key]; else Object.defineProperty(event, key, {
            writable: true,
            enumerable: true,
            value: base[key]
        });
    }
    var skipProps = {};
    for (var z in doc.createEvent("CustomEvent")) skipProps[z] = 1;
    function inheritEvent(event, base) {
        var desc = Object.getOwnPropertyDescriptor(event, "target");
        for (var z in base) {
            if (!skipProps[z]) writeProperty(z, event, base, desc);
        }
        event.baseEvent = base;
    }
    function getArgs(attr, value) {
        return {
            value: attr.boolean ? "" : value,
            method: attr.boolean && !value ? "removeAttribute" : "setAttribute"
        };
    }
    function modAttr(element, attr, name, value) {
        var args = getArgs(attr, value);
        element[args.method](name, args.value);
    }
    function syncAttr(element, attr, name, value, method) {
        var nodes = attr.property ? [ element.xtag[attr.property] ] : attr.selector ? xtag.query(element, attr.selector) : [], index = nodes.length;
        while (index--) nodes[index][method](name, value);
    }
    function updateView(element, name, value) {
        if (element.__view__) {
            element.__view__.updateBindingValue(element, name, value);
        }
    }
    function attachProperties(tag, prop, z, accessor, attr, name) {
        var key = z.split(":"), type = key[0];
        if (type == "get") {
            key[0] = prop;
            tag.prototype[prop].get = xtag.applyPseudos(key.join(":"), accessor[z], tag.pseudos, accessor[z]);
        } else if (type == "set") {
            key[0] = prop;
            var setter = tag.prototype[prop].set = xtag.applyPseudos(key.join(":"), attr ? function(value) {
                this.xtag._skipSet = true;
                if (!this.xtag._skipAttr) modAttr(this, attr, name, value);
                if (this.xtag._skipAttr && attr.skip) delete this.xtag._skipAttr;
                accessor[z].call(this, attr.boolean ? !!value : value);
                updateView(this, name, value);
                delete this.xtag._skipSet;
            } : accessor[z] ? function(value) {
                accessor[z].call(this, value);
                updateView(this, name, value);
            } : null, tag.pseudos, accessor[z]);
            if (attr) attr.setter = setter;
        } else tag.prototype[prop][z] = accessor[z];
    }
    function parseAccessor(tag, prop) {
        tag.prototype[prop] = {};
        var accessor = tag.accessors[prop], attr = accessor.attribute, name = attr && attr.name ? attr.name.toLowerCase() : prop;
        if (attr) {
            attr.key = prop;
            tag.attributes[name] = attr;
        }
        for (var z in accessor) attachProperties(tag, prop, z, accessor, attr, name);
        if (attr) {
            if (!tag.prototype[prop].get) {
                var method = (attr.boolean ? "has" : "get") + "Attribute";
                tag.prototype[prop].get = function() {
                    return this[method](name);
                };
            }
            if (!tag.prototype[prop].set) tag.prototype[prop].set = function(value) {
                modAttr(this, attr, name, value);
                updateView(this, name, value);
            };
        }
    }
    var unwrapComment = /\/\*!?(?:\@preserve)?[ \t]*(?:\r\n|\n)([\s\S]*?)(?:\r\n|\n)\s*\*\//;
    function parseMultiline(fn) {
        return unwrapComment.exec(fn.toString())[1];
    }
    var readyTags = {};
    function fireReady(name) {
        readyTags[name] = (readyTags[name] || []).filter(function(obj) {
            return (obj.tags = obj.tags.filter(function(z) {
                return z != name && !xtag.tags[z];
            })).length || obj.fn();
        });
    }
    var xtag = {
        tags: {},
        defaultOptions: {
            pseudos: [],
            mixins: [],
            events: {},
            methods: {},
            accessors: {},
            lifecycle: {},
            attributes: {},
            prototype: {
                xtag: {
                    get: function() {
                        return this.__xtag__ ? this.__xtag__ : this.__xtag__ = {
                            data: {}
                        };
                    }
                }
            }
        },
        register: function(name, options) {
            var _name;
            if (typeof name == "string") {
                _name = name.toLowerCase();
            } else {
                return;
            }
            xtag.tags[_name] = options || {};
            var basePrototype = options.prototype;
            delete options.prototype;
            var tag = xtag.tags[_name].compiled = applyMixins(xtag.merge({}, xtag.defaultOptions, options));
            for (var z in tag.events) tag.events[z] = xtag.parseEvent(z, tag.events[z]);
            for (z in tag.lifecycle) tag.lifecycle[z.split(":")[0]] = xtag.applyPseudos(z, tag.lifecycle[z], tag.pseudos, tag.lifecycle[z]);
            for (z in tag.methods) tag.prototype[z.split(":")[0]] = {
                value: xtag.applyPseudos(z, tag.methods[z], tag.pseudos, tag.methods[z]),
                enumerable: true
            };
            for (z in tag.accessors) parseAccessor(tag, z);
            var shadow = tag.shadow ? xtag.createFragment(tag.shadow) : null;
            var ready = tag.lifecycle.created || tag.lifecycle.ready;
            tag.prototype.createdCallback = {
                enumerable: true,
                value: function() {
                    var element = this;
                    if (shadow && this.createShadowRoot) {
                        var root = this.createShadowRoot();
                        root.appendChild(shadow.cloneNode(true));
                    }
                    xtag.addEvents(this, tag.events);
                    var output = ready ? ready.apply(this, arguments) : null;
                    for (var name in tag.attributes) {
                        var attr = tag.attributes[name], hasAttr = this.hasAttribute(name);
                        if (hasAttr || attr.boolean) {
                            this[attr.key] = attr.boolean ? hasAttr : this.getAttribute(name);
                        }
                    }
                    tag.pseudos.forEach(function(obj) {
                        obj.onAdd.call(element, obj);
                    });
                    return output;
                }
            };
            var inserted = tag.lifecycle.inserted, removed = tag.lifecycle.removed;
            if (inserted || removed) {
                tag.prototype.attachedCallback = {
                    value: function() {
                        if (removed) this.xtag.__parentNode__ = this.parentNode;
                        if (inserted) return inserted.apply(this, arguments);
                    },
                    enumerable: true
                };
            }
            if (removed) {
                tag.prototype.detachedCallback = {
                    value: function() {
                        var args = toArray(arguments);
                        args.unshift(this.xtag.__parentNode__);
                        var output = removed.apply(this, args);
                        delete this.xtag.__parentNode__;
                        return output;
                    },
                    enumerable: true
                };
            }
            if (tag.lifecycle.attributeChanged) tag.prototype.attributeChangedCallback = {
                value: tag.lifecycle.attributeChanged,
                enumerable: true
            };
            var setAttribute = tag.prototype.setAttribute || HTMLElement.prototype.setAttribute;
            tag.prototype.setAttribute = {
                writable: true,
                enumberable: true,
                value: function(name, value) {
                    var attr = tag.attributes[name.toLowerCase()];
                    if (!this.xtag._skipAttr) setAttribute.call(this, name, attr && attr.boolean ? "" : value);
                    if (attr) {
                        if (attr.setter && !this.xtag._skipSet) {
                            this.xtag._skipAttr = true;
                            attr.setter.call(this, attr.boolean ? true : value);
                        }
                        value = attr.skip ? attr.boolean ? this.hasAttribute(name) : this.getAttribute(name) : value;
                        syncAttr(this, attr, name, attr.boolean ? "" : value, "setAttribute");
                    }
                    delete this.xtag._skipAttr;
                }
            };
            var removeAttribute = tag.prototype.removeAttribute || HTMLElement.prototype.removeAttribute;
            tag.prototype.removeAttribute = {
                writable: true,
                enumberable: true,
                value: function(name) {
                    var attr = tag.attributes[name.toLowerCase()];
                    if (!this.xtag._skipAttr) removeAttribute.call(this, name);
                    if (attr) {
                        if (attr.setter && !this.xtag._skipSet) {
                            this.xtag._skipAttr = true;
                            attr.setter.call(this, attr.boolean ? false : undefined);
                        }
                        syncAttr(this, attr, name, undefined, "removeAttribute");
                    }
                    delete this.xtag._skipAttr;
                }
            };
            var elementProto = basePrototype ? basePrototype : options["extends"] ? Object.create(doc.createElement(options["extends"]).constructor).prototype : win.HTMLElement.prototype;
            var definition = {
                prototype: Object.create(elementProto, tag.prototype)
            };
            if (options["extends"]) {
                definition["extends"] = options["extends"];
            }
            var reg = doc.registerElement(_name, definition);
            fireReady(_name);
            return reg;
        },
        ready: function(names, fn) {
            var obj = {
                tags: toArray(names),
                fn: fn
            };
            if (obj.tags.reduce(function(last, name) {
                if (xtag.tags[name]) return last;
                (readyTags[name] = readyTags[name] || []).push(obj);
            }, true)) fn();
        },
        mixins: {},
        prefix: prefix,
        captureEvents: [ "focus", "blur", "scroll", "underflow", "overflow", "overflowchanged", "DOMMouseScroll" ],
        customEvents: {
            overflow: createFlowEvent("over"),
            underflow: createFlowEvent("under"),
            animationstart: {
                attach: [ prefix.dom + "AnimationStart" ]
            },
            animationend: {
                attach: [ prefix.dom + "AnimationEnd" ]
            },
            transitionend: {
                attach: [ prefix.dom + "TransitionEnd" ]
            },
            move: {
                attach: [ "mousemove", "touchmove" ],
                condition: touchFilter
            },
            enter: {
                attach: [ "mouseover", "touchenter" ],
                condition: touchFilter
            },
            leave: {
                attach: [ "mouseout", "touchleave" ],
                condition: touchFilter
            },
            scrollwheel: {
                attach: [ "DOMMouseScroll", "mousewheel" ],
                condition: function(event) {
                    event.delta = event.wheelDelta ? event.wheelDelta / 40 : Math.round(event.detail / 3.5 * -1);
                    return true;
                }
            },
            tapstart: {
                observe: {
                    mousedown: doc,
                    touchstart: doc
                },
                condition: touchFilter
            },
            tapend: {
                observe: {
                    mouseup: doc,
                    touchend: doc
                },
                condition: touchFilter
            },
            tapmove: {
                attach: [ "tapstart", "dragend", "touchcancel" ],
                condition: function(event, custom) {
                    switch (event.type) {
                      case "move":
                        return true;

                      case "dragover":
                        var last = custom.lastDrag || {};
                        custom.lastDrag = event;
                        return last.pageX != event.pageX && last.pageY != event.pageY || null;

                      case "tapstart":
                        if (!custom.move) {
                            custom.current = this;
                            custom.move = xtag.addEvents(this, {
                                move: custom.listener,
                                dragover: custom.listener
                            });
                            custom.tapend = xtag.addEvent(doc, "tapend", custom.listener);
                        }
                        break;

                      case "tapend":
                      case "dragend":
                      case "touchcancel":
                        if (!event.touches.length) {
                            if (custom.move) xtag.removeEvents(custom.current, custom.move || {});
                            if (custom.tapend) xtag.removeEvent(doc, custom.tapend || {});
                            delete custom.lastDrag;
                            delete custom.current;
                            delete custom.tapend;
                            delete custom.move;
                        }
                    }
                }
            }
        },
        pseudos: {
            __mixin__: {},
            mixins: {
                onCompiled: function(fn, pseudo) {
                    var mixins = pseudo.source.__mixins__;
                    if (mixins) switch (pseudo.value) {
                      case "before":
                        return function() {
                            var self = this, args = arguments;
                            mixins.forEach(function(m) {
                                m.apply(self, args);
                            });
                            return fn.apply(self, args);
                        };

                      case null:
                      case "":
                      case "after":
                        return function() {
                            var self = this, args = arguments;
                            returns = fn.apply(self, args);
                            mixins.forEach(function(m) {
                                m.apply(self, args);
                            });
                            return returns;
                        };
                    }
                }
            },
            keypass: keypseudo,
            keyfail: keypseudo,
            delegate: {
                action: delegateAction
            },
            within: {
                action: delegateAction,
                onAdd: function(pseudo) {
                    var condition = pseudo.source.condition;
                    if (condition) pseudo.source.condition = function(event, custom) {
                        return xtag.query(this, pseudo.value).filter(function(node) {
                            return node == event.target || node.contains ? node.contains(event.target) : null;
                        })[0] ? condition.call(this, event, custom) : null;
                    };
                }
            },
            preventable: {
                action: function(pseudo, event) {
                    return !event.defaultPrevented;
                }
            }
        },
        clone: clone,
        typeOf: typeOf,
        toArray: toArray,
        wrap: function(original, fn) {
            return function() {
                var args = arguments, output = original.apply(this, args);
                fn.apply(this, args);
                return output;
            };
        },
        merge: function(source, k, v) {
            if (typeOf(k) == "string") return mergeOne(source, k, v);
            for (var i = 1, l = arguments.length; i < l; i++) {
                var object = arguments[i];
                for (var key in object) mergeOne(source, key, object[key]);
            }
            return source;
        },
        uid: function() {
            return Math.random().toString(36).substr(2, 10);
        },
        query: query,
        skipTransition: function(element, fn, bind) {
            var prop = prefix.js + "TransitionProperty";
            element.style[prop] = element.style.transitionProperty = "none";
            var callback = fn ? fn.call(bind) : null;
            return xtag.requestFrame(function() {
                xtag.requestFrame(function() {
                    element.style[prop] = element.style.transitionProperty = "";
                    if (callback) xtag.requestFrame(callback);
                });
            });
        },
        requestFrame: function() {
            var raf = win.requestAnimationFrame || win[prefix.lowercase + "RequestAnimationFrame"] || function(fn) {
                return win.setTimeout(fn, 20);
            };
            return function(fn) {
                return raf(fn);
            };
        }(),
        cancelFrame: function() {
            var cancel = win.cancelAnimationFrame || win[prefix.lowercase + "CancelAnimationFrame"] || win.clearTimeout;
            return function(id) {
                return cancel(id);
            };
        }(),
        matchSelector: function(element, selector) {
            return matchSelector.call(element, selector);
        },
        set: function(element, method, value) {
            element[method] = value;
            if (window.CustomElements) CustomElements.upgradeAll(element);
        },
        innerHTML: function(el, html) {
            xtag.set(el, "innerHTML", html);
        },
        hasClass: function(element, klass) {
            return element.className.split(" ").indexOf(klass.trim()) > -1;
        },
        addClass: function(element, klass) {
            var list = element.className.trim().split(" ");
            klass.trim().split(" ").forEach(function(name) {
                if (!~list.indexOf(name)) list.push(name);
            });
            element.className = list.join(" ").trim();
            return element;
        },
        removeClass: function(element, klass) {
            var classes = klass.trim().split(" ");
            element.className = element.className.trim().split(" ").filter(function(name) {
                return name && !~classes.indexOf(name);
            }).join(" ");
            return element;
        },
        toggleClass: function(element, klass) {
            return xtag[xtag.hasClass(element, klass) ? "removeClass" : "addClass"].call(null, element, klass);
        },
        queryChildren: function(element, selector) {
            if (!element || !selector) {
                console.trace(element, selector);
            }
            
            var id = element.id, guid = element.id = id || "x_" + xtag.uid(), attr = "#" + guid + " > ", noParent = false;
            if (!element.parentNode) {
                noParent = true;
                container.appendChild(element);
            }
            selector = attr + (selector + "").replace(",", "," + attr, "g");
            var result = element.parentNode.querySelectorAll(selector);
            if (!id) element.removeAttribute("id");
            if (noParent) {
                container.removeChild(element);
            }
            return toArray(result);
        },
        createFragment: function(content) {
            var frag = doc.createDocumentFragment();
            if (content) {
                var div = frag.appendChild(doc.createElement("div")), nodes = toArray(content.nodeName ? arguments : !(div.innerHTML = typeof content == "function" ? parseMultiline(content) : content) || div.children), length = nodes.length, index = 0;
                while (index < length) frag.insertBefore(nodes[index++], div);
                frag.removeChild(div);
            }
            return frag;
        },
        manipulate: function(element, fn) {
            var next = element.nextSibling, parent = element.parentNode, frag = doc.createDocumentFragment(), returned = fn.call(frag.appendChild(element), frag) || element;
            if (next) parent.insertBefore(returned, next); else parent.appendChild(returned);
        },
        applyPseudos: function(key, fn, target, source) {
            var listener = fn, pseudos = {};
            if (key.match(":")) {
                var split = key.match(regexPseudoSplit), i = split.length;
                while (--i) {
                    split[i].replace(regexPseudoReplace, function(match, name, value) {
                        if (!xtag.pseudos[name]) throw "pseudo not found: " + name + " " + split;
                        value = value === "" || typeof value == "undefined" ? null : value;
                        var pseudo = pseudos[i] = Object.create(xtag.pseudos[name]);
                        pseudo.key = key;
                        pseudo.name = name;
                        pseudo.value = value;
                        pseudo["arguments"] = (value || "").split(",");
                        pseudo.action = pseudo.action || trueop;
                        pseudo.source = source;
                        var last = listener;
                        listener = function() {
                            var args = toArray(arguments), obj = {
                                key: key,
                                name: name,
                                value: value,
                                source: source,
                                arguments: pseudo["arguments"],
                                listener: last
                            };
                            var output = pseudo.action.apply(this, [ obj ].concat(args));
                            if (output === null || output === false) return output;
                            return obj.listener.apply(this, args);
                        };
                        if (target && pseudo.onAdd) {
                            if (target.nodeName) pseudo.onAdd.call(target, pseudo); else target.push(pseudo);
                        }
                    });
                }
            }
            for (var z in pseudos) {
                if (pseudos[z].onCompiled) listener = pseudos[z].onCompiled(listener, pseudos[z]) || listener;
            }
            return listener;
        },
        removePseudos: function(target, pseudos) {
            pseudos.forEach(function(obj) {
                if (obj.onRemove) obj.onRemove.call(target, obj);
            });
        },
        parseEvent: function(type, fn) {
            var pseudos = type.split(":"), key = pseudos.shift(), custom = xtag.customEvents[key], event = xtag.merge({
                type: key,
                stack: noop,
                condition: trueop,
                attach: [],
                _attach: [],
                pseudos: "",
                _pseudos: [],
                onAdd: noop,
                onRemove: noop
            }, custom || {});
            event.attach = toArray(event.base || event.attach);
            event.chain = key + (event.pseudos.length ? ":" + event.pseudos : "") + (pseudos.length ? ":" + pseudos.join(":") : "");
            var condition = event.condition;
            event.condition = function(e) {
                var t = e.touches, tt = e.targetTouches;
                return condition.apply(this, arguments);
            };
            var stack = xtag.applyPseudos(event.chain, fn, event._pseudos, event);
            event.stack = function(e) {
                e.currentTarget = e.currentTarget || this;
                var t = e.touches, tt = e.targetTouches;
                var detail = e.detail || {};
                if (!detail.__stack__) return stack.apply(this, arguments); else if (detail.__stack__ == stack) {
                    e.stopPropagation();
                    e.cancelBubble = true;
                    return stack.apply(this, arguments);
                }
            };
            event.listener = function(e) {
                var args = toArray(arguments), output = event.condition.apply(this, args.concat([ event ]));
                if (!output) return output;
                if (e.type != key && e.baseEvent && e.type != e.baseEvent.type) {
                    xtag.fireEvent(e.target, key, {
                        baseEvent: e,
                        detail: output !== true && (output.__stack__ = stack) ? output : {
                            __stack__: stack
                        }
                    });
                } else return event.stack.apply(this, args);
            };
            event.attach.forEach(function(name) {
                event._attach.push(xtag.parseEvent(name, event.listener));
            });
            if (custom && custom.observe && !custom.__observing__) {
                custom.observer = function(e) {
                    var output = event.condition.apply(this, toArray(arguments).concat([ custom ]));
                    if (!output) return output;
                    xtag.fireEvent(e.target, key, {
                        baseEvent: e,
                        detail: output !== true ? output : {}
                    });
                };
                for (var z in custom.observe) xtag.addEvent(custom.observe[z] || document, z, custom.observer, true);
                custom.__observing__ = true;
            }
            return event;
        },
        addEvent: function(element, type, fn, capture) {
            var event = typeof fn == "function" ? xtag.parseEvent(type, fn) : fn;
            event._pseudos.forEach(function(obj) {
                obj.onAdd.call(element, obj);
            });
            event._attach.forEach(function(obj) {
                xtag.addEvent(element, obj.type, obj);
            });
            event.onAdd.call(element, event, event.listener);
            element.addEventListener(event.type, event.stack, capture || xtag.captureEvents.indexOf(event.type) > -1);
            return event;
        },
        addEvents: function(element, obj) {
            var events = {};
            for (var z in obj) {
                events[z] = xtag.addEvent(element, z, obj[z]);
            }
            return events;
        },
        removeEvent: function(element, type, event) {
            event = event || type;
            event.onRemove.call(element, event, event.listener);
            xtag.removePseudos(element, event._pseudos);
            event._attach.forEach(function(obj) {
                xtag.removeEvent(element, obj);
            });
            element.removeEventListener(event.type, event.stack);
        },
        removeEvents: function(element, obj) {
            for (var z in obj) xtag.removeEvent(element, obj[z]);
        },
        fireEvent: function(element, type, options, warn) {
            var event = doc.createEvent("CustomEvent");
            options = options || {};
            if (warn) console.warn("fireEvent has been modified");
            event.initCustomEvent(type, options.bubbles !== false, options.cancelable !== false, options.detail);
            if (options.baseEvent) inheritEvent(event, options.baseEvent);
            try {
                element.dispatchEvent(event);
            } catch (e) {
                console.warn("This error may have been caused by a change in the fireEvent method", e);
            }
        },
        addObserver: function(element, type, fn) {
            if (!element._records) {
                element._records = {
                    inserted: [],
                    removed: []
                };
                if (mutation) {
                    element._observer = new mutation(function(mutations) {
                        parseMutations(element, mutations);
                    });
                    element._observer.observe(element, {
                        subtree: true,
                        childList: true,
                        attributes: !true,
                        characterData: false
                    });
                } else [ "Inserted", "Removed" ].forEach(function(type) {
                    element.addEventListener("DOMNode" + type, function(event) {
                        event._mutation = true;
                        element._records[type.toLowerCase()].forEach(function(fn) {
                            fn(event.target, event);
                        });
                    }, false);
                });
            }
            if (element._records[type].indexOf(fn) == -1) element._records[type].push(fn);
        },
        removeObserver: function(element, type, fn) {
            var obj = element._records;
            if (obj && fn) {
                obj[type].splice(obj[type].indexOf(fn), 1);
            } else {
                obj[type] = [];
            }
        }
    };
    var touching = false, touchTarget = null;
    doc.addEventListener("mousedown", function(e) {
        touching = true;
        touchTarget = e.target;
    }, true);
    doc.addEventListener("mouseup", function() {
        touching = false;
        touchTarget = null;
    }, true);
    doc.addEventListener("dragend", function() {
        touching = false;
        touchTarget = null;
    }, true);
    var UIEventProto = {
        touches: {
            configurable: true,
            get: function() {
                return this.__touches__ || (this.identifier = 0) || (this.__touches__ = touching ? [ this ] : []);
            }
        },
        targetTouches: {
            configurable: true,
            get: function() {
                return this.__targetTouches__ || (this.__targetTouches__ = touching && this.currentTarget && (this.currentTarget == touchTarget || this.currentTarget.contains && this.currentTarget.contains(touchTarget)) ? (this.identifier = 0) || [ this ] : []);
            }
        },
        changedTouches: {
            configurable: true,
            get: function() {
                return this.__changedTouches__ || (this.identifier = 0) || (this.__changedTouches__ = [ this ]);
            }
        }
    };
    for (z in UIEventProto) {
        UIEvent.prototype[z] = UIEventProto[z];
        Object.defineProperty(UIEvent.prototype, z, UIEventProto[z]);
    }
    function addTap(el, tap, e) {
        if (!el.__tap__) {
            el.__tap__ = {
                click: e.type == "mousedown"
            };
            if (el.__tap__.click) el.addEventListener("click", tap.observer); else {
                el.__tap__.scroll = tap.observer.bind(el);
                window.addEventListener("scroll", el.__tap__.scroll, true);
                el.addEventListener("touchmove", tap.observer);
                el.addEventListener("touchcancel", tap.observer);
                el.addEventListener("touchend", tap.observer);
            }
        }
        if (!el.__tap__.click) {
            el.__tap__.x = e.touches[0].pageX;
            el.__tap__.y = e.touches[0].pageY;
        }
    }
    function removeTap(el, tap) {
        if (el.__tap__) {
            if (el.__tap__.click) el.removeEventListener("click", tap.observer); else {
                window.removeEventListener("scroll", el.__tap__.scroll, true);
                el.removeEventListener("touchmove", tap.observer);
                el.removeEventListener("touchcancel", tap.observer);
                el.removeEventListener("touchend", tap.observer);
            }
            delete el.__tap__;
        }
    }
    function checkTapPosition(el, tap, e) {
        var touch = e.changedTouches[0], tol = tap.gesture.tolerance;
        if (touch.pageX < el.__tap__.x + tol && touch.pageX > el.__tap__.x - tol && touch.pageY < el.__tap__.y + tol && touch.pageY > el.__tap__.y - tol) return true;
    }
    xtag.customEvents.tap = {
        observe: {
            mousedown: document,
            touchstart: document
        },
        gesture: {
            tolerance: 8
        },
        condition: function(e, tap) {
            var el = e.target;
            switch (e.type) {
              case "touchstart":
                if (el.__tap__ && el.__tap__.click) removeTap(el, tap);
                addTap(el, tap, e);
                return;

              case "mousedown":
                if (!el.__tap__) addTap(el, tap, e);
                return;

              case "scroll":
              case "touchcancel":
                removeTap(this, tap);
                return;

              case "touchmove":
              case "touchend":
                if (this.__tap__ && !checkTapPosition(this, tap, e)) {
                    removeTap(this, tap);
                    return;
                }
                return e.type == "touchend" || null;

              case "click":
                removeTap(this, tap);
                return true;
            }
        }
    };
    win.xtag = xtag;
    if (typeof define == "function" && define.amd) define(xtag);
    doc.addEventListener("WebComponentsReady", function() {
        xtag.fireEvent(doc.body, "DOMComponentsLoaded");
    });
})();
(function() {
    var events = {}, elements = {}, observers = {};
    function outerNodes(element, event) {
        var type = event.type, el = elements[type] || (elements[type] = []), ev = events[type] || (events[type] = []), i = el.indexOf(element);
        if (i == -1) {
            el.push(element);
            ev.push(event);
        } else {
            el.splice(i, 1);
            ev.splice(i, 1);
        }
        return el;
    }
    xtag.pseudos.outer = {
        action: function(pseudo, e) {
            if (this == e.target || this.contains && this.contains(e.target)) return null;
        },
        onRemove: function(pseudo) {
            if (!outerNodes(this, pseudo.source).length) {
                xtag.removeEvent(document, observers[pseudo.source.type]);
            }
        },
        onAdd: function(pseudo) {
            outerNodes(this, pseudo.source);
            var element = this, type = pseudo.source.type;
            if (!observers[type]) {
                observers[type] = xtag.addEvent(document, type, function(e) {
                    elements[type].forEach(function(node, i) {
                        if (node == e.target || node.contains(e.target)) return;
                        events[type][i].stack.call(node, e);
                    });
                });
            }
        }
    };
})();
if (typeof WeakMap === "undefined") {
    (function() {
        var defineProperty = Object.defineProperty;
        var counter = Date.now() % 1e9;
        var WeakMap = function() {
            this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
        };
        WeakMap.prototype = {
            set: function(key, value) {
                var entry = key[this.name];
                if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
                    value: [ key, value ],
                    writable: true
                });
            },
            get: function(key) {
                var entry;
                return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
            },
            "delete": function(key) {
                this.set(key, undefined);
            }
        };
        window.WeakMap = WeakMap;
    })();
}
(function(global) {
    var registrationsTable = new WeakMap();
    var setImmediate = window.msSetImmediate;
    if (!setImmediate) {
        var setImmediateQueue = [];
        var sentinel = String(Math.random());
        window.addEventListener("message", function(e) {
            if (e.data === sentinel) {
                var queue = setImmediateQueue;
                setImmediateQueue = [];
                queue.forEach(function(func) {
                    func();
                });
            }
        });
        setImmediate = function(func) {
            setImmediateQueue.push(func);
            window.postMessage(sentinel, "*");
        };
    }
    var isScheduled = false;
    var scheduledObservers = [];
    function scheduleCallback(observer) {
        scheduledObservers.push(observer);
        if (!isScheduled) {
            isScheduled = true;
            setImmediate(dispatchCallbacks);
        }
    }
    function wrapIfNeeded(node) {
        return node;
    }
    function dispatchCallbacks() {
        isScheduled = false;
        var observers = scheduledObservers;
        scheduledObservers = [];
        observers.sort(function(o1, o2) {
            return o1.uid_ - o2.uid_;
        });
        var anyNonEmpty = false;
        observers.forEach(function(observer) {
            var queue = observer.takeRecords();
            removeTransientObserversFor(observer);
            if (queue.length) {
                observer.callback_(queue, observer);
                anyNonEmpty = true;
            }
        });
        if (anyNonEmpty) dispatchCallbacks();
    }
    function removeTransientObserversFor(observer) {
        observer.nodes_.forEach(function(node) {
            var registrations = registrationsTable.get(node);
            if (!registrations) return;
            registrations.forEach(function(registration) {
                if (registration.observer === observer) registration.removeTransientObservers();
            });
        });
    }
    function forEachAncestorAndObserverEnqueueRecord(target, callback) {
        for (var node = target; node; node = node.parentNode) {
            var registrations = registrationsTable.get(node);
            if (registrations) {
                for (var j = 0; j < registrations.length; j++) {
                    var registration = registrations[j];
                    var options = registration.options;
                    if (node !== target && !options.subtree) continue;
                    var record = callback(options);
                    if (record) registration.enqueue(record);
                }
            }
        }
    }
    var uidCounter = 0;
    function JsMutationObserver(callback) {
        this.callback_ = callback;
        this.nodes_ = [];
        this.records_ = [];
        this.uid_ = ++uidCounter;
    }
    JsMutationObserver.prototype = {
        observe: function(target, options) {
            target = wrapIfNeeded(target);
            if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
                throw new SyntaxError();
            }
            var registrations = registrationsTable.get(target);
            if (!registrations) registrationsTable.set(target, registrations = []);
            var registration;
            for (var i = 0; i < registrations.length; i++) {
                if (registrations[i].observer === this) {
                    registration = registrations[i];
                    registration.removeListeners();
                    registration.options = options;
                    break;
                }
            }
            if (!registration) {
                registration = new Registration(this, target, options);
                registrations.push(registration);
                this.nodes_.push(target);
            }
            registration.addListeners();
        },
        disconnect: function() {
            this.nodes_.forEach(function(node) {
                var registrations = registrationsTable.get(node);
                for (var i = 0; i < registrations.length; i++) {
                    var registration = registrations[i];
                    if (registration.observer === this) {
                        registration.removeListeners();
                        registrations.splice(i, 1);
                        break;
                    }
                }
            }, this);
            this.records_ = [];
        },
        takeRecords: function() {
            var copyOfRecords = this.records_;
            this.records_ = [];
            return copyOfRecords;
        }
    };
    function MutationRecord(type, target) {
        this.type = type;
        this.target = target;
        this.addedNodes = [];
        this.removedNodes = [];
        this.previousSibling = null;
        this.nextSibling = null;
        this.attributeName = null;
        this.attributeNamespace = null;
        this.oldValue = null;
    }
    function copyMutationRecord(original) {
        var record = new MutationRecord(original.type, original.target);
        record.addedNodes = original.addedNodes.slice();
        record.removedNodes = original.removedNodes.slice();
        record.previousSibling = original.previousSibling;
        record.nextSibling = original.nextSibling;
        record.attributeName = original.attributeName;
        record.attributeNamespace = original.attributeNamespace;
        record.oldValue = original.oldValue;
        return record;
    }
    var currentRecord, recordWithOldValue;
    function getRecord(type, target) {
        return currentRecord = new MutationRecord(type, target);
    }
    function getRecordWithOldValue(oldValue) {
        if (recordWithOldValue) return recordWithOldValue;
        recordWithOldValue = copyMutationRecord(currentRecord);
        recordWithOldValue.oldValue = oldValue;
        return recordWithOldValue;
    }
    function clearRecords() {
        currentRecord = recordWithOldValue = undefined;
    }
    function recordRepresentsCurrentMutation(record) {
        return record === recordWithOldValue || record === currentRecord;
    }
    function selectRecord(lastRecord, newRecord) {
        if (lastRecord === newRecord) return lastRecord;
        if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
        return null;
    }
    function Registration(observer, target, options) {
        this.observer = observer;
        this.target = target;
        this.options = options;
        this.transientObservedNodes = [];
    }
    Registration.prototype = {
        enqueue: function(record) {
            var records = this.observer.records_;
            var length = records.length;
            if (records.length > 0) {
                var lastRecord = records[length - 1];
                var recordToReplaceLast = selectRecord(lastRecord, record);
                if (recordToReplaceLast) {
                    records[length - 1] = recordToReplaceLast;
                    return;
                }
            } else {
                scheduleCallback(this.observer);
            }
            records[length] = record;
        },
        addListeners: function() {
            this.addListeners_(this.target);
        },
        addListeners_: function(node) {
            var options = this.options;
            if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
            if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
            if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
            if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
        },
        removeListeners: function() {
            this.removeListeners_(this.target);
        },
        removeListeners_: function(node) {
            var options = this.options;
            if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
            if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
            if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
            if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
        },
        addTransientObserver: function(node) {
            if (node === this.target) return;
            this.addListeners_(node);
            this.transientObservedNodes.push(node);
            var registrations = registrationsTable.get(node);
            if (!registrations) registrationsTable.set(node, registrations = []);
            registrations.push(this);
        },
        removeTransientObservers: function() {
            var transientObservedNodes = this.transientObservedNodes;
            this.transientObservedNodes = [];
            transientObservedNodes.forEach(function(node) {
                this.removeListeners_(node);
                var registrations = registrationsTable.get(node);
                for (var i = 0; i < registrations.length; i++) {
                    if (registrations[i] === this) {
                        registrations.splice(i, 1);
                        break;
                    }
                }
            }, this);
        },
        handleEvent: function(e) {
            e.stopImmediatePropagation();
            switch (e.type) {
              case "DOMAttrModified":
                var name = e.attrName;
                var namespace = e.relatedNode.namespaceURI;
                var target = e.target;
                var record = new getRecord("attributes", target);
                record.attributeName = name;
                record.attributeNamespace = namespace;
                var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
                forEachAncestorAndObserverEnqueueRecord(target, function(options) {
                    if (!options.attributes) return;
                    if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
                        return;
                    }
                    if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
                    return record;
                });
                break;

              case "DOMCharacterDataModified":
                var target = e.target;
                var record = getRecord("characterData", target);
                var oldValue = e.prevValue;
                forEachAncestorAndObserverEnqueueRecord(target, function(options) {
                    if (!options.characterData) return;
                    if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
                    return record;
                });
                break;

              case "DOMNodeRemoved":
                this.addTransientObserver(e.target);

              case "DOMNodeInserted":
                var target = e.relatedNode;
                var changedNode = e.target;
                var addedNodes, removedNodes;
                if (e.type === "DOMNodeInserted") {
                    addedNodes = [ changedNode ];
                    removedNodes = [];
                } else {
                    addedNodes = [];
                    removedNodes = [ changedNode ];
                }
                var previousSibling = changedNode.previousSibling;
                var nextSibling = changedNode.nextSibling;
                var record = getRecord("childList", target);
                record.addedNodes = addedNodes;
                record.removedNodes = removedNodes;
                record.previousSibling = previousSibling;
                record.nextSibling = nextSibling;
                forEachAncestorAndObserverEnqueueRecord(target, function(options) {
                    if (!options.childList) return;
                    return record;
                });
            }
            clearRecords();
        }
    };
    global.JsMutationObserver = JsMutationObserver;
    if (!global.MutationObserver) global.MutationObserver = JsMutationObserver;
})(this);
(function() {
    if (typeof window.Element === "undefined" || "classList" in document.documentElement) return;
    var prototype = Array.prototype, indexOf = prototype.indexOf, slice = prototype.slice, push = prototype.push, splice = prototype.splice, join = prototype.join;
    function DOMTokenList(el) {
        this._element = el;
        if (el.className != this._classCache) {
            this._classCache = el.className;
            if (!this._classCache) return;
            var classes = this._classCache.replace(/^\s+|\s+$/g, "").split(/\s+/), i;
            for (i = 0; i < classes.length; i++) {
                push.call(this, classes[i]);
            }
        }
    }
    function setToClassName(el, classes) {
        el.className = classes.join(" ");
    }
    DOMTokenList.prototype = {
        add: function(token) {
            if (this.contains(token)) return;
            push.call(this, token);
            setToClassName(this._element, slice.call(this, 0));
        },
        contains: function(token) {
            return indexOf.call(this, token) !== -1;
        },
        item: function(index) {
            return this[index] || null;
        },
        remove: function(token) {
            var i = indexOf.call(this, token);
            if (i === -1) {
                return;
            }
            splice.call(this, i, 1);
            setToClassName(this._element, slice.call(this, 0));
        },
        toString: function() {
            return join.call(this, " ");
        },
        toggle: function(token) {
            if (indexOf.call(this, token) === -1) {
                this.add(token);
            } else {
                this.remove(token);
            }
        }
    };
    window.DOMTokenList = DOMTokenList;
    function defineElementGetter(obj, prop, getter) {
        if (Object.defineProperty) {
            Object.defineProperty(obj, prop, {
                get: getter
            });
        } else {
            obj.__defineGetter__(prop, getter);
        }
    }
    defineElementGetter(Element.prototype, "classList", function() {
        return new DOMTokenList(this);
    });
})();
if (!window.CustomElements) {
    window.CustomElements = {
        flags: {}
    };
}

(function(scope) {
    var logFlags = window.logFlags || {};
    var IMPORT_LINK_TYPE = window.HTMLImports ? HTMLImports.IMPORT_LINK_TYPE : "none";
    function findAll(node, find, data) {
        var e = node.firstElementChild;
        if (!e) {
            e = node.firstChild;
            while (e && e.nodeType !== Node.ELEMENT_NODE) {
                e = e.nextSibling;
            }
        }
        while (e) {
            if (find(e, data) !== true) {
                findAll(e, find, data);
            }
            e = e.nextElementSibling;
        }
        return null;
    }
    function forRoots(node, cb) {
        var root = node.shadowRoot;
        while (root) {
            forSubtree(root, cb);
            root = root.olderShadowRoot;
        }
    }
    function forSubtree(node, cb) {
        findAll(node, function(e) {
            if (cb(e)) {
                return true;
            }
            forRoots(e, cb);
        });
        forRoots(node, cb);
    }
    function added(node) {
        if (upgrade(node)) {
            insertedNode(node);
            return true;
        }
        inserted(node);
    }
    function addedSubtree(node) {
        forSubtree(node, function(e) {
            if (added(e)) {
                return true;
            }
        });
    }
    function addedNode(node) {
        return added(node) || addedSubtree(node);
    }
    function upgrade(node) {
        if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {
            var type = node.getAttribute("is") || node.localName;
            var definition = scope.registry[type];
            if (definition) {
                logFlags.dom && console.group("upgrade:", node.localName);
                scope.upgrade(node);
                logFlags.dom && console.groupEnd();
                return true;
            }
        }
    }
    function insertedNode(node) {
        inserted(node);
        if (inDocument(node)) {
            forSubtree(node, function(e) {
                inserted(e);
            });
        }
    }
    var hasPolyfillMutations = !window.MutationObserver || window.MutationObserver === window.JsMutationObserver;
    scope.hasPolyfillMutations = hasPolyfillMutations;
    var isPendingMutations = false;
    var pendingMutations = [];
    function deferMutation(fn) {
        pendingMutations.push(fn);
        if (!isPendingMutations) {
            isPendingMutations = true;
            var async = window.Platform && window.Platform.endOfMicrotask || setTimeout;
            async(takeMutations);
        }
    }
    function takeMutations() {
        isPendingMutations = false;
        var $p = pendingMutations;
        for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
            p();
        }
        pendingMutations = [];
    }
    function inserted(element) {
        if (hasPolyfillMutations) {
            deferMutation(function() {
                _inserted(element);
            });
        } else {
            _inserted(element);
        }
    }
    function _inserted(element) {
        if (element.attachedCallback || element.detachedCallback || element.__upgraded__ && logFlags.dom) {
            logFlags.dom && console.group("inserted:", element.localName);
            if (inDocument(element)) {
                element.__inserted = (element.__inserted || 0) + 1;
                if (element.__inserted < 1) {
                    element.__inserted = 1;
                }
                if (element.__inserted > 1) {
                    logFlags.dom && console.warn("inserted:", element.localName, "insert/remove count:", element.__inserted);
                } else if (element.attachedCallback) {
                    logFlags.dom && console.log("inserted:", element.localName);
                    element.attachedCallback();
                }
            }
            logFlags.dom && console.groupEnd();
        }
    }
    function removedNode(node) {
        removed(node);
        forSubtree(node, function(e) {
            removed(e);
        });
    }
    function removed(element) {
        if (hasPolyfillMutations) {
            deferMutation(function() {
                _removed(element);
            });
        } else {
            _removed(element);
        }
    }
    function _removed(element) {
        if (element.attachedCallback || element.detachedCallback || element.__upgraded__ && logFlags.dom) {
            logFlags.dom && console.group("removed:", element.localName);
            if (!inDocument(element)) {
                element.__inserted = (element.__inserted || 0) - 1;
                if (element.__inserted > 0) {
                    element.__inserted = 0;
                }
                if (element.__inserted < 0) {
                    logFlags.dom && console.warn("removed:", element.localName, "insert/remove count:", element.__inserted);
                } else if (element.detachedCallback) {
                    element.detachedCallback();
                }
            }
            logFlags.dom && console.groupEnd();
        }
    }
    function wrapIfNeeded(node) {
        return node;
    }
    function inDocument(element) {
        var p = element;
        var doc = wrapIfNeeded(document);
        while (p) {
            if (p == doc) {
                return true;
            }
            p = p.parentNode || p.host;
        }
    }
    function watchShadow(node) {
        if (node.shadowRoot && !node.shadowRoot.__watched) {
            logFlags.dom && console.log("watching shadow-root for: ", node.localName);
            var root = node.shadowRoot;
            while (root) {
                watchRoot(root);
                root = root.olderShadowRoot;
            }
        }
    }
    function watchRoot(root) {
        if (!root.__watched) {
            observe(root);
            root.__watched = true;
        }
    }
    function handler(mutations) {
        if (logFlags.dom) {
            var mx = mutations[0];
            if (mx && mx.type === "childList" && mx.addedNodes) {
                if (mx.addedNodes) {
                    var d = mx.addedNodes[0];
                    while (d && d !== document && !d.host) {
                        d = d.parentNode;
                    }
                    var u = d && (d.URL || d._URL || d.host && d.host.localName) || "";
                    u = u.split("/?").shift().split("/").pop();
                }
            }
            console.group("mutations (%d) [%s]", mutations.length, u || "");
        }
        mutations.forEach(function(mx) {
            if (mx.type === "childList") {
                forEach(mx.addedNodes, function(n) {
                    if (!n.localName) {
                        return;
                    }
                    addedNode(n);
                });
                forEach(mx.removedNodes, function(n) {
                    if (!n.localName) {
                        return;
                    }
                    removedNode(n);
                });
            }
        });
        logFlags.dom && console.groupEnd();
    }
    var observer = new MutationObserver(handler);
    function takeRecords() {
        handler(observer.takeRecords());
        takeMutations();
    }
    var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
    function observe(inRoot) {
        observer.observe(inRoot, {
            childList: true,
            subtree: true
        });
    }
    function observeDocument(doc) {
        observe(doc);
    }
    function upgradeDocument(doc) {
        logFlags.dom && console.group("upgradeDocument: ", doc.baseURI.split("/").pop());
        addedNode(doc);
        logFlags.dom && console.groupEnd();
    }
    function upgradeDocumentTree(doc) {
        doc = wrapIfNeeded(doc);
        var imports = doc.querySelectorAll("link[rel=" + IMPORT_LINK_TYPE + "]");
        for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {
            if (n.import && n.import.__parsed) {
                upgradeDocumentTree(n.import);
            }
        }
        upgradeDocument(doc);
    }
    scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;
    scope.watchShadow = watchShadow;
    scope.upgradeDocumentTree = upgradeDocumentTree;
    scope.upgradeAll = addedNode;
    scope.upgradeSubtree = addedSubtree;
    scope.insertedNode = insertedNode;
    scope.observeDocument = observeDocument;
    scope.upgradeDocument = upgradeDocument;
    scope.takeRecords = takeRecords;
})(window.CustomElements);



(function(scope) {
    function bootstrap() {
        CustomElements.parser.parse(document);
        CustomElements.upgradeDocument(document);
        var async = window.Platform && Platform.endOfMicrotask ? Platform.endOfMicrotask : setTimeout;
        async(function() {
            CustomElements.ready = true;
            CustomElements.readyTime = Date.now();
            if (window.HTMLImports) {
                CustomElements.elapsed = CustomElements.readyTime - HTMLImports.readyTime;
            }
            document.dispatchEvent(new CustomEvent("WebComponentsReady", {
                bubbles: true
            }));
            if (window.HTMLImports) {
                HTMLImports.__importsParsingHook = function(elt) {
                    CustomElements.parser.parse(elt.import);
                };
            }
        });
    }
    if (typeof window.CustomEvent !== "function") {
        window.CustomEvent = function(inType) {
            var e = document.createEvent("HTMLEvents");
            e.initEvent(inType, true, true);
            return e;
        };
    }
    if (document.readyState === "complete" || scope.flags.eager) {
        bootstrap();
    } else if (document.readyState === "interactive" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {
        bootstrap();
    } else {
        var loadEvent = window.HTMLImports && !HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
        window.addEventListener(loadEvent, bootstrap);
    }
})(window.CustomElements);



;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		//deviceIsIOS was added by Mojo
		if (deviceIsAndroid || deviceIsIOS) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}
        
        // CODE ADDED BY MICHAEL (added for case when we need to have click for html that we have no control over
        //                          (our example is the contents of an ACE editor need regular clicks but we cant add a "needsclick" to every element in an ACE editor)
        //                       )
        var currentElement = target.parentNode;
        
        // loop through parents and if any of the parents has the "childrenneedsclick" class than return true
        while (currentElement && currentElement.parentNode && currentElement.parentNode.nodeName !== 'HTML') {
            if (currentElement.classList.contains('childrenneedsclick')) {//alert('test');
                return true;
            }
            
            currentElement = currentElement.parentNode;
        }
        
		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];
		//console.log('test click');

		// Synthesise a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none') {
			return true;
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};


	if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {

		// AMD. Register as an anonymous module.
		define(function() {
			return FastClick;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = FastClick.attach;
		module.exports.FastClick = FastClick;
	}// else {
	
	window.FastClick = FastClick;
	//}
}());



//(function () {
//	'use strict';
//
//	/**
//	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
//	 *
//	 * @codingstandard ftlabs-jsv2
//	 * @copyright The Financial Times Limited [All Rights Reserved]
//	 * @license MIT License (see LICENSE.txt)
//	 */
//
//	/*jslint browser:true, node:true*/
//	/*global define, Event, Node*/
//
//
//	/**
//	 * Instantiate fast-clicking listeners on the specified layer.
//	 *
//	 * @constructor
//	 * @param {Element} layer The layer to listen on
//	 * @param {Object} [options={}] The options to override the defaults
//	 */
//	function FastClick(layer, options) {
//		var oldOnClick;
//
//		options = options || {};
//
//		/**
//		 * Whether a click is currently being tracked.
//		 *
//		 * @type boolean
//		 */
//		this.trackingClick = false;
//
//
//		/**
//		 * Timestamp for when click tracking started.
//		 *
//		 * @type number
//		 */
//		this.trackingClickStart = 0;
//
//
//		/**
//		 * The element being tracked for a click.
//		 *
//		 * @type EventTarget
//		 */
//		this.targetElement = null;
//
//
//		/**
//		 * X-coordinate of touch start event.
//		 *
//		 * @type number
//		 */
//		this.touchStartX = 0;
//
//
//		/**
//		 * Y-coordinate of touch start event.
//		 *
//		 * @type number
//		 */
//		this.touchStartY = 0;
//
//
//		/**
//		 * ID of the last touch, retrieved from Touch.identifier.
//		 *
//		 * @type number
//		 */
//		this.lastTouchIdentifier = 0;
//
//
//		/**
//		 * Touchmove boundary, beyond which a click will be cancelled.
//		 *
//		 * @type number
//		 */
//		this.touchBoundary = options.touchBoundary || 10;
//
//
//		/**
//		 * The FastClick layer.
//		 *
//		 * @type Element
//		 */
//		this.layer = layer;
//
//		/**
//		 * The minimum time between tap(touchstart and touchend) events
//		 *
//		 * @type number
//		 */
//		this.tapDelay = options.tapDelay || 200;
//
//		/**
//		 * The maximum time for a tap
//		 *
//		 * @type number
//		 */
//		this.tapTimeout = options.tapTimeout || 700;
//
//		if (FastClick.notNeeded(layer)) {
//			return;
//		}
//
//		// Some old versions of Android don't have Function.prototype.bind
//		function bind(method, context) {
//			return function() { return method.apply(context, arguments); };
//		}
//
//
//		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
//		var context = this;
//		for (var i = 0, l = methods.length; i < l; i++) {
//			context[methods[i]] = bind(context[methods[i]], context);
//		}
//
//		// Set up event handlers as required
//		if (deviceIsAndroid) {
//			layer.addEventListener('mouseover', this.onMouse, true);
//			layer.addEventListener('mousedown', this.onMouse, true);
//			layer.addEventListener('mouseup', this.onMouse, true);
//		}
//
//		layer.addEventListener('click', this.onClick, true);
//		layer.addEventListener('touchstart', this.onTouchStart, false);
//		layer.addEventListener('touchmove', this.onTouchMove, false);
//		layer.addEventListener('touchend', this.onTouchEnd, false);
//		layer.addEventListener('touchcancel', this.onTouchCancel, false);
//
//		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
//		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
//		// layer when they are cancelled.
//		if (!Event.prototype.stopImmediatePropagation) {
//			layer.removeEventListener = function(type, callback, capture) {
//				var rmv = Node.prototype.removeEventListener;
//				if (type === 'click') {
//					rmv.call(layer, type, callback.hijacked || callback, capture);
//				} else {
//					rmv.call(layer, type, callback, capture);
//				}
//			};
//
//			layer.addEventListener = function(type, callback, capture) {
//				var adv = Node.prototype.addEventListener;
//				if (type === 'click') {
//					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
//						if (!event.propagationStopped) {
//							callback(event);
//						}
//					}), capture);
//				} else {
//					adv.call(layer, type, callback, capture);
//				}
//			};
//		}
//
//		// If a handler is already declared in the element's onclick attribute, it will be fired before
//		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
//		// adding it as listener.
//		if (typeof layer.onclick === 'function') {
//
//			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
//			// - the old one won't work if passed to addEventListener directly.
//			oldOnClick = layer.onclick;
//			layer.addEventListener('click', function(event) {
//				oldOnClick(event);
//			}, false);
//			layer.onclick = null;
//		}
//	}
//
//	/**
//	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
//	*
//	* @type boolean
//	*/
//	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;
//
//	/**
//	 * Android requires exceptions.
//	 *
//	 * @type boolean
//	 */
//	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;
//
//
//	/**
//	 * iOS requires exceptions.
//	 *
//	 * @type boolean
//	 */
//	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;
//
//
//	/**
//	 * iOS 4 requires an exception for select elements.
//	 *
//	 * @type boolean
//	 */
//	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);
//
//
//	/**
//	 * iOS 6.0-7.* requires the target element to be manually derived
//	 *
//	 * @type boolean
//	 */
//	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);
//
//	/**
//	 * BlackBerry requires exceptions.
//	 *
//	 * @type boolean
//	 */
//	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;
//
//	/**
//	 * Determine whether a given element requires a native click.
//	 *
//	 * @param {EventTarget|Element} target Target DOM element
//	 * @returns {boolean} Returns true if the element needs a native click
//	 */
//	FastClick.prototype.needsClick = function(target) {
//		switch (target.nodeName.toLowerCase()) {
//
//		// Don't send a synthetic click to disabled inputs (issue #62)
//		case 'button':
//		case 'select':
//		case 'textarea':
//			if (target.disabled) {
//				return true;
//			}
//
//			break;
//		case 'input':
//
//			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
//			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
//				return true;
//			}
//
//			break;
//		case 'label':
//		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
//		case 'video':
//			return true;
//		}
//
//		return (/\bneedsclick\b/).test(target.className);
//	};
//
//
//	/**
//	 * Determine whether a given element requires a call to focus to simulate click into element.
//	 *
//	 * @param {EventTarget|Element} target Target DOM element
//	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
//	 */
//	FastClick.prototype.needsFocus = function(target) {
//		switch (target.nodeName.toLowerCase()) {
//		case 'textarea':
//			return true;
//		case 'select':
//			return !deviceIsAndroid;
//		case 'input':
//			switch (target.type) {
//			case 'button':
//			case 'checkbox':
//			case 'file':
//			case 'image':
//			case 'radio':
//			case 'submit':
//				return false;
//			}
//
//			// No point in attempting to focus disabled inputs
//			return !target.disabled && !target.readOnly;
//		default:
//			return (/\bneedsfocus\b/).test(target.className);
//		}
//	};
//
//
//	/**
//	 * Send a click event to the specified element.
//	 *
//	 * @param {EventTarget|Element} targetElement
//	 * @param {Event} event
//	 */
//	FastClick.prototype.sendClick = function(targetElement, event) {
//		var clickEvent, touch;
//        
//		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
//		if (document.activeElement && document.activeElement !== targetElement) {
//			document.activeElement.blur();
//		}
//
//		touch = event.changedTouches[0];
//
//		// Synthesise a click event, with an extra attribute so it can be tracked
//		clickEvent = document.createEvent('MouseEvents');
//		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
//		clickEvent.forwardedTouchEvent = true;
//		targetElement.dispatchEvent(clickEvent);
//	};
//
//	FastClick.prototype.determineEventType = function(targetElement) {
//
//		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
//		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
//			return 'mousedown';
//		}
//
//		return 'click';
//	};
//
//
//	/**
//	 * @param {EventTarget|Element} targetElement
//	 */
//	FastClick.prototype.focus = function(targetElement) {
//		var length;
//
//		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
//		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && //targetElement.type !== 'month') {
//			length = targetElement.value.length;
//			targetElement.setSelectionRange(length, length);
//		} else {
//			targetElement.focus();
//		}
//	};
//
//
//	/**
//	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
//	 *
//	 * @param {EventTarget|Element} targetElement
//	 */
//	FastClick.prototype.updateScrollParent = function(targetElement) {
//		var scrollParent, parentElement;
//
//		scrollParent = targetElement.fastClickScrollParent;
//
//		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
//		// target element was moved to another parent.
//		if (!scrollParent || !scrollParent.contains(targetElement)) {
//			parentElement = targetElement;
//			do {
//				if (parentElement.scrollHeight > parentElement.offsetHeight) {
//					scrollParent = parentElement;
//					targetElement.fastClickScrollParent = parentElement;
//					break;
//				}
//
//				parentElement = parentElement.parentElement;
//			} while (parentElement);
//		}
//
//		// Always update the scroll top tracker if possible.
//		if (scrollParent) {
//			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
//		}
//	};
//
//
//	/**
//	 * @param {EventTarget} targetElement
//	 * @returns {Element|EventTarget}
//	 */
//	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
//
//		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
//		if (eventTarget.nodeType === Node.TEXT_NODE) {
//			return eventTarget.parentNode;
//		}
//
//		return eventTarget;
//	};
//
//
//	/**
//	 * On touch start, record the position and scroll offset.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onTouchStart = function(event) {
//		var targetElement, touch, selection;
//
//		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
//		if (event.targetTouches.length > 1) {
//			return true;
//		}
//
//		targetElement = this.getTargetElementFromEventTarget(event.target);
//		touch = event.targetTouches[0];
//
//		if (deviceIsIOS) {
//
//			// Only trusted events will deselect text on iOS (issue #49)
//			selection = window.getSelection();
//			if (selection.rangeCount && !selection.isCollapsed) {
//				return true;
//			}
//
//			if (!deviceIsIOS4) {
//
//				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
//				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
//				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
//				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
//				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
//				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
//				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
//				// random integers, it's safe to to continue if the identifier is 0 here.
//				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
//					event.preventDefault();
//					return false;
//				}
//
//				this.lastTouchIdentifier = touch.identifier;
//
//				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
//				// 1) the user does a fling scroll on the scrollable layer
//				// 2) the user stops the fling scroll with another tap
//				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
//				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
//				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
//				this.updateScrollParent(targetElement);
//			}
//		}
//
//		this.trackingClick = true;
//		this.trackingClickStart = event.timeStamp;
//		this.targetElement = targetElement;
//
//		this.touchStartX = touch.pageX;
//		this.touchStartY = touch.pageY;
//
//		// Prevent phantom clicks on fast double-tap (issue #36)
//		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
//			event.preventDefault();
//		}
//
//		return true;
//	};
//
//
//	/**
//	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.touchHasMoved = function(event) {
//		var touch = event.changedTouches[0], boundary = this.touchBoundary;
//
//		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
//			return true;
//		}
//
//		return false;
//	};
//
//
//	/**
//	 * Update the last position.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onTouchMove = function(event) {
//		if (!this.trackingClick) {
//			return true;
//		}
//
//		// If the touch has moved, cancel the click tracking
//		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
//			this.trackingClick = false;
//			this.targetElement = null;
//		}
//
//		return true;
//	};
//
//
//	/**
//	 * Attempt to find the labelled control for the given label element.
//	 *
//	 * @param {EventTarget|HTMLLabelElement} labelElement
//	 * @returns {Element|null}
//	 */
//	FastClick.prototype.findControl = function(labelElement) {
//
//		// Fast path for newer browsers supporting the HTML5 control attribute
//		if (labelElement.control !== undefined) {
//			return labelElement.control;
//		}
//
//		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
//		if (labelElement.htmlFor) {
//			return document.getElementById(labelElement.htmlFor);
//		}
//
//		// If no for attribute exists, attempt to retrieve the first labellable descendant element
//		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
//		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
//	};
//
//
//	/**
//	 * On touch end, determine whether to send a click event at once.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onTouchEnd = function(event) {
//		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;
//        
//        //console.trace('TRACE');
//        
//		if (!this.trackingClick) {
//			return true;
//		}
//
//		// Prevent phantom clicks on fast double-tap (issue #36)
//		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
//			this.cancelNextClick = true;
//			return true;
//		}
//
//		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
//			return true;
//		}
//
//		// Reset to prevent wrong click cancel on input (issue #156).
//		this.cancelNextClick = false;
//
//		this.lastClickTime = event.timeStamp;
//
//		trackingClickStart = this.trackingClickStart;
//		this.trackingClick = false;
//		this.trackingClickStart = 0;
//
//		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
//		// is performing a transition or scroll, and has to be re-detected manually. Note that
//		// for this to function correctly, it must be called *after* the event target is checked!
//		// See issue #57; also filed as rdar://13048589 .
//		if (deviceIsIOSWithBadTarget) {
//			touch = event.changedTouches[0];
//
//			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
//			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
//			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
//		}
//
//		targetTagName = targetElement.tagName.toLowerCase();
//		if (targetTagName === 'label') {
//			forElement = this.findControl(targetElement);
//			if (forElement) {
//				this.focus(targetElement);
//				if (deviceIsAndroid) {
//					return false;
//				}
//
//				targetElement = forElement;
//			}
//		} else if (this.needsFocus(targetElement)) {
//
//			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
//			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
//			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
//				this.targetElement = null;
//				return false;
//			}
//
//			this.focus(targetElement);
//			this.sendClick(targetElement, event);
//
//			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
//			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
//			if (!deviceIsIOS || targetTagName !== 'select') {
//				this.targetElement = null;
//				event.preventDefault();
//			}
//
//			return false;
//		}
//
//		if (deviceIsIOS && !deviceIsIOS4) {
//
//			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
//			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
//			scrollParent = targetElement.fastClickScrollParent;
//			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
//				return true;
//			}
//		}
//
//		// Prevent the actual click from going though - unless the target node is marked as requiring
//		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
//		if (!this.needsClick(targetElement)) {
//			event.preventDefault();
//			this.sendClick(targetElement, event);
//		}
//
//		return false;
//	};
//
//
//	/**
//	 * On touch cancel, stop tracking the click.
//	 *
//	 * @returns {void}
//	 */
//	FastClick.prototype.onTouchCancel = function() {
//		this.trackingClick = false;
//		this.targetElement = null;
//	};
//
//
//	/**
//	 * Determine mouse events which should be permitted.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onMouse = function(event) {
//
//		// If a target element was never set (because a touch event was never fired) allow the event
//		if (!this.targetElement) {
//			return true;
//		}
//
//		if (event.forwardedTouchEvent) {
//			return true;
//		}
//
//		// Programmatically generated events targeting a specific element should be permitted
//		if (!event.cancelable) {
//			return true;
//		}
//
//		// Derive and check the target element to see whether the mouse event needs to be permitted;
//		// unless explicitly enabled, prevent non-touch click events from triggering actions,
//		// to prevent ghost/doubleclicks.
//		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
//
//			// Prevent any user-added listeners declared on FastClick element from being fired.
//			if (event.stopImmediatePropagation) {
//				event.stopImmediatePropagation();
//			} else {
//
//				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
//				event.propagationStopped = true;
//			}
//
//			// Cancel the event
//			event.stopPropagation();
//			event.preventDefault();
//
//			return false;
//		}
//
//		// If the mouse event is permitted, return true for the action to go through.
//		return true;
//	};
//
//
//	/**
//	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
//	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
//	 * an actual click which should be permitted.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onClick = function(event) {
//		var permitted;
//        
//		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
//		if (this.trackingClick) {
//			this.targetElement = null;
//			this.trackingClick = false;
//			return true;
//		}
//        
//		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
//		if (event.target.type === 'submit' && event.detail === 0) {
//			return true;
//		}
//        
//		permitted = this.onMouse(event);
//        
//		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the //browser's click doesn't go through.
//		if (!permitted) {
//			this.targetElement = null;
//		}
//        
//		// If clicks are permitted, return true for the action to go through.
//		return permitted;
//	};
//
//
//	/**
//	 * Remove all FastClick's event listeners.
//	 *
//	 * @returns {void}
//	 */
//	FastClick.prototype.destroy = function() {
//		var layer = this.layer;
//
//		if (deviceIsAndroid) {
//			layer.removeEventListener('mouseover', this.onMouse, true);
//			layer.removeEventListener('mousedown', this.onMouse, true);
//			layer.removeEventListener('mouseup', this.onMouse, true);
//		}
//
//		layer.removeEventListener('click', this.onClick, true);
//		layer.removeEventListener('touchstart', this.onTouchStart, false);
//		layer.removeEventListener('touchmove', this.onTouchMove, false);
//		layer.removeEventListener('touchend', this.onTouchEnd, false);
//		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
//	};
//
//
//	/**
//	 * Check whether FastClick is needed.
//	 *
//	 * @param {Element} layer The layer to listen on
//	 */
//	FastClick.notNeeded = function(layer) {
//		var metaViewport;
//		var chromeVersion;
//		var blackberryVersion;
//		var firefoxVersion;
//
//		// Devices that don't support touch don't need FastClick
//		if (typeof window.ontouchstart === 'undefined') {
//			return true;
//		}
//
//		// Chrome version - zero for other browsers
//		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];
//
//		if (chromeVersion) {
//
//			if (deviceIsAndroid) {
//				metaViewport = document.querySelector('meta[name=viewport]');
//
//				if (metaViewport) {
//					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
//					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
//						return true;
//					}
//					// Chrome 32 and above with width=device-width or less don't need FastClick
//					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
//						return true;
//					}
//				}
//
//			// Chrome desktop doesn't need FastClick (issue #15)
//			} else {
//				return true;
//			}
//		}
//
//		if (deviceIsBlackBerry10) {
//			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);
//
//			// BlackBerry 10.3+ does not require Fastclick library.
//			// https://github.com/ftlabs/fastclick/issues/251
//			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
//				metaViewport = document.querySelector('meta[name=viewport]');
//
//				if (metaViewport) {
//					// user-scalable=no eliminates click delay.
//					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
//						return true;
//					}
//					// width=device-width (or less than device-width) eliminates click delay.
//					if (document.documentElement.scrollWidth <= window.outerWidth) {
//						return true;
//					}
//				}
//			}
//		}
//
//		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
//		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
//			return true;
//		}
//
//		// Firefox version - zero for other browsers
//		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];
//
//		if (firefoxVersion >= 27) {
//			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896
//
//			metaViewport = document.querySelector('meta[name=viewport]');
//			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
//				return true;
//			}
//		}
//
//		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
//		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
//		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
//			return true;
//		}
//
//		return false;
//	};
//
//
//	/**
//	 * Factory method for creating a FastClick object
//	 *
//	 * @param {Element} layer The layer to listen on
//	 * @param {Object} [options={}] The options to override the defaults
//	 */
//	FastClick.attach = function(layer, options) {
//		return new FastClick(layer, options);
//	};
//
//
//	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
//
//		// AMD. Register as an anonymous module.
//		define(function() {
//			return FastClick;
//		});
//	} else if (typeof module !== 'undefined' && module.exports) {
//		module.exports = FastClick.attach;
//		module.exports.FastClick = FastClick;
//	} else {
//		window.FastClick = FastClick;
//	}
//}());




/*
    json_parse.js
    2012-06-20

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    This file creates a json_parse function.

        json_parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = json_parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

    This is a reference implementation. You are free to copy, modify, or
    redistribute.

    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.
*/

/*members "", "\"", "\/", "\\", at, b, call, charAt, f, fromCharCode,
    hasOwnProperty, message, n, name, prototype, push, r, t, text
*/


window.JSON = window.JSON || {};

window.JSON.parse = (function () {
    "use strict";

// This is a function that can parse a JSON text, producing a JavaScript
// data structure. It is a simple, recursive descent parser. It does not use
// eval or regular expressions, so it can be used as a model for implementing
// a JSON parser in other languages.

// We are defining the function inside of another function to avoid creating
// global variables.

    var at,     // The index of the current character
        ch,     // The current character
        escapee = {
            '"':  '"',
            '\\': '\\',
            '/':  '/',
            b:    '\b',
            f:    '\f',
            n:    '\n',
            r:    '\r',
            t:    '\t'
        },
        text,

        error = function (m) {

// Call error when something is wrong.

            throw {
                name:    'SyntaxError',
                message: m,
                at:      at,
                text:    text
            };
        },

        next = function (c) {

// If a c parameter is provided, verify that it matches the current character.

            if (c && c !== ch) {
                error("Expected '" + c + "' instead of '" + ch + "'");
            }

// Get the next character. When there are no more characters,
// return the empty string.

            ch = text.charAt(at);
            at += 1;
            return ch;
        },

        number = function () {

// Parse a number value.

            var number,
                string = '';

            if (ch === '-') {
                string = '-';
                next('-');
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
            if (ch === '.') {
                string += '.';
                while (next() && ch >= '0' && ch <= '9') {
                    string += ch;
                }
            }
            if (ch === 'e' || ch === 'E') {
                string += ch;
                next();
                if (ch === '-' || ch === '+') {
                    string += ch;
                    next();
                }
                while (ch >= '0' && ch <= '9') {
                    string += ch;
                    next();
                }
            }
            number = +string;
            if (!isFinite(number)) {
                error("Bad number");
            } else {
                return number;
            }
        },

        string = function () {

// Parse a string value.

            var hex,
                i,
                string = '',
                uffff;

// When parsing for string values, we must look for " and \ characters.

            if (ch === '"') {
                while (next()) {
                    if (ch === '"') {
                        next();
                        return string;
                    }
                    if (ch === '\\') {
                        next();
                        if (ch === 'u') {
                            uffff = 0;
                            for (i = 0; i < 4; i += 1) {
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                uffff = uffff * 16 + hex;
                            }
                            string += String.fromCharCode(uffff);
                        } else if (typeof escapee[ch] === 'string') {
                            string += escapee[ch];
                        } else {
                            break;
                        }
                    } else {
                        string += ch;
                    }
                }
            }
            error("Bad string");
        },

        white = function () {

// Skip whitespace.

            while (ch && ch <= ' ') {
                next();
            }
        },

        word = function () {

// true, false, or null.

            switch (ch) {
            case 't':
                next('t');
                next('r');
                next('u');
                next('e');
                return true;
            case 'f':
                next('f');
                next('a');
                next('l');
                next('s');
                next('e');
                return false;
            case 'n':
                next('n');
                next('u');
                next('l');
                next('l');
                return null;
            }
            error("Unexpected '" + ch + "'");
        },

        value,  // Place holder for the value function.

        array = function () {

// Parse an array value.

            var array = [];

            if (ch === '[') {
                next('[');
                white();
                if (ch === ']') {
                    next(']');
                    return array;   // empty array
                }
                while (ch) {
                    array.push(value());
                    white();
                    if (ch === ']') {
                        next(']');
                        return array;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad array");
        },

        object = function () {

// Parse an object value.

            var key,
                object = {};

            if (ch === '{') {
                next('{');
                white();
                if (ch === '}') {
                    next('}');
                    return object;   // empty object
                }
                while (ch) {
                    key = string();
                    white();
                    next(':');
                    if (Object.hasOwnProperty.call(object, key)) {
                        error('Duplicate key "' + key + '"');
                    }
                    object[key] = value();
                    white();
                    if (ch === '}') {
                        next('}');
                        return object;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad object");
        };

    value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

        white();
        switch (ch) {
        case '{':
            return object();
        case '[':
            return array();
        case '"':
            return string();
        case '-':
            return number();
        default:
            return ch >= '0' && ch <= '9' ? number() : word();
        }
    };

// Return the json_parse function. It will have access to all of the above
// functions and variables.

    return function (source, reviver) {
        var result;

        text = source;
        at = 0;
        ch = ' ';
        result = value();
        white();
        if (ch) {
            error("Syntax error");
        }

// If there is a reviver function, we recursively walk the new structure,
// passing each name/value pair to the reviver function for possible
// transformation, starting with a temporary root object that holds the result
// in an empty key. If there is not a reviver function, we simply return the
// result.

        return typeof reviver === 'function'
            ? (function walk(holder, key) {
                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }({'': result}, ''))
            : result;
    };
}());// ##############################################################
// ################ doT.js AND RELATED FUNCTIONS ################
// ##############################################################

// Laura Doktorova https://github.com/olado/doT
// version: 1.0.3
(function(){function p(b,a,d){return("string"===typeof a?a:a.toString()).replace(b.define||h,function(a,c,e,g){0===c.indexOf("def.")&&(c=c.substring(4));c in d||(":"===e?(b.defineParams&&g.replace(b.defineParams,function(a,b,l){d[c]={arg:b,text:l}}),c in d||(d[c]=g)):(new Function("def","def['"+c+"']="+g))(d));return""}).replace(b.use||h,function(a,c){b.useParams&&(c=c.replace(b.useParams,function(a,b,c,l){if(d[c]&&d[c].arg&&l)return a=(c+":"+l).replace(/'|\\/g,"_"),d.__exp=d.__exp||{},d.__exp[a]=
d[c].text.replace(new RegExp("(^|[^\\w$])"+d[c].arg+"([^\\w$])","g"),"$1"+l+"$2"),b+"def.__exp['"+a+"']"}));var e=(new Function("def","return "+c))(d);return e?p(b,e,d):e})}function k(b){return b.replace(/\\('|\\)/g,"$1").replace(/[\r\t\n]/g," ")}var f={version:"1.0.3",templateSettings:{evaluate:/\{\{([\s\S]+?(\}?)+)\}\}/g,interpolate:/\{\{=([\s\S]+?)\}\}/g,encode:/\{\{!([\s\S]+?)\}\}/g,use:/\{\{#([\s\S]+?)\}\}/g,useParams:/(^|[^\w$])def(?:\.|\[[\'\"])([\w$\.]+)(?:[\'\"]\])?\s*\:\s*([\w$\.]+|\"[^\"]+\"|\'[^\']+\'|\{[^\}]+\})/g,
define:/\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,defineParams:/^\s*([\w$]+):([\s\S]+)/,conditional:/\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,iterate:/\{\{~\s*(?:\}\}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,varname:"it",strip:!0,append:!0,selfcontained:!1,doNotSkipEncoded:!1},template:void 0,compile:void 0},m;


f.encodeHTMLSource=function(b){var a={"&":"&#38;","<":"&#60;",">":"&#62;",'"':"&#34;","'":"&#39;","/":"&#47;"},d=b?/[&<>"'\/]/g:/&(?!#?\w+;)|<|>|"|'|\//g;return function(b){return b?
b.toString().replace(d,function(b){return a[b]||b}):b}}; // replaced :"" with :b so that if you put a zero in encodehtml you get a zero out of encodehtml


m=function(){return this||(0,eval)("this")}();

"undefined"!==typeof module&&module.exports?module.exports=f:"function"===typeof define&&define.amd?define(function(){return f}):m.doT=f;



var r={start:"'+(",end:")+'",startencode:"'+encodeHTML("},s={start:"';out+=(",end:");out+='",startencode:"';out+=encodeHTML("},h=/$^/;f.template=function(b,a,d){a=a||f.templateSettings;var n=a.append?r:s,c,e=0,g;b=a.use||a.define?p(a,b,d||{}):b;b=("var out='"+(a.strip?
b.replace(/(^|\r|\n)\t* +| +\t*(\r|\n|$)/g," ").replace(/\r|\n|\t|\/\*[\s\S]*?\*\//g,""):b).replace(/'|\\/g,"\\$&").replace(a.interpolate||h,function(b,a){return n.start+k(a)+n.end}).replace(a.encode||h,function(b,a){c=!0;return n.startencode+k(a)+n.end}).replace(a.conditional||h,function(b,a,c){return a?c?"';}else if("+k(c)+"){out+='":"';}else{out+='":c?"';if("+k(c)+"){out+='":"';}out+='"}).replace(a.iterate||h,function(b,a,c,d){if(!a)return"';} } out+='";e+=1;g=d||"i"+e;a=k(a);return"';var arr"+
e+"="+a+";if(arr"+e+"){var "+c+","+g+"=-1,l"+e+"=arr"+e+".length-1;while("+g+"<l"+e+"){"+c+"=arr"+e+"["+g+"+=1];out+='"}).replace(a.evaluate||h,function(a,b){return"';"+k(b)+"out+='"})+"';return out;").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r").replace(/(\s|;|\}|^|\{)out\+='';/g,"$1").replace(/\+''/g,"");c&&(a.selfcontained||!m||m._encodeHTML||(m._encodeHTML=f.encodeHTMLSource(a.doNotSkipEncoded)),b="var encodeHTML = typeof _encodeHTML !== 'undefined' ? _encodeHTML : ("+f.encodeHTMLSource.toString()+
"("+(a.doNotSkipEncoded||"")+"));"+b);try{return new Function(a.varname,b)}catch(q){throw"undefined"!==typeof console&&console.log("Could not create a template function: "+b),q;}};f.compile=function(b,a){return f.template(b,null,a)}


    // we use doT.js in the global space, but sometimes module may be
    //      defined (electron defines module automatically) so we need to copy dot to
    //      the global namespace
    if (!window.doT) { // && window.module
        window.doT = f;
        
        //window.doT.encodeHTMLSource = module.exports.encodeHTMLSource;
        //window.doT.compile = module.exports.compile;
        //window.doT.templateSettings = module.exports.templateSettings;
        //window.doT.template = module.exports.template;
    }
})();


doT.templateSettings = {
    evaluate:    /\{\{([\s\S]+?)\}\}/g,
    interpolate: /\{\{=([\s\S]+?)\}\}/g,
    encode:      /\{\{!([\s\S]+?)\}\}/g,
    use:         /\{\{#([\s\S]+?)\}\}/g,
    define:      /\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,
    conditional: /\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,
    iterate:     /\{\{~\s*(?:}}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,
    varname: 'jo',
    strip: false,
    append: true,
    selfcontained: false
};

// html encoding function used by doT.js
function encodeHTML(text) {
    'use strict';
    var encode = {
        "&": "&#38;",
        "<": "&#60;",
        ">": "&#62;",
        '"': "&#34;",
        "'": "&#39;",
        "/": "&#47;"
    };
    return text ? text.toString().replace(/&|<|>|"|'|\//g, function (letter) {
        return encode[letter] || letter;
    }) : text;
}

// html decoding function
function decodeHTML(text) {
    'use strict';
    var decode = {
        "&#38;": "&",
        "&amp;": "&",
        
        "&#60;": "<",
        "&#62;": ">",
        
        "&lt;":  "<", // The rose by another name
        "&gt;":  ">", // The rose by another name
        
        "&#34;": '"',
        "&#39;": "'",
        "&#47;": "/"
    };
    return text ? text.toString().replace(/&#38;|&amp;|&#60;|&#62;|&lt;|&gt;|&#34;|&#39;|&#47;/g, function (letter) {
        return decode[letter] || letter;
    }) : text;
}

// multiline strings in javascript
//
// ml(function () {/*
//     multiline string
//     hey
// */console.log});
function ml(func) {
    'use strict';
    
    func = func.toString();
    
    return func.substring(func.indexOf('/*') + 2, func.indexOf('*/'));
}
//global window
//jslint white:true multivar:true

// #############################################################
// ################### CROSS PLATFORM EVENTS ###################
// #############################################################

if (window.evt === undefined) {
    window.evt = {};
}

// function for testing if the device has touch capibilities
function touchDeviceTest() {
    'use strict';
    //return 'ontouchstart' in window ||    // works on most browsers
    //       'onmsgesturechange' in window; // works on ie10
    return (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) || false;
}

// display type based on size
function getDeviceType() {
    'use strict';
    // if we are not on a touch device than we must be a desktop
    if (evt.touchDevice === false) {
        return 'desktop';
    }
    // if touch device and screen is bigger than normal phone
    if (evt.touchDevice === true && screen.width > 500) {
        return 'tablet';
    }
    // if the screen is small and we are a touch device we are a phone
    return 'phone';
}

/*DOC
Name:
    evt.*

Description:
    This is a collection of global variables that are used for browser-type detection and for using different events for different devices.
    The reason for this is because even though the 'mousedown' event works on a phone it is substantially slower than if you had used 'touchstart',
    But if you used 'touchstart' it wouldn't work on the computer so we wrap both under the name evt.mousedown and only give mobile browsers
    'touchstart' and desktop browsers 'mousedown' so that you dont have to differentiate.
    
List of variables:
    evt.touchDevice  equals true|false depending on whether or not we are on a touch-enabled devide
    evt.deviceType   equals 'desktop'|'tablet'|'phone' depending on what type of device you are on
    
    evt.mousedown    if we are on a touch device: 'touchstart'  else  'mousedown'
    evt.mouseover    if we are on a touch device: 'touchenter'  else  'mouseover'
    evt.mousemove    if we are on a touch device: 'touchmove'   else  'mousemove'
    evt.mouseout     if we are on a touch device: 'touchleave'  else  'mouseout'
    evt.mouseup      if we are on a touch device: 'touchend'    else  'mouseup'
    evt.click        if we are on a touch device: 'touchend'    else  'click'

*/

// this is for detecting whether or not we are in an touch device
evt.touchDevice = touchDeviceTest();

// set global variable for display type
evt.deviceType = getDeviceType();

evt.mousedown = evt.touchDevice ? 'touchstart': 'mousedown';
evt.mouseover = evt.touchDevice ? 'touchenter': 'mouseover';
evt.mousemove = evt.touchDevice ? 'touchmove' : 'mousemove';
evt.mouseout  = evt.touchDevice ? 'touchleave': 'mouseout';
evt.mouseup   = evt.touchDevice ? 'touchend'  : 'mouseup';
evt.click     = 'click';

// ##############################################################
// ########### PINK BACKGROUND WHEN NOT IN PRODUCTION ###########
// ##############################################################
/*
//DO NOT UNCOMMENT
//To use:
//Add this javascript to the test.sh file
//Append to greyspots.js after the rsync of the web_root files
window.addEventListener('load', function () {
    var styleElement, helperElement, helperFunction;
    
    styleElement = document.createElement('style');
    styleElement.innerHTML = 'body, body gs-panel, body gs-panel gs-header, body gs-panel gs-body, ' +
                             'body gs-page, body gs-page gs-header, body gs-page gs-body {\n' +
                             '    background-color: #FFBBBB;\n' +
                             '}';
    
    document.head.appendChild(styleElement);
});
*/

// #############################################################
// #################### DEFINE GS NAMESPACE ####################
// #############################################################

if (window.GS === undefined) {
    window.GS = {};
    
    GS.version = function () {
        'use strict';
        return '1.1.1';
    };
    
    window.addEventListener('design-register-element', function () {
        'use strict';
        
        registerDesignSnippet('GS.version', 'GS.version', 'GS.version();');
    });
}

// ##############################################################
// ################## DEFINE support NAMESPACE ##################
// ##############################################################

if (window.shimmed === undefined) {
    window.shimmed = {};
}

// ##############################################################
// ############### DEFINE functionality NAMESPACE ###############
// ##############################################################

if (window.functionality === undefined) {
    window.functionality = {"errors": {}};
}

// ##############################################################
// ####################### NO CONSOLE FIX #######################
// ##############################################################

// in IE8 when the dev tools are not open console.log is not defined so if there was a console.log() the page would error
//      this defines the console object if it is empty so that if there is a console.log() it will not error in IE8
if (typeof console === 'undefined' || !console.log) {
    window.console = {
        log:   function () { 'use strict'; },
        info:  function () { 'use strict'; },
        debug: function () { 'use strict'; },
        warn:  function () { 'use strict'; },
        trace: function () { 'use strict'; },
        error: function () { 'use strict'; }
    };
}


// ##############################################################
// ######## PREVENT WINDOW OVERSCROLLING ON TOUCH DEVICE ########
// ##############################################################
/*
if (evt.touchDevice) {
    (function () {
        var startTime, startTouchTop, endTime, endTouchTop, lastTouchTop, currentTouchTop,
            bolCurrentlyMonitoring = false, bolTouchScrollPrevented = false, currentScrollingElement, scrollingLooper;
        
        window.ontouchstart = function(event){
            lastTouchTop = GS.mousePosition(event).top;
        };
        
        //window.addEventListener('scroll', function (event) {
        //    console.log(event);
        //}, true);
        
        window.ontouchmove = function (event) {
            var currentTouchTop = GS.mousePosition(event).top, currentElement = GS.scrollParent(event.target), bolFoundScrollable = Boolean(currentElement);
            
            //console.log(currentElement,
            //            event.target,
            //            bolFoundScrollable,
            //            currentElement.scrollTop,
            //            currentElement.clientHeight,
            //            currentElement.scrollHeight,
            //            currentTouchTop,
            //            lastTouchTop);
            //console.log(currentElement.scrollTop <= 0,
            //            currentTouchTop > lastTouchTop,
            //            currentElement.scrollTop + currentElement.clientHeight >= currentElement.scrollHeight,
            //            currentTouchTop < lastTouchTop);
            
            if (bolFoundScrollable === false ||
                (currentElement.scrollTop <= 0 && currentTouchTop > lastTouchTop) ||
                (currentElement.scrollTop + currentElement.clientHeight >= currentElement.scrollHeight && currentTouchTop < lastTouchTop)) {
                
                //console.log('prevent default');
                
                bolTouchScrollPrevented = true;
                event.preventDefault();
                //event.stopPropagation();
                
            } else if (bolFoundScrollable === true && bolTouchScrollPrevented === true) {
                currentElement.scrollTop += (lastTouchTop - currentTouchTop);
            }
            
            currentScrollingElement = currentElement;
            lastTouchTop = currentTouchTop;
        };
        
        window.ontouchend = function () {
            bolTouchScrollPrevented = false;
        };
    })();
}*/


// ##############################################################
// ################### DATABASE NORMALIZATION ###################
// ##############################################################

GS.database = {"engine": "", "type": {}};
GS.database.engine = "postgres";


// if db is SQL Server: utf16 else utf8
(function () {
    "use strict";
    
    // get a cookie from the browser
    function getCookie(c_name) {
        var c_value = document.cookie, c_end,
            c_start = c_value.indexOf(" " + c_name + "=");

        if (c_start === -1) {
            c_start = c_value.indexOf(c_name + "=");
        }
        if (c_start === -1) {
            c_value = null;
        } else {
            c_start = c_value.indexOf("=", c_start) + 1;
            c_end = c_value.indexOf(";", c_start);
            if (c_end === -1) {
                c_end = c_value.length;
            }
            c_value = decodeURIComponent(c_value.substring(c_start, c_end));
        }
        return c_value;
    };

    if ((getCookie('DB') || 'PG').toUpperCase() === 'PG') {
        GS.database.engine = 'postgres';
    } else { //ss
        GS.database.engine = 'mssqlserver'
    }
    
    if (GS.database.engine === "postgres") {
        GS.database.type.text = "text";
        GS.database.type.timestamp = "timestamptz";
        
    } else if (GS.database.engine === "mssqlserver") {
        GS.database.type.text = "nvarchar(MAX)";
        GS.database.type.timestamp = "datetime";
    }
}());





// ##############################################################
// ########### LABEL CLICK: FOCUS USING FOR ATTRIBUTE ###########
// ##############################################################

window.addEventListener('click', function (event) {
    'use strict';
    var labelElement, targetElement;
    
    //console.log(event.target, GS.findParentTag(event.target, 'LABEL'));
    
    if (event.target.nodeName === 'LABEL') {
        labelElement = event.target;
    } else if (GS.findParentTag(event.target, 'LABEL')) {
        labelElement = GS.findParentTag(event.target, 'LABEL');
    }
    
    //console.log(labelElement, labelElement.getAttribute('for'));
    
    if (labelElement && labelElement.hasAttribute('for')) {
        targetElement = document.getElementById(labelElement.getAttribute('for'));
        
        //console.log(targetElement);
        //console.log(targetElement.focus, !targetElement.hasAttribute('disabled'));
        
        if (targetElement && targetElement.focus && !targetElement.hasAttribute('disabled')) {
            targetElement.focus();
        }
    }
});


// #############################################################
// ######################### PAGE CURL #########################
// #############################################################
(function () {
    function aboutDialog() {
        'use strict';
        var templateElement = document.createElement('template');
        
        templateElement.innerHTML = ml(function () {/*
            <gs-page>
                <gs-header><center><h3>About Envelope</h3></center></gs-header>
                <gs-body padded>
                    <gs-grid widths="1,1" reflow-at="767px">
                        <gs-block>
                            <center><h3><a target="_blank" href="http://x-tag.github.io/">X-Tag</a></h3></center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center><h3><a target="_blank" href="http://olado.github.io/doT/">doT.js</a></h3></center>
                        </gs-block>
                        <gs-block>
                            <center><h4>{{DOT}}</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center><h3><a target="_blank" href="http://ace.c9.io/">Ace Editor</a></h3></center>
                        </gs-block>
                        <gs-block>
                            <center><h4>1.2.3</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center><h3><a target="_blank" href="http://jsbeautifier.org/">JSBeautifier</a></h3></center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center>
                                <h3><a target="_blank" href="https://github.com/douglascrockford/JSON-js">
                                    json_parse.js (modified)
                                </a></h3>
                            </center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center>
                                <h3><a target="_blank" href="https://www.polymer-project.org/1.0/">
                                    HTML Template Polyfill (modified)
                                </a></h3>
                            </center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center>
                                <h3><a target="_blank" href="https://github.com/ftlabs/fastclick">FastClick</a></h3>
                            </center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center>
                                <h3><a target="_blank" href="https://code.google.com/archive/p/crypto-js/">CryptoJS (MD5 Portion)</a></h3>
                            </center>
                        </gs-block>
                        <gs-block>
                            <center><h4>3.1.2</h4></center>
                        </gs-block>
                        
                    </gs-grid>
                    
                    <div>
                        All other source code and documentation copyright Workflow Products, LLC. All Rights Reserved.
                        <br /><br />
                        The Envelope platform is available for many platforms and most embedded devices. If you'd like your application built using Envelope technology please contact us.
                        <br /><br />
                        Commercial license terms for the Envelope platform are available for a small fee. Contact us for details.
                        <br /><br />
                        <center><b>Workflow Products, L.L.C.</b></center>
                        <center>7813 Harwood Road</center>
                        <center>North Richland Hills Texas 76180</center>
                        <center>(817) 503-9545</center>
                    </div>
                    <br />
                    <center><small><i>Copyright &copy; 2016-present by Workflow Products, L.L.C. (817) 503-9545</i></small></center>
                </gs-body>
                <gs-footer>
                    <gs-button dialogclose>Done</gs-button>
                </gs-footer>
            </gs-page>
        */}).replace(/\{\{DOT\}\}/gi, doT.version);
        
        GS.openDialog(templateElement);
    }
    
    
    window.addEventListener('load', function () {
        'use strict';
        var bolOpen, intMaxHeight, curlElement, menuElement, strPostageUName, strHTML, toggleCurl;
        
        if (window.bolCurl !== false) {
            bolOpen = false;
            intMaxHeight = 0;
            curlElement = document.createElement('div');
            menuElement = document.createElement('div');
            strPostageUName = GS.getCookie('postage_uname');
            strHTML = '';
            
            curlElement.setAttribute('id', 'gs-document-curl-container');
            curlElement.innerHTML = '<div id="gs-document-curl-part-1"></div>' +
                                    '<div id="gs-document-curl-part-2"></div>' +
                                    '<div id="gs-document-curl-part-3"></div>' +
                                    '<div id="gs-document-curl-part-4"></div>';
            
            document.body.appendChild(curlElement);
            
            if (evt.deviceType === 'phone') {
                curlElement.setAttribute('style', 'font-size: 1.3em;');
            } else {
                curlElement.setAttribute('style', 'font-size: 0.7em;');
            }
            
            menuElement.setAttribute('id', 'gs-document-menu-container');
            menuElement.setAttribute('style', 'height: 0px;');
            
            // this is for envelope
            if (location.pathname.indexOf('/env/') === 0) {
                strHTML += '<center><b><a target="_self" href="/env/app/all/index.html">Back To Main Menu</a></b></center>';
                strHTML += '<center>' +
                                '<gs-button target="_self" href="/env/auth/?action=logout" inline>Log out</gs-button><br />' +
                                '<gs-button onclick="GS.userChangePassword()" inline>Change Password</gs-button>' +
                            '</center>';
                intMaxHeight += 4.8;
                
            // and this is for postage
            } else {
                strHTML += '<center>' +
                                '<gs-button target="_self" href="/postage/auth?action=logout" inline>Log out</gs-button><br />' +
                                '<gs-button onclick="GS.userChangePassword()" inline>Change Password</gs-button>' +
                            '</center>';
                intMaxHeight += 3.4;
            }
            
            strHTML += '<center><gs-button onclick="GS.showShimmed()" inline>Browser Support</gs-button></center>';
            intMaxHeight += 1.9;
            
            strHTML += '<center><gs-button onclick="window.location.reload(true);" inline>Update Software</gs-button></center>';
            intMaxHeight += 1.9;
            
            if (location.pathname.indexOf('/env/') === 0) {
                strHTML += '<center><gs-button id="gs-button-about" inline>About</gs-button></center>';
                intMaxHeight += 1.9;
            }
            
            intMaxHeight += 1;
            
            menuElement.innerHTML = '<div id="gs-document-menu-link-container" style="height: ' + intMaxHeight + 'em;">' + strHTML + '</div>';
            document.body.appendChild(menuElement);
            
            if (location.pathname.indexOf('/env/') === 0) {
                document.getElementById('gs-button-about').addEventListener('click', aboutDialog);
            }
            
            // define function for toggling the page curl
            toggleCurl = function () {
                var intFontSize = GS.pxToEm(document.body, window.innerWidth) / 4,
                    intBottomLine = window.innerHeight - (GS.emToPx(document.body, intFontSize)),
                    closedSize = (evt.deviceType === 'phone' ? '1.3em' : '0.7em'); // replace evt.touchDevice with true to test on a desktop
                
                // maximum bottom line
                if (GS.pxToEm(document.body, intBottomLine) > intMaxHeight) {
                    intBottomLine = GS.emToPx(document.body, intMaxHeight);
                }
                
                //curlElement.classList.add('animating');
                //menuElement.classList.add('animating');
                
                if (bolOpen === false) {
                    document.body.insertBefore(GS.stringToElement('<div id="gs-document-curl-modal-background"></div>'), curlElement);
                    document.getElementById('gs-document-curl-modal-background').addEventListener('click', toggleCurl);
                    
                    curlElement.style.fontSize = intFontSize + 'em';
                    curlElement.style.bottom = intBottomLine + 'px';
                    menuElement.style.height = intBottomLine + 'px';
                    
                    //GS.animateStyle(curlElement, 'font-size', closedSize, intFontSize + 'em', function () {
                    //    curlElement.classList.remove('animating');
                    //}, 185, 14);
                    //
                    //GS.animateStyle(curlElement, 'bottom', '0px', intBottomLine + 'px', function () {
                    //    curlElement.classList.remove('animating');
                    //}, 185, 14);
                    //
                    //GS.animateStyle(menuElement, 'height', '0px', intBottomLine + 'px', function () {
                    //    menuElement.classList.remove('animating');
                    //}, 185, 14);
                    
                    bolOpen = true;
                } else {
                    document.body.removeChild(document.getElementById('gs-document-curl-modal-background'));
                    
                    curlElement.style.fontSize = closedSize;
                    curlElement.style.bottom = '0px';
                    menuElement.style.height = '0px';
                    
                    //GS.animateStyle(curlElement, 'font-size', intFontSize + 'em', closedSize, function () {
                    //    curlElement.classList.remove('animating');
                    //}, 185, 14);
                    //
                    //GS.animateStyle(curlElement, 'bottom', intBottomLine + 'px', '0px', function () {
                    //    curlElement.classList.remove('animating');
                    //}, 185, 14);
                    //
                    //GS.animateStyle(menuElement, 'height', intBottomLine + 'px', '0px', function () {
                    //    menuElement.classList.remove('animating');
                    //}, 185, 14);
                    
                    bolOpen = false;
                }
            };
            
            curlElement.addEventListener('click', toggleCurl);
        }
    });
})();

// ################################################################
// ###################### FASTCLICK POLYFILL ######################
// ################################################################

// double clicks will not work while using fastclick
// click events will not have a delay while using fastclick
// we chose fastclick :)

// if you need to turn fastclick off for an element use the "needsclick" class
// if you need to turn fastclick off for an elements children (but not the element itself) use the "childrenneedsclick" class
// if you need to turn fastclick off for an elements children and the element itself use the "childrenneedsclick" class and the "needsclick" class
if ('addEventListener' in document) {
    document.addEventListener('DOMContentLoaded', function() {
        'use strict';
        FastClick.attach(document.body);
    }, false);
}



// ##################################################################
// ##################### TEMPLATE GET INERT DOM #####################
// ##################################################################
/*
HTMLTemplateElement.prototype.contentTemplate = function () {
    'use strict';
    
    if (this.content) {
        
    } else {
        
    }
};
*/

// #################################################################
// ###################### POLYFILL/SHIM CHECK ######################
// #################################################################

window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('GS.showShimmed', 'GS.showShimmed', 'GS.showShimmed();');
});

window.addEventListener('load', function () {
    'use strict';
    function cleanFunctionForTest(fn) {
        fn = fn.toString().toLowerCase();   // convert function string and turn all text lowercase
        fn = fn.substring(fn.indexOf('{')); // remove everything up until the first open curly brace
        fn = fn.replace(/ /gim, '');        // remove all spaces
        
        return fn;
    }
    
    function nativeTest(fn) {
        // if there is not function: not native: return false
        if (!fn) {
            return false;
        }
        
        // clean function for native testing
        fn = cleanFunctionForTest(fn);
        
        return fn.indexOf('[nativecode]') > -1 ||                   // if '[nativecode]' is found in the cleaned text: native
               fn === cleanFunctionForTest(document.createElement); // else if the cleaned text matches a native function: native
    }
    
    shimmed.matchesSelector     = !nativeTest(Element.prototype.matchesSelector) &&
                                  !nativeTest(Element.prototype.webkitMatchesSelector) &&
                                  !nativeTest(Element.prototype.mozMatchesSelector) &&
                                  !nativeTest(Element.prototype.msMatchesSelector) &&
                                  !nativeTest(Element.prototype.MSMatchesSelector);
    
    shimmed.MutationObserver    = !nativeTest(window.MutationObserver);
    shimmed.WeakMap             = !nativeTest(window.WeakMap);
    shimmed.registerElement     = !nativeTest(document.registerElement);
    shimmed.DOMTokenList        = !nativeTest(window.DOMTokenList);
    shimmed.HTMLTemplateElement = Boolean(HTMLTemplateElement.bootstrap);
    
    // automated functionality testing
    
    functionality.matchesSelector = false;
    try {
        var bodyElement = document.body
          , matchesSelector = (Element.prototype.matchesSelector
                                || Element.prototype.webkitMatchesSelector
                                || Element.prototype.mozMatchesSelector
                                || Element.prototype.msMatchesSelector
                                || Element.prototype.MSMatchesSelector);
        
        functionality.matchesSelector = matchesSelector.apply(bodyElement, ['body']);
        
    } catch (e) {
        functionality.matchesSelector = false;
        functionality.errors.matchesSelector = e;
    }
    
    functionality.MutationObserver = false;
    try {
        var testElement = document.createElement('div'), observer;
        
        observer = new MutationObserver(function(mutations) {
            functionality.MutationObserver = (mutations.length > 0);
        });
        
        observer.observe(testElement, {'childList': true});
        testElement.appendChild(document.createElement('div'));
    } catch (e) {
        functionality.MutationObserver = false;
        functionality.errors.MutationObserver = e;
    }
    
    functionality.WeakMap = false;
    try {
        var testMap = new WeakMap(), testObject = function(){};
        
        testMap.set(testObject, 'asdfasdf');
        
        functionality.WeakMap = (testMap.get(testObject) === 'asdfasdf');
        functionality.WeakMap = (functionality.WeakMap && testMap.has(testObject) === true);
        
        testMap.delete(testObject);
        
        functionality.WeakMap = (functionality.WeakMap && testMap.has(testObject) === false);
        
    } catch (e) {
        functionality.WeakMap = false;
        functionality.errors.WeakMap = e;
    }
    
    functionality.registerElement = false;
    try {
        var prototype = Object.create(HTMLElement.prototype);
        prototype.testmethod = function () { return true; };
        document.registerElement('asdf-test', {'prototype': prototype});
        
        var testElement;
        testElement = document.createElement('asdf-test');
        
        functionality.registerElement = testElement.testmethod();
        
    } catch (e) {
        functionality.registerElement = false;
        functionality.errors.registerElement = e;
    }
    
    functionality.DOMTokenList = false;
    try {
        functionality.DOMTokenList = Boolean(document.body.classList);
    } catch (e) {
        functionality.DOMTokenList = false;
        functionality.errors.DOMTokenList = e;
    }
    
    functionality.HTMLTemplateElement = false;
    try {
        var testElement = document.createElement('template');
        
        xtag.register('asdf-test-two', {
            'lifecycle': {
                'created': function () {
                    var divElement = document.createElement('div');
                    divElement.classList.add('find-me');
                    this.appendChild(divElement);
                }
            }
        });
        
        testElement.innerHTML = '<div></div><p></p><asdf-test-two></asdf-test-two>';
        
        functionality.HTMLTemplateElement = (xtag.query(testElement, '.find-me').length === 0);
        
    } catch (e) {
        functionality.HTMLTemplateElement = false;
        functionality.errors.HTMLTemplateElement = e;
    }
    
    // function to show shim and functionality results
    GS.showShimmed = function () {
        var strHTML = '', key, templateElement;
        
        strHTML += '<br />\n' +
                   '<center>This dialog is for developers so that they can determine what technologies this browser supports and what technologies are being implemented manually.</center>\n' +
                   '<br />\n' +
                   '<hr />\n';
        
        for (key in shimmed) {
            strHTML += '<gs-grid reflow-at="450px">\n' +
                       '    <gs-block><center>' + encodeHTML(key) + '</center></gs-block>\n' +
                       '    <gs-block>\n' +
                       '        <center><b>' + (shimmed[key] ? 'SHIMMED' : 'NATIVE') + '</center></b>\n' +
                       '    </gs-block>\n' +
                       '    <gs-block>\n' +
                       '        <center>' + (functionality[key] ? '<b style="color: #3F9A3F;">FUNCTION PASS' : '<b style="color: #F00;">FUNCTION FAIL') + '</center></b>\n' +
                       '    </gs-block>\n' +
                       '</gs-grid>\n' +
                       '<hr />\n';
        }
        
        strHTML += '<br />';
        
        
        templateElement = document.createElement('template');
        
        templateElement.innerHTML = ml(function () {/*
            <gs-page>
                <gs-header><center><h3>Native Detection</h3></center></gs-header>
                <gs-body padded>
                    {{HTML}}
                </gs-body>
                <gs-footer><gs-button dialogclose>Done</gs-button></gs-footer>
            </gs-page>
        */}).replace('{{HTML}}', strHTML);
        
        GS.openDialog(templateElement);
    };
});

// ##################################################################
// ################ MULTIPLE ONBEFOREUNLOAD HANDLERS ################
// ##################################################################


window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('GS.addUnloadEvent', 'GS.addUnloadEvent', 'GS.addUnloadEvent(function () {' +
                                                                    '    $0' +
                                                                    '});');
});

(function () {
    'use strict';
    var arrFunctions = [],
        unloadFunction = function () {
            var i, len, ret, current;
            
            for (i = 0, len = arrFunctions.length; i < len; i += 1) {
                current = arrFunctions[i]();
                
                if (current && !ret) {
                    ret = current;
                }
            }
            
            if (ret) {
                return ret;
            }
        };
    
    window.addEventListener('load', function () {
        if (window.onbeforeunload && window.onbeforeunload !== unloadFunction) {
            console.error('Please use the GS.addUnloadEvent function to run code onbeforeunload.');
        }
    });
    
    GS.addBeforeUnloadEvent = function (functionToCall) {
        if (typeof functionToCall !== 'function') {
            throw new TypeError('GS.addUnloadEvent takes one argument, and it must be a function.');
        }
        
        if (!window.onbeforeunload) {
            window.onbeforeunload = unloadFunction;
            
        } else if (window.onbeforeunload !== unloadFunction) {
            console.error('Please use just the GS.addBeforeUnloadEvent function to run code onbeforeunload.');
            window.onbeforeunload = unloadFunction;
        }
        
        arrFunctions.push(functionToCall);
    };
})();





/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(h,r){var k={},l=k.lib={},n=function(){},f=l.Base={extend:function(a){n.prototype=this;var b=new n;a&&b.mixIn(a);b.hasOwnProperty("init")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
j=l.WordArray=f.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=r?b:4*a.length},toString:function(a){return(a||s).stringify(this)},concat:function(a){var b=this.words,d=a.words,c=this.sigBytes;a=a.sigBytes;this.clamp();if(c%4)for(var e=0;e<a;e++)b[c+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((c+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)b[c+e>>>2]=d[e>>>2];else b.push.apply(b,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,b=this.sigBytes;a[b>>>2]&=4294967295<<
32-8*(b%4);a.length=h.ceil(b/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var b=[],d=0;d<a;d+=4)b.push(4294967296*h.random()|0);return new j.init(b,a)}}),m=k.enc={},s=m.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++){var e=b[c>>>2]>>>24-8*(c%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c+=2)d[c>>>3]|=parseInt(a.substr(c,
2),16)<<24-4*(c%8);return new j.init(d,b/2)}},p=m.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++)d.push(String.fromCharCode(b[c>>>2]>>>24-8*(c%4)&255));return d.join("")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c++)d[c>>>2]|=(a.charCodeAt(c)&255)<<24-8*(c%4);return new j.init(d,b)}},t=m.Utf8={stringify:function(a){try{return decodeURIComponent(escape(p.stringify(a)))}catch(b){throw Error("Malformed UTF-8 data");}},parse:function(a){return p.parse(unescape(encodeURIComponent(a)))}},
q=l.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new j.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=t.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var b=this._data,d=b.words,c=b.sigBytes,e=this.blockSize,f=c/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;c=h.min(4*a,c);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);b.sigBytes-=c}return new j.init(g,c)},clone:function(){var a=f.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});l.Hasher=q.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){q.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,d){return(new a.init(d)).finalize(b)}},_createHmacHelper:function(a){return function(b,d){return(new u.HMAC.init(a,
d)).finalize(b)}}});var u=k.algo={};return k}(Math);
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(E){function h(a,f,g,j,p,h,k){a=a+(f&g|~f&j)+p+k;return(a<<h|a>>>32-h)+f}function k(a,f,g,j,p,h,k){a=a+(f&j|g&~j)+p+k;return(a<<h|a>>>32-h)+f}function l(a,f,g,j,h,k,l){a=a+(f^g^j)+h+l;return(a<<k|a>>>32-k)+f}function n(a,f,g,j,h,k,l){a=a+(g^(f|~j))+h+l;return(a<<k|a>>>32-k)+f}for(var r=CryptoJS,q=r.lib,F=q.WordArray,s=q.Hasher,q=r.algo,a=[],t=0;64>t;t++)a[t]=4294967296*E.abs(E.sin(t+1))|0;q=q.MD5=s.extend({_doReset:function(){this._hash=new F.init([1732584193,4023233417,2562383102,271733878])},
_doProcessBlock:function(m,f){for(var g=0;16>g;g++){var j=f+g,p=m[j];m[j]=(p<<8|p>>>24)&16711935|(p<<24|p>>>8)&4278255360}var g=this._hash.words,j=m[f+0],p=m[f+1],q=m[f+2],r=m[f+3],s=m[f+4],t=m[f+5],u=m[f+6],v=m[f+7],w=m[f+8],x=m[f+9],y=m[f+10],z=m[f+11],A=m[f+12],B=m[f+13],C=m[f+14],D=m[f+15],b=g[0],c=g[1],d=g[2],e=g[3],b=h(b,c,d,e,j,7,a[0]),e=h(e,b,c,d,p,12,a[1]),d=h(d,e,b,c,q,17,a[2]),c=h(c,d,e,b,r,22,a[3]),b=h(b,c,d,e,s,7,a[4]),e=h(e,b,c,d,t,12,a[5]),d=h(d,e,b,c,u,17,a[6]),c=h(c,d,e,b,v,22,a[7]),
b=h(b,c,d,e,w,7,a[8]),e=h(e,b,c,d,x,12,a[9]),d=h(d,e,b,c,y,17,a[10]),c=h(c,d,e,b,z,22,a[11]),b=h(b,c,d,e,A,7,a[12]),e=h(e,b,c,d,B,12,a[13]),d=h(d,e,b,c,C,17,a[14]),c=h(c,d,e,b,D,22,a[15]),b=k(b,c,d,e,p,5,a[16]),e=k(e,b,c,d,u,9,a[17]),d=k(d,e,b,c,z,14,a[18]),c=k(c,d,e,b,j,20,a[19]),b=k(b,c,d,e,t,5,a[20]),e=k(e,b,c,d,y,9,a[21]),d=k(d,e,b,c,D,14,a[22]),c=k(c,d,e,b,s,20,a[23]),b=k(b,c,d,e,x,5,a[24]),e=k(e,b,c,d,C,9,a[25]),d=k(d,e,b,c,r,14,a[26]),c=k(c,d,e,b,w,20,a[27]),b=k(b,c,d,e,B,5,a[28]),e=k(e,b,
c,d,q,9,a[29]),d=k(d,e,b,c,v,14,a[30]),c=k(c,d,e,b,A,20,a[31]),b=l(b,c,d,e,t,4,a[32]),e=l(e,b,c,d,w,11,a[33]),d=l(d,e,b,c,z,16,a[34]),c=l(c,d,e,b,C,23,a[35]),b=l(b,c,d,e,p,4,a[36]),e=l(e,b,c,d,s,11,a[37]),d=l(d,e,b,c,v,16,a[38]),c=l(c,d,e,b,y,23,a[39]),b=l(b,c,d,e,B,4,a[40]),e=l(e,b,c,d,j,11,a[41]),d=l(d,e,b,c,r,16,a[42]),c=l(c,d,e,b,u,23,a[43]),b=l(b,c,d,e,x,4,a[44]),e=l(e,b,c,d,A,11,a[45]),d=l(d,e,b,c,D,16,a[46]),c=l(c,d,e,b,q,23,a[47]),b=n(b,c,d,e,j,6,a[48]),e=n(e,b,c,d,v,10,a[49]),d=n(d,e,b,c,
C,15,a[50]),c=n(c,d,e,b,t,21,a[51]),b=n(b,c,d,e,A,6,a[52]),e=n(e,b,c,d,r,10,a[53]),d=n(d,e,b,c,y,15,a[54]),c=n(c,d,e,b,p,21,a[55]),b=n(b,c,d,e,w,6,a[56]),e=n(e,b,c,d,D,10,a[57]),d=n(d,e,b,c,u,15,a[58]),c=n(c,d,e,b,B,21,a[59]),b=n(b,c,d,e,s,6,a[60]),e=n(e,b,c,d,z,10,a[61]),d=n(d,e,b,c,q,15,a[62]),c=n(c,d,e,b,x,21,a[63]);g[0]=g[0]+b|0;g[1]=g[1]+c|0;g[2]=g[2]+d|0;g[3]=g[3]+e|0},_doFinalize:function(){var a=this._data,f=a.words,g=8*this._nDataBytes,j=8*a.sigBytes;f[j>>>5]|=128<<24-j%32;var h=E.floor(g/
4294967296);f[(j+64>>>9<<4)+15]=(h<<8|h>>>24)&16711935|(h<<24|h>>>8)&4278255360;f[(j+64>>>9<<4)+14]=(g<<8|g>>>24)&16711935|(g<<24|g>>>8)&4278255360;a.sigBytes=4*(f.length+1);this._process();a=this._hash;f=a.words;for(g=0;4>g;g++)j=f[g],f[g]=(j<<8|j>>>24)&16711935|(j<<24|j>>>8)&4278255360;return a},clone:function(){var a=s.clone.call(this);a._hash=this._hash.clone();return a}});r.MD5=s._createHelper(q);r.HmacMD5=s._createHmacHelper(q)})(Math);
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){if("function"==typeof ArrayBuffer){var b=CryptoJS.lib.WordArray,e=b.init;(b.init=function(a){a instanceof ArrayBuffer&&(a=new Uint8Array(a));if(a instanceof Int8Array||a instanceof Uint8ClampedArray||a instanceof Int16Array||a instanceof Uint16Array||a instanceof Int32Array||a instanceof Uint32Array||a instanceof Float32Array||a instanceof Float64Array)a=new Uint8Array(a.buffer,a.byteOffset,a.byteLength);if(a instanceof Uint8Array){for(var b=a.byteLength,d=[],c=0;c<b;c++)d[c>>>2]|=a[c]<<
24-8*(c%4);e.call(this,d,b)}else e.apply(this,arguments)}).prototype=b}})();

// if db is SQL Server: utf16 else utf8
(function () {
    "use strict";
    
    // get a cookie from the browser
    function getCookie(c_name) {
        var c_value = document.cookie, c_end,
            c_start = c_value.indexOf(" " + c_name + "=");

        if (c_start === -1) {
            c_start = c_value.indexOf(c_name + "=");
        }
        if (c_start === -1) {
            c_value = null;
        } else {
            c_start = c_value.indexOf("=", c_start) + 1;
            c_end = c_value.indexOf(";", c_start);
            if (c_end === -1) {
                c_end = c_value.length;
            }
            c_value = decodeURIComponent(c_value.substring(c_start, c_end));
        }
        return c_value;
    };

    if ((getCookie('DB') || 'PG').toUpperCase() === 'PG') {
        GS.utfSafeMD5 = CryptoJS.MD5;
    } else { //ss
        GS.utfSafeMD5 = function (str) {
            "use strict";
            var buf = new ArrayBuffer(str.length * 2);
            var bufView = new Uint16Array(buf);
            var i;
            var strLen;

            for (i = 0, strLen = str.length; i < strLen; i += 1) {
                bufView[i] = str.charCodeAt(i);
            }

            return CryptoJS.MD5(CryptoJS.lib.WordArray.create(bufView));
        }
    }
}());
//global registerDesignSnippet

// snippets are in the textmate format more info:
//      http://blog.macromates.com/2005/the-power-of-snippets/

window.addEventListener('design-register-element', function () {
    // uncategorized snippets
    registerDesignSnippet('Lorem Ipsum', 'Lorem Ipsum', 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.');

    registerDesignSnippet('Document Start', 'Document Start',
            '<!DOCTYPE html>\n' +
            '<html>\n' +
            '    <head>\n' +
            '        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />\n' +
            '        <meta name="apple-mobile-web-app-capable" content="yes" />\n' +
            '        <meta name="apple-mobile-web-app-status-bar-style" content="black" />\n' +
            '        <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1.0, maximum-scale=1.0, minimal-ui" />\n' +
            '        <!-- Make this page use standard caching procedure when used as an iframe -->\n' +
            '        <meta http-equiv="Cache-control" content="no-store, must-revalidate" />\n' +
            '        \n' +
            '        <title>${1:New Page}</title>\n' +
            '        \n' +
            '        <script src="/js/greyspots.js" type="text/javascript"></script>\n' +
            '        <link href="/css/greyspots.css" type="text/css" rel="stylesheet" />\n' +
            '    </head>\n' +
            '    <body>\n' +
            '        $0\n' +
            '    </body>\n' +
            '</html>');

    registerDesignSnippet('Centered H1', 'Centered H1', '<center><h1>$0</h1></center>');
    registerDesignSnippet('Centered H2', 'Centered H2', '<center><h2>$0</h2></center>');
    registerDesignSnippet('Centered H3', 'Centered H3', '<center><h3>$0</h3></center>');
    registerDesignSnippet('Centered H4', 'Centered H4', '<center><h4>$0</h4></center>');
    registerDesignSnippet('Centered H5', 'Centered H5', '<center><h5>$0</h5></center>');
    registerDesignSnippet('Centered H6', 'Centered H6', '<center><h6>$0</h6></center>');

    // javascript snippets
    registerDesignSnippet('Window Load', 'window.addEventListener',
            'window.addEventListener(\'load\', function () {\n' +
            '    $0\n' +
            '});');

    registerDesignSnippet('Multiline String', 'Multiline String',
            'ml(function () {/*\n' +
            '    ${0}\n' +
            '})');

    registerDesignSnippet('ml()', 'ml()',
            'ml(function () {/*\n' +
            '    ${0}\n' +
            '})');

    // HTML snippets
    registerDesignSnippet('<style>', '<style>', 'style>\n' +
                                                '    $0\n' +
                                                '</style>');
    registerDesignSnippet('<script>', '<script>', 'script>\n' +
                                                  '    $0\n' +
                                                  '</script>');
    registerDesignSnippet('<link>', '<link>', 'link href="${1}" type="text/css" rel="stylesheet" />');
    
    
    // CSS snippets
    registerDesignSnippet('Curved Borders', 'Curved Borders', '-webkit-border-radius: ${1:50%};\n' +
                                                             '-moz-border-radius: ${1:50%};\n' +
                                                             '-ms-border-radius: ${1:50%};\n' +
                                                             '-o-border-radius: ${1:50%};\n' +
                                                             'border-radius: ${1:50%};');
    registerDesignSnippet('border-radius', 'border-radius', '-webkit-border-radius: ${1:50%};\n' +
                                                             '-moz-border-radius: ${1:50%};\n' +
                                                             '-ms-border-radius: ${1:50%};\n' +
                                                             '-o-border-radius: ${1:50%};\n' +
                                                             'border-radius: ${1:50%};');
    registerDesignSnippet('box-sizing', 'box-sizing', '-webkit-box-sizing: ${1:border-box};\n' +
                                                      '-moz-box-sizing: ${1:border-box};\n' +
                                                      '-ms-box-sizing: ${1:border-box};\n' +
                                                      '-o-box-sizing: ${1:border-box};\n' +
                                                      'box-sizing: ${1:border-box};');
    registerDesignSnippet('transform', 'transform', '-webkit-transform: ${1:rotate(42deg)};\n' +
                                                    '-moz-transform: ${1:rotate(42deg)};\n' +
                                                    '-ms-transform: ${1:rotate(42deg)};\n' +
                                                    '-o-transform: ${1:rotate(42deg)};\n' +
                                                    'transform: ${1:rotate(42deg)};');
    
    registerDesignSnippet('Desktop Media Query', 'Desktop Media Query', '@media only screen and (max-width: 5000px) {\n' +
                                                                        '    $0\n' +
                                                                        '}');
    registerDesignSnippet('Tablet Media Query', 'Tablet Media Query', '@media only screen and (max-width: 768px) {\n' +
                                                                      '    $0\n' +
                                                                      '}');
    registerDesignSnippet('Phone Media Query', 'Phone Media Query', '@media only screen and (max-width: 321px) {\n' +
                                                                    '    $0\n' +
                                                                    '}');
});//global registerDesignSnippet, window, GS, ml, encodeHTML
//jslint white:true multivar:true

window.addEventListener('design-register-element', function () {
    var strNormalCallbackContent = '    if (!error) {\n' +
                                   '        $0\n' +
                                   '    } else {\n' +
                                   '        GS.ajaxErrorDialog(data);\n' +
                                   '    }\n';
    
    registerDesignSnippet('JSON Ajax', 'JSON Ajax', 'GS.ajaxJSON(\'/env/${1:test.action_ship}\', \'${2:action=ship&id=}\', function (data, error) {\n' +
                                                        strNormalCallbackContent +
                                                    '});');
    registerDesignSnippet('GS.ajaxJSON', 'GS.ajaxJSON', 'GS.ajaxJSON(\'/env/${1:test.action_ship}\', \'${2:action=ship&id=}\', function (data, error) {\n' +
                                                            strNormalCallbackContent +
                                                        '});');
    
    
    registerDesignSnippet('TEXT Ajax', 'TEXT Ajax', 'GS.ajaxText(\'/env/${1:test.action_description}\', \'${2:action=get&id=}\', function (data, error) {\n' +
                                                        strNormalCallbackContent +
                                                    '});');
    registerDesignSnippet('GS.ajaxText', 'GS.ajaxText', 'GS.ajaxText(\'/env/${1:test.action_description}\', \'${2:action=get&id=}\', function (data, error) {\n' +
                                                            strNormalCallbackContent +
                                                        '});');
    
    registerDesignSnippet('PG FUNCTION AJAX', 'PG FUNCTION AJAX', 'GS.ajaxJSON(\'/env/${1:test.action_ship}\', \'${2:action=ship&id=}\', function (data, error) {\n' +
                                                  strNormalCallbackContent +
                                              '});');
    
    registerDesignSnippet('ENV SELECT AJAX', 'ENV SELECT AJAX', 'GS.ajaxJSON(\'/env/action_select\', \'view=${1:test.tpeople}&where=&order_by=&limit=&offset=\', function (data, error) {\n' +
                                                                    strNormalCallbackContent +
                                                                '});');
    
    registerDesignSnippet('ENV UPDATE AJAX', 'ENV UPDATE AJAX', 'GS.ajaxJSON(\'/env/action_update\', \'view=${1:test.tpeople}\' +\n' +
                                                                '                                        \'&where=\' + encodeURIComponent(\'id=\' + ${2:strID} + \'&change_stamp=\' + ${3:strChangeStamp}) +\n' +
                                                                '                                        \'&column=${4:first_name}&value=\' + encodeURIComponent(${5:newValue}), function (data, error) {\n' +
                                                                    strNormalCallbackContent +
                                                                '});');
    
    registerDesignSnippet('ENV INSERT AJAX', 'ENV INSERT AJAX', 'GS.ajaxJSON(\'/env/action_insert\', \'view=${1:test.tpeople}&data=\' + encodeURIComponent(${2:strInsertString}), function (data, error) {\n' +
                                                                    strNormalCallbackContent +
                                                                '});');
    
    registerDesignSnippet('ENV DELETE AJAX', 'ENV DELETE AJAX', 'GS.ajaxJSON(\'/env/action_delete\', \'view=${1:test.tpeople}&id=\' + ${2:strIDs}, function (data, error) {\n' +
                                                                    strNormalCallbackContent +
                                                                '});');
    
    registerDesignSnippet('GS.ajaxErrorDialog', 'GS.ajaxErrorDialog', 'GS.ajaxErrorDialog(data,\n' +
              '                   function () {\n' +
              '                       // Try Again Button Callback\n' +
              '                       // delete this function if you dont want a try again button\n' +
              '                   },\n' +
              '                   function () {\n' +
              '                       // Cance Button Callback\n' +
              '                       // if you dont need to do anything when the cancel button is clicked: delete this function\n' +
              '                   });');
    
    registerDesignSnippet('GS.dataFetch', 'GS.dataFetch', 
            'function getData(bolClearPrevious) {\n' +
            '    var data, strLink, dataResultHandler, dataEventFunction;\n' +
            '    \n' +
            '    // create function that will use the data\n' +
            '    dataResultHandler = function (data, error) {\n' +
            '        \n' +
            '    };\n' +
            '    \n' +
            '    // save data from request or\n' +
            '    //     start ajax if it hasn\'t already gotten the data yet or\n' +
            '    //     start new ajax if bolClearPrevious is true\n' +
            '    data = GS.dataFetch(strLink, bolClearPrevious);\n' +
            '    \n' +
            '    // if this request already has been completed\n' +
            '    if (data) {\n' +
            '        // handle result\n' +
            '        dataResultHandler(data.response, data.error);\n' +
            '    } else {\n' +
            '        dataEventFunction = function (event) {\n' +
            '            // unbind data event function\n' +
            '            document.removeEventListener(\'dataready_\' + encodeURIComponent(strLink), dataEventFunction);\n' +
            '            \n' +
            '            // handle result\n' +
            '            dataResultHandler(event.detail.response, event.detail.error);\n' +
            '        };\n' +
            '        \n' +
            '        // bind data event function\n' +
            '        document.addEventListener(\'dataready_\' + encodeURIComponent(strLink), dataEventFunction);\n' +
            '    }\n' +
            '}');
    
});

(function () {
    'use strict';
    function ajaxCheckJSONResponseForError(request) {
        if (request.responseJSON) {
            if (request.responseJSON.stat === false) {
                return true;
            }
        } else {
            return true;
        }
        
        return false;
    }
    
    function ajaxNormalizeError (request) {
        var response = request.response, jsnTemp, jsnRet = {
            'error_title': '',
            'error_hint': '',
            'error_text': '',
            'error_file': '',
            'error_context': '',
            'original_response': response
        };
        
        // get error title and error hint
        if (request.bolFrontEndTimeout === true) {
            jsnRet.error_text = 'Front-end Timeout Reached';
            jsnRet.error_title = 'Front-end Timeout Reached';
            jsnRet.error_hint = 'This request took too long. Please report this to a system administrator.';
            
        } else if (response.status === 403) {
            jsnRet.error_title = '403 Link Is Forbidden';
            jsnRet.error_hint = 'You have no permission to use this link. If you need this link contact a system administrator and request permission for this link.';
            
        } else if (response.status === 404) {
            jsnRet.error_title = '404 Link Could Not Be Found';
            jsnRet.error_hint = 'This link does not exist. Please report this to a system administrator.';
            
        } else if (response.status === 408) {
            jsnRet.error_title = '408 Request Took Too Long';
            jsnRet.error_hint = 'This link is broken. Please report this to a system administrator.';
            
        } else if (response.status === 500) {
            jsnRet.error_title = '500 Internal Server Error';
            jsnRet.error_hint = 'This call to the server failed. Please report this to a system administrator.';
            
        } else if (response.status === 502) {
            jsnRet.error_title = '502 Bad Gateway';
            jsnRet.error_hint = 'This link is broken. Please report this to a system administrator.';
            
        } else if (response.status === 504) {
            jsnRet.error_title = '504 Gateway Timeout';
            jsnRet.error_hint = 'This link is broken. Please report this to a system administrator.';
        }
        
        // get error text
        try {
            jsnTemp = JSON.parse(response.responseText || response).dat;
            
            jsnRet.error_text = jsnTemp.error;
            jsnRet.error_file = jsnTemp.filename;
            jsnRet.error_context = jsnTemp.context;
            
            if (!jsnRet.error_text) {
                jsnRet.error_text = JSON.parse(response.responseText || response).dat;
            }
        } catch (err) {
            if (response) {
                jsnRet.error_text = response.responseText || JSON.stringify(response);
            } else {
                jsnRet.error_text = jsnRet.error_text || response;
            }
        }
        
        jsnRet.error_file = jsnRet.error_file || '';
        
        return jsnRet;
    }
    
    GS.ajaxJSON = function (strLink, strParams, callback, intTimeout) {
        var request = new XMLHttpRequest();
        
        callback = callback || function () {};
        
        request.onreadystatechange = function() {
            var normalizedError;
            
            // if expired cookie: go to login page
            if (request.readyState === 4) {
                if (request.status === 440) {
                    window.location = '/index.html?error=Connection%20timed%20out&redirect=' + encodeURIComponent(window.location.pathname);
                } else {
                    try {
                        request.responseJSON = JSON.parse(request.responseText || request.response);
                    } catch (e) {
                        //throw e;
                    }
                    
                    if (!ajaxCheckJSONResponseForError(request)) {
                        callback(request.responseJSON);
                        
                    } else {
                        normalizedError = ajaxNormalizeError(request);
                        
                        // if session error: have the user log back in and refresh
                        if ((normalizedError.error_text.indexOf('Session expired') === 0 ||
                            normalizedError.error_text.indexOf('No Cookie') !== -1 ||
                            normalizedError.error_text.indexOf('requires you to login') !== -1) &&
                            strLink.indexOf('action_info') === -1) {
                            GS.normalUserLogin(function () {
                                window.location.reload();
                            }, '', request.responseJSON.dat.default_subdomain);
                            
                        // else: callback with normalized error
                        } else {
                            callback(normalizedError, 'error');
                        }
                    }
                }
            }
        };
        
        request.open('POST', strLink + '?anticache=' + ((new Date()).getMilliseconds() + Math.floor(Math.random() * 1e9)), true);
        request.setRequestHeader('Content-type','application/x-www-form-urlencoded; charset=UTF-8');
        request.send(strParams);
        
        // if intTimeout has been set: start a timer to abort
        if (typeof intTimeout === 'number') {
            if (request && request.readyState !== 4) {
                setTimeout(function() {
                    request.bolFrontEndTimeout = true;
                    request.abort();
                }, intTimeout);
            }
        }
        
        return request;
    };
    
    GS.ajaxText = function (strLink, strParams, callback, intTimeout) {
        var request = new XMLHttpRequest();
        
        callback = callback || function () {};
        
        request.onreadystatechange = function() {
            var normalizedError;
            
            if (request.readyState === 4) {
                if (request.status === 200) {
                    callback(request.responseText);
                    
                } else if (request.status === 440) {
                    window.location = '/index.html?error=Connection%20timed%20out&redirect=' + encodeURIComponent(window.location.pathname);
                    
                } else {
                    normalizedError = ajaxNormalizeError(request);
                    
                    // if session error: have the user log back in and refresh
                    if ((normalizedError.error_text.indexOf('Session expired') === 0 ||
                        normalizedError.error_text.indexOf('No Cookie') !== -1 ||
                        normalizedError.error_text.indexOf('requires you to login') !== -1) &&
                        strLink.indexOf('action_info') === -1) {
                        GS.normalUserLogin(function () {
                            window.location.reload();
                        }); //, '', JSON.parse(request.responseText || request.response).dat.default_subdomain
                        
                    // else: callback with normalized error
                    } else {
                        callback(normalizedError, 'error');
                    }
                }
            }
        };
        
        request.open('POST', strLink + '?anticache=' + ((new Date()).getMilliseconds() + Math.floor(Math.random() * 1e9)), true);
        request.setRequestHeader('Content-type','application/x-www-form-urlencoded; charset=UTF-8');
        request.send(strParams);
        
        // if intTimeout has been set: start a timer to abort
        if (typeof intTimeout === 'number') {
            if (request && request.readyState !== 4) {
                setTimeout(function() {
                    request.bolFrontEndTimeout = true;
                    request.abort();
                }, intTimeout);
            }
        }
        
        return request;
    };
}());

(function () {
    "use strict";
    
    function cleanErrorValue(strValue) {
        strValue = strValue || '';
        
        if (strValue.indexOf('DB_exec failed:') !== -1) {
            strValue = strValue.replace(/[.\s\S]*DB_exec\ failed:/mi, '');
        }
        
        if (strValue.indexOf('Query failed:') !== -1) {
            strValue = strValue.replace(/[.\s\S]*Query\ failed:/mi, '');
        }
        
        if (strValue.indexOf('FATAL') !== -1) {
            strValue = strValue.replace(/[.\s\S]*FATAL/mi, '');
        }
        
        strValue = strValue
                        .replace(/\\?\\n/gi, '\n')
                        .replace(/\\?\\t/gi, '\t')
                        .replace(/\[.*\]/gi, '')
                        .replace(/\([0-9]*\)/gi, '');
        
        return GS.trim(strValue.trim(), '"');
    }
    
    function errorJSONToHTML(errorJSON) {
        return '<pre style="word-break: break-all; white-space: pre-wrap;">' +
                    'There was an error:' +
                    (errorJSON.error_text //TODO: maybe make this red -Joseph 09/14/16
                        ? '<br /><br />' + encodeHTML(errorJSON.error_text)                        
                        : '') +
                    (errorJSON.error_file
                        ? '<br /><br />The error was on file: ' + encodeHTML(errorJSON.error_file) 
                        : '') +
                    (errorJSON.error_hint
                        ? '<br /><br />' + encodeHTML(errorJSON.error_hint)                        
                        : '') +
                    (errorJSON.error_context
                        ? '<br /><br />' + encodeHTML(errorJSON.error_context)                     
                        : '') +
                    (errorJSON.error_addin
                        ? '<br /><br />' + encodeHTML(errorJSON.error_addin)                       
                        : '') +
                '</pre>';
    }
    
    GS.ajaxErrorDialog = function (jsnError, tryAgainCallback, cancelCallback) {
        'use strict';
        var templateElement = document.createElement('template'), strHTML;
        
        var jsnErrorCopy = {};
        jsnErrorCopy.error_text    = cleanErrorValue(jsnError.error_text);
        jsnErrorCopy.error_file    = cleanErrorValue(jsnError.error_file);
        jsnErrorCopy.error_hint    = cleanErrorValue(jsnError.error_hint);
        jsnErrorCopy.error_context = cleanErrorValue(jsnError.error_context);
        jsnErrorCopy.error_addin   = cleanErrorValue(jsnError.error_addin);
        
        templateElement.setAttribute('data-theme', 'error');
        strHTML = ml(function () {/*
            <gs-page>
                <gs-header><center><h3>There was an error!</h3></center></gs-header>
                <gs-body padded>
                    {{HTML}}
                    <gs-button class="error-button-show-full-text">Show Full Error Text</gs-button>
                </gs-body>
                <gs-footer>{{BUTTONS}}</gs-footer>
            </gs-page>
        */}).replace('{{HTML}}', errorJSONToHTML(jsnErrorCopy));
        
        
        var openFunction = function () {
            xtag.query(this, '.error-button-show-full-text')[0].addEventListener('click', function () {
                var templateElement = document.createElement('template');
                
                templateElement.innerHTML = ml(function () {/*
                    <gs-page>
                        <gs-header><center><h3>Full Error Text</h3></center></gs-header>
                        <gs-body padded>
                            {{HTML}}
                        </gs-body>
                        <gs-footer><gs-button dialogclose>Done</gs-button></gs-footer>
                    </gs-page>
                */}).replace('{{HTML}}', errorJSONToHTML(jsnError));
                
                GS.openDialog(templateElement);
            });
        };
        
        
        if (typeof tryAgainCallback === 'function') {
            templateElement.innerHTML = strHTML.replace('{{BUTTONS}}',
                        '<gs-grid>' +
                        '   <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>' +
                        '   <gs-block><gs-button dialogclose listen-for-return>Try Again</gs-button></gs-block>' +
                        '</gs-grid>');
            GS.openDialog(templateElement, openFunction, function (event, strAnswer) {
                if (strAnswer === 'Try Again') {
                    tryAgainCallback(strAnswer);
                } else {
                    if (typeof cancelCallback === 'function') {
                        cancelCallback(strAnswer);
                    }
                }
            });
        } else {
            templateElement.innerHTML = strHTML.replace('{{BUTTONS}}', '<gs-button dialogclose listen-for-return>Ok</gs-button>');
            GS.openDialog(templateElement, openFunction);
        }
    };
    
}());

/*

var strLink = '/env/action_select?view=wtkv2.ttime&where=user_name%20%3D%20\'michael%40tocci.org\'&offset=0&limit=25&order_by=id%20DESC&header=true';

document.addEventListener('dataready_' + encodeURIComponent(strLink), function (event) {
    console.log(event);
});f

dataFetch(strLink, false);

*/

if (GS.dataLedger === undefined) {
    GS.dataLedger = {};
}

GS.dataFetch = function (strLink, bolClearPrevious) {
    'use strict';
    var arrLinkParts = strLink.split('?'), strId = encodeURIComponent(strLink);
    
    // if something wants to fetch data where the id does not already exist then do an ajax call 
    if (GS.dataLedger[strId] === undefined || bolClearPrevious === true) {
        
        GS.dataLedger[strId] = {'status': 'waiting', 'response': ''};
        
        GS.ajaxJSON(arrLinkParts[0], arrLinkParts[1] || '', function (data, error) {
            var event; // The custom event that will be created
            
            if (document.createEvent) {
                event = document.createEvent('HTMLEvents');
                event.initEvent('dataready_' + strId, true, true);
                event.eventName = 'dataready_' + strId;
            } else {
                event = document.createEventObject();
                event.eventType = 'dataready_' + strId;
                event.eventName = 'dataready_' + strId;
            }
            
            if (!error) {
                GS.dataLedger[strId].response = (data.dat !== undefined ? data.dat : data);
                GS.dataLedger[strId].status = 'finished';
                
                event.detail = {'response': GS.dataLedger[strId].response};
                
            } else {
                GS.dataLedger[strId].data = data;
                GS.dataLedger[strId].status = 'error';
                GS.dataLedger[strId].error = 'error';
                
                event.detail = {'response': data, 'error': 'error'};
            }
            
            if (document.createEvent) {
                document.dispatchEvent(event);
            } else {
                document.fireEvent('on' + event.eventType, event);
            }
        });
        
        return '';
    }
    
    if (GS.dataLedger[strId].status === 'finished' || GS.dataLedger[strId].status === 'error') {
        return GS.dataLedger[strId];
    }
    
    return '';
};
window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('GS.findParentTag', 'GS.findParentTag', 'GS.findParentTag(${1:element}, \'${0:tag-to-find}\');');
    
    registerDesignSnippet('GS.findParentElement', 'GS.findParentElement',
                                                    'GS.findParentElement(${1:element}, ${0:\'selector, element or function\'});');
    
    registerDesignSnippet('GS.insertElementAfter', 'GS.insertElementAfter',
                                                    'GS.insertElementAfter(${1:elementToInsert}, \'${0:elementToInsertAfter}\');');
    
    registerDesignSnippet('GS.getElementOffset', 'GS.getElementOffset', 'GS.getElementOffset(${0:element});');
    
    registerDesignSnippet('GS.animateStyle', 'GS.animateStyle',
                                            'GS.animateStyle(${1:elementToAnimate}, ' +
                                                            '${2:CSSPropertyToAnimate}, ' +
                                                            '${3:startValue}, ' +
                                                            '${4:endValue}, ' +
                                                            '${5:callbackAfterAnimation}, ' +
                                                            '${6:durationInMilliseconds}, ' +
                                                            '${0:numberOfFrames});');
    
    registerDesignSnippet('GS.stringToElement', 'GS.stringToElement', 'GS.stringToElement(\'${0:<div>your HTML here</div>}\');');
    
    registerDesignSnippet('GS.cloneElement', 'GS.cloneElement', 'GS.cloneElement(${0:element});');
    
    registerDesignSnippet('GS.isElementFocusable', 'GS.isElementFocusable', 'GS.isElementFocusable(${0:element});');
    
    registerDesignSnippet('GS.scrollParent', 'GS.scrollParent', 'GS.scrollParent(${0:element});');
    
    registerDesignSnippet('GS.scrollIntoView', 'GS.scrollIntoView', 'GS.scrollIntoView(${0:element});');
    
    registerDesignSnippet('GS.getInputSelection', 'GS.getInputSelection', 'GS.getInputSelection(${0:inputOrTextareaElement});');
    
    registerDesignSnippet('GS.setInputSelection', 'GS.setInputSelection',
                                    'GS.setInputSelection(${1:inputOrTextareaElement}, ${2:startAtNumber}, ${0:endAtNumber});');
    
    registerDesignSnippet('GS.getElementPositionData', 'GS.getElementPositionData', 'GS.getElementPositionData(${0:element});');
});

// #################################################################
// #################### DOM TRAVERSAL FUNCTIONS ####################
// #################################################################

// loop through parents until tag is found
GS.findParentTag = function (element, strTagName) {
    'use strict';
    var currentElement = element.parentNode;
    
    strTagName = strTagName.toUpperCase();
    
    while (currentElement && currentElement.nodeName !== strTagName && currentElement.nodeName !== 'HTML') {
        currentElement = currentElement.parentNode;
    }
    
    if (!currentElement || currentElement.nodeName !== strTagName) {
        return undefined;
    }
    
    return currentElement;
};

// loop through parents until checkParameter is satisfied or we run into HTML
GS.findParentElement = function (element, checkParameter) {
    'use strict';
    var currentElement = element;
    
    // if checkParameter is a function: use it to check the element
    if (typeof checkParameter === 'function') {
        while (currentElement && !checkParameter(currentElement) && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }
        
    // else if checkParameter is a string: use checkParameter as a selector string and use xtag.matchSelector
    } else if (typeof checkParameter === 'string') {
        while (currentElement && !xtag.matchSelector(currentElement, checkParameter) && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }
        
    // else: assume checkParameter is an element and use ===
    } else {
        while (currentElement && currentElement !== checkParameter && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }
    }
    
    if (!currentElement) {
        return undefined;
    }
    
    return currentElement;
};


// ################################################################
// #################### HTML ELEMENT FUNCTIONS ####################
// ################################################################

// insert element after another element
GS.insertElementAfter = function (elementToInsert, target) {
    if (target.nextElementSibling) {
        target.parentNode.insertBefore(elementToInsert, target.nextElementSibling);
    } else {
        target.parentNode.appendChild(elementToInsert);
    }
};

// get element's position on the screen
GS.getElementOffset = function (element) {
    'use strict';
    var intX = 0, intY = 0, ret;
    
    if (element.getBoundingClientRect) {
        ret = element.getBoundingClientRect();
        
    } else {
        while (element && element.nodeName !== 'HTML') {
            intX += element.offsetLeft - element.scrollLeft;// + element.clientLeft;
            intY += element.offsetTop - element.scrollTop;// + element.clientTop;
            
            //console.log(element.offsetTop, element.scrollTop, element);
            
            element = element.parentNode; //element.offsetParent
        }
        
        ret = {
            left: intX,
            top: intY
        };
    }
    
    return ret;
};

//
GS.animateStyle = function (element, strStyleProperty, strStart, strEnd, callback, intDuration, intFrames) {
    var intStart         = parseInt(strStart, 10),
        intEnd           = parseInt(strEnd, 10),
        strStartUnit     = strStart.replace(/[0-9\.-]/gi, '').toLowerCase(),
        //strEndUnit       = strEnd.replace(/[0-9\.-]/gi, '').toLowerCase(),
        intFrameDuration = intDuration / intFrames,
        i, timeoutFunction, intCurrent, intJump;
    
    //if (strStartUnit !== 'em' && strStartUnit !== 'px' && strStartUnit !== '') {
    //    throw 'animateStyle error: strStart has an invalid unit, use px or em or nothing';
    //    
    //} else if (strEndUnit !== 'em' && strEndUnit !== 'px' && strEndUnit !== '') {
    //    throw 'animateStyle error: strEnd has an invalid unit, use px or em or nothing';
    //    
    //} else {
    intCurrent = intStart;
    intJump = (intEnd - intStart) / intFrames;
    i = 1;
    
    element.style[strStyleProperty] = strStart;
    
    timeoutFunction = function () {
        setTimeout(function () {
            intCurrent += intJump;
            //element.style[strStyleProperty] = intCurrent + strStartUnit;
            //console.log(intCurrent, i, intFrames, element, element.style[strStyleProperty], intStart, intCurrent, strStartUnit);
            
            if (i < intFrames) {
                element.style[strStyleProperty] = intCurrent + strStartUnit;
                i += 1;
                timeoutFunction();
            } else {
                element.style[strStyleProperty] = strEnd;
                callback();
            }
        }, intFrameDuration);
    };
    
    timeoutFunction();
    //}
};

//
GS.stringToElement = function (strHTML, optionalTargetDocument) {
    var strFirstTagName, parentElement, indexInElement, parsedElement, targetDocument;
    
    if (optionalTargetDocument) {
        targetDocument = optionalTargetDocument;
    } else {
        targetDocument = document;
    }
    
    //console.log(strFirstTagName);
    
    strFirstTagName = strHTML.substring(strHTML.indexOf('<') + 1, strHTML.indexOf('>'));
    
    //console.log(strFirstTagName);
    
    if (strFirstTagName.indexOf(' ') > -1) {
        strFirstTagName = strFirstTagName.substring(0, strFirstTagName.indexOf(' '));
    }
    
    //console.log(strFirstTagName);
    
    if (strFirstTagName === 'body') {
        parentElement = targetDocument.createElement('html');
        indexInElement = 1;
        
    } else if (strFirstTagName === 'thead' || strFirstTagName === 'tbody') {
        parentElement = targetDocument.createElement('table');
        indexInElement = 0;
        
    } else if (strFirstTagName === 'tr') {
        parentElement = targetDocument.createElement('tbody');
        indexInElement = 0;
        
    } else if (strFirstTagName === 'td' || strFirstTagName === 'th') {
        parentElement = targetDocument.createElement('tr');
        indexInElement = 0;
        
    } else if (strFirstTagName === 'li') {
        parentElement = targetDocument.createElement('ul');
        indexInElement = 0;
    } else {
        parentElement = targetDocument.createElement('div');
        indexInElement = 0;
    }
    
    parentElement.innerHTML = strHTML;
    parsedElement = parentElement.children[indexInElement];
    
    //console.log(strFirstTagName, parsedElement);
    
    return parsedElement;
};

//
GS.cloneElement = function (element, optionalTargetDocument) {
    // if there is a template element in the element: copy the element without cloneNode because for some reason cloneNode breaks templates on IOS
    if (xtag.query(element, 'template').length > 0 || optionalTargetDocument) {
        return GS.stringToElement(element.outerHTML, optionalTargetDocument);
    }
    
    // else: just use cloneNode
    return element.cloneNode(true);
};

/*
// change the tag of an element
GS.changeElementTag = function (element, strNewTag, alterCallback) {
    var strHTML = element.outerHTML.trim(), newElement;
    
    strHTML = '<' + strNewTag + strHTML.substring(strHTML.indexOf(' '), strHTML.lastIndexOf('</')) + '</' + strNewTag + '>';
    
    //console.log(strHTML);
    
    newElement = GS.stringToElement(strHTML);
    
    if (typeof alterCallback === 'function') {
        alterCallback.apply(newElement);
    }
    
    return newElement;
};*/

// check to see if an element is focusable
GS.isElementFocusable = function (element) {
    return  (
                element.nodeName === 'INPUT' ||
                element.nodeName === 'TEXTAREA' ||
                element.nodeName === 'SELECT' ||
                element.nodeName === 'BUTTON' ||
                element.nodeName === 'IFRAME' ||
                (element.hasAttribute('tabindex') && element.getAttribute('tabindex') !== '-1') ||
                (element.focus &&
                    element.focus.toString().indexOf('[native code]') === -1 &&
                    element.focus.toString() !== document.createElement('div').focus.toString()) ||
                (
                    element.nodeName === 'A' &&
                    element.hasAttribute('href')
                ) ||
                (
                    element.nodeName === 'AREA' &&
                    element.hasAttribute('href')
                )
            ) &&
            !element.hasAttribute('disabled');
};

// see function in 006-utl.js
//// search for a parent with a scrollbar
//GS.scrollParent = function (element) {
//    var i = 0, currentElement = element, bolFoundScrollable = false, strOverflow;
//    
//    if (currentElement) {
//        while (currentElement && currentElement.nodeName !== 'HTML' && bolFoundScrollable === false && i < 75) {
//            strOverflow = GS.getStyle(currentElement, 'overflow');
//            
//            if (strOverflow === 'scroll' || (strOverflow === 'auto' && currentElement.clientHeight < currentElement.scrollHeight)) {
//                bolFoundScrollable = true;
//            } else {
//                currentElement = currentElement.parentNode;
//                i += 1;
//            }
//        }
//        return bolFoundScrollable ? currentElement : undefined;
//    }
//    return undefined;
//};

// scroll an element to the middle of its scrollparent
GS.scrollIntoView = function (element) {
    var scrollingContainer = GS.scrollParent(element), arrSiblings, i, len, intScrollTop;
    
    if (scrollingContainer) {
        //console.log(scrollingContainer);
        
        arrSiblings = element.parentNode.children;
        
        for (i = 0, intScrollTop = 0, len = arrSiblings.length; i < len; i += 1) {
            if (arrSiblings[i] === element) {
                intScrollTop += arrSiblings[i].offsetHeight / 2;
                
                break;
            } else {
                intScrollTop += arrSiblings[i].offsetHeight;
            }
        }
        
        intScrollTop = intScrollTop - (scrollingContainer.offsetHeight / 2);
        
        //console.log(intScrollTop);
        
        scrollingContainer.scrollTop = intScrollTop;
    }
};


// #################################################################
// ################### INPUT SELECTION FUNCTIONS ###################
// #################################################################

GS.getInputSelection = function (input) {
    'use strict';
    var start = 0, end = 0, normalizedValue, range, textInputRange, len, endRange;
    
    if (typeof input.selectionStart === "number" && typeof input.selectionEnd === "number") {
        start = input.selectionStart;
        end = input.selectionEnd;
    } else {
        range = (document.createRange() || document.selection.createRange());
        
        if (range && range.parentElement() == input) {
            len = input.value.length;
            normalizedValue = input.value.replace(/\r\n/g, "\n");
            
            // Create a working TextRange that lives only in the input
            textInputRange = input.createTextRange();
            textInputRange.moveToBookmark(range.getBookmark());
            
            // Check if the start and end of the selection are at the very end
            // of the input, since moveStart/moveEnd doesn't return what we want
            // in those cases
            endRange = input.createTextRange();
            endRange.collapse(false);
            
            if (textInputRange.compareEndPoints("StartToEnd", endRange) > -1) {
                start = end = len;
            } else {
                start = -textInputRange.moveStart("character", -len);
                start += normalizedValue.slice(0, start).split("\n").length - 1;
                
                if (textInputRange.compareEndPoints("EndToEnd", endRange) > -1) {
                    end = len;
                } else {
                    end = -textInputRange.moveEnd("character", -len);
                    end += normalizedValue.slice(0, end).split("\n").length - 1;
                }
            }
        }
    }
    
    return {
        start: start,
        end: end
    };
};

GS.setInputSelection = function (input, intStart, intEnd) {
    'use strict';
    var range;
    
    if (intStart === undefined || intStart === '' || isNaN(intStart) || intStart === null) {
        intStart = input.value.length;
    }
    
    if (intEnd === undefined || intEnd === '' || isNaN(intEnd) || intEnd === null) {
        intEnd = intStart;
    }
    
    if (input.createTextRange) {
        range = input.createTextRange();
        range.collapse();
        range.moveStart('character', intStart);
        range.collapse();
        range.moveEnd('character', intEnd);
        range.select();
    } else if (input.setSelectionRange) {
        input.focus();
        input.setSelectionRange(intStart, intEnd);
    }
};


// #################################################################
// ################### ELEMENT POSITION FUNCTION ###################
// #################################################################

// return a whole bunch of position data variables for an element
GS.getElementPositionData = function (element) {
    var objElementOffset  = GS.getElementOffset(element),
        intElementWidth   = element.offsetWidth,
        intElementHeight  = element.offsetHeight,
        intElementTop     = objElementOffset.top,
        intElementLeft    = objElementOffset.left,
        intElementBottom  = window.innerHeight - (intElementTop    + intElementHeight),
        intElementRight   = window.innerWidth  - (intElementLeft   + intElementWidth),
        intRoomAbove      = window.innerHeight - (intElementBottom + intElementHeight),
        intRoomBelow      = intElementBottom,
        intRoomLeft       = window.innerWidth  - (intElementRight  + intElementWidth),
        intRoomRight      = intElementRight;
    
    /*console.log(element, '\n' +
                'intElementWidth:   ' + intElementWidth + '\n' +
                'intElementHeight:  ' + intElementHeight + '\n' +
                'intElementTop:     ' + intElementTop + '\n' +
                'intElementBottom:  ' + intElementBottom + '\n' +
                'intElementLeft:    ' + intElementLeft + '\n' +
                'intElementRight:   ' + intElementRight + '\n' +
                'intRoomAbove:      ' + intRoomAbove + '\n' +
                'intRoomBelow:      ' + intRoomBelow + '\n' +
                'intRoomLeft:       ' + intRoomLeft + '\n' +
                'intRoomRight:      ' + intRoomRight);*/
    
    return {
        'element':           element,
        'objElementOffset':  objElementOffset,
        'intElementWidth':   intElementWidth,
        'intElementHeight':  intElementHeight,
        'intElementTop':     intElementTop,
        'intElementLeft':    intElementLeft,
        'intElementBottom':  intElementBottom,
        'intElementRight':   intElementRight,
        'intRoomAbove':      intRoomAbove,
        'intRoomBelow':      intRoomBelow,
        'intRoomLeft':       intRoomLeft,
        'intRoomRight':      intRoomRight
    };
};

// #################################################################
// ####################### DOCUMENT FRAGMENT #######################
// #################################################################
/*                                       ,--- the problem with this code is the DOM we get back is not 100% reliably inert. 
                                         V          To make it reliable I believe I have to change how my elements work.
GS.createDocumentFragment = function (strHTML) {
    'use strict';
    var element = document.createElement('div'),
        fragment = document.createDocumentFragment(),
        arrChildren = element.childNodes;
    
    // fill element with HTML
    element.innerHTML = strHTML;
    
    // append the element to the body (NECCESSARY FOR THE HTML TO BE INERT, I DON'T KNOW WHY -michael)
    document.body.appendChild(element);
    
    // transfer children from element to fragment
    while (arrChildren[0]) {
        fragment.appendChild(arrChildren[0]);
    }
    
    // remove element from the body
    document.body.removeChild(element);
    
    // return inert fragment
    return fragment;
};

GS.getDocumentFragmentHTML = function (fragment) {
    'use strict';
    var strHTML, i, len, arrChildren = fragment.children;
    
    for (strHTML = '', i = 0, len = arrChildren.length; i < len; i += 1) {
        strHTML += arrChildren[i].outerHTML;
    }
    
    return strHTML;
};
*/

// #################################################################
// ########################### INERT DOM ###########################
// #################################################################
/*tell papa if you uncomment
GS.createInertDOM = function (strHTML) {
    'use strict';
    var templateElement = document.createElement('template'), iframeElement;
    
    // if the content property is on a template element: no iframe neccessary
    if ('content' in templateElement) {
        templateElement.innerHTML = strHTML;
        
        return templateElement.content;
        
    // else: use iframe to create inert HTML
    } else {
        if (!document.getElementById('gs-inert-dom-generator')) {
            iframeElement = document.createElement('iframe');
            
            iframeElement.setAttribute('id', 'gs-inert-dom-generator');
            iframeElement.setAttribute('hidden', '');
            
            document.body.appendChild(iframeElement);
            
        } else {
            iframeElement = document.getElementById('gs-inert-dom-generator');
        }
        
        iframeElement.contentWindow.inertDOM = iframeElement.contentWindow.document.createElement('div');
        iframeElement.contentWindow.inertDOM.innerHTML = strHTML;
        
        return iframeElement.contentWindow.inertDOM;
    }
};

GS.getInertDOMHTML = function (inertDOM) {
    'use strict';
    var strHTML, i, len, arrChildren = inertDOM.children;
    
    for (strHTML = '', i = 0, len = arrChildren.length; i < len; i += 1) {
        strHTML += arrChildren[i].outerHTML;
    }
    
    return strHTML;
};
*/

// ##################################################################
// ###################### TABLE COPY/SELECTION ######################
// ##################################################################
(function () {
    'use strict';
    function getCellFromTarget(element) {
        var currentElement = element;
        
        while (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH' && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }
        
        if (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH') {
            return undefined;
        }
        
        return currentElement;
    }
    
    function selectHandler(tableElement, dragOrigin, dragCurrentCell, dragMode) {
        var bolThead, bolFirstTh, arrRecords, arrCells, arrRecordsToAffect = [], arrCellsToAffect = [],
            arrNewSelection = [], arrCellsToRemoveFromSelection = [], i, len, intFrom, intTo;
        
        arrRecords = xtag.query(tableElement, 'tr');
        arrCells = xtag.query(tableElement, 'td, th');
        
        if (arrRecords.length > 0) {
            bolThead = Boolean(xtag.queryChildren(tableElement, 'thead')[0]);
            
            if ((bolThead && arrRecords.length > 1) || (!bolThead && arrRecords > 0)) {
                if (bolThead) {
                    bolFirstTh = arrRecords[1].children[0].nodeName === 'TH';
                } else {
                    bolFirstTh = arrRecords[0].children[0].nodeName === 'TH';
                }
            }
            
            // if origin & currentCell are both the top-left cell and the cell is a heading: select all cells
            if (bolThead && bolFirstTh &&
                dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0 &&
                dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                arrCellsToAffect = arrCells;
                
            // else if origin & currentCell are both first ths: select the records from origin to currentCell
            } else if (bolFirstTh && dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                arrRecordsToAffect =
                    arrRecords.slice(Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                                     Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1);
                
                for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
                }
                
            // else if origin & currentCell are both headings: select the columns from origin to currentCell
            } else if (bolThead && dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0) {
                intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                intTo   = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;
                
                for (i = 0, len = arrRecords.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecords[i].children).slice(intFrom, intTo));
                }
                
            //// else if origin & currentCell are the same cell: select the record
            //} else if (dragOrigin === dragCurrentCell) {
            //    arrRecordsToAffect = arrRecords.slice(dragOrigin.parentNode.rowIndex, dragOrigin.parentNode.rowIndex + 1);
            //    
            //    for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
            //        Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
            //    }
            //    
            // else select cells from origin to currentCell
            } else {
                arrRecordsToAffect =
                    arrRecords.slice(Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                                     Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1);
                
                intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                intTo   = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;
                
                for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children).slice(intFrom, intTo));
                }
            }
            
            if (dragMode === 'select') {
                // add new cells to tableElement.selectionSelectedCells
                for (i = 0, len = tableElement.selectionSelectedCells.length; i < len; i += 1) {
                    if (arrCellsToAffect.indexOf(tableElement.selectionSelectedCells[i]) === -1) {
                        arrCellsToRemoveFromSelection.push(tableElement.selectionSelectedCells[i]);
                    }
                }
                tableElement.selectionSelectedCells = arrCellsToAffect;
                
                // add new cells to tableElement.selectedCells
                arrNewSelection = tableElement.selectedCells;
                for (i = 0, len = arrCellsToAffect.length; i < len; i += 1) {
                    GS.listAdd(arrNewSelection, arrCellsToAffect[i]);
                }
                for (i = 0, len = arrCellsToRemoveFromSelection.length; i < len; i += 1) {
                    arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToRemoveFromSelection[i]), 1);
                }
                tableElement.selectedCells = arrNewSelection;
                
            } else { // implied if: dragMode === 'deselect'
                // deselect cells from arrCellsToAffect
                arrNewSelection = tableElement.selectedCells;
                
                for (i = 0, len = arrCellsToAffect.length; i < len; i += 1) {
                    if (arrNewSelection.indexOf(arrCellsToAffect[i]) > -1) {
                        arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToAffect[i]), 1);
                    }
                }
                tableElement.selectedCells = arrNewSelection;
            }
        }
    }
    
    
    
    
    
    
    function getSelectedCopyHTML(element) {
        var strHTMLCopyString, intFromRecord, intToRecord, intFromCell = 9999999, intToCell = 0
          , i, len, cell_i, cell_len, arrSelected, strCellHTML, arrRecords, arrCells
          , strHTMLRecordString, strNull, bolColumns;
        
        arrSelected = element.selectedCells;
        
        strNull    = (element.getAttribute('null-values')  || "NULL");
        bolColumns = (element.getAttribute('column-names') || "true") === "true";
        
        // loop through the selected cells and create an html string using the text of the cell
        if (arrSelected.length > 0) {
            intFromRecord = arrSelected[0].parentNode.rowIndex;
            intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;
            
            for (i = 0, len = arrSelected.length; i < len; i += 1) {
                if (arrSelected[i].cellIndex < intFromCell) {
                    intFromCell = arrSelected[i].cellIndex;
                    intFromCell = (intFromCell === 0 ? 1 : intFromCell);
                }
                if (arrSelected[i].cellIndex + 1 > intToCell) {
                    intToCell = arrSelected[i].cellIndex + 1;
                }
            }
            
            arrRecords = xtag.query(element, 'tr');
            strHTMLCopyString = '';
            
            // if bolColumns is true and the first record is not selected: add first record first
            if (bolColumns && intFromRecord > 0) {
                arrCells = arrRecords[0].children;
                strHTMLRecordString = '';
                
                for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                    strCellHTML = '';
                    
                    if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) {
                        strCellHTML = arrCells[cell_i].firstElementChild.textValue ||
                                      arrCells[cell_i].firstElementChild.value ||
                                      (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                      arrCells[cell_i].firstElementChild.textContent || '';//.trim();
                        
                    } else if (arrCells[cell_i].lastElementChild) { 
                        strCellHTML = arrCells[cell_i].lastElementChild.textValue ||
                                      arrCells[cell_i].lastElementChild.value ||
                                      (arrCells[cell_i].lastElementChild.checked || '').toString() ||
                                      arrCells[cell_i].lastElementChild.textContent || '';
                    } else {
                        strCellHTML = arrCells[cell_i].textContent;//.trim();
                    }
                    
                    strCellHTML = encodeHTML(strCellHTML).replace(/\n/gim, '<br />');
                    
                    strCellHTML = '<' + 'td rowspan="1" colspan="1">' + (strCellHTML || '') + '</td>'
                    
                    strHTMLRecordString += (cell_i === intFromCell ? '<' + 'tr>' : '');
                    strHTMLRecordString += (strCellHTML || '');
                    strHTMLRecordString += (cell_i === (intToCell - 1) ? '<' + '/tr>' : '');
                }
                
                if (strHTMLRecordString.trim()) {
                    strHTMLCopyString += strHTMLRecordString;
                }
            }
            
            for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                arrCells = arrRecords[i].children;
                strHTMLRecordString = '';
                
                if (!arrRecords[i].classList.contains('insert-record')) {
                    for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                        strCellHTML = '';
                        
                        if (arrCells[cell_i].hasAttribute('selected') || (i === 0 && bolColumns)) {
                            if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) {
                                strCellHTML = arrCells[cell_i].firstElementChild.textValue ||
                                              arrCells[cell_i].firstElementChild.value ||
                                              (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                              arrCells[cell_i].firstElementChild.textContent || '';//.trim();
                                
                            } else if (arrCells[cell_i].lastElementChild) { 
                                strCellHTML = arrCells[cell_i].lastElementChild.textValue ||
                                              arrCells[cell_i].lastElementChild.value ||
                                              (arrCells[cell_i].lastElementChild.checked || '').toString() ||
                                              arrCells[cell_i].lastElementChild.textContent || '';
                            } else {
                                strCellHTML = arrCells[cell_i].textContent;//.trim();
                            }
                            
                            strCellHTML = encodeHTML(strCellHTML).replace(/\n/gim, '<br />');
                            
                            if (strCellHTML === 'NULL' || strCellHTML === '\N') {
                                strCellHTML = strNull;
                            }
                        }
                        
                        strCellHTML = '<' + 'td rowspan="1" colspan="1">' + (strCellHTML || '') + '</td>'
                        
                        strHTMLRecordString += (cell_i === intFromCell ? '<' + 'tr>' : '');
                        strHTMLRecordString += (strCellHTML || '');
                        strHTMLRecordString += (cell_i === (intToCell - 1) ? '<' + '/tr>' : '');
                    }
                }
                if (strHTMLRecordString.trim()) {
                    strHTMLCopyString += strHTMLRecordString;
                }
            }
            //console.log('*****', strHTMLCopyString);
            if (strHTMLCopyString) {
                strHTMLCopyString = '<' + 'style>' +
                                        'br { mso-data-placement:same-cell; } ' +
                                        'th, td { white-space: pre-wrap; }' +
                                    '<' + '/style>' +
                                    '<' + 'table border="0" cellpadding="0" cellspacing="0">' + strHTMLCopyString + '<' + '/table>';
            }
        }
        
        return strHTMLCopyString || '';
    }
    
    function getSelectedCopyText(element) {
        var strTextCopyString, intFromRecord, intToRecord, intFromCell = 9999999, intToCell = 0,
            i, len, cell_i, cell_len, arrSelected, strCellText, arrRecords, arrCells, arrCellIndexes, strTextRecordString,
            strQuoteType, strQuoteChar, strFieldDelimiter, strRowDelimiter, strNull, bolColumns, quoteRegex;
        
        strQuoteType      = (element.getAttribute('quote-type')      || "strings");
        strQuoteChar      = (element.getAttribute('quote-char')      || '"');
        strFieldDelimiter = (element.getAttribute('field-delimiter') || "\t");
        strNull           = (element.getAttribute('null-values')     || "NULL");
        bolColumns        = (element.getAttribute('column-names')    || "true") === "true";
        strRowDelimiter   = (element.getAttribute('row-delimiter')   || "\n");
        
        quoteRegex = new RegExp(strQuoteChar, 'g');
        
        arrSelected = element.selectedCells;
        
        // loop through the selected cells and create a tsv string using the text of the cell
        if (arrSelected.length > 0) {
            intFromRecord = arrSelected[0].parentNode.rowIndex;
            intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;
            
            for (i = 0, len = arrSelected.length; i < len; i += 1) {
                if (arrSelected[i].cellIndex < intFromCell) {
                    intFromCell = arrSelected[i].cellIndex;
                    intFromCell = (intFromCell === 0 ? 1 : intFromCell);
                }
                if (arrSelected[i].cellIndex + 1 > intToCell) {
                    intToCell = arrSelected[i].cellIndex + 1;
                }
            }
            
            arrRecords = xtag.query(element, 'tr');
            strTextCopyString = '';
            
            // if bolColumns is true and the first record is not selected: add first record first
            if (bolColumns && intFromRecord > 0) {
                arrCells = arrRecords[0].children;
                strTextRecordString = '';
                
                for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                    strCellText = '';
                    
                    if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) {
                        strCellText = arrCells[cell_i].firstElementChild.textValue ||
                                      arrCells[cell_i].firstElementChild.value ||
                                      (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                      arrCells[cell_i].firstElementChild.textContent || '';//.trim();
                        
                    } else if (arrCells[cell_i].lastElementChild) {
                        strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                      arrCells[cell_i].lastElementChild.value ||
                                      (arrCells[cell_i].lastElementChild.checked || '').toString();
                    } else {
                        strCellText = arrCells[cell_i].textContent;//.trim();
                    }
                    
                    strCellText = strCellText.replace(quoteRegex, (strQuoteChar + strQuoteChar));
                    
                    if (strCellText === 'NULL' || strCellText === '\N') {
                        strCellText = strNull;
                    } else {
                        if (strQuoteType === 'all') {
                            strCellText = strQuoteChar + strCellText + strQuoteChar;
                        } else if (strQuoteType === 'strings' && isNaN(strCellText)) {
                            strCellText = strQuoteChar + strCellText + strQuoteChar;
                        }
                    }
                    
                    strTextRecordString += (cell_i !== intFromCell ? strFieldDelimiter : '');
                    strTextRecordString += (strCellText || '');
                }
                
                strTextCopyString += strTextRecordString;
                strTextCopyString += strRowDelimiter;
            }
            
            for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                arrCells = arrRecords[i].children;
                strTextRecordString = '';
                
                for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                    strCellText = '';
                    
                    if (arrCells[cell_i].hasAttribute('selected')) {
                        if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) { 
                            strCellText = arrCells[cell_i].firstElementChild.textValue ||
                                          arrCells[cell_i].firstElementChild.value ||
                                          (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                          arrCells[cell_i].firstElementChild.textContent;//.trim();
                            
                        } else if (arrCells[cell_i].lastElementChild) {
                            strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                          arrCells[cell_i].lastElementChild.value ||
                                          (arrCells[cell_i].lastElementChild.checked || '').toString();
                        } else {
                            strCellText = arrCells[cell_i].textContent;//.trim();
                        }
                        
                        strCellText = strCellText.replace(quoteRegex, (strQuoteChar + strQuoteChar));
                        
                        if (strCellText === 'NULL' || strCellText === '\N') {
                            strCellText = strNull;
                        } else {
                            if (strQuoteType === 'all') {
                                strCellText = strQuoteChar + strCellText + strQuoteChar;
                            } else if (strQuoteType === 'strings' && isNaN(strCellText)) {
                                strCellText = strQuoteChar + strCellText + strQuoteChar;
                            }
                        }
                    } else {
                        if (strQuoteType === 'all' || strQuoteType === 'strings') {
                            strCellText = strQuoteChar + strCellText + strQuoteChar;
                        }
                    }
                    
                    strTextRecordString += (cell_i !== intFromCell ? strFieldDelimiter : '');
                    strTextRecordString += (strCellText || '');
                }
                //if (strTextRecordString.trim()) {
                strTextCopyString += strTextRecordString;
                //}
                if (i + 1 !== len) { //&& strTextRecordString.trim()
                    strTextCopyString += strRowDelimiter;
                }
            }
        }
        
        return strTextCopyString || '';
    }
    
    function handleClipboardData(event, strCopyString, strType) {
        var clipboardData = event.clipboardData || window.clipboardData, strMime;
        
        if (!clipboardData) { return; }
        if (!clipboardData.setData) { return; }
        
        if (strType === 'text') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = 'Text';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/plain';
            }
            
        } else if (strType === 'html') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = '';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/html';
            }
            
        } else {
            throw 'handleClipboardData Error: Type "' + strType + '" not recognized, recognized types are "text" and "html".';
        }
        
        if (strMime) {
            if (strCopyString && strMime) {
                return clipboardData.setData(strMime, strCopyString) !== false;
            } else {
                return clipboardData.getData(strMime);
            }
        }
    }
    
    
    
    //function handleClipboardData(event, strCopyString) {
    //    var clipboardData = event.clipboardData || window.clipboardData, strMime;
    //    
    //    if (!clipboardData) {
    //        return;
    //    }
    //    if (!clipboardData.setData) {
    //        return;
    //    }
    //    
    //    if (window.clipboardData && window.clipboardData.getData) { // IE
    //        strMime = 'Text';
    //    } else if (event.clipboardData && event.clipboardData.getData) {
    //        strMime = 'text/plain';
    //    }
    //    
    //    if (strCopyString) {
    //        return clipboardData.setData(strMime, strCopyString) !== false;
    //    } else {
    //        return clipboardData.getData(strMime);
    //    }
    //}

    GS.makeTableSelectable = function (tableElement, bolSingleRecord) {
        var copyElement;
        
        // tableElement verification
        if (!tableElement || tableElement.nodeName !== 'TABLE') {
            throw 'GS.makeTableSelectable Error: you must provide a <table> element as the first parameter.';
        }
        
        // prevent text selection
        //tableElement.setAttribute('prevent-text-selection', '');
        
        // define selectedCells getter and setter on the table element itself
        Object.defineProperty(tableElement, 'selectedCells', {
            get: function () {
                return xtag.query(this, '[selected]');
            },
            
            set: function (newValue) {
                var i, len, intIdIndex, arrCells = this.selectedCells, arrRecords, cell_i, cell_len;
                
                // clear old selection
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].removeAttribute('selected');
                }
                
                arrCells = xtag.query(this, '[selected-secondary]');
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].removeAttribute('selected-secondary');
                }
                
                // if newValue is not an array: make it an array
                if (typeof newValue === 'object' && newValue.length === undefined) {
                    arrCells = [newValue];
                } else {
                    arrCells = newValue;
                }
                
                // set new selection
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].setAttribute('selected', '');
                }
                
                arrRecords = this.selectedRecords;
                
                for (i = 0, len = arrRecords.length; i < len; i += 1) {
                    arrCells = arrRecords[i].children;
                    
                    for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                        if (!arrCells[cell_i].hasAttribute('selected')) {
                            arrCells[cell_i].setAttribute('selected-secondary', '');
                        }
                    }
                }
                
                GS.triggerEvent(this, 'after_selection');
            }
        });
        
        // define selectedRecords getter and setter on the table element itself
        Object.defineProperty(tableElement, 'selectedRecords', {
            get: function () {
                var i, len, intRecordIndex = -1, arrRecord = [], selected = this.selectedCells;
                
                // loop through the selected cells and create an array of trs
                for (i = 0, len = selected.length; i < len; i += 1) {
                    if (selected[i].parentNode.rowIndex > intRecordIndex && selected[i].parentNode.parentNode.nodeName !== 'THEAD') {
                        intRecordIndex = selected[i].parentNode.rowIndex;
                        
                        arrRecord.push(selected[i].parentNode);
                    }
                }
                
                return arrRecord;
            },
            
            set: function (newValue) {
                var i, len, cell_i, cell_len, intIdIndex, arrCells = this.selectedCells, arrRecords, arrCellChildren;
                
                // clear old selection
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].removeAttribute('selected');
                }
                
                arrCells = xtag.query(this, '[selected-secondary]');
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].removeAttribute('selected-secondary');
                }
                
                // if newValue is not an array: make it an array
                if (typeof newValue === 'object' && newValue.length === undefined) {
                    arrRecords = [newValue];
                } else {
                    arrRecords = newValue;
                }
                
                // set new selection
                for (i = 0, len = arrRecords.length, arrCells = []; i < len; i += 1) {
                    arrCellChildren = arrRecords[i].children;
                    
                    for (cell_i = 0, cell_len = arrCellChildren.length; cell_i < cell_len; cell_i += 1) {
                        arrCells.push(arrCellChildren[cell_i]);
                    }
                }
                
                this.selectedCells = arrCells;
                
                GS.triggerEvent(this, 'after_selection');
            }
        });
        
        // if we are on a touchdevice or bolSingleRecord is true: single record selection
        if (evt.touchDevice || bolSingleRecord === true) {
            tableElement.addEventListener(evt.mousedown, function (event) {
                var target = event.target;
                
                if (target.nodeName === 'TD' || target.nodeName === 'TH' || getCellFromTarget(target)) {
                    tableElement.selectedCells = [];
                    
                    // if there is a parent record to the target: select all of the cells in the record
                    if (GS.findParentTag(target, 'tr')) {
                        tableElement.selectedCells = GS.findParentTag(target, 'tr').children;
                    }
                }
            });
            
        // else: cell/record selection
        } else {
            // mousedown (on selected and unselected) + drag
            //      clear previous selection(s)
            //      select cells from origin cell to current cell
            //
            // shift + mousedown (on selected and unselected) + drag
            //      alter previous selection
            //      select cells from previous origin cell to current cell
            //
            // command + mousedown (on unselected) + drag
            //      maintain previous selection(s)
            //      select cells from origin cell to current cell
            //
            // command + mousedown (on selected) + drag
            //      maintain previous selection(s)
            //      deselect cells from origin cell to current cell
            //
            // collision handling
            //      when colliding with previous selections: dont treat them different
            //
            // copy handling
            //      selection ("X" marks selected cells (imagine all cells contain the letter "a")):
            //          1  2  3  4  5
            //          -------------
            //          a  a  a  a  a
            //          a  X  X  a  a
            //          a  a  X  X  a
            //          a  a  a  a  a
            //
            //      yields ("'" marks an empty cell):
            //          2  3  4 
            //          -------
            //          a  a  ' 
            //          '  a  a 
            
            tableElement.addEventListener(evt.mousedown, function (event) {
                var target = event.target, cellFromTarget = getCellFromTarget(target), closestCell, arrSelectedCells, i, len;
                
                if (GS.findParentTag(event.target, 'table')) {
                    if (cellFromTarget) {
                        closestCell = cellFromTarget;
                    }
                    
                    if (closestCell) {
                        tableElement.dragAllowed = true;
                        tableElement.dragCurrentCell = closestCell;
                        tableElement.selectionSelectedCells = [];
                        
                        // if shift is down and there is a previous origin: use previous origin for current origin
                        if (event.shiftKey && tableElement.selectionPreviousOrigin) {
                            
                            // if there are previously selected cells: deselect the previous selected cells
                            if (tableElement.selectionPreviousSelectedCells) {
                                arrSelectedCells = tableElement.selectedCells;
                                
                                for (i = 0, len = tableElement.selectionPreviousSelectedCells.length; i < len; i += 1) {
                                    arrSelectedCells.splice(arrSelectedCells.indexOf(tableElement.selectionPreviousSelectedCells[i]), 1);
                                }
                                
                                tableElement.selectedCells = arrSelectedCells;
                            }
                            
                            tableElement.dragOrigin = tableElement.selectionPreviousOrigin;
                            tableElement.dragMode = 'select';
                            
                        // else if ctrl or cmd is down and the target cell is not selected: select cells from target cell to current cell
                        } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && !closestCell.hasAttribute('selected')) {
                            tableElement.dragOrigin = closestCell;
                            tableElement.dragMode = 'select';
                            
                        // else if ctrl or cmd is down and the target cell is selected: deselect cells from target cell to current cell
                        } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && closestCell.hasAttribute('selected')) {
                            tableElement.dragOrigin = closestCell;
                            tableElement.dragMode = 'deselect';
                            
                        // else: deselect all cells and start new selection
                        } else {
                            tableElement.selectedCells = [];
                            tableElement.dragOrigin = closestCell;
                            tableElement.dragMode = 'select';
                        }
                        
                        selectHandler(tableElement, tableElement.dragOrigin, tableElement.dragCurrentCell, tableElement.dragMode);
                    }
                }
            });
            tableElement.addEventListener(evt.mousemove, function (event) {
                var target, closestCell, cellFromTarget;
                
                // if mouse is down
                if (event.which !== 0) {
                    target = event.target;
                    cellFromTarget = getCellFromTarget(target);
                    
                    if (cellFromTarget) {
                        closestCell = cellFromTarget;
                    }
                    
                    // if selection is allowed at this point and closestCell is different from tableElement.dragCurrentCell
                    if (tableElement.dragAllowed && tableElement.dragCurrentCell !== closestCell) {
                        tableElement.dragCurrentCell = getCellFromTarget(closestCell);
                        selectHandler(tableElement, tableElement.dragOrigin, tableElement.dragCurrentCell, tableElement.dragMode);
                    }
                } else {
                    tableElement.dragAllowed = false;
                    tableElement.selectionPreviousOrigin = tableElement.dragOrigin;
                    tableElement.selectionPreviousSelectedCells = tableElement.selectionSelectedCells;
                }
            });
            tableElement.addEventListener(evt.mouseup, function (event) {
                tableElement.dragAllowed = false;
                
                if (tableElement.dragMode === 'select') {
                    tableElement.selectionPreviousOrigin = tableElement.dragOrigin;
                    tableElement.selectionPreviousSelectedCells = tableElement.selectionSelectedCells;
                }
            });
        }
        
        // add input for clipboard compatibility
        copyElement = document.createElement('input');
        copyElement.value = 'Firefox compatibility input';
        copyElement.setAttribute('gs-dynamic', '');
        copyElement.setAttribute('style', 'position: fixed; left: 50%; top: 50%; z-index: -5000; opacity: 0.00000001;');
        
        tableElement.appendChild(copyElement);
        
        // add tabindex so that we can listen for focus on the table
        tableElement.tabIndex = 0;
        
        // when a focus event happens on the table: focus the copy input if the element that is focused is the table
        tableElement.addEventListener('focus', function (event) {
            if (document.activeElement === tableElement) {
                tableElement.focus();
                GS.setInputSelection(copyElement, 0, 'Firefox compatibility input'.length);
            }
        });
        
        // clipboard handling
        document.body.addEventListener('copy', function (event) {
            var elementClosestTable = GS.findParentTag(document.activeElement, 'table')
              , strTextCopyString, strHTMLCopyString;
            
            if (elementClosestTable === tableElement &&
                (
                    document.activeElement.value === 'Firefox compatibility input' ||
                    document.activeElement.selectionStart === document.activeElement.selectionEnd
                )) {
                GS.setInputSelection(document.activeElement, document.activeElement.value.length,
                                            document.activeElement.value.length);
                
                strTextCopyString = getSelectedCopyText(tableElement);
                strHTMLCopyString = getSelectedCopyHTML(tableElement);
                
                if (strTextCopyString && strHTMLCopyString) {
                    if (handleClipboardData(event, strTextCopyString, 'text')) {
                        event.preventDefault(event);
                    }
                    if (handleClipboardData(event, strHTMLCopyString, 'html')) {
                        event.preventDefault(event);
                    }
                }
                
                GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
            }
        });
            //var elementClosestTable = GS.findParentTag(document.activeElement, 'table'), strCopyString,
            //    i, len, cell_i, cell_len, arrSelected, intFromRecord = 9999999, intFromCell = 9999999,
            //    intToRecord = 0, intToCell = 0, strCellText, arrRecords, arrCells, strRecordString;
            //
            //if (elementClosestTable === tableElement &&
            //    (
            //        document.activeElement.value === 'Firefox compatibility input' ||
            //        document.activeElement.selectionStart === document.activeElement.selectionEnd
            //    )) {
            //    arrSelected = tableElement.selectedCells;
            //    
            //    // loop through the selected cells and create a tsv string using the text of the cell
            //    if (arrSelected.length > 0) {
            //        for (i = 0, len = arrSelected.length; i < len; i += 1) {
            //            if (arrSelected[i].parentNode.rowIndex < intFromRecord) {
            //                intFromRecord = arrSelected[i].parentNode.rowIndex;
            //            }
            //            if (arrSelected[i].cellIndex < intFromCell) {
            //                intFromCell = arrSelected[i].cellIndex;
            //            }
            //            if (arrSelected[i].parentNode.rowIndex + 1 > intToRecord) {
            //                intToRecord = arrSelected[i].parentNode.rowIndex + 1;
            //            }
            //            if (arrSelected[i].cellIndex + 1 > intToCell) {
            //                intToCell = arrSelected[i].cellIndex + 1;
            //            }
            //        }
            //        
            //        arrRecords = xtag.query(tableElement, 'tr');
            //        strCopyString = '';
            //        
            //        for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
            //            arrCells = arrRecords[i].children;
            //            
            //            for (cell_i = intFromCell, cell_len = intToCell, strRecordString = ''; cell_i < cell_len; cell_i += 1) {
            //                if (arrCells[cell_i].hasAttribute('selected')) {
            //                    if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) { 
            //                        strCellText = arrCells[cell_i].firstElementChild.textValue ||
            //                                      arrCells[cell_i].firstElementChild.value ||
            //                                      (arrCells[cell_i].firstElementChild.checked || '').toString() ||
            //                                      arrCells[cell_i].firstElementChild.textContent.trim();
            //                    } else if (arrCells[cell_i].lastElementChild) { 
            //                        strCellText = arrCells[cell_i].lastElementChild.textValue ||
            //                                      arrCells[cell_i].lastElementChild.value ||
            //                                      (arrCells[cell_i].lastElementChild.checked || '').toString() ||
            //                                      arrCells[cell_i].lastElementChild.textContent.trim();
            //                    } else {
            //                        strCellText = arrCells[cell_i].textContent.trim();
            //                    }
            //                } else {
            //                    strCellText = '';
            //                }
            //                
            //                strRecordString += (cell_i !== intFromCell ? '\t' : '') + (strCellText || '');
            //            }
            //            
            //            if (strRecordString.trim()) {
            //                strCopyString += strRecordString;
            //            }
            //            
            //            if (i + 1 !== len && strRecordString.trim()) {
            //                strCopyString += '\r\n';
            //            }
            //        }
            //    }
            //    
            //    if (strCopyString) {
            //        if (handleClipboardData(event, strCopyString)) {
            //            event.preventDefault(event);
            //        }
            //    }
            //}
    };
})();
window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('GS.qryFromJSON', 'GS.qryFromJSON', 'GS.qryFromJSON(${0:jsnObjectToConvert});');
    
    registerDesignSnippet('GS.qryToJSON', 'GS.qryToJSON', 'GS.qryToJSON(${0:strQueryStringToConvert});');
    
    registerDesignSnippet('GS.qryToWhere', 'GS.qryToWhere',
                                'GS.qryToWhere(${1:strQueryString}, ${2:strColumnNameInQueryString}, ${0:strColumnNameInTarget});');
    
    registerDesignSnippet('GS.qryGetKeys', 'GS.qryGetKeys', 'GS.qryGetKeys(${0:queryString});');
    
    registerDesignSnippet('GS.qryGetVals', 'GS.qryGetVals', 'GS.qryGetVals(${0:queryString});');
    
    registerDesignSnippet('GS.qryGetVal', 'GS.qryGetVal', 'GS.qryGetVal(${1:queryString}, \'${0:keyToGet}\');');
    
    registerDesignSnippet('GS.qrySetVal', 'GS.qrySetVal', 'GS.qrySetVal(${1:queryString}, \'${0:newKeyValuePair}\');');
    
    registerDesignSnippet('GS.qryDeleteKey', 'GS.qryDeleteKey', 'GS.qryDeleteKey(${1:queryString}, \'${0:keyToDelete}\');');
    
    registerDesignSnippet('GS.getQueryString', 'GS.getQueryString', 'GS.getQueryString();');
    
    registerDesignSnippet('GS.pushQueryString', 'GS.pushQueryString', 'GS.pushQueryString(${0:newQueryString});');
    
    registerDesignSnippet('GS.removeFromQueryString', 'GS.removeFromQueryString', 'GS.removeFromQueryString(${0:removeKeys});');
});


// ########## CONVERSION FUNCTIONS ##########
GS.qryFromJSON = function (jsnToConvert) {
    'use strict';
    var key, strRet = '', strType, currentValue;
    
    for (key in jsnToConvert) {
        currentValue = jsnToConvert[key];
        strType = typeof currentValue;
        
        if (strType === 'number' || strType === 'string' || strType === 'boolean') {
            strRet += (strRet === '' ? '' : '&') + key + '=' + encodeURIComponent(jsnToConvert[key]);
            
        } else if (currentValue === null || currentValue === undefined) {
            strRet += (strRet === '' ? '' : '&') + key + '=';
            
        } else if (typeof currentValue !== 'object') {
            throw 'GS.qryFromJSON Error: Invalid value: ' + JSON.stringify(currentValue);
        }
    }
    
    return strRet;
};

GS.qryToJSON = function (strQueryString) {
    'use strict';
    var arrKeyValueList = [], jsnQueryString = {}, strKeyValue, i, len, strKey, strValue, jsnNavigator, arrSubParts, sub_i, sub_len;
    
    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');
        
        for (i = 0, len = arrKeyValueList.length; i < len; i += 1) {
            strKeyValue = arrKeyValueList[i];
            strKey      = strKeyValue.substring(0, strKeyValue.indexOf('='));
            strValue    = decodeURIComponent(strKeyValue.substring(strKeyValue.indexOf('=') + 1));
            
            jsnQueryString[strKey] = strValue;
            
            // if a dot is found in the key: create a sub JSON structure
            if (strKey.indexOf('.') > -1) {
                arrSubParts = strKey.split('.');
                
                jsnNavigator = jsnQueryString;
                for (sub_i = 0, sub_len = arrSubParts.length; sub_i < sub_len; sub_i += 1) {
                    if (sub_i < sub_len - 1) {
                        jsnNavigator[arrSubParts[sub_i]] = jsnNavigator[arrSubParts[sub_i]] || {};
                    } else {
                        jsnNavigator[arrSubParts[sub_i]] = jsnNavigator[arrSubParts[sub_i]] || strValue;
                    }
                    
                    jsnNavigator = jsnNavigator[arrSubParts[sub_i]];
                }
            }
        }
    }
    
    return jsnQueryString;
};

// get data from query string and turn it into a where clause
//      (
//          the second two params are optional
//              (
//                  they are for when you want only one column out of a query string to be converted
//              )
//      )
GS.qryToWhere = function (strQS, strColumnNameInQS, strColumnNameInTarget) {
    'use strict';
    var strWhere = '', key, jsnArgs;
    
    if (strColumnNameInQS) {
        strColumnNameInTarget = (strColumnNameInTarget || strColumnNameInQS);
        
        if (!isNaN(GS.qryGetVal(strQS, strColumnNameInQS))) {
            strWhere = strColumnNameInTarget + '=' + GS.qryGetVal(strQS, strColumnNameInQS);
        } else {
            strWhere = 'CAST(' + strColumnNameInTarget + ' AS ' + GS.database.type.text + ') = ' +
                       'CAST($WhereQUOTE$' +
                            encodeURIComponent(GS.qryGetVal(strQS, strColumnNameInQS)) +
                            '$WhereQUOTE$ AS ' + GS.database.type.text + ')';
        }
    } else {
        jsnArgs = GS.qryToJSON(strQS);

        for (key in jsnArgs) {
            if (jsnArgs.hasOwnProperty(key)) {
                if (!isNaN(jsnArgs[key])) {
                    strWhere += (strWhere === '' ? '': ' AND ') + key + '=' + jsnArgs[key];
                } else {
                    strWhere += (strWhere === '' ? '': ' AND ') +
                                'CAST(' + key + ' AS ' + GS.database.type.text + ') = ' +
                                'CAST($WhereQUOTE$' + encodeURIComponent(jsnArgs[key]) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')';
                }
            }
        }
    }
    
    return strWhere;
};


// ########## LISTING FUNCTIONS ##########
GS.qryGetKeys = function (strQueryString) {
    'use strict';
    var arrKeyValueList = [], arrKeys = [], i, len, strKeyValue;
    
    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');
        
        for (i = 0, len = arrKeyValueList.length; i < len; i += 1) {
            strKeyValue = arrKeyValueList[i];
            
            arrKeys.push(strKeyValue.substring(0, strKeyValue.indexOf('=')));
        }
    }
    
    return arrKeys;
};

GS.qryGetVals = function (strQueryString) {
    'use strict';
    var arrKeyValueList = [], arrValues = [], i, len, strKeyValue;
    
    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');
        
        for (i = 0, len = arrKeyValueList.length; i < len; i += 1) {
            strKeyValue = arrKeyValueList[i];
            
            arrValues.push(strKeyValue.substring(strKeyValue.indexOf('=') + 1));
        }
    }
    
    return arrValues;
};


// ########## PARAMETER GET/SET FUNCTIONS ##########
GS.qryGetVal = function (strQueryString, strKey) {
    'use strict';
    var arrKeyValueList, strSlice, i, len;
    
    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');
        
        for (i = 0, len = arrKeyValueList.length; i < len; i = i + 1) {
            strSlice = arrKeyValueList[i];
            
            if (strSlice.split('=')[0] === strKey) {
                return decodeURIComponent(strSlice.substring(strSlice.indexOf('=') + 1));
            }
        }
    }
    
    return '';
};

GS.qrySetVal = function (strQueryString, strKeyValue) {
    'use strict';
    strQueryString = GS.qryDeleteKey(strQueryString, strKeyValue.split('=')[0]);
    strQueryString = strQueryString + (strQueryString ? '&' : '') + strKeyValue;
    
    return strQueryString;
};


// ########## KEY DELETE FUNCTION ##########
GS.qryDeleteKey = function (strQueryString, strKey) {
    'use strict';
    var arrKeyValueList, strSlice, i, len;
    
    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');
        
        for (i = 0, len = arrKeyValueList.length; i < len; i = i + 1) {
            strSlice = arrKeyValueList[i];
            
            if (strSlice.split('=')[0] === strKey) {
                arrKeyValueList.splice(i, 1);
                
                break;
            }
        }
        
        return arrKeyValueList.join('&');
    }
    
    return '';
};


// ########## MISC FUNCTIONS ##########
GS.getQueryString = function () {
    'use strict';
    return window.location.search.substring(1);
};

GS.pushQueryString = function (QS) {
    var arrNewQS = QS.split('&'), i, len, newQS = GS.getQueryString();
    for (i = 0, len = arrNewQS.length; i < len; i += 1) {
        newQS = GS.qrySetVal(newQS, arrNewQS[i]);
    }
    GS.pushState({}, '', '?' + newQS);
};


GS.removeFromQueryString = function (keys) {
    var arrRemoveKeys = keys.split(','), i, len, newQS = GS.getQueryString();
    for (i = 0, len = arrRemoveKeys.length; i < len; i += 1) {
        newQS = GS.qryDeleteKey(newQS, arrRemoveKeys[i]);
    }
    GS.pushState({}, '', '?' + newQS);
};

window.addEventListener('design-register-element', function () {
    'use strict';
    
    //registerDesignSnippet('GS.qryFromJSON', 'GS.qryFromJSON', 'GS.qryFromJSON(${0:jsnObjectToConvert});');
});



GS.templateColumnToValue = function (templateHTML) {
    'use strict';
    var templateElementEncoded = document.createElement('template'),
        templateElementNonEncoded = document.createElement('template'),
        arrTemplateElementEncoded, arrTemplateElementNonEncoded,
        jsnTemplates = {}, arrColumnElement = [], templateHTMLEncoded, bolInCommand, i, len, strID;
    
    // get template element encoded with all "&"s (that are not inside a doT command) encoded,
    //      so that html encoded characters are not lost in the next operations
    
    for (i = 0, len = templateHTML.length, templateHTMLEncoded = '', bolInCommand = false; i < len; i += 1) {
        if (!bolInCommand && templateHTML[i] === '{' && templateHTML[i + 1] === '{') {
            bolInCommand = true;
            i += 1;
            templateHTMLEncoded += '{{';
            
        } else if (bolInCommand && templateHTML[i] === '}' && templateHTML[i + 1] === '}') {
            bolInCommand = false;
            i += 1;
            templateHTMLEncoded += '}}';
            
        } else if (!bolInCommand && templateHTML[i] === '&') {
            templateHTMLEncoded += '&amp;';
            
        } else {
            templateHTMLEncoded += templateHTML[i];
        }
    }
    
    //console.log(templateHTML);
    //console.log(templateHTMLEncoded);
    templateElementEncoded.innerHTML = templateHTMLEncoded; //templateHTML.replace(/&/gi, '&amp;');
    
    // get template element non-encoded with everything in it, so that sub templates are not touched
    templateElementNonEncoded.innerHTML = templateHTML;
    
    // go through element encoded and replace templates with tokens
    // go through element non-encoded and gather templates and make sure they reference the same tokens
    arrTemplateElementEncoded = xtag.query(templateElementEncoded.content, 'template');
    arrTemplateElementNonEncoded = xtag.query(templateElementNonEncoded.content, 'template');
    i = 0;
    
    //console.log(arrTemplateElementEncoded);
    //console.log(arrTemplateElementNonEncoded);
    
    //console.log(arrTemplateElementEncoded.length);
    while (arrTemplateElementEncoded.length > 0 && i < 500) {
        //console.log(arrTemplateElementNonEncoded[0].parentNode);
        
        if (arrTemplateElementNonEncoded[0].parentNode &&
            arrTemplateElementNonEncoded[0].parentNode.hasAttribute &&
                (
                    arrTemplateElementNonEncoded[0].parentNode.hasAttribute('src') ||
                    arrTemplateElementNonEncoded[0].parentNode.hasAttribute('source')
                )) {
            strID = 'UnIqUE_PLaCEh0LDER-' + GS.GUID() + '-UniQUE_PLaCEh0LdER';
            jsnTemplates[strID] = arrTemplateElementNonEncoded[0].outerHTML;
            arrTemplateElementEncoded[0].outerHTML = strID;
        } else {
            // append any sub templates to the "arrTemplateElementEncoded" and "arrTemplateElementNonEncoded"
            //      variables
            arrTemplateElementEncoded = arrTemplateElementEncoded
                                            .concat(xtag.query(arrTemplateElementEncoded[0].content, 'template'));
            arrTemplateElementNonEncoded = arrTemplateElementNonEncoded
                                                .concat(xtag.query(arrTemplateElementNonEncoded[0].content, 'template'));
            
            // append any column elements in this template to the "arrColumnElement" variable
            arrColumnElement = arrColumnElement.concat(xtag.query(arrTemplateElementEncoded[0].content, '[column]'));
        }
        
        // remove the current template from the arrays
        arrTemplateElementEncoded.splice(0, 1);
        arrTemplateElementNonEncoded.splice(0, 1);
        
        i += 1;
    }
    
    // go through element encoded and add calculated "value" attribute to any element with a "column"
    //      attribute but no "value" attribute
    arrColumnElement = arrColumnElement.concat(xtag.query(templateElementEncoded.content, '[column]'));
    
    for (i = 0, len = arrColumnElement.length; i < len; i += 1) {
        if (!arrColumnElement[i].hasAttribute('value')) {
            arrColumnElement[i].setAttribute('value', '{{! row.' + arrColumnElement[i].getAttribute('column') + ' }}');
        }
    }
    
    //console.log(templateHTML);
    //console.log(arrColumnElement);
    //console.log(jsnTemplates);
    //console.log(templateElementEncoded.innerHTML);
    
    // save element encoded innerHTML as template HTML
    templateHTML = templateElementEncoded.innerHTML;
    
    // go through template HTML and replace template tokens with template HTML
    for (strID in jsnTemplates) {
        //                                      DO NOT DELETE, this allows single dollar signs to be inside dot notation
        //                                                                                                V
        templateHTML = templateHTML.replace(new RegExp(strID, 'g'), jsnTemplates[strID].replace(/\$/g, '$$$$'));
    }
    
    //console.log(element.templateHTML);
    
    return templateHTML;
};


GS.templateWithQuerystring = function (templateText) {
    'use strict';
    var strWrapperTemplate = '{{##def.snippet:\n' +
                             '    {{ var qs = jo; }} {{# def.template }}\n' +
                             '#}}\n' +
                             '{{#def.snippet}}';
    
    return doT.template(strWrapperTemplate, null, {'template': templateText})(GS.qryToJSON(GS.getQueryString())).trim();
};


GS.templateHideSubTemplates = function (templateHTML, bolRecord) {
    'use strict';
    var templateElement, strID, arrTemplates, i, len, jsnTemplates, strRet, strStart, strEnd;
    
    if (bolRecord) {
        strStart = '<table><tbody>';
        strEnd = '</tbody></table>';
        templateHTML = (strStart + templateHTML + strEnd);
    }
    
    templateElement = document.createElement('template');
    templateElement.innerHTML = templateHTML;
    
    // temporarily remove templates
    // recursively go through templates whose parents do not have the source attribute
    i = 0;
    arrTemplates = xtag.query(templateElement.content, 'template');
    jsnTemplates = {};
    
    //console.log(arrTemplates.length);
    
    while (arrTemplates.length > 0 && i < 100) {
        //console.log(arrTemplates[0], arrTemplates[0].parentNode);
        // if the current template has a source parent: remove temporarily
        if (arrTemplates[0].parentNode &&
            arrTemplates[0].parentNode.hasAttribute && (arrTemplates[0].parentNode.hasAttribute('src') ||
                                                        arrTemplates[0].parentNode.hasAttribute('source'))) {
            strID = 'UNIqUE_PLaCEhOLDER-' + GS.GUID() + '-UNiQUE_PLaCEhOLdER';
            jsnTemplates[strID] = arrTemplates[0].outerHTML;
            arrTemplates[0].outerHTML = strID;
            
        // else: add to the arrTemplates array
        } else if (arrTemplates[0].content) {
            arrTemplates.push.apply(arrTemplates, xtag.query(arrTemplates[0].content, 'template'));
        }
        
        // remove the current template from the arrTemplates array
        arrTemplates.splice(0, 1);
        
        i += 1;
    }
    
    strRet = decodeHTML(templateElement.innerHTML);
    
    if (bolRecord) {
        strRet = strRet.substring(strStart.length, strRet.length - strEnd.length);
    }
    
    return {'templateHTML': strRet, 'templateData': jsnTemplates}
};

GS.templateShowSubTemplates = function (strRet, jsnTemplate) {
    'use strict';
    var strID;
    
    for (strID in jsnTemplate.templateData) {
        //                                       DO NOT DELETE, this allows single dollar signs to be inside dot notation
        //                                                                  V
        strRet = strRet.replace(new RegExp(strID, 'g'), jsnTemplate.templateData[strID].replace(/\$/g, '$$$$'));
    }
    
    return strRet;
};

GS.templateWithEnvelopeData = function (templateHTML, data, i, len, rowNumberOffset) {
    'use strict';
    return doT.template(ml(function () {/*
        {{##def.snippet:
            {{ var row, row_number, i, len, col_i, col_len
                 , qs = GS.qryToJSON(GS.getQueryString())
                 , rowNumberOffset = (jo.rowNumberOffset || 0);
            
            if (!isNaN(jo.i)) {
                i = jo.i;
                len = (jo.len === undefined || jo.len === null ? jo.i + 1 : jo.len);
                
            } else {
                i = 0;
                len = jo.data.dat.length;
            }
            
            for (; i < len; i += 1) {
                row = {};
                row_number = (i + 1) + rowNumberOffset;
                row.row_number = row_number;
                
                for (col_i = 0, col_len = jo.data.arr_column.length; col_i < col_len; col_i += 1) {
                    if (jo.data.dat[i][col_i] === undefined || jo.data.dat[i][col_i] === null) {
                        row[jo.data.arr_column[col_i]] = '';
                    } else {
                        row[jo.data.arr_column[col_i]] = jo.data.dat[i][col_i];
                    }
                } }}{{# def.record }}
            {{ } }}
        #}}
        {{#def.snippet}}*/console.log;
    }), null, {"record":  templateHTML})({ 'data': data, 'i': i, 'len': len, 'rowNumberOffset': rowNumberOffset });
};





window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('GS.userChangePassword', 'GS.userChangePassword', 'GS.userChangePassword();');
    //registerDesignSnippet('GS.superChangePassword', 'GS.superChangePassword', 'GS.superChangePassword();');
    //registerDesignSnippet('GS.superUserLogin', 'GS.superUserLogin', 'GS.superUserLogin(${0:loggedInCallback});');
    registerDesignSnippet('GS.normalUserLogin', 'GS.normalUserLogin', 'GS.normalUserLogin(${0:loggedInCallback});');
});

(function () {
    function changePassword(strLink, strRank) {
        var templateElement = document.createElement('template');
        
        templateElement.innerHTML = ml(function () {/*
            <gs-page>
                <gs-header><center><h3>Change {{RANK}} Password</h3></center></gs-header>
                <gs-body padded>
                    <div id="pword-error" style="color: #FF0000;"></div>
                    <label for="old-password">Old Password:</label>
                    <gs-text id="old-password" type="password"></gs-text>
                    <label for="new-password">New Password:</label>
                    <gs-text id="new-password" type="password"></gs-text>
                    <label for="new-password-confirm">Confirm New Password:</label>
                    <gs-text id="new-password-confirm" type="password"></gs-text>
                </gs-body>
                <gs-footer>
                    <gs-grid>
                        <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                        <gs-block><gs-button id="button-change-password" disabled>Change {{RANK}} Password</gs-button></gs-block>
                    </gs-grid>
                </gs-footer>
            </gs-page>
        */}).replace(/\{\{RANK\}\}/gim, strRank);
        
        GS.openDialog(templateElement, function () {
            var dialog = this, keydownHandler;
            
            keydownHandler = function (event) {
                var intKeyCode = event.which || event.keyCode;
                
                if (intKeyCode === 13 &&
                    document.getElementById('old-password').value &&
                    document.getElementById('new-password').value &&
                    document.getElementById('new-password-confirm').value) {
                    GS.triggerEvent(document.getElementById('button-change-password'), 'click');
                    
                } else {
                    if (document.getElementById('old-password').value &&
                        document.getElementById('new-password').value &&
                        document.getElementById('new-password-confirm').value) {
                        document.getElementById('button-change-password').removeAttribute('disabled');
                    } else {
                        document.getElementById('button-change-password').setAttribute('disabled');
                    }
                }
            };
            
            document.getElementById('old-password').addEventListener('keydown', keydownHandler);
            document.getElementById('new-password').addEventListener('keydown', keydownHandler);
            document.getElementById('new-password-confirm').addEventListener('keydown', keydownHandler);
            
            document.getElementById('button-change-password').addEventListener('click', function () {
                var newPassword, parameters;
                
                if (document.getElementById('new-password').value === document.getElementById('new-password-confirm').value) {
                    parameters = 'action=change_pw' +
                                '&password_old=' + encodeURIComponent(document.getElementById('old-password').value) +
                                '&password_new=' + encodeURIComponent(document.getElementById('new-password').value);
                    
                    document.getElementById('old-password').value = '';
                    document.getElementById('new-password').value = '';
                    document.getElementById('new-password-confirm').value = '';
                    
                    GS.ajaxJSON(
                        location.pathname.indexOf('/env/') === 0 ? 
                        '/env/auth' : '/postage/auth', parameters, function (data, error) {
                        if (!error) {
                            GS.pushMessage('Password Successfully Changed', 1000);
                            GS.closeDialog(dialog, 'change');
                        } else {
                            document.getElementById('pword-error').textContent = data.error_text;
                        }
                    });
                } else {
                    document.getElementById('pword-error').textContent = 'New Password Doesn\'t Match Confirm New Password.';
                }
            });
        });
    }
    
    GS.userChangePassword = function () {
        changePassword('env', 'User');
    };
    
    //GS.superChangePassword = function () {
    //    changePassword('postage', 'SUPERUSER');
    //};
})();

// check if the user is logged in as a normal user
// if there is no login dialog create it then open it
GS.normalUserLogin = function (loggedInCallback, strOldError, strDefaultSubDomain) {
    'use strict';
    GS.removeAllLoaders();
    
    if (!window.userLogin) {
        window.userLogin = true;
        
        // this action checks to see if we are logged in as a super user
        // if not, open a login dialog
        GS.ajaxJSON('/env/action_info', '', function (data, error) {
            var templateElement = document.createElement('template');
            
            if (!error && data.dat) {
                if (typeof loggedInCallback === 'function') {
                    loggedInCallback(data.dat, strDefaultSubDomain);
                }
            } else {
                templateElement.innerHTML = ml(function () {/*
                    <gs-page>
                        <gs-header><center><h3>Login</h3></center></gs-header>
                        <gs-body padded>
                            You are not currently logged in, please fill in the login form below.<br /><br />
                            <label for="normal-uname">Username:</label>
                            <gs-text id="normal-uname" autocapitalize="off" autocomplete="off" autocorrect="off"></gs-text>
                            <label for="normal-pword">Password:</label>
                            <gs-text id="normal-pword" type="password"></gs-text>
                            {{ERROR}}
                        </gs-body>
                        <gs-footer>
                            <gs-grid>
                                <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                                <gs-block><gs-button id="normal-login">Log In</gs-button></gs-block>
                            </gs-grid>
                        </gs-footer>
                    </gs-page>
                */}).replace('{{ERROR}}', (strOldError ? '<br /><div style="color: #FF0000">' + strOldError + '</div>' : ''));
                
                if (GS.getCookie('greyspots_uname')) {
                    xtag.query(templateElement.content, '#normal-uname')[0].setAttribute('value', decodeURIComponent(GS.getCookie('greyspots_uname')));
                    xtag.query(templateElement.content, '#normal-pword')[0].setAttribute('autofocus', '');
                } else {
                    xtag.query(templateElement.content, '#normal-uname')[0].setAttribute('autofocus', '');
                }
                
                GS.openDialog(templateElement, function () {
                    var dialog = this;
                    
                    document.getElementById('normal-pword').addEventListener('keydown', function (event) {
                        var intKeyCode = event.which || event.keyCode;
                        
                        if (intKeyCode === 13) {
                            GS.triggerEvent(document.getElementById('normal-login'), 'click');
                        }
                        //if (this.value) {
                        //    document.getElementById('normal-login').removeAttribute('disabled');
                        //} else {
                        //    document.getElementById('normal-login').setAttribute('disabled', '');
                        //}
                    });
                    
                    //document.getElementById('normal-pword').addEventListener('keyup', function () {
                    //    if (this.value) {
                    //        document.getElementById('normal-login').removeAttribute('disabled');
                    //    } else {
                    //        document.getElementById('normal-login').setAttribute('disabled', '');
                    //    }
                    //});
                    
                    document.getElementById('normal-login').addEventListener('click', function () {
                        var strUserName = document.getElementById('normal-uname').value, strLink;
                        
                        if (document.getElementById('normal-pword').value) {
                            GS.addLoader('log-in', 'Logging In...');
                            
                            GS.ajaxJSON('/env/auth', 'action=login' +
                                                       '&username=' + encodeURIComponent(document.getElementById('normal-uname').value) +
                                                       '&password=' + encodeURIComponent(document.getElementById('normal-pword').value),
                                                       function (data, error) {
                                GS.removeLoader('log-in');
                                GS.closeDialog(dialog, '');
                                window.userLogin = false;
                                
                                if (!error) {
                                    GS.setCookie('greyspots_uname', strUserName, 30);
                                    
                                    if (typeof loggedInCallback === 'function') {
                                        if (window.location.hostname.substring(0, window.location.hostname.indexOf('.')) ===
                                                        strDefaultSubDomain) {
                                            GS.normalUserLogin(loggedInCallback, '', strDefaultSubDomain);
                                        } else {
                                            loggedInCallback(data.dat, strDefaultSubDomain);
                                        }
                                    }
                                    
                                } else {
                                    GS.normalUserLogin(loggedInCallback, data.error_text, strDefaultSubDomain);
                                }
                            });
                        }
                    });
                });
            }
        });
    }
};
//jslint white:true

(function () {
    'use strict';
    
    // encodeForTabDelimited('asdf\\asdf\\asdf\r\nasdf\r\nasdf\tasdf\tasdf')
    function encodeForTabDelimited(strValue) {
        return  strValue === '\\N' ? strValue :
                strValue.replace(/\\/g, '\\\\') // double up backslashes
                        .replace(/\n/g, '\\n')  // replace newline with the text representation '\n'
                        .replace(/\r/g, '\\r')  // replace carriage return with the text representation '\r'
                        .replace(/\t/g, '\\t')  // replace tab with the text representation '\t'
                        .replace(/^NULL$/g, '\\N');
    }
    
    GS.bolPreventErrors = false;
    function webSocketConnectionErrorDialog(socket, addinText, retryCallback, cancelCallback) {
        
        if (!document.getElementById('dialog-from-dialog-ws-conn-error') && GS.bolPreventErrors === false) {
            var templateElement = document.createElement('template');
            
            GS.removeAllLoaders();
            
            templateElement.setAttribute('id', 'dialog-ws-conn-error');
            templateElement.setAttribute('data-theme', 'error');
            templateElement.innerHTML = ml(function () {/*
                <gs-page>
                    <gs-header><center><h3>There was an error!</h3></center></gs-header>
                    <gs-body padded>
                        <pre style="white-space: pre-wrap;">
    There has been an error with the Database connection.{{ADDIN}}</pre>
                    </gs-body>
                    <gs-footer>
                        <gs-grid gutter reflow-at="420">
                            <gs-block><gs-button dialogclose>Try to reconnect</gs-button></gs-block>
                            <gs-block><gs-button dialogclose>Dismiss so I can copy my progress</gs-button></gs-block>
                        </gs-grid>
                    </gs-footer>
                </gs-page>
            */}).replace('{{ADDIN}}', (addinText ? '\n\n' + addinText : ''));
            
            GS.openDialog(templateElement, '', function (event, strAnswer) {
                if (strAnswer === 'Try to reconnect') {
                    GS.closeSocket(GS.envSocket);
                    GS.envSocket = GS.openSocket('env', socket.GSSessionID, socket.notifications);
                } else {
                    GS.bolPreventErrors = true;
                }
            });
        }
    }
    
    function webSocketNormalizeError(event) {
        var i, len, arrLines, arrLine, strData,
            jsnRet = {
                'error_title': '',
                'error_text': '',
                'error_detail': '',
                'error_hint': '',
                'error_query': '',
                'error_context': '',
                'error_position': '',
                'error_notice': '',
                'original_data': event
            };
        
        event = event || {};
        
        jsnRet.error_text = event.reason || '';
        
        // if there is message data: parse it
        if (event.data) {
            strData = event.data;
            
            // strip out messageid
            if (strData.substring(0, strData.indexOf(' ')) === 'messageid') {
                strData = strData.substring(strData.indexOf('\n') + 1);
            }
            
            // strip out response number
            if (strData.substring(0, strData.indexOf(' ')) === 'responsenumber') {
                strData = strData.substring(strData.indexOf('\n') + 1);
            }
            
            // strip out fatal
            if (strData.indexOf('FATAL\n') === 0) {
                strData = strData.substring(strData.indexOf('\n') + 1);
            }
            
            // strip out "Query failed: "
            if (strData.indexOf('Query failed: ') === 0) {
                strData = strData.substring('Query failed: '.length);
            }
            
            // save error text in case we dont find any error part labels
            jsnRet.error_text = strData;
            
            // trim and split on return for parsing
            arrLines = strData.trim().split('\n');
            
            for (i = 0, len = arrLines.length; i < len; i += 1) {
                arrLine = arrLines[i].split('\t');
                
                jsnRet[arrLine[0]] = GS.decodeFromTabDelimited(arrLine[1] || '');
            }
        }
        
        // get error title and error hint
        if (event.code === 1001) {
            jsnRet.error_title = 'Going Away';
            jsnRet.error_hint = 'The server or client closed the connection because of server shutdown or navigating away from the page.';
            
        } else if (event.code === 1002) {
            jsnRet.error_title = 'Protocol';
            jsnRet.error_hint = 'The connection was closed because of error related to the protocol used.';
            
        } else if (event.code === 1003) {
            jsnRet.error_title = 'Unsupported Data';
            jsnRet.error_hint = 'The connection was closed because the data that was received was not it a supported format.';
            
        } else if (event.code === 1005) {
            jsnRet.error_title = 'No Status Received';
            jsnRet.error_hint = 'The connection was closed because it received an empty status.';
            
        } else if (event.code === 1006) {
            jsnRet.error_title = 'Abnormal Closure';
            jsnRet.error_hint = 'The connection was closed because of abnormal circumstances.';
            
        } else if (event.code === 1007) {
            jsnRet.error_title = 'Invalid Payload Data';
            jsnRet.error_hint = 'The connection was closed because the payload type did not match the defined message type.';
            
        } else if (event.code === 1008) {
            jsnRet.error_title = 'Policy Violation';
            jsnRet.error_hint = 'The connection was closed because policy governing this connection was violated.';
            
        } else if (event.code === 1009) {
            jsnRet.error_title = 'Message Too Big';
            jsnRet.error_hint = 'The connection was closed because the message was too long for it to proccess.';
            
        } else if (event.code === 1010) {
            jsnRet.error_title = 'Mandatory Extension';
            jsnRet.error_hint = 'The client closed the connection because the server was supposed to negotiate extension(s) but it did not.';
            
        } else if (event.code === 1011) {
            jsnRet.error_title = 'Internal Server';
            jsnRet.error_hint = 'The server closed the connection because it could not fulfill the request.';
            
        } else if (event.code === 1015) {
            jsnRet.error_title = 'TLS handshake';
            jsnRet.error_hint = 'The connection was closed because the handshake failed.';
        }
        
        //console.log(jsnRet);
        
        return jsnRet;
    }
    
    function cleanErrorValue(strValue) {
        strValue = strValue || '';
        
        if (strValue.indexOf('DB_exec failed:') !== -1) {
            strValue = strValue.replace(/[.\s\S]*DB_exec\ failed:/mi, '');
        }
        
        if (strValue.indexOf('Query failed:') !== -1) {
            strValue = strValue.replace(/[.\s\S]*Query\ failed:/mi, '');
        }
        
        if (strValue.indexOf('FATAL') !== -1) {
            strValue = strValue.replace(/[.\s\S]*FATAL/mi, '');
        }
        
        strValue = strValue
                        .replace(/\\n/gi, '\n')
                        .replace(/\\t/gi, '\t')
                        .replace(/\[.*\]/gi, '')
                        .replace(/\([0-9]*\)/gi, '');
        
        return GS.trim(strValue.trim(), '"');
    }
    
    function errorJSONToHTML(errorJSON) {
        return '<pre style="word-break: break-all; white-space: pre-wrap;">' +
                    (errorJSON.error_title ?
                        'There was ' +
                            (
                                ['A', 'E', 'I', 'O', 'U']
                                    .indexOf(errorJSON.error_title[0].toUpperCase()) === -1
                                        ? 'a'
                                        : 'an'
                            ) +
                            ' "' + encodeHTML(errorJSON.error_title) + '" error:' :
                        'There was an error:') +
                        (
                            !errorJSON.error_hint &&
                            !errorJSON.error_query &&
                            !errorJSON.error_context &&
                            !errorJSON.error_notice
                                ? '<br /><br />' + encodeHTML(errorJSON.error_text)
                                : ''
                        ) +
                        (errorJSON.error_hint     ? '<br /><br />HINT: ' + encodeHTML(errorJSON.error_hint) : '') +
                      //(errorJSON.error_detail   ? '<br /><br />DETAIL: ' + encodeHTML(errorJSON.error_detail) : '') +
                        (errorJSON.error_query    ? '<br /><br />QUERY: ' + encodeHTML(errorJSON.error_query) : '') +
                        (errorJSON.error_position ? '<br /><br />ERROR POSITION: ' + encodeHTML(errorJSON.error_position) : '') +
                        (errorJSON.error_context  ? '<br /><br />CONTEXT: ' + encodeHTML(errorJSON.error_context) : '') +
                        (errorJSON.error_notice   ? '<br /><br /><br />' + encodeHTML(errorJSON.error_notice) : '') +
                '</pre>';
    }
    
    GS.webSocketErrorDialog = function (jsnError, tryAgainCallback, cancelCallback) {
        if (GS.bolPreventErrors === false) {
            var templateElement = document.createElement('template'), strHTML, jsnErrorClean;
            
            jsnErrorClean = {};
            
            jsnErrorClean.error_text     = cleanErrorValue(jsnError.error_text);
            jsnErrorClean.error_hint     = cleanErrorValue(jsnError.error_hint);
            jsnErrorClean.error_detail   = cleanErrorValue(jsnError.error_detail);
            jsnErrorClean.error_query    = cleanErrorValue(jsnError.error_query);
            jsnErrorClean.error_position = cleanErrorValue(jsnError.error_position);
            jsnErrorClean.error_context  = cleanErrorValue(jsnError.error_context);
            jsnErrorClean.error_notice   = cleanErrorValue(jsnError.error_notice);
            
            templateElement.setAttribute('data-theme', 'error');
            strHTML = ml(function () {/*
                <gs-page>
                    <gs-header><center><h3>There was an error!</h3></center></gs-header>
                    <gs-body padded>
                        {{HTML}}
                        <br />
                        <gs-button class="error-button-show-full-text">Show Full Error Text</gs-button>
                    </gs-body>
                    <gs-footer>{{BUTTONS}}</gs-footer>
                </gs-page>
            */}).replace('{{HTML}}', errorJSONToHTML(jsnErrorClean));
            
            var openFunction = function () {
                xtag.query(this, '.error-button-show-full-text')[0].addEventListener('click', function () {
                    var templateElement = document.createElement('template');
                    
                    templateElement.innerHTML = ml(function () {/*
                        <gs-page>
                            <gs-header><center><h3>Full Error Text</h3></center></gs-header>
                            <gs-body padded>
                                {{HTML}}
                            </gs-body>
                            <gs-footer><gs-button dialogclose>Done</gs-button></gs-footer>
                        </gs-page>
                    */}).replace('{{HTML}}', errorJSONToHTML(jsnError));
                    
                    GS.openDialog(templateElement);
                });
            };
            
            if (typeof tryAgainCallback === 'function') {
                templateElement.innerHTML =
                    strHTML.replace(
                        '{{BUTTONS}}',
                        '<gs-grid>' +
                        '    <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>' +
                        '    <gs-block><gs-button dialogclose listen-for-return>Try Again</gs-button></gs-block>' +
                        '</gs-grid>'
                    );
                
                GS.openDialog(templateElement, openFunction, function (event, strAnswer) {
                    if (strAnswer === 'Try Again') {
                        tryAgainCallback(strAnswer);
                    } else {
                        if (typeof cancelCallback === 'function') {
                            cancelCallback(strAnswer);
                        }
                    }
                });
                
            } else {
                templateElement.innerHTML = strHTML.replace('{{BUTTONS}}', '<gs-button dialogclose listen-for-return>Ok</gs-button>');
                GS.openDialog(templateElement, openFunction);
            }
        }
    };
    
    GS.websockets = new Array();

    GS.closeAllSockets = function () {
        var i, len = GS.websockets.length;
        for (i = 0;i < len;i++) {
            GS.closeSocket(GS.websockets[i]);
        }
    };
    
    var sequence = 0, jsnMessages = {}, arrWaitingCalls = [];
    GS.openSocket = function (strLink, relinkSessionID, relinkSessionNotifications) {
        var strLoc = window.location.toString(),
            intUrlStart = strLoc.indexOf('/postage/') + 9,
            strConn = strLoc.substring(intUrlStart, strLoc.substring(intUrlStart).indexOf('/') + intUrlStart);
        var socket = new WebSocket(
                            (window.location.protocol.toLowerCase().indexOf('https') === 0 ? 'wss' : 'ws') +
                            '://' + (window.location.host || window.location.hostname) + '/postage/' + strConn + '/' + strLink +
                            (relinkSessionID ? '?sessionid=' + relinkSessionID : '')); //nunzio.wfprod.com
        
        GS.websockets.push(socket);
        
        if (relinkSessionID) {
            socket.GSSessionID = relinkSessionID;
            socket.oldSessionID = relinkSessionID;
        }
        if (relinkSessionNotifications) {
            socket.notifications = relinkSessionNotifications;
        } else {
            socket.notifications = [];
        }
        socket.onmessage = function (event) {
            var message = event.data, messageID, responseNumber, key, strError, arrLines, i, len, jsnMessage, startFrom;
            
            if (typeof (message) === 'object') {
                //window.binaryTestTEST = message;
                //console.log(message);
                var buf = message;
                message = String.fromCharCode.apply(null, new Uint8Array(buf));
                //console.log(buf);
                //console.log(message);
            }
            
            // if sessionid
            if (message.indexOf('sessionid = ') === 0) {
                socket.GSSessionID = message.substring('sessionid = '.length, message.indexOf('\n'));
                GS.triggerEvent(window, 'socket-connect');
                
                for (key in jsnMessages) {
                    jsnMessage = jsnMessages[key];
                    
                    if ((
                            jsnMessage.session === socket.GSSessionID ||
                            jsnMessage.session === socket.oldSessionID
                        ) && jsnMessage.bolFinished === false) {
                        
                        jsnMessage.session = socket.GSSessionID;
                        
                        startFrom = 1;
                        for (i = 0, len = jsnMessage.arrResponseNumbers.length; i < len; i += 1) {
                            // if there is a difference between the current response number and the
                            //      startFrom: stop looping because startFrom now holds the number that we want
                            if (startFrom !== jsnMessage.arrResponseNumbers[i]) {
                                break;
                            }
                            startFrom += 1;
                        }
                        
                        GS.requestFromSocket(socket, 'SEND FROM\t' + startFrom, '', jsnMessage.id);
                    }
                }
                
                for (i = 0, len = arrWaitingCalls.length; i < len; i += 1) {
                    arrWaitingCalls[0]();
                    arrWaitingCalls.splice(0, 1);
                }
                
            // else
            } else {
                messageID = message.substring('messageid = '.length, message.indexOf('\n'));
                message = message.substring(message.indexOf('\n') + 1);
                
                jsnMessage = jsnMessages[messageID];
                
                // if there is a message entry for this message ID
                if (jsnMessage) {
                    arrLines = message.split('\n');
                    
                    // if there is no response number: assume this is the last message and mark the message as finished
                    if (message.indexOf('responsenumber = ') === -1 ||
                        (
                            message.indexOf('responsenumber = ') === 0 &&
                            (
                                arrLines[1] === 'TRANSACTION COMPLETED' ||
                                arrLines[2] === 'OK'
                            )
                        )) {
                        jsnMessage.bolFinished = true;
                    }
                    
                    // if there is a response number
                    if (message.indexOf('responsenumber = ') === 0) {
                        // get message number
                        responseNumber = message.substring('responsenumber = '.length, message.indexOf('\n'));
                        message = message.substring(message.indexOf('\n') + 1);
                        
                        // append message number and message content to arrays
                        jsnMessage.arrResponseNumbers.push(parseInt(responseNumber, 10));
                        jsnMessage.arrResponses.push(message);
                        
                        // send confirm signal
                        GS.requestFromSocket(socket, 'CONFIRM\t' + responseNumber, '', messageID);
                    }
                    
                    // ERROR CHECK
                    arrLines = message.split('\n');
                    
                    // if there is a transactionid: look at the second line
                    if (arrLines[0].indexOf('transactionid') === 0 && arrLines[1] === 'FATAL') {
                        strError = 'error';
                        message = message.substring(message.indexOf('\n') + 1);
                        message = message.substring(message.indexOf('\n') + 1);
                        message = arrLines[0] + '\n' + message;
                        
                    // else: check the first line
                    } else if (arrLines[0] === 'FATAL') {
                        strError = 'error';
                        message = message.substring(message.indexOf('\n') + 1);
                    }
                    
                    // if transaction complete: clear message arrays and mark as finised
                    if (message === 'TRANSACTION COMPLETED') { // || message === 'EMPTY\n\\.'
                        jsnMessage.arrResponseNumbers = [];
                        jsnMessage.arrResponses = [];
                        jsnMessage.bolFinished = true;
                    }
                    
                    // if there was a FATAL: mark as finished and apply callback
                    if (strError) {
                        jsnMessage.bolFinished = true;
                        jsnMessage.callback.apply(null, [message, strError, webSocketNormalizeError(event)]);
                        
                    // else: call callback with message
                    } else {
                        jsnMessage.callback.apply(null, [message]);
                    }
                    
                // else if the messageID is 'NULL': notification from the server
                } else if (messageID === 'NULL') {
                    socket.notifications.push(message);
                    GS.triggerEvent(window, 'notification', {'socket': socket, 'message': message});
                }
            }
        };
        
        socket.onopen = function (event) {
            
        };
        
        socket.onerror = function (event) {
            var i, len;
            
            console.log('SOCKET ERROR', event);
            socket.bolError = true;
            //socket.stayClosed = true;
            
            //for (i = 0, len = arrWaitingCalls.length; i < len; i += 1) {
            //    arrWaitingCalls[0]();
            //    arrWaitingCalls.splice(0, 1);
            //}
        };
        
        socket.onclose = function (event) {
            console.log('SOCKET CLOSING', socket.stayClosed, socket.bolError, event);
            
            // error closure dialog
            if (socket.bolError && arrWaitingCalls.length > 0) {
                // abnormal closure
                if (event.code === 1006) {
                    webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. We cannot display the reasons for this closure because the browser does not give us access to those details, please check the server logs for the error details.');
                    
                // protocol error
                } else if (event.code === 1002) {
                    webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. Either the server or the browser has closed the connection because of a Websocket Protocol error.');
                    
                // type error
                } else if (event.code === 1003) {
                    webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. Either the server or the browser has closed the connection because of it was sent a data type it could not understand.');
                } else {
                    webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. The cause of this is unknown.');
                }
            }
            
            if (!socket.stayClosed) {
                setTimeout(function() {
                    console.log('ATTEMPTING SOCKET RE-OPEN', socket);
                    GS.triggerEvent(window, 'socket-reconnect');
                    GS.closeSocket(GS.envSocket);
                    GS.envSocket = GS.openSocket('env', GS.envSocket.GSSessionID, GS.envSocket.notifications);
                }, 1000);
            } else {
                if (socket.bolError) {
                    console.log('SOCKET NOT RE-OPENING DUE TO ERROR');
                } else {
                    console.log('SOCKET NOT RE-OPENING DUE TO MANUAL CLOSE');
                }
            }
        };
        
        return socket;
    };
    
    GS.requestFromSocket = function (socket, strMessage, callback, forceMessageID) {
        var oldOnOpen, messageID;
        
        if (!socket || socket.readyState === socket.CLOSED) {
            if (!GS.envSocket || GS.envSocket.readyState === socket.CLOSED) {
                //console.trace('ATTEMPTING SOCKET RE-OPEN 2');
                GS.envSocket = GS.openSocket('env');
            }
            socket = GS.envSocket;
        }
        
        // if the socket is open: register callback and send request
        if (socket.readyState === socket.OPEN && socket.GSSessionID) {
            
            if (!forceMessageID) {
                sequence += 1;
                messageID = socket.GSSessionID + '_' + sequence;
                jsnMessages[messageID] = {
                    'id': messageID,
                    'session': socket.GSSessionID,
                    'callback': callback,
                    'arrResponseNumbers': [],
                    'arrResponses': [],
                    'bolFinished': false
                };
                
            } else {
                messageID = forceMessageID;
            }
            
            if (typeof (strMessage) === 'object') {
                jsnMessages[messageID].parameters = new Blob(['messageid = ' + messageID + '\n', strMessage], {type: 'application/x-binary'});
            } else {
                jsnMessages[messageID].parameters = 'messageid = ' + messageID + '\n' + strMessage;
            }
            socket.send(jsnMessages[messageID].parameters);
            //console.log('SOCKET MESSAGE SENT                   ', 'messageid = ' + sequence);// + '\n' + strMessage);
            
            return messageID;
            
        // if the socket is connecting: bind socket onopen to call this funtion again
        } else if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
            //console.log('SOCKET REQUEST WHILE CONNECTING       ');
            
            arrWaitingCalls.push(function () {
                GS.requestFromSocket(socket, strMessage, callback);
            });
            
        // if the socket is closed: error
        } else if (socket.readyState === socket.CLOSED) {
            //console.log('SOCKET REQUEST WHILE CLOSED           ');
            callback.apply(null, ['Socket Is Closed', 'error', webSocketNormalizeError({'reason': 'Socket Is Closed'})]);
            
        // if the socket is closing: error
        } else if (socket.readyState === socket.CLOSING) {
            //console.log('SOCKET REQUEST WHILE CLOSING          ');
            callback.apply(null, ['Socket Is Closing', 'error', webSocketNormalizeError({'reason': 'Socket Is Closing'})]);
        }
    };
    
    
    GS.requestActionFromSocket = function (socket, strSchema, strObject, strArgs, finalCallback) {
        var strMessage = 'ACTION\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                            '\t' + encodeForTabDelimited(strArgs) + '\n',
            intResponse = 0, strRet;
        
        //console.log(strMessage);
        
        GS.requestFromSocket(socket, strMessage, function (data, error, errorData) {
            var arrLines, i, len;
            if (!error) {
                if (intResponse === 0) {
                    strRet = data;
                    
                } else {
                    finalCallback(strRet, error);
                }
                
            } else {
                finalCallback(errorData, error);
            }
            intResponse += 1;
        });
    };
    
    // abstraction function for ease of use of the RAW format
    GS.requestRawFromSocket = function (socket, strQuery, callback, bolAutocommit) {
        var intResponsePart = 0, intQueryNumber = 0, intCallbackNumber = 0, intCallbackNumberThisQuery = 0
          , intResponseNumberThisQuery = 0, arrMessages, arrColumnNames, arrColumnTypes
          , arrStart, dteStart, arrEnd, dteEnd, intRows;
        
        return GS.requestFromSocket(socket, 'RAW' + (bolAutocommit ? '\tAUTOCOMMIT\n' : '\n') + strQuery, function (data, error, errorData) {
            var arrRecords, arrLines, i, len, strMode;
            
            if (!error) {
                if (intResponseNumberThisQuery === 0) {
                    // clear variables
                    strQuery = '';
                    arrMessages = [];
                    arrColumnNames = [];
                    arrColumnTypes = [];
                }
                
                // if QUERY is found: reset response part to 0
                if (data.indexOf('QUERY\n') === 0) {
                    //console.log('Per Query Reset');
                    intResponsePart = 0;
                    intCallbackNumberThisQuery = 0;
                }
                
                // if first line is 'Rows Affected': add one to intResponsePart
                if (data.indexOf('Rows Affected\n') === 0 || data === 'EMPTY' || data === 'TRANSACTION COMPLETED') {
                    intResponsePart += 1;
                }
                
                //console.log('1***', data);
                //console.log(intResponsePart, data);
                
                // response part 0 is:
                //      strQuery
                //      arrMessages
                //      arrColumnNames
                //      arrColumnTypes
                if (intResponsePart === 0) {
                    //console.log('2***');
                    // split lines
                    arrLines = data.split('\n');
                    
                    // loop through lines
                    for (i = 0, len = arrLines.length; i < len; i += 1) {
                        // if mode line: set mode
                        if (arrLines[i].indexOf('QUERY\t') === 0 ||
                            arrLines[i].indexOf('START\t') === 0 ||
                            arrLines[i].indexOf('END\t') === 0 ||
                            arrLines[i].indexOf('ROWS\t') === 0 ||
                            arrLines[i].indexOf('DEBUG\t') === 0 ||
                            arrLines[i].indexOf('LOG\t') === 0 ||
                            arrLines[i].indexOf('INFO\t') === 0 ||
                            arrLines[i].indexOf('NOTICE\t') === 0 ||
                            arrLines[i].indexOf('WARNING\t') === 0 ||
                            arrLines[i] === 'COLUMNS') {
                            
                            if (arrLines[i] === 'COLUMNS') {
                                strMode = arrLines[i];
                            } else {
                                strMode = arrLines[i].substring(0, arrLines[i].indexOf('\t'));
                            }
                        }
                        
                        //console.log(strMode, arrLines[i]);
                        
                        // if mode is QUERY: save query
                        if (strMode === 'QUERY') {
                            strQuery = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1));
                            //console.log(arrLines[i], strQuery);
                            
                        // if mode is START: save start
                        } else if (strMode === 'START') {
                            arrStart = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1)).split('\t');
                            dteStart = new Date(arrStart[0] + ' ' + arrStart[1] + ' GMT');
                            if (arrStart[2]) {
                                dteStart.setMilliseconds(parseInt(arrStart[2], 10) / 1000);
                            }
                            //console.log(strStart, dteStart);
                            
                        // if mode is END: save end
                        } else if (strMode === 'END') {
                            arrEnd = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1)).split('\t');
                            dteEnd = new Date(arrEnd[0] + ' ' + arrEnd[1] + ' GMT');
                            if (arrEnd[2]) {
                                dteEnd.setMilliseconds(parseInt(arrEnd[2], 10) / 1000);
                            }
                            //console.log(strEnd, dteEnd);
                            
                        // if mode is ROWS: save total rows
                        } else if (strMode === 'ROWS') {
                            intRows = parseInt(GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1)), 10);
                            
                        // if mode is DEBUG: add DEBUG to array
                        } else if (strMode === 'DEBUG') {
                            arrMessages.push({
                                'level': 'DEBUG',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });
                            
                        // if mode is LOG: add LOG to array
                        } else if (strMode === 'LOG') {
                            arrMessages.push({
                                'level': 'LOG',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });
                            
                        // if mode is INFO: add INFO to array
                        } else if (strMode === 'INFO') {
                            arrMessages.push({
                                'level': 'INFO',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });
                            
                        // if mode is NOTICE: add NOTICE to array
                        } else if (strMode === 'NOTICE') {
                            arrMessages.push({
                                'level': 'NOTICE',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });
                            
                        // if mode is WARNING: add WARNING to array
                        } else if (strMode === 'WARNING') {
                            arrMessages.push({
                                'level': 'WARNING',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });
                            
                        // if mode is COLUMNS: get COLUMNS
                        } else if (strMode === 'COLUMNS') {
                            arrColumnNames = arrLines[i + 1].split('\t');
                            arrColumnTypes = arrLines[i + 2].split('\t');
                            intResponsePart += 1;
                            break;
                        }
                    }
                    
                } else if (intResponsePart >= 1) {
                    //console.log(intQueryNumber, intCallbackNumber, intCallbackNumberThisQuery,
                    //            strQuery, arrMessages, arrColumnNames, arrColumnTypes, data);
                    //console.log('3***');
                    if (typeof callback === 'function') {
                        //console.log('4*** CALLBACK');
                        callback({
                            'intQueryNumber': intQueryNumber,
                            'intCallbackNumber': intCallbackNumber,
                            'intCallbackNumberThisQuery': intCallbackNumberThisQuery,
                            'strQuery': strQuery,
                            'dteStart': dteStart,
                            'dteEnd': dteEnd,
                            'intRows': intRows,
                            'arrMessages': arrMessages,
                            'arrColumnNames': arrColumnNames,
                            'arrColumnTypes': arrColumnTypes,
                            'strMessage': (data !== 'TRANSACTION COMPLETED' ? data : ''),
                            'bolLastMessage': (data === 'TRANSACTION COMPLETED')
                        }, error);
                        
                        intCallbackNumber += 1;
                        intCallbackNumberThisQuery += 1;
                    }
                }
                
                intResponseNumberThisQuery += 1;
                
                if (data === '\\.' || data.indexOf('Rows Affected\n') === 0) {
                    intQueryNumber += 1;
                    intCallbackNumberThisQuery = 0;
                    intResponsePart = 0;
                    intResponseNumberThisQuery = 0;
                }
                
            } else {
                // if QUERY is found: reset response part to 0
                if (data.indexOf('QUERY\n') === 0) {
                    //console.log('Per Query Reset');
                    intResponsePart = 0;
                    intCallbackNumberThisQuery = 0;
                }
                
                if (intResponsePart === 0) {
                    //console.log('2***');
                    // split lines
                    arrLines = data.split('\n');
                    
                    // loop through lines
                    for (i = 0, len = arrLines.length; i < len; i += 1) {
                        // if mode line: set mode
                        if (arrLines[i].indexOf('QUERY\t') === 0 ||
                            arrLines[i].indexOf('START\t') === 0 ||
                            arrLines[i].indexOf('END\t') === 0 ||
                            arrLines[i].indexOf('ROWS\t') === 0 ||
                            arrLines[i].indexOf('DEBUG\t') === 0 ||
                            arrLines[i].indexOf('LOG\t') === 0 ||
                            arrLines[i].indexOf('INFO\t') === 0 ||
                            arrLines[i].indexOf('NOTICE\t') === 0 ||
                            arrLines[i].indexOf('WARNING\t') === 0 ||
                            arrLines[i] === 'COLUMNS') {
                            
                            if (arrLines[i] === 'COLUMNS') {
                                strMode = arrLines[i];
                            } else {
                                strMode = arrLines[i].substring(0, arrLines[i].indexOf('\t'));
                            }
                        }
                        
                        //console.log(strMode, arrLines[i]);
                        
                        // if mode is QUERY: save query
                        if (strMode === 'QUERY') {
                            strQuery = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1));
                            //console.log(arrLines[i], strQuery);
                            
                        // if mode is COLUMNS: get COLUMNS
                        } else if (strMode === 'COLUMNS') {
                            break;
                        }
                    }
                }
                
                errorData.strQuery = strQuery;
                errorData.arrMessages = arrMessages
                if (typeof callback === 'function') {
                    callback(errorData, error);
                }
            }
        });
    };
    
    GS.requestSelectFromSocket = function (socket, strSchema, strObject, strReturnCols, strWhere, strOrd, strLimit, strOffset, finalCallback) {
        var strMessage = 'SELECT\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                            '\nRETURN\t' + strReturnCols + '\n\n' +
                            'where\t' + (strOrd ? 'order by\t' : '') + 'limit\toffset\n' +
                            encodeForTabDelimited(strWhere || '1=1') + '\t' + (strOrd ? encodeForTabDelimited(strOrd) + '\t' : '') +
                            encodeForTabDelimited(strLimit || 'ALL') + '\t' + encodeForTabDelimited(strOffset || '0'),
            intResponse = 0, intCallback = 0, arrColumnNames, arrColumnTypes, arrDecodedColumnNames, arrDecodedColumnTypes;
        
        //console.log(strMessage);
        
        GS.requestFromSocket(socket, strMessage, function (data, error, errorData) {
            var arrLines, i, len;
            if (!error) {
                if (intResponse === 0) {
                    arrLines = data.split('\n');
                    arrColumnNames = arrLines[0].split('\t');
                    arrColumnTypes = arrLines[1].split('\t');
                    arrDecodedColumnNames = [];
                    arrDecodedColumnTypes = [];
                    
                    for (i = 0, len = arrColumnNames.length; i < len; i += 1) {
                        arrDecodedColumnNames.push(GS.decodeFromTabDelimited(arrColumnNames[i]));
                    }
                    
                    for (i = 0, len = arrColumnTypes.length; i < len; i += 1) {
                        arrDecodedColumnTypes.push(GS.decodeFromTabDelimited(arrColumnTypes[i]));
                    }
                    
                } else {
                    finalCallback({
                        'arrColumnNames': arrColumnNames,
                        'arrColumnTypes': arrColumnTypes,
                        'arrDecodedColumnNames': arrDecodedColumnNames,
                        'arrDecodedColumnTypes': arrDecodedColumnTypes,
                        'intCallback': intCallback,
                        'strMessage': data
                    }, error);
                    intCallback += 1;
                }
                
            } else {
                finalCallback(errorData, error);
            }
            intResponse += 1;
        });
    };
    
    
    /*
        INSERT	test	rmultiple_pk_test
        RETURN	id1	id2	id3	page_name_pk	id4	test1	test2	test3
        PK	id1	id2	id3	page_name_pk	id4
        SEQ	test.seq1	test.seq2			
        
        page_name_pk	test1	test2	test3
        page_name_pk1	test1	test2	test3
        page_name_pk2	test1	test2	test3
        page_name_pk3	test1	test2	test3
        page_name_pk4	test1	test2	test3
        
        
        
        If a column is being inserted, then the SEQ entry for it needs to be empty
    */
    GS.requestInsertFromSocket = function (socket, strSchema, strObject, strReturnCols, strPkCols, strSeqCols, insertData, beginCallback, confirmCallback, finalCallback) {
        var strMessage = 'INSERT\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                         '\nRETURN\t' + strReturnCols +
                         (strPkCols ? '\nPK\t' + strPkCols : '') +
                         (strPkCols ? '\nSEQ\t' + strSeqCols : '') +
                         '\n\n' + insertData;
        
        //console.log(strMessage);
        
        GS.requestBegin(socket, function (data, error) {
            var transactionID;
            
            if (!error) {
                transactionID = data;
                if (typeof beginCallback === 'function') { beginCallback(data, error); }
                
                GS.requestFromSocket(GS.envSocket, 'transactionid = ' + transactionID + '\n' + strMessage, function (data, error, errorData) {
                    var commitFunction, rollbackFunction;
                    
                    if (!error) {
                        data = data.substring(data.indexOf('\n') + 1); // transactionid
                        //data = data.substring(data.indexOf('\n') + 1); // responsenumber
                    }
                    
                    console.log('INSERT DATA:', data);
                    console.log('INSERT TRANSID:', transactionID);
                    
                    commitFunction = function () {
                        GS.requestCommit(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }
                            
                            finalCallback('COMMIT', data, error);
                        });
                    };
                    rollbackFunction = function () {
                        GS.requestRollback(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }
                            
                            finalCallback('ROLLBACK', data, error);
                        });
                    };
                    
                    if (!error) {
                        confirmCallback(data, error, transactionID, commitFunction, rollbackFunction);
                    } else {
                        confirmCallback(errorData, error, transactionID, commitFunction, rollbackFunction);
                    }
                });
                
            } else {
                if (typeof beginCallback === 'function') { beginCallback(data, error); }
            }
        });
    };
    
    
    GS.requestUpdateFromSocket = function (socket, strSchema, strObject, strReturnCols, strHashCols, updateData, beginCallback, confirmCallback, finalCallback) {
        var strMessage = 'UPDATE\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                         '\nRETURN\t' + strReturnCols +
                         (strHashCols ? '\nHASH\t' + strHashCols : '') +
                         '\n\n' + updateData;
        
        //console.log(strMessage);
        
        GS.requestBegin(socket, function (data, error) {
            var transactionID;
            
            if (!error) {
                transactionID = data;
                if (typeof beginCallback === 'function') { beginCallback(data, error); }
                
                GS.requestFromSocket(GS.envSocket, 'transactionid = ' + transactionID + '\n' + strMessage, function (data, error, errorData) {
                    var commitFunction, rollbackFunction;
                    
                    if (!error) {
                        data = data.substring(data.indexOf('\n') + 1); // transactionid
                        //data = data.substring(data.indexOf('\n') + 1); // responsenumber
                    }
                    
                    commitFunction = function () {
                        GS.requestCommit(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }
                            
                            finalCallback('COMMIT', data, error);
                        });
                    };
                    rollbackFunction = function () {
                        GS.requestRollback(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }
                            
                            finalCallback('ROLLBACK', data, error);
                        });
                    };
                    
                    if (!error) {
                        confirmCallback(data, error, transactionID, commitFunction, rollbackFunction);
                    } else {
                        confirmCallback(errorData, error, transactionID, commitFunction, rollbackFunction);
                    }
                });
                
            } else {
                if (typeof beginCallback === 'function') { beginCallback(data, error); }
            }
        });
    };
    
    GS.requestDeleteFromSocket = function (socket, strSchema, strObject, strHashCols, deleteData, beginCallback, confirmCallback, finalCallback) {
        var strMessage = 'DELETE\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                         (strHashCols ? '\nHASH\t' + strHashCols : '') + '\n\n' +
                         deleteData;
        
        //console.log(strMessage);
        
        GS.requestBegin(socket, function (data, error) {
            var transactionID;
            
            if (!error) {
                transactionID = data;
                if (typeof beginCallback === 'function') { beginCallback(data, error); }
                
                GS.requestFromSocket(GS.envSocket, 'transactionid = ' + transactionID + '\n' + strMessage, function (data, error, errorData) {
                    var commitFunction, rollbackFunction;
                    
                    if (!error) {
                        data = data.substring(data.indexOf('\n') + 1); // transactionid
                        //data = data.substring(data.indexOf('\n') + 1); // responsenumber
                    }
                    
                    commitFunction = function () {
                        GS.requestCommit(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }
                            
                            finalCallback('COMMIT', data, error);
                        });
                    };
                    rollbackFunction = function () {
                        GS.requestRollback(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }
                            
                            finalCallback('ROLLBACK', data, error);
                        });
                    };
                    
                    if (!error) {
                        confirmCallback(data, error, transactionID, commitFunction, rollbackFunction);
                    } else {
                        confirmCallback(errorData, error, transactionID, commitFunction, rollbackFunction);
                    }
                });
                
            } else {
                if (typeof beginCallback === 'function') { beginCallback(data, error); }
            }
        });
    };
    
    GS.requestBegin = function (socket, callback) {
        GS.requestFromSocket(GS.envSocket, 'BEGIN', function (data, error, errorData) {
            var transactionID;
            
            if (typeof callback === 'function') {
                if (!error) {
                    transactionID = data.substring('transactionid = '.length, data.indexOf('\n'));
                    callback(transactionID, error);
                } else {
                    callback(errorData, error);
                }
            }
        });
    };
    
    GS.requestRollback = function (socket, transactionID, callback) {
        GS.requestFromSocket(GS.envSocket, 'transactionid = ' + transactionID + '\nROLLBACK', function (data, error, errorData) {
            if (typeof callback === 'function') {
                if (!error) {
                    callback(data, error);
                } else {
                    callback(errorData, error);
                }
            }
        });
    };
    
    GS.requestCommit = function (socket, transactionID, callback) {
        GS.requestFromSocket(GS.envSocket, 'transactionid = ' + transactionID + '\nCOMMIT', function (data, error, errorData) {
            if (typeof callback === 'function') {
                if (!error) {
                    callback(data, error);
                } else {
                    callback(errorData, error);
                }
            }
        });
    };
    
    GS.rebootSocket = function (socket) {
        socket.stayClosed = false;
        socket.close();
    };
    
    GS.closeSocket = function (socket) {
        socket.stayClosed = true;
        socket.close();
    };
    
    
    var cacheQueries = [], cacheCallbacks = [], cacheResults = [];
    GS.requestCachingSelect = function (socket, strSchema, strObject, strColumns, strWhere, strOrd, strLimit, strOffset, callback, bolClearCache) {
        var strKey = (strSchema + strObject + strColumns + strWhere + strOrd + strLimit + strOffset)
          , intQueryIndex, i, len;
        
        if (bolClearCache) {
            intQueryIndex = cacheQueries.indexOf(strKey);
            
            cacheQueries.splice(intQueryIndex, 1);
            cacheCallbacks.splice(intQueryIndex, 1);
            cacheResults.splice(intQueryIndex, 1);
        }
        
        intQueryIndex = cacheQueries.indexOf(strKey);
        
        if (intQueryIndex !== -1) {
            for (i = 0, len = cacheResults[intQueryIndex].length; i < len; i += 1) {
                callback(cacheResults[intQueryIndex][i][0], cacheResults[intQueryIndex][i][1]);
            }
            cacheCallbacks[intQueryIndex].push({'callback': callback, 'ready': true});
            
        } else {
            cacheQueries.push(strKey);
            cacheCallbacks.push([{'callback': callback, 'ready': true}]);
            cacheResults.push([]);
            intQueryIndex = (cacheQueries.length - 1);
            
            GS.requestSelectFromSocket(socket, strSchema, strObject, strColumns
                                     , strWhere, strOrd, strLimit, strOffset
                                     , function (data, error) {
                var i, len;
                
                cacheResults[intQueryIndex].push([data, error]);
                
                for (i = 0, len = cacheCallbacks[intQueryIndex].length; i < len; i += 1) {
                    if (cacheCallbacks[intQueryIndex][i].ready) {
                        cacheCallbacks[intQueryIndex][i].callback(data, error);
                    }
                }
            });
        }
    };
})();


// GS.encodeForTabDelimited('asdf\\asdf\\asdf\r\nasdf\r\nasdf\tasdf\tasdf')
GS.encodeForTabDelimited = function (strValue, nullValue) {
    'use strict';
    strValue = String(strValue || '');
    
    if (strValue === '\\N') {
        return strValue;
    } else {
        strValue = strValue.replace(/\\/g, '\\\\') // double up backslashes
                        .replace(/\n/g, '\\n')     // replace newline with the text representation '\n'
                        .replace(/\r/g, '\\r')     // replace carriage return with the text representation '\r'
                        .replace(/\t/g, '\\t');    // replace tab with the text representation '\t'
        
        if (strValue === nullValue) {
            strValue = '\\N';
        }
        
        return strValue;
    }
};

// GS.decodeFromTabDelimited('asdf\\\\asdf\\\\asdf\\r\\nasdf\\r\\nasdf\\tasdf\\tasdf')
GS.decodeFromTabDelimited = function (strValue, nullValue) {
    'use strict';
    var i, len, strRet = '';
    
    if (nullValue === undefined) {
        nullValue = '\\N';
    }
    
    for (i = 0, len = strValue.length; i < len; i += 1) {
        if (strValue[i] === '\\' && strValue[i + 1]) {
            i += 1;
            
            if (strValue[i] === 'n') {
                strRet += '\n';
                
            } else if (strValue[i] === 'r') {
                strRet += '\r';
                
            } else if (strValue[i] === 't') {
                strRet += '\t';
                
            } else if (strValue[i] === 'N') {
                strRet += nullValue;
                
            } else if (strValue[i] === '\\') {
                strRet += '\\';
                
            } else {
                strRet += '\\' + strValue[i];
            }
            
        } else {
            strRet += strValue[i];
        }
    }
    
    return strRet;
    
    //return strValue.replace(/\\\\/g, '\\')
    //               .replace(/\\n/g, '\n')
    //               .replace(/\\r/g, '\r')
    //               .replace(/\\t/g, '\t')
    //               .replace(/\\N/g, 'NULL');
};

window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('GS.rightPad', 'GS.rightPad',
                                    'GS.rightPad(${1:stringToPad}, \'${2:stringToPadWith}\', ${0:lengthToPadTo});');
    
    registerDesignSnippet('GS.leftPad', 'GS.leftPad',
                                    'GS.leftPad(${1:stringToPad}, \'${2:stringToPadWith}\', ${0:lengthToPadTo});');
    
    registerDesignSnippet('GS.pxToEm', 'GS.pxToEm', 'GS.pxToEm(${1:elementToTestIn}, ${0:pxToConvert});');
    
    registerDesignSnippet('GS.emToPx', 'GS.emToPx', 'GS.emToPx(${1:elementToTestIn}, ${0:emToConvert});');

    registerDesignSnippet('GS.keyCode', 'GS.keyCode', 'GS.keyCode(\'${0:characterToGetTheKeyCodeOf}\');');
    
    registerDesignSnippet('GS.charFromKeyCode', 'GS.charFromKeyCode', 'GS.charFromKeyCode(\'${0:eventObject}\');');
    
    registerDesignSnippet('GS.getStyle', 'GS.getStyle', 'GS.getStyle(${1:element}, \'${0:CSSProperty}\');');
    
    registerDesignSnippet('GS.listAdd', 'GS.listAdd', 'GS.listAdd(${1:arrayToAddTo}, \'${0:valueToAddIfUnique}\');');
    
    registerDesignSnippet('GS.triggerEvent', 'GS.triggerEvent', 'GS.triggerEvent(${1:target}, \'${2:eventName}\', ${0:jsnModifiers});');
    
    registerDesignSnippet('GS.strToTitle', 'GS.strToTitle', 'GS.strToTitle(${0:valueToConvert});');
    
    registerDesignSnippet('GS.mousePosition', 'GS.mousePosition', 'GS.mousePosition(${0:event});');
    
    registerDesignSnippet('GS.GUID', 'GS.GUID', 'GS.GUID();');
    
    registerDesignSnippet('GS.safeDecodeURIComponent', 'GS.safeDecodeURIComponent', 'GS.safeDecodeURIComponent(${0:valueToDecode});');
    
    registerDesignSnippet('GS.getTextHeight', 'GS.getTextHeight', 'GS.getTextHeight(${1:elementToTestIn}, ${0:bolNormalLineHeight});');
    
    registerDesignSnippet('GS.getTextWidth', 'GS.getTextWidth', 'GS.getTextWidth(${1:elementToTestIn}, ${0:strTextToGetTheWidthOf});');
    
    registerDesignSnippet('GS.scrollParent', 'GS.scrollParent', 'GS.scrollParent(${0:elementToStartFrom});');
    
    registerDesignSnippet('GS.scrollIntoView', 'GS.scrollIntoView', 'GS.scrollIntoView(${0:elementToScrollIntoView});');
    
    registerDesignSnippet('GS.envGetCell', 'GS.envGetCell', 'GS.envGetCell(${1:envelopeData}, ${2:recordNumber}, \'${0:columnName}\');');
    
    registerDesignSnippet('GS.trim', 'GS.trim', 'GS.trim(${1:stringToBeTrimmed}, \'${0:stringToTrimOff}\');');
    
    registerDesignSnippet('GS.setCookie', 'GS.setCookie', 'GS.setCookie(\'${1:cookieName}\', ${2:newValue}, ${0:daysUntilExpire});');
    
    registerDesignSnippet('GS.getCookie', 'GS.getCookie', 'GS.getCookie(\'${1:cookieName}\');');
    
    registerDesignSnippet('GS.pushState', 'GS.pushState', 'GS.pushState(${1:stateObj}, ${2:title}, ${0:newURL});');
    
    registerDesignSnippet('GS.replaceState', 'GS.replaceState', 'GS.replaceState(${1:stateObj}, ${2:title}, ${0:newURL});');
    
    registerDesignSnippet('GS.searchToWhere', 'GS.searchToWhere', 'GS.searchToWhere(\'${1:columns}\', ${0:searchClause});');
    
    registerDesignSnippet('GS.iconList', 'GS.iconList', 'GS.iconList();');
    
    registerDesignSnippet('GS.lorem', 'GS.lorem', 'GS.lorem();');
    
    registerDesignSnippet('GS.numberSuffix', 'GS.numberSuffix', 'GS.numberSuffix(intNumber);');
});



GS.numberSuffix = function(intNumber) {
    'use strict';
    var strNumber = String(intNumber),
        jsnSuffixes = {
            '0': 'th', '1': 'st',
            '2': 'nd', '3': 'rd',
            '4': 'th', '5': 'th',
            '6': 'th', '7': 'th',
            '8': 'th', '9': 'th'
        };
                
    return strNumber + jsnSuffixes[strNumber[strNumber.length - 1]];
}

// ###########################################################
// #################### PADDING FUNCTIONS ####################
// ###########################################################

// pad a string with another string on the right side of the string
//      repeating until the pad_str until the str length is >= the padToLength

//  PARAM         "str": string to pad
//  PARAM   "padString": string to pad with
//  PARAM "padToLength": number of characters to pad for
GS.rightPad = function (str, padString, padToLength) {
    'use strict';
    str = String(str);
    
    while (str.length < padToLength) {
        str += padString;
    }
   
    return str;
};


// pad a string with another string on the left side of the string
//      repeating until the padString until the str length is >= the padToLength

//  PARAM         "str": string to pad
//  PARAM   "padString": string to pad with
//  PARAM "padToLength": number of characters to pad for
GS.leftPad = function (str, padString, padToLength) {
    'use strict';
    str = String(str);
    
    while (str.length < padToLength) {
        str = padString + str;
    }
   
    return str;
};



// ################################################################
// ################ EM AND PX CONVERSION FUNCTIONS ################
// ################################################################

// convert pixels to ems
GS.pxToEm = function (elementScope, fromPX) {
    'use strict';
	var intPX = parseFloat(fromPX),
	    heightTestElement = document.createElement('div'),
	    intElementHeight;
    
    elementScope = elementScope || document.body;
    
    heightTestElement.style.fontSize = '1em';
    heightTestElement.style.margin = '0';
    heightTestElement.style.padding = '0';
    heightTestElement.style.lineHeight = '1';
    heightTestElement.style.border = '0';
    
    heightTestElement.innerHTML = 'a';
    
    elementScope.appendChild(heightTestElement);
    intElementHeight = heightTestElement.offsetHeight;
    elementScope.removeChild(heightTestElement);
    
	return parseFloat((intPX / intElementHeight).toFixed(8), 10);
};

// convert ems to pixels
GS.emToPx = function (elementScope, fromEM) {
    'use strict';
	var intEM = parseFloat(fromEM),
	    heightTestElement = document.createElement('div'),
	    intElementHeight;
    
    elementScope = elementScope || document.body;
    
    heightTestElement.style.fontSize = '1em';
    heightTestElement.style.margin = '0';
    heightTestElement.style.padding = '0';
    heightTestElement.style.lineHeight = '1';
    heightTestElement.style.border = '0';
    
    heightTestElement.innerHTML = 'a';
    
    elementScope.appendChild(heightTestElement);
    intElementHeight = heightTestElement.offsetHeight;
    elementScope.removeChild(heightTestElement);
    
	return Math.round(intEM * intElementHeight); // not sure if we want to round here but the old function did
	                                             // so I will leave it here until there is a problem -michael
};



// ################################################################
// #################### MISC UTILITY FUNCTIONS ####################
// ################################################################

GS.charFromKeyCode = function (event) {
    // (this function contains a (modified) substantial portion of code from another source
    //    here is the copyright for sake of legality)
    
    // name: jQuery getChar
    // repository: https://github.com/bpeacock/key-to-charCode
    // @author Brian Peacock
    // @version 0.3
    // Copyright 2013, Brian Peacock
    // Licensed under the MIT license.
    
    'use strict';
    
    var code = event.which;
    
    //Ignore Shift Key events & arrows
    var ignoredCodes = {
        16: true,
        37: true,
        38: true,
        39: true,
        40: true,
        20: true,
        17: true,
        18: true,
        91: true
    };
    
    if (ignoredCodes[code] === true) {
        return false;
    }
    
    // These are special cases that don't fit the ASCII mapping
    var exceptions = {
        186: 59, // ;
        187: 61, // =
        188: 44, // ,
        189: 45, // -
        190: 46, // .
        191: 47, // /
        192: 96, // `
        219: 91, // [
        220: 92, // \
        221: 93, // ]
        222: 39, // '
        //numeric keypad
        96: '0'.charCodeAt(0),
        97: '1'.charCodeAt(0),
        98: '2'.charCodeAt(0),
        99: '3'.charCodeAt(0),
        100: '4'.charCodeAt(0),
        101: '5'.charCodeAt(0),
        102: '6'.charCodeAt(0),
        103: '7'.charCodeAt(0),
        104: '8'.charCodeAt(0),
        105: '9'.charCodeAt(0)
    };

    if (exceptions[code] !== undefined) {
        code = exceptions[code];
    }
    
    var ch = String.fromCharCode(code);
    
    // Handle Shift
    if (event.shiftKey) {
        var special = {
            1: '!',
            2: '@',
            3: '#',
            4: '$',
            5: '%',
            6: '^',
            7: '&',
            8: '*',
            9: '(',
            0: ')',
            ',': '<',
            '.': '>',
            '/': '?',
            ';': ':',
            "'": '"',
            '[': '{',
            ']': '}',
            '\\': '|',
            '`': '~',
            '-': '_',
            '=': '+'
        };

        if (special[ch] !== undefined) {
            ch = special[ch];
        }
    } else {
        ch = ch.toLowerCase();
    }
    
    return ch;
};

// keyCode string to number
GS.keyCode = function (inChar) {
    "use strict";
	/*
	Key 	Code
backspace 	8
tab 	9
enter 	13
shift 	16
ctrl 	17
alt 	18
pause/break 	19
caps lock 	20
escape 	27
(space) 	32
page up 	33
page down 	34
end 	35
home 	36
left arrow 	37
up arrow 	38
right arrow 	39
down arrow 	40
insert 	45
delete 	46
0 	48
1 	49
2 	50
3 	51
4 	52
5 	53
6 	54
7 	55
8 	56
9 	57
a 	65
b 	66
c 	67
d 	68

Key 	Code
e 	69
f 	70
g 	71
h 	72
i 	73
j 	74
k 	75
l 	76
m 	77
n 	78
o 	79
p 	80
q 	81
r 	82
s 	83
t 	84
u 	85
v 	86
w 	87
x 	88
y 	89
z 	90
left window key 	91
right window key 	92
select key 	93
numpad 0 	96
numpad 1 	97
numpad 2 	98
numpad 3 	99
numpad 4 	100
numpad 5 	101
numpad 6 	102
numpad 7 	103
*/
    inChar = inChar.toLowerCase();
	return '\b'          == inChar ? '8' :
	       'backspace'   == inChar ? '8' :
	       '\t'          == inChar ? '9' :
	       'tab'         == inChar ? '9' :
	       '\r'          == inChar ? '13' :
	       '\n'          == inChar ? '13' :
	       'enter'       == inChar ? '13' :
	       'return'      == inChar ? '13' :
	       'newline'     == inChar ? '13' :
	       'shift'       == inChar ? '16' :
	       'ctrl'        == inChar ? '17' :
	       'alt'         == inChar ? '18' :
	       'pause/break' == inChar ? '19' :
	       'caps lock'   == inChar ? '20' :
	       'escape'      == inChar ? '27' :
	       'space'       == inChar ? '32' :
	       ' '           == inChar ? '32' :
	       'page up'     == inChar ? '33' :
	       'page down'   == inChar ? '34' :
	       'end'         == inChar ? '35' :
	       'home'        == inChar ? '36' :
	       'left arrow'  == inChar ? '37' :
	       'up arrow'    == inChar ? '38' :
	       'right arrow' == inChar ? '39' :
	       'down arrow'  == inChar ? '40' :
	       'insert'      == inChar ? '45' :
	       'delete'      == inChar ? '46' :
	       '0'           == inChar ? '48' :
	       '1'           == inChar ? '49' :
	       '2'           == inChar ? '50' :
	       '3'           == inChar ? '51' :
	       '4'           == inChar ? '52' :
	       '5'           == inChar ? '53' :
	       '6'           == inChar ? '54' :
	       '7'           == inChar ? '55' :
	       '8'           == inChar ? '56' :
	       '9'           == inChar ? '57' :
	       'a'           == inChar ? '65' :
	       'b'           == inChar ? '66' :
	       'c'           == inChar ? '67' :
	       'd'           == inChar ? '68' :
	       'e'           == inChar ? '69' :
	       'f'           == inChar ? '70' :
	       'g'           == inChar ? '71' :
	       'h'           == inChar ? '72' :
	       'i'           == inChar ? '73' :
	       'j'           == inChar ? '74' :
	       'k'           == inChar ? '75' :
	       'l'           == inChar ? '76' :
	       'm'           == inChar ? '77' :
	       'n'           == inChar ? '78' :
	       'o'           == inChar ? '79' :
	       'p'           == inChar ? '80' :
	       'q'           == inChar ? '81' :
	       'r'           == inChar ? '82' :
	       's'           == inChar ? '83' :
	       't'           == inChar ? '84' :
	       'u'           == inChar ? '85' :
	       'v'           == inChar ? '86' :
	       'w'           == inChar ? '87' :
	       'x'           == inChar ? '88' :
	       'y'           == inChar ? '89' :
	       'z'           == inChar ? '90' :
	       'left window key'  == inChar ? '91' :
	       'right window key' == inChar ? '92' :
	       'select key'  == inChar ? '93' :
	       'numpad 0'    == inChar ? '96' :
	       'numpad 1'    == inChar ? '97' :
	       'numpad 2'    == inChar ? '98' :
	       'numpad 3'    == inChar ? '99' :
	       'numpad 4'    == inChar ? '100' :
	       'numpad 5'    == inChar ? '101' :
	       'numpad 6'    == inChar ? '102' :
	       'numpad 7'    == inChar ? '103' :
	       'numpad 8'    == inChar ? '104' :
	       'numpad 9'    == inChar ? '105' :
	       'multiply'    == inChar ? '106' :
	       'add'         == inChar ? '107' :
	       '+'           == inChar ? '107' :
	       'subtract'    == inChar ? '109' :
	       '-'           == inChar ? '109' :
	       'decimal point' == inChar ? '110' :
	       'divide'      == inChar ? '111' :
	       'f1'          == inChar ? '112' :
	       'f2'          == inChar ? '113' :
	       'f3'          == inChar ? '114' :
	       'f4'          == inChar ? '115' :
	       'f5'          == inChar ? '116' :
	       'f6'          == inChar ? '117' :
	       'f7'          == inChar ? '118' :
	       'f8'          == inChar ? '119' :
	       'f9'          == inChar ? '120' :
	       'f10'         == inChar ? '121' :
	       'f11'         == inChar ? '122' :
	       'f12'         == inChar ? '123' :
	       'num lock'    == inChar ? '144' :
	       'scroll lock' == inChar ? '145' :
	       'semi-colon'  == inChar ? '186' :
	       ';'           == inChar ? '186' :
	       'equal sign'  == inChar ? '187' :
	       '='           == inChar ? '187' :
	       'comma'       == inChar ? '188' :
	       ','           == inChar ? '188' :
	       'dash'        == inChar ? '189' :
	       '-'           == inChar ? '189' :
	       'period'      == inChar ? '190' :
	       '.'           == inChar ? '190' :
	       'forward slash' == inChar ? '191' :
	       '/'             == inChar ? '191' :
	       'grave accent'  == inChar ? '192' :
	       'open bracket'  == inChar ? '219' :
	       '['             == inChar ? '219' :
	       'back slash'    == inChar ? '220' :
	       '\\'            == inChar ? '220' :
	       'close bracket' == inChar ? '221' :
	       ']'             == inChar ? '221' :
	       'single quote'  == inChar ? '222' :
	       '\''            == inChar ? '222' :
	       '';
	/*
Key 	Code
numpad 8 	104
numpad 9 	105
multiply 	106
add 	107
subtract 	109
decimal point 	110
divide 	111
f1 	112
f2 	113
f3 	114
f4 	115
f5 	116
f6 	117
f7 	118
f8 	119
f9 	120
f10 	121
f11 	122
f12 	123
num lock 	144
scroll lock 	145
semi-colon 	186
equal sign 	187
comma 	188
dash 	189
period 	190
forward slash 	191
grave accent 	192
open bracket 	219
back slash 	220
close braket 	221
single quote 	222
*/
};

// get computed or current style (current style if it is availible)
GS.getStyle = function (element, style) {
	if (element.currentStyle !== undefined) {
        return element.currentStyle[style];
	}
    
    return document.defaultView.getComputedStyle(element, null)[style];
};

// push to array if the value is unique
GS.listAdd = function (arrArray, newValue) {
    'use strict';
    if (arrArray.indexOf(newValue) === -1) {
        arrArray.push(newValue);
    }
};

// trigger an event on a target
GS.triggerEvent = function (target, strEventName, jsnConfig) {
    'use strict';
    var event, key;
    
    //console.trace('trigger', target);
    
    if (document.createEvent) {
        event = document.createEvent('HTMLEvents');
        event.initEvent(strEventName, true, true);
    } else {
        event = document.createEventObject();
        event.eventType = strEventName;
    }
    
    event.eventName = strEventName;
    
    if (jsnConfig) {
        for (key in jsnConfig) {
            event[key] = jsnConfig[key];
        }
    }
    
    if (document.createEvent) {
        target.dispatchEvent(event);
    } else {
        target.fireEvent("on" + event.eventType, event);
    }
    
    return event;
};

// converts a string into a more user readable format
GS.strToTitle = function (strInput) {
    'use strict';
    var i, len, chrCurrent, chrLast = '', strRet = '';
    
    strInput = strInput || '';
    
    for (i = 0, len = strInput.length; i < len; i += 1) {
        chrCurrent = strInput.charAt(i);
        
        if (!(/[a-zA-Z]/).test(chrLast)) {
            strRet += chrCurrent.toUpperCase();
            
        } else if (chrCurrent === '_') {
            strRet += ' ';
            
        } else {
            strRet += chrCurrent;
        }
        
        chrLast = chrCurrent;
    }
    
    return strRet;
};

// normalize top, left, bottom and right on a mouse event
GS.mousePosition = function (event) {
    'use strict';
    var pageX = (evt.touchDevice ? event.touches[0].pageX: event.pageX),// get the left and top of the mouse
        pageY = (evt.touchDevice ? event.touches[0].pageY: event.pageY);//   (or the touch position if we are on a phone)
    
    return {
        'top':    pageY,
        'left':   pageX,
        'bottom': window.innerHeight - pageY,
        'right':  window.innerWidth - pageX,
        
        //'x':      pageY, // alias <== messed these up
        //'y':      pageX  // alias
        
        'x':      pageX, // alias
        'y':      pageY  // alias
    };
};

// original function found here: http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
GS.GUID = function () {
    var strTime = new Date().getTime().toString();
    
    function randomString() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }
    
    return  randomString() + randomString() + '-' +
            randomString() + '-' +
            randomString() + '-' +
            randomString() + '-' +
            strTime.substring(strTime.length - 4) + '-' +
            randomString() + randomString() + randomString();
};

/*  ,---- no longer works
//  V
GS.getSelectedText = function () {
    if (window.getSelection) {
        return window.getSelection() + '';
    }
    
    // FireFox
    if (document.getSelection) {
        return document.getSelection() + '';
    }
    
    // IE 6/7
    if (document.selection) {
        return document.selection.createRange().text + '';
    }
    
    console.warn('GS.getSelectedText warning: no selection collection function found (could not find a way to get the selected text)');
    return '';
}*/

// decode uri component safe from "URI malformed" error
GS.safeDecodeURIComponent = function (string) {
    var strRet;
    
    try {
        strRet = decodeURIComponent(string);
        
    } catch (error) {
        if (error.toString().indexOf('URI malformed') > -1) {
            strRet = string;
        } else {
            throw error;
        }
    }
    
    return strRet;
};

//
GS.getTextHeight = function (scope, bolNormalLineHeight) {
    var divElement = document.createElement('div'), intHeight;
    
    scope = scope || document.body;
    
    divElement.style.visibility = 'invisible';
    divElement.style.fontSize   = '1em';
    divElement.style.margin     = '0';
    divElement.style.padding    = '0';
    divElement.style.lineHeight = (bolNormalLineHeight ? 'normal' : '1');
    divElement.style.border     = '0';
    divElement.textContent      = 'a';
    
    scope.appendChild(divElement);
    
    intHeight = divElement.clientHeight;
    
    scope.removeChild(divElement);
    
    return intHeight;
};


//
GS.getTextWidth = function (scope, strText, bolWhitePreserve) {
    var divElement = document.createElement('div'), intWidth;
    
    scope = scope || document.body;
    
    divElement.style.display       = 'inline-block';
    divElement.style.visibility    = 'invisible';
    divElement.style.fontSize      = '1em';
    divElement.style.margin        = '0';
    divElement.style.padding       = '0';
    divElement.style.letterSpacing = 'inherit';
    divElement.style.border        = '0';
    divElement.style.whiteSpace    = (bolWhitePreserve ? 'pre' : '');
    divElement.textContent         = strText;
    
    scope.appendChild(divElement);
    
    intWidth = divElement.clientWidth;
    
    scope.removeChild(divElement);
    
    return intWidth;
};



GS.scrollParent = function (element) {
    var i = 0, currentElement = element, bolFoundScrollable = false, strOverflow;
    
    if (currentElement) {
        while (currentElement && currentElement.nodeName !== 'HTML' && bolFoundScrollable === false && i < 75) {
            strOverflow = GS.getStyle(currentElement, 'overflow');
            
            if (strOverflow === 'scroll' || (strOverflow === 'auto' && currentElement.clientHeight < currentElement.scrollHeight)) {
                bolFoundScrollable = true;
            } else {
                currentElement = currentElement.parentNode;
                i += 1;
            }
        }
        
        //console.log(currentElement.nodeName);
        if (!currentElement || currentElement.nodeName === 'HTML') {
            return document.body;
        }
        
        return bolFoundScrollable ? currentElement : undefined;
    }
    return undefined;
};

//
GS.scrollIntoView = function (element) {
    var scrollingContainer = GS.scrollParent(element), arrSiblings, i, len, intScrollTop;
    
    if (scrollingContainer) {
        //console.log(scrollingContainer);
        
        arrSiblings = element.parentNode.children;
        
        for (i = 0, intScrollTop = 0, len = arrSiblings.length; i < len; i += 1) {
            if (arrSiblings[i] === element) {
                intScrollTop += arrSiblings[i].offsetHeight / 2;
                
                break;
            } else {
                intScrollTop += arrSiblings[i].offsetHeight;
            }
        }
        
        intScrollTop = intScrollTop - (scrollingContainer.offsetHeight / 2);
        
        //console.log(intScrollTop);
        
        scrollingContainer.scrollTop = intScrollTop;
    }
};

// return value from: envelope data, record number and column name
GS.envGetCell = function (data, record_number, column_name) {
    'use strict';
    var index;
    
    if (data.stat) {
        data = data.dat;
    }
    
    index = data.arr_column.indexOf(column_name);
    
    if (index === -1) {
        console.error(column_name, data);
        throw 'Error in GS.envGetCell: column not found';
    }
    
    return data.dat[record_number][index];
};

GS.trim = function(string, strStringToTrim) {
    "use strict";
    var safeRegexString = strStringToTrim.replace(/([.?*+^$[\]\\(){}|-])/g,'\\$1'),
        trimRegex = new RegExp('^' + safeRegexString + '+|' + safeRegexString + '+$', 'g');
    
    return string.replace(trimRegex, '');
};

// set a cookie in the browser
GS.setCookie = function (c_name, value, exdays) {
    'use strict';
    var exDayNum;
    if (!exdays) {
        exDayNum = 30;
    } else {
        exDayNum = exdays;
    }
    
    var hostname = location.hostname;
    var exdate = new Date(), c_value;
    hostname = hostname.substring(hostname.indexOf('.'));
    exdate.setDate(exdate.getDate() + exDayNum);
    
    c_value = encodeURIComponent(value) + ((exDayNum === null || exDayNum === undefined) ? '' : '; expires=' + exdate.toUTCString()) + '; domain=' + hostname + '; path=/';
    
    document.cookie = c_name + '=' + c_value;
};

// get a cookie from the browser
GS.getCookie = function (c_name) {
    'use strict';
    var c_value = document.cookie, c_end,
        c_start = c_value.indexOf(" " + c_name + "=");
    
    if (c_start === -1) {
        c_start = c_value.indexOf(c_name + "=");
    }
    
    if (c_start === -1) {
        c_value = null;
    } else {
        c_start = c_value.indexOf("=", c_start) + 1;
        c_end = c_value.indexOf(";", c_start);
        if (c_end === -1) {
            c_end = c_value.length;
        }
        c_value = decodeURIComponent(c_value.substring(c_start, c_end));
    }
    
    return c_value;
};

GS.pushState = function (stateObj, title, url) {
    history.pushState(stateObj, title, url);
    GS.triggerEvent(window, 'pushstate');
};

GS.replaceState = function (stateObj, title, url) {
    history.replaceState(stateObj, title, url);
    GS.triggerEvent(window, 'replacestate');
};

GS.searchToWhere = function (columns, searchClause) {
    //console.log(searchClause);
    var arrToken, arrNoQuotes = [], strNoQuotes = '', arrColumn, arrRequired = [], strRequired = '', arrWhere = [], strWhere = '', strRet = '', token, numTokens, col, numCols, i, len, strSearch;
    
    if (!searchClause) {
        return '1=1';
    }
    
    arrColumn = columns.split(',');
    
    // First get all quoted tokens, leave everything else
    arrToken = searchClause.match(/[\+|\-]?"[^"]*?"/g);
    
    if (arrToken) {
        for (token = 0, numTokens = arrToken.length; token < numTokens; token += 1) {
            arrToken[token] = GS.trim(arrToken[token], '+');
            for (col = 0, numCols = arrColumn.length; col < numCols; col += 1) {
                if (arrToken[token][0] === '-') {
                    arrToken[token] = GS.trim(arrToken[token], '-');
                    arrRequired[token] =
                        (arrRequired[token] ? arrRequired[token] + ' AND ' : '') +
                        'CASE WHEN ' + arrColumn[col] +
                        ' IS NOT NULL THEN ' + arrColumn[col] +
                        ' NOT ILIKE \'%' + GS.trim(arrToken[token], '"') +
                        '%\' ELSE TRUE END';
                    arrToken[token] = '-' + arrToken[token];
                } else {
                    arrRequired[token] = 
                        (arrRequired[token] ? arrRequired[token] + ' OR ' : '') +
                        (arrColumn[col] + ' ILIKE \'%' + GS.trim(arrToken[token], '"') + '%\'');
                }
            }
        }
        
        for (i = 0, len = arrRequired.length; i < len; i += 1) {
            strRequired = (strRequired ? strRequired + ' AND ' : '') + '(' + arrRequired[i] + ')';
        }
        //console.log('strRequired:', strRequired);
    }
    
    // Get non-quoted tokens and remove extra space
    /*
    //NOT CROSS BROWSER
    arrNoQuotes = strSearch.split(/([\+|\-]?"[^"]*?")/);
    strNoQuotes = arrNoQuotes.join(' ');
    arrNoQuotes = strNoQuotes.split(/[ ]+/);
    */
    strSearch = searchClause.trim();
    strSearch = strSearch.replace('-"', '"');
    strSearch = strSearch.replace('+"', '"');
    strSearch = strSearch.replace(/"[^"]*"/, '""');
    arrNoQuotes = strSearch.split('""');
    //console.log("arrNoQuotes: ", arrNoQuotes);
    strNoQuotes = arrNoQuotes.join(' ');
    //console.log("strNoQuotes: >" + strNoQuotes + "<");
    strNoQuotes = strNoQuotes.replace('  ', ' ');
    strNoQuotes = strNoQuotes.replace('  ', ' ');
    arrNoQuotes = strNoQuotes.split(' ');
    //console.log("arrNoQuotes: ", arrNoQuotes);
    /*
    //DIDN'T WORK
    strSearch = searchClause.trim();
    strSearch = strSearch.replace('-"', '"');
    strSearch = strSearch.replace('+"', '"');
    arrNoQuotes = strSearch.split('"');
    strSearch = '';
    if (searchClause.trim()[0] === '"') {
        for (i = 1, len = arrNoQuotes.length; i < len; i += 2) {
            strSearch = strSearch + (strSearch === '' ? '' : ' ') + arrNoQuotes[i].trim();
        }
    } else {
        for (i = 0, len = arrNoQuotes.length; i < len; i += 2) {
            strSearch = strSearch + (strSearch === '' ? '' : ' ') + arrNoQuotes[i].trim();
        }
    }
    //console.log(strSearch);
    strSearch = strSearch.replace('  ', ' ');
    strSearch = strSearch.replace('  ', ' ');
    arrNoQuotes = strSearch.split(' ');
    //console.log(arrNoQuotes);
    */
    // Put items into arrRequired or arrWhere
    arrRequired = [''];
    if (arrNoQuotes.length > 0) {
        //console.log('1');
        for (token = 0, numTokens = arrNoQuotes.length; token < numTokens; token += 1) {
            //console.log('2');
            for (col = 0, numCols = arrColumn.length; col < numCols; col += 1) {
                //console.log('3 arrNoQuotes[' + token + ']: ' + arrNoQuotes[token]);
                if (arrNoQuotes[token].length > 0) {
                    //console.log('4');
                    if (arrNoQuotes[token][0] === '-') {
                        arrRequired[token] = 
                            (arrRequired[token] ? arrRequired[token] + ' AND ' : '') +
                            ' CASE WHEN ' + arrColumn[col] +
                            ' IS NOT NULL THEN ' + arrColumn[col] +
                            ' NOT ILIKE $$%' + GS.trim(GS.trim(arrNoQuotes[token], '-'), ' ') +
                            '%$$ ELSE TRUE END ';
                    } else if (arrNoQuotes[token][0] === '+') {
                        arrRequired[token] = 
                            (arrRequired[token] ? arrRequired[token] + ' OR ' : '') +
                            arrColumn[col] + ' ILIKE $$%' +
                            GS.trim(GS.trim(arrNoQuotes[token], '+'), ' ') + '%$$ ';
                    } else {
                        arrWhere[token] = 
                            (arrWhere[token] ? arrWhere[token] + ' OR ' : '') +
                            arrColumn[col] + ' ILIKE $$%' + GS.trim(arrNoQuotes[token], ' ') + '%$$ ';
                    }
                }
            }
        }
    }
    
    if (arrRequired.length > 0) {
        for (i = 0, len = arrRequired.length; i < len; i += 1) {
            if (arrRequired[i]) {
                strRequired = (strRequired ? strRequired + ' AND ' : '') + '(' + arrRequired[i] + ')';
            }
        }
    }
    //console.log('strRequired: ', strRequired);
    
    if (arrWhere.length > 0) {
        for (i = 0, len = arrWhere.length; i < len; i += 1) {
            if (arrWhere[i]) {
                strWhere = (strWhere ? strWhere + ' AND ' : '') + '(' + arrWhere[i] + ')';
            }
        }
    }
    //console.log('strWhere: ', strWhere);
    
    strRet = 
        (
            strWhere && strRequired ? '(' + strWhere + ') AND (' + strRequired + ')' :
            strWhere ? strWhere :
            strRequired
        );
    
    //console.log('strRet: ' + strRet);
    
    return strRet;
};

GS.iconList = function () {
    return [{"name":"500px","code":"f26e"},{"name":"adjust","code":"f042"},{"name":"adn","code":"f170"},{"name":"align-center","code":"f037"},{"name":"align-justify","code":"f039"},{"name":"align-left","code":"f036"},{"name":"align-right","code":"f038"},{"name":"amazon","code":"f270"},{"name":"ambulance","code":"f0f9"},{"name":"anchor","code":"f13d"},{"name":"android","code":"f17b"},{"name":"angellist","code":"f209"},{"name":"angle-double-down","code":"f103"},{"name":"angle-double-left","code":"f100"},{"name":"angle-double-right","code":"f101"},{"name":"angle-double-up","code":"f102"},{"name":"angle-down","code":"f107"},{"name":"angle-left","code":"f104"},{"name":"angle-right","code":"f105"},{"name":"angle-up","code":"f106"},{"name":"apple","code":"f179"},{"name":"archive","code":"f187"},{"name":"area-chart","code":"f1fe"},{"name":"arrow-circle-down","code":"f0ab"},{"name":"arrow-circle-left","code":"f0a8"},{"name":"arrow-circle-o-down","code":"f01a"},{"name":"arrow-circle-o-left","code":"f190"},{"name":"arrow-circle-o-right","code":"f18e"},{"name":"arrow-circle-o-up","code":"f01b"},{"name":"arrow-circle-right","code":"f0a9"},{"name":"arrow-circle-up","code":"f0aa"},{"name":"arrow-down","code":"f063"},{"name":"arrow-left","code":"f060"},{"name":"arrow-right","code":"f061"},{"name":"arrow-up","code":"f062"},{"name":"arrows","code":"f047"},{"name":"arrows-alt","code":"f0b2"},{"name":"arrows-h","code":"f07e"},{"name":"arrows-v","code":"f07d"},{"name":"asterisk","code":"f069"},{"name":"at","code":"f1fa"},{"name":"automobile","code":"f1b9"},{"name":"backward","code":"f04a"},{"name":"balance-scale","code":"f24e"},{"name":"ban","code":"f05e"},{"name":"bank","code":"f19c"},{"name":"bar-chart","code":"f080"},{"name":"bar-chart-o","code":"f080"},{"name":"barcode","code":"f02a"},{"name":"bars","code":"f0c9"},{"name":"battery-0","code":"f244"},{"name":"battery-1","code":"f243"},{"name":"battery-2","code":"f242"},{"name":"battery-3","code":"f241"},{"name":"battery-4","code":"f240"},{"name":"battery-empty","code":"f244"},{"name":"battery-full","code":"f240"},{"name":"battery-half","code":"f242"},{"name":"battery-quarter","code":"f243"},{"name":"battery-three-quarters","code":"f241"},{"name":"bed","code":"f236"},{"name":"beer","code":"f0fc"},{"name":"behance","code":"f1b4"},{"name":"behance-square","code":"f1b5"},{"name":"bell","code":"f0f3"},{"name":"bell-o","code":"f0a2"},{"name":"bell-slash","code":"f1f6"},{"name":"bell-slash-o","code":"f1f7"},{"name":"bicycle","code":"f206"},{"name":"binoculars","code":"f1e5"},{"name":"birthday-cake","code":"f1fd"},{"name":"bitbucket","code":"f171"},{"name":"bitbucket-square","code":"f172"},{"name":"bitcoin","code":"f15a"},{"name":"black-tie","code":"f27e"},{"name":"bluetooth","code":"f293"},{"name":"bluetooth-b","code":"f294"},{"name":"bold","code":"f032"},{"name":"bolt","code":"f0e7"},{"name":"bomb","code":"f1e2"},{"name":"book","code":"f02d"},{"name":"bookmark","code":"f02e"},{"name":"bookmark-o","code":"f097"},{"name":"briefcase","code":"f0b1"},{"name":"btc","code":"f15a"},{"name":"bug","code":"f188"},{"name":"building","code":"f1ad"},{"name":"building-o","code":"f0f7"},{"name":"bullhorn","code":"f0a1"},{"name":"bullseye","code":"f140"},{"name":"bus","code":"f207"},{"name":"buysellads","code":"f20d"},{"name":"cab","code":"f1ba"},{"name":"calculator","code":"f1ec"},{"name":"calendar","code":"f073"},{"name":"calendar-check-o","code":"f274"},{"name":"calendar-minus-o","code":"f272"},{"name":"calendar-o","code":"f133"},{"name":"calendar-plus-o","code":"f271"},{"name":"calendar-times-o","code":"f273"},{"name":"camera","code":"f030"},{"name":"camera-retro","code":"f083"},{"name":"car","code":"f1b9"},{"name":"caret-down","code":"f0d7"},{"name":"caret-left","code":"f0d9"},{"name":"caret-right","code":"f0da"},{"name":"caret-square-o-down","code":"f150"},{"name":"caret-square-o-left","code":"f191"},{"name":"caret-square-o-right","code":"f152"},{"name":"caret-square-o-up","code":"f151"},{"name":"caret-up","code":"f0d8"},{"name":"cart-arrow-down","code":"f218"},{"name":"cart-plus","code":"f217"},{"name":"cc","code":"f20a"},{"name":"cc-amex","code":"f1f3"},{"name":"cc-diners-club","code":"f24c"},{"name":"cc-discover","code":"f1f2"},{"name":"cc-jcb","code":"f24b"},{"name":"cc-mastercard","code":"f1f1"},{"name":"cc-paypal","code":"f1f4"},{"name":"cc-stripe","code":"f1f5"},{"name":"cc-visa","code":"f1f0"},{"name":"certificate","code":"f0a3"},{"name":"chain","code":"f0c1"},{"name":"chain-broken","code":"f127"},{"name":"check","code":"f00c"},{"name":"check-circle","code":"f058"},{"name":"check-circle-o","code":"f05d"},{"name":"check-square","code":"f14a"},{"name":"check-square-o","code":"f046"},{"name":"chevron-circle-down","code":"f13a"},{"name":"chevron-circle-left","code":"f137"},{"name":"chevron-circle-right","code":"f138"},{"name":"chevron-circle-up","code":"f139"},{"name":"chevron-down","code":"f078"},{"name":"chevron-left","code":"f053"},{"name":"chevron-right","code":"f054"},{"name":"chevron-up","code":"f077"},{"name":"child","code":"f1ae"},{"name":"chrome","code":"f268"},{"name":"circle","code":"f111"},{"name":"circle-o","code":"f10c"},{"name":"circle-o-notch","code":"f1ce"},{"name":"circle-thin","code":"f1db"},{"name":"clipboard","code":"f0ea"},{"name":"clock-o","code":"f017"},{"name":"clone","code":"f24d"},{"name":"close","code":"f00d"},{"name":"cloud","code":"f0c2"},{"name":"cloud-download","code":"f0ed"},{"name":"cloud-upload","code":"f0ee"},{"name":"cny","code":"f157"},{"name":"code","code":"f121"},{"name":"code-fork","code":"f126"},{"name":"codepen","code":"f1cb"},{"name":"codiepie","code":"f284"},{"name":"coffee","code":"f0f4"},{"name":"cog","code":"f013"},{"name":"cogs","code":"f085"},{"name":"columns","code":"f0db"},{"name":"comment","code":"f075"},{"name":"comment-o","code":"f0e5"},{"name":"commenting","code":"f27a"},{"name":"commenting-o","code":"f27b"},{"name":"comments","code":"f086"},{"name":"comments-o","code":"f0e6"},{"name":"compass","code":"f14e"},{"name":"compress","code":"f066"},{"name":"connectdevelop","code":"f20e"},{"name":"contao","code":"f26d"},{"name":"copy","code":"f0c5"},{"name":"copyright","code":"f1f9"},{"name":"creative-commons","code":"f25e"},{"name":"credit-card","code":"f09d"},{"name":"credit-card-alt","code":"f283"},{"name":"crop","code":"f125"},{"name":"crosshairs","code":"f05b"},{"name":"css3","code":"f13c"},{"name":"cube","code":"f1b2"},{"name":"cubes","code":"f1b3"},{"name":"cut","code":"f0c4"},{"name":"cutlery","code":"f0f5"},{"name":"dashboard","code":"f0e4"},{"name":"dashcube","code":"f210"},{"name":"database","code":"f1c0"},{"name":"dedent","code":"f03b"},{"name":"delicious","code":"f1a5"},{"name":"desktop","code":"f108"},{"name":"deviantart","code":"f1bd"},{"name":"diamond","code":"f219"},{"name":"digg","code":"f1a6"},{"name":"dollar","code":"f155"},{"name":"dot-circle-o","code":"f192"},{"name":"download","code":"f019"},{"name":"dribbble","code":"f17d"},{"name":"dropbox","code":"f16b"},{"name":"drupal","code":"f1a9"},{"name":"edge","code":"f282"},{"name":"edit","code":"f044"},{"name":"eject","code":"f052"},{"name":"ellipsis-h","code":"f141"},{"name":"ellipsis-v","code":"f142"},{"name":"empire","code":"f1d1"},{"name":"envelope","code":"f0e0"},{"name":"envelope-o","code":"f003"},{"name":"envelope-square","code":"f199"},{"name":"eraser","code":"f12d"},{"name":"eur","code":"f153"},{"name":"euro","code":"f153"},{"name":"exchange","code":"f0ec"},{"name":"exclamation","code":"f12a"},{"name":"exclamation-circle","code":"f06a"},{"name":"exclamation-triangle","code":"f071"},{"name":"expand","code":"f065"},{"name":"expeditedssl","code":"f23e"},{"name":"external-link","code":"f08e"},{"name":"external-link-square","code":"f14c"},{"name":"eye","code":"f06e"},{"name":"eye-slash","code":"f070"},{"name":"eyedropper","code":"f1fb"},{"name":"facebook","code":"f09a"},{"name":"facebook-f","code":"f09a"},{"name":"facebook-official","code":"f230"},{"name":"facebook-square","code":"f082"},{"name":"fast-backward","code":"f049"},{"name":"fast-forward","code":"f050"},{"name":"fax","code":"f1ac"},{"name":"feed","code":"f09e"},{"name":"female","code":"f182"},{"name":"fighter-jet","code":"f0fb"},{"name":"file","code":"f15b"},{"name":"file-archive-o","code":"f1c6"},{"name":"file-audio-o","code":"f1c7"},{"name":"file-code-o","code":"f1c9"},{"name":"file-excel-o","code":"f1c3"},{"name":"file-image-o","code":"f1c5"},{"name":"file-movie-o","code":"f1c8"},{"name":"file-o","code":"f016"},{"name":"file-pdf-o","code":"f1c1"},{"name":"file-photo-o","code":"f1c5"},{"name":"file-picture-o","code":"f1c5"},{"name":"file-powerpoint-o","code":"f1c4"},{"name":"file-sound-o","code":"f1c7"},{"name":"file-text","code":"f15c"},{"name":"file-text-o","code":"f0f6"},{"name":"file-video-o","code":"f1c8"},{"name":"file-word-o","code":"f1c2"},{"name":"file-zip-o","code":"f1c6"},{"name":"files-o","code":"f0c5"},{"name":"film","code":"f008"},{"name":"filter","code":"f0b0"},{"name":"fire","code":"f06d"},{"name":"fire-extinguisher","code":"f134"},{"name":"firefox","code":"f269"},{"name":"flag","code":"f024"},{"name":"flag-checkered","code":"f11e"},{"name":"flag-o","code":"f11d"},{"name":"flash","code":"f0e7"},{"name":"flask","code":"f0c3"},{"name":"flickr","code":"f16e"},{"name":"floppy-o","code":"f0c7"},{"name":"folder","code":"f07b"},{"name":"folder-o","code":"f114"},{"name":"folder-open","code":"f07c"},{"name":"folder-open-o","code":"f115"},{"name":"font","code":"f031"},{"name":"fonticons","code":"f280"},{"name":"fort-awesome","code":"f286"},{"name":"forumbee","code":"f211"},{"name":"forward","code":"f04e"},{"name":"foursquare","code":"f180"},{"name":"frown-o","code":"f119"},{"name":"futbol-o","code":"f1e3"},{"name":"gamepad","code":"f11b"},{"name":"gavel","code":"f0e3"},{"name":"gbp","code":"f154"},{"name":"ge","code":"f1d1"},{"name":"gear","code":"f013"},{"name":"gears","code":"f085"},{"name":"genderless","code":"f22d"},{"name":"get-pocket","code":"f265"},{"name":"gg","code":"f260"},{"name":"gg-circle","code":"f261"},{"name":"gift","code":"f06b"},{"name":"git","code":"f1d3"},{"name":"git-square","code":"f1d2"},{"name":"github","code":"f09b"},{"name":"github-alt","code":"f113"},{"name":"github-square","code":"f092"},{"name":"gittip","code":"f184"},{"name":"glass","code":"f000"},{"name":"globe","code":"f0ac"},{"name":"google","code":"f1a0"},{"name":"google-plus","code":"f0d5"},{"name":"google-plus-square","code":"f0d4"},{"name":"google-wallet","code":"f1ee"},{"name":"graduation-cap","code":"f19d"},{"name":"gratipay","code":"f184"},{"name":"group","code":"f0c0"},{"name":"h-square","code":"f0fd"},{"name":"hacker-news","code":"f1d4"},{"name":"hand-grab-o","code":"f255"},{"name":"hand-lizard-o","code":"f258"},{"name":"hand-o-down","code":"f0a7"},{"name":"hand-o-left","code":"f0a5"},{"name":"hand-o-right","code":"f0a4"},{"name":"hand-o-up","code":"f0a6"},{"name":"hand-paper-o","code":"f256"},{"name":"hand-peace-o","code":"f25b"},{"name":"hand-pointer-o","code":"f25a"},{"name":"hand-rock-o","code":"f255"},{"name":"hand-scissors-o","code":"f257"},{"name":"hand-spock-o","code":"f259"},{"name":"hand-stop-o","code":"f256"},{"name":"hashtag","code":"f292"},{"name":"hdd-o","code":"f0a0"},{"name":"header","code":"f1dc"},{"name":"headphones","code":"f025"},{"name":"heart","code":"f004"},{"name":"heart-o","code":"f08a"},{"name":"heartbeat","code":"f21e"},{"name":"history","code":"f1da"},{"name":"home","code":"f015"},{"name":"hospital-o","code":"f0f8"},{"name":"hotel","code":"f236"},{"name":"hourglass","code":"f254"},{"name":"hourglass-1","code":"f251"},{"name":"hourglass-2","code":"f252"},{"name":"hourglass-3","code":"f253"},{"name":"hourglass-end","code":"f253"},{"name":"hourglass-half","code":"f252"},{"name":"hourglass-o","code":"f250"},{"name":"hourglass-start","code":"f251"},{"name":"houzz","code":"f27c"},{"name":"html5","code":"f13b"},{"name":"i-cursor","code":"f246"},{"name":"ils","code":"f20b"},{"name":"image","code":"f03e"},{"name":"inbox","code":"f01c"},{"name":"indent","code":"f03c"},{"name":"industry","code":"f275"},{"name":"info","code":"f129"},{"name":"info-circle","code":"f05a"},{"name":"inr","code":"f156"},{"name":"instagram","code":"f16d"},{"name":"institution","code":"f19c"},{"name":"internet-explorer","code":"f26b"},{"name":"intersex","code":"f224"},{"name":"ioxhost","code":"f208"},{"name":"italic","code":"f033"},{"name":"joomla","code":"f1aa"},{"name":"jpy","code":"f157"},{"name":"jsfiddle","code":"f1cc"},{"name":"key","code":"f084"},{"name":"keyboard-o","code":"f11c"},{"name":"krw","code":"f159"},{"name":"language","code":"f1ab"},{"name":"laptop","code":"f109"},{"name":"lastfm","code":"f202"},{"name":"lastfm-square","code":"f203"},{"name":"leaf","code":"f06c"},{"name":"leanpub","code":"f212"},{"name":"legal","code":"f0e3"},{"name":"lemon-o","code":"f094"},{"name":"level-down","code":"f149"},{"name":"level-up","code":"f148"},{"name":"life-bouy","code":"f1cd"},{"name":"life-buoy","code":"f1cd"},{"name":"life-ring","code":"f1cd"},{"name":"life-saver","code":"f1cd"},{"name":"lightbulb-o","code":"f0eb"},{"name":"line-chart","code":"f201"},{"name":"link","code":"f0c1"},{"name":"linkedin","code":"f0e1"},{"name":"linkedin-square","code":"f08c"},{"name":"linux","code":"f17c"},{"name":"list","code":"f03a"},{"name":"list-alt","code":"f022"},{"name":"list-ol","code":"f0cb"},{"name":"list-ul","code":"f0ca"},{"name":"location-arrow","code":"f124"},{"name":"lock","code":"f023"},{"name":"long-arrow-down","code":"f175"},{"name":"long-arrow-left","code":"f177"},{"name":"long-arrow-right","code":"f178"},{"name":"long-arrow-up","code":"f176"},{"name":"magic","code":"f0d0"},{"name":"magnet","code":"f076"},{"name":"mail-forward","code":"f064"},{"name":"mail-reply","code":"f112"},{"name":"mail-reply-all","code":"f122"},{"name":"male","code":"f183"},{"name":"map","code":"f279"},{"name":"map-marker","code":"f041"},{"name":"map-o","code":"f278"},{"name":"map-pin","code":"f276"},{"name":"map-signs","code":"f277"},{"name":"mars","code":"f222"},{"name":"mars-double","code":"f227"},{"name":"mars-stroke","code":"f229"},{"name":"mars-stroke-h","code":"f22b"},{"name":"mars-stroke-v","code":"f22a"},{"name":"maxcdn","code":"f136"},{"name":"meanpath","code":"f20c"},{"name":"medium","code":"f23a"},{"name":"medkit","code":"f0fa"},{"name":"meh-o","code":"f11a"},{"name":"mercury","code":"f223"},{"name":"microphone","code":"f130"},{"name":"microphone-slash","code":"f131"},{"name":"minus","code":"f068"},{"name":"minus-circle","code":"f056"},{"name":"minus-square","code":"f146"},{"name":"minus-square-o","code":"f147"},{"name":"mixcloud","code":"f289"},{"name":"mobile","code":"f10b"},{"name":"mobile-phone","code":"f10b"},{"name":"modx","code":"f285"},{"name":"money","code":"f0d6"},{"name":"moon-o","code":"f186"},{"name":"mortar-board","code":"f19d"},{"name":"motorcycle","code":"f21c"},{"name":"mouse-pointer","code":"f245"},{"name":"music","code":"f001"},{"name":"navicon","code":"f0c9"},{"name":"neuter","code":"f22c"},{"name":"newspaper-o","code":"f1ea"},{"name":"object-group","code":"f247"},{"name":"object-ungroup","code":"f248"},{"name":"odnoklassniki","code":"f263"},{"name":"odnoklassniki-square","code":"f264"},{"name":"opencart","code":"f23d"},{"name":"openid","code":"f19b"},{"name":"opera","code":"f26a"},{"name":"optin-monster","code":"f23c"},{"name":"outdent","code":"f03b"},{"name":"pagelines","code":"f18c"},{"name":"paint-brush","code":"f1fc"},{"name":"paper-plane","code":"f1d8"},{"name":"paper-plane-o","code":"f1d9"},{"name":"paperclip","code":"f0c6"},{"name":"paragraph","code":"f1dd"},{"name":"paste","code":"f0ea"},{"name":"pause","code":"f04c"},{"name":"pause-circle","code":"f28b"},{"name":"pause-circle-o","code":"f28c"},{"name":"paw","code":"f1b0"},{"name":"paypal","code":"f1ed"},{"name":"pencil","code":"f040"},{"name":"pencil-square","code":"f14b"},{"name":"pencil-square-o","code":"f044"},{"name":"percent","code":"f295"},{"name":"phone","code":"f095"},{"name":"phone-square","code":"f098"},{"name":"photo","code":"f03e"},{"name":"picture-o","code":"f03e"},{"name":"pie-chart","code":"f200"},{"name":"pied-piper","code":"f1a7"},{"name":"pied-piper-alt","code":"f1a8"},{"name":"pinterest","code":"f0d2"},{"name":"pinterest-p","code":"f231"},{"name":"pinterest-square","code":"f0d3"},{"name":"plane","code":"f072"},{"name":"play","code":"f04b"},{"name":"play-circle","code":"f144"},{"name":"play-circle-o","code":"f01d"},{"name":"plug","code":"f1e6"},{"name":"plus","code":"f067"},{"name":"plus-circle","code":"f055"},{"name":"plus-square","code":"f0fe"},{"name":"plus-square-o","code":"f196"},{"name":"power-off","code":"f011"},{"name":"print","code":"f02f"},{"name":"product-hunt","code":"f288"},{"name":"puzzle-piece","code":"f12e"},{"name":"qq","code":"f1d6"},{"name":"qrcode","code":"f029"},{"name":"question","code":"f128"},{"name":"question-circle","code":"f059"},{"name":"quote-left","code":"f10d"},{"name":"quote-right","code":"f10e"},{"name":"ra","code":"f1d0"},{"name":"random","code":"f074"},{"name":"rebel","code":"f1d0"},{"name":"recycle","code":"f1b8"},{"name":"reddit","code":"f1a1"},{"name":"reddit-alien","code":"f281"},{"name":"reddit-square","code":"f1a2"},{"name":"refresh","code":"f021"},{"name":"registered","code":"f25d"},{"name":"remove","code":"f00d"},{"name":"renren","code":"f18b"},{"name":"reorder","code":"f0c9"},{"name":"repeat","code":"f01e"},{"name":"reply","code":"f112"},{"name":"reply-all","code":"f122"},{"name":"retweet","code":"f079"},{"name":"rmb","code":"f157"},{"name":"road","code":"f018"},{"name":"rocket","code":"f135"},{"name":"rotate-left","code":"f0e2"},{"name":"rotate-right","code":"f01e"},{"name":"rouble","code":"f158"},{"name":"rss","code":"f09e"},{"name":"rss-square","code":"f143"},{"name":"rub","code":"f158"},{"name":"ruble","code":"f158"},{"name":"rupee","code":"f156"},{"name":"safari","code":"f267"},{"name":"save","code":"f0c7"},{"name":"scissors","code":"f0c4"},{"name":"scribd","code":"f28a"},{"name":"search","code":"f002"},{"name":"search-minus","code":"f010"},{"name":"search-plus","code":"f00e"},{"name":"sellsy","code":"f213"},{"name":"send","code":"f1d8"},{"name":"send-o","code":"f1d9"},{"name":"server","code":"f233"},{"name":"share","code":"f064"},{"name":"share-alt","code":"f1e0"},{"name":"share-alt-square","code":"f1e1"},{"name":"share-square","code":"f14d"},{"name":"share-square-o","code":"f045"},{"name":"shekel","code":"f20b"},{"name":"sheqel","code":"f20b"},{"name":"shield","code":"f132"},{"name":"ship","code":"f21a"},{"name":"shirtsinbulk","code":"f214"},{"name":"shopping-bag","code":"f290"},{"name":"shopping-basket","code":"f291"},{"name":"shopping-cart","code":"f07a"},{"name":"sign-in","code":"f090"},{"name":"sign-out","code":"f08b"},{"name":"signal","code":"f012"},{"name":"simplybuilt","code":"f215"},{"name":"sitemap","code":"f0e8"},{"name":"skyatlas","code":"f216"},{"name":"skype","code":"f17e"},{"name":"slack","code":"f198"},{"name":"sliders","code":"f1de"},{"name":"slideshare","code":"f1e7"},{"name":"smile-o","code":"f118"},{"name":"soccer-ball-o","code":"f1e3"},{"name":"sort","code":"f0dc"},{"name":"sort-alpha-asc","code":"f15d"},{"name":"sort-alpha-desc","code":"f15e"},{"name":"sort-amount-asc","code":"f160"},{"name":"sort-amount-desc","code":"f161"},{"name":"sort-asc","code":"f0de"},{"name":"sort-desc","code":"f0dd"},{"name":"sort-down","code":"f0dd"},{"name":"sort-numeric-asc","code":"f162"},{"name":"sort-numeric-desc","code":"f163"},{"name":"sort-up","code":"f0de"},{"name":"soundcloud","code":"f1be"},{"name":"space-shuttle","code":"f197"},{"name":"spinner","code":"f110"},{"name":"spoon","code":"f1b1"},{"name":"spotify","code":"f1bc"},{"name":"square","code":"f0c8"},{"name":"square-o","code":"f096"},{"name":"stack-exchange","code":"f18d"},{"name":"stack-overflow","code":"f16c"},{"name":"star","code":"f005"},{"name":"star-half","code":"f089"},{"name":"star-half-empty","code":"f123"},{"name":"star-half-full","code":"f123"},{"name":"star-half-o","code":"f123"},{"name":"star-o","code":"f006"},{"name":"steam","code":"f1b6"},{"name":"steam-square","code":"f1b7"},{"name":"step-backward","code":"f048"},{"name":"step-forward","code":"f051"},{"name":"stethoscope","code":"f0f1"},{"name":"sticky-note","code":"f249"},{"name":"sticky-note-o","code":"f24a"},{"name":"stop","code":"f04d"},{"name":"stop-circle","code":"f28d"},{"name":"stop-circle-o","code":"f28e"},{"name":"street-view","code":"f21d"},{"name":"strikethrough","code":"f0cc"},{"name":"stumbleupon","code":"f1a4"},{"name":"stumbleupon-circle","code":"f1a3"},{"name":"subscript","code":"f12c"},{"name":"subway","code":"f239"},{"name":"suitcase","code":"f0f2"},{"name":"sun-o","code":"f185"},{"name":"superscript","code":"f12b"},{"name":"support","code":"f1cd"},{"name":"table","code":"f0ce"},{"name":"tablet","code":"f10a"},{"name":"tachometer","code":"f0e4"},{"name":"tag","code":"f02b"},{"name":"tags","code":"f02c"},{"name":"tasks","code":"f0ae"},{"name":"taxi","code":"f1ba"},{"name":"television","code":"f26c"},{"name":"tencent-weibo","code":"f1d5"},{"name":"terminal","code":"f120"},{"name":"text-height","code":"f034"},{"name":"text-width","code":"f035"},{"name":"th","code":"f00a"},{"name":"th-large","code":"f009"},{"name":"th-list","code":"f00b"},{"name":"thumb-tack","code":"f08d"},{"name":"thumbs-down","code":"f165"},{"name":"thumbs-o-down","code":"f088"},{"name":"thumbs-o-up","code":"f087"},{"name":"thumbs-up","code":"f164"},{"name":"ticket","code":"f145"},{"name":"times","code":"f00d"},{"name":"times-circle","code":"f057"},{"name":"times-circle-o","code":"f05c"},{"name":"tint","code":"f043"},{"name":"toggle-down","code":"f150"},{"name":"toggle-left","code":"f191"},{"name":"toggle-off","code":"f204"},{"name":"toggle-on","code":"f205"},{"name":"toggle-right","code":"f152"},{"name":"toggle-up","code":"f151"},{"name":"trademark","code":"f25c"},{"name":"train","code":"f238"},{"name":"transgender","code":"f224"},{"name":"transgender-alt","code":"f225"},{"name":"trash","code":"f1f8"},{"name":"trash-o","code":"f014"},{"name":"tree","code":"f1bb"},{"name":"trello","code":"f181"},{"name":"tripadvisor","code":"f262"},{"name":"trophy","code":"f091"},{"name":"truck","code":"f0d1"},{"name":"try","code":"f195"},{"name":"tty","code":"f1e4"},{"name":"tumblr","code":"f173"},{"name":"tumblr-square","code":"f174"},{"name":"turkish-lira","code":"f195"},{"name":"tv","code":"f26c"},{"name":"twitch","code":"f1e8"},{"name":"twitter","code":"f099"},{"name":"twitter-square","code":"f081"},{"name":"umbrella","code":"f0e9"},{"name":"underline","code":"f0cd"},{"name":"undo","code":"f0e2"},{"name":"university","code":"f19c"},{"name":"unlink","code":"f127"},{"name":"unlock","code":"f09c"},{"name":"unlock-alt","code":"f13e"},{"name":"unsorted","code":"f0dc"},{"name":"upload","code":"f093"},{"name":"usb","code":"f287"},{"name":"usd","code":"f155"},{"name":"user","code":"f007"},{"name":"user-md","code":"f0f0"},{"name":"user-plus","code":"f234"},{"name":"user-secret","code":"f21b"},{"name":"user-times","code":"f235"},{"name":"users","code":"f0c0"},{"name":"venus","code":"f221"},{"name":"venus-double","code":"f226"},{"name":"venus-mars","code":"f228"},{"name":"viacoin","code":"f237"},{"name":"video-camera","code":"f03d"},{"name":"vimeo","code":"f27d"},{"name":"vimeo-square","code":"f194"},{"name":"vine","code":"f1ca"},{"name":"vk","code":"f189"},{"name":"volume-down","code":"f027"},{"name":"volume-off","code":"f026"},{"name":"volume-up","code":"f028"},{"name":"warning","code":"f071"},{"name":"wechat","code":"f1d7"},{"name":"weibo","code":"f18a"},{"name":"weixin","code":"f1d7"},{"name":"whatsapp","code":"f232"},{"name":"wheelchair","code":"f193"},{"name":"wifi","code":"f1eb"},{"name":"wikipedia-w","code":"f266"},{"name":"windows","code":"f17a"},{"name":"won","code":"f159"},{"name":"wordpress","code":"f19a"},{"name":"wrench","code":"f0ad"},{"name":"xing","code":"f168"},{"name":"xing-square","code":"f169"},{"name":"y-combinator","code":"f23b"},{"name":"y-combinator-square","code":"f1d4"},{"name":"yahoo","code":"f19e"},{"name":"yc","code":"f23b"},{"name":"yc-square","code":"f1d4"},{"name":"yelp","code":"f1e9"},{"name":"yen","code":"f157"},{"name":"youtube","code":"f167"},{"name":"youtube-play","code":"f16a"},{"name":"youtube-square","code":"f166"}];
};

GS.lorem = function () {
    return 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';
};


window.addEventListener('design-register-element', function () {
    registerDesignSnippet('Add Loader (to page)', 'GS.addLoader', 'addLoader(\'${0:class-name}\', \'${1:Loading...}\');');
    registerDesignSnippet('Add Loader (to element)', 'GS.addLoader', 'addLoader(${0:document.getElementById(\'id\')}, \'${1:Loading...}\');');
    registerDesignSnippet('Remove Loader (from page)', 'GS.removeLoader', 'removeLoader(\'${0:class-name}\');');
    registerDesignSnippet('Remove Loader (from element)', 'GS.removeLoader', 'removeLoader(${0:document.getElementById(\'id\')});');
});

document.addEventListener('DOMContentLoaded', function () {
    xtag.register('gs-loader', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
});

GS.addLoader = function (loaderClassOrTarget, loaderContent) {
    var loaderElement = document.createElement('gs-loader'), loaderClass, loaderTarget;
    
    // turn loaderClassOrTarget into class or target
    if (typeof loaderClassOrTarget === 'string') {
        loaderClass = loaderClassOrTarget;
        
    } else if (typeof loaderClassOrTarget === 'object') {
        loaderTarget = loaderClassOrTarget;
    }
    
    // if there is a loader class: add class to loader for future identification
    if (loaderClass) {
        loaderElement.classList.add('loader-' + loaderClass);
    }
    
    // default loader target to body
    if (!loaderTarget) {
        loaderTarget = document.body;
    }
    
    // add spinning elements and loader content to loader container
    loaderElement.innerHTML =   '<div class="loader-positioning" gs-dynamic>' +
                                    '<div class="loader" gs-dynamic></div>' +
                                    '<div class="loader-inner spinning" gs-dynamic></div>' +
                                    '<div class="loader-inner-inner spinning" gs-dynamic></div>' +
                                    '<div class="loader-inner-inner-inner spinning" gs-dynamic></div>' +
                                    (loaderContent ? '<div class="loader-content" gs-dynamic>' + loaderContent + '</div>' : '') +
                                '</div>';
    
    // prevent scrolling on a loader
    loaderElement.addEventListener('mousewheel', function (event) {
        event.preventDefault();
    });
    
    // append loader to target
    loaderTarget.appendChild(loaderElement); // document.body
};

GS.removeLoader = function (loaderClassOrTarget) {
    var element, i, len, arrLoaders, loaderClass, loaderTarget;
    
    if (typeof loaderClassOrTarget === 'string') {
        loaderClass = loaderClassOrTarget;
        
    } else if (typeof loaderClassOrTarget === 'object') {
        loaderTarget = loaderClassOrTarget;
    }
    
    if (loaderClass) {
        element = document.getElementsByClassName('loader-' + loaderClass)[0];
        
    } else if (loaderTarget) {
        element = xtag.queryChildren(loaderTarget, 'gs-loader')[0];
        
    } else {
        arrLoaders = xtag.queryChildren(document.body, 'gs-loader');
        
        for (i = 0, len = arrLoaders.length; i < len; i += 1) {
            if (!arrLoaders[i].hasAttribute('id')) {
                element = arrLoaders[i];
                break;
            }
        }
    }
    
    if (element) {
        element.parentNode.removeChild(element);
    } else {
        console.warn('GS.removeLoader Error: loader' + (loaderClass ? ' class: "' + loaderClass + '"' : '') + ' not found');
    }
};

GS.removeAllLoaders = function () {
    'use strict';
    var i, len, arrLoaders;
    
    arrLoaders = xtag.query(document.body, 'gs-loader');
    
    for (i = 0, len = arrLoaders.length; i < len; i += 1) {
        if (!arrLoaders[i].hasAttribute('id')) {
            arrLoaders[i].parentNode.removeChild(arrLoaders[i]);
        }
    }
};
window.addEventListener('design-register-element', function () {
    window.designElementProperty_GSBODY = function(selectedElement) {
        addFlexContainerProps(selectedElement);
        //addFlexProps(selectedElement);
        
        addProp('Padded', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('padded')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'padded', (this.value === 'true'), true);
        });
    };
    
    registerDesignSnippet('<gs-body>', '<gs-body>', 'gs-body>\n' +
                                                    '    $0\n' +
                                                    '</gs-body>');
    
    designRegisterElement('gs-body', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-page.html');
});

document.addEventListener('DOMContentLoaded', function () {
    xtag.register('gs-body', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
});

(function () {
    'use strict';

    function defineButton(strTagName, strDocLink, arrDisableWhenEmptyAttributes, designAdditionalFunction, clickFunction) {
        strDocLink = strDocLink || '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-buttons-toggle.html';
        designAdditionalFunction = designAdditionalFunction || function () {};
        clickFunction = clickFunction || function () {};

        window.addEventListener('design-register-element', function () {
            registerDesignSnippet('<' + strTagName + '>', '<' + strTagName + '>', strTagName + '>${1}</' + strTagName + '>');

            designRegisterElement(strTagName, strDocLink);

            window['designElementProperty_' + strTagName.replace(/[^a-z0-9]/gi, '').toUpperCase()] = function (selectedElement) {
                var strIconPos = '', strIconRotation = '', strVisibilityAttribute = '', strFontAttribute = '', strBackgroundAttribute = '';

                addProp('Icon', true, '<div flex-horizontal>' +
                                      '     <gs-text id="prop-icon-input" class="target" value="' + (selectedElement.getAttribute('icon') || '') +
                                                                                                            '" mini flex></gs-text>' +
                                      '     <gs-button id="prop-icon-picker-button" mini icononly icon="list"></gs-button>' +
                                      '     <style>#prop-icon-picker-button:after {font-size: 1em;}</style>' +
                                      '</div>', function () {
                    return setOrRemoveTextAttribute(selectedElement, 'icon', this.value, false);
                });

                document.getElementById('prop-icon-picker-button').addEventListener('click', function () {
                    var i, len, html, arrIcons = GS.iconList(), strName, templateElement;

                    for (i = 0, len = arrIcons.length, html = ''; i < len; i += 1) {
                        strName = arrIcons[i].name;
                        html += '<gs-block>' +
                                    '<gs-button iconleft icon="' + strName + '" dialogclose>' + strName + '</gs-button>' +
                                '</gs-block>';
                    }

                    templateElement = document.createElement('template');
                    templateElement.setAttribute('data-max-width', '1100px');
                    templateElement.innerHTML =
                        '<gs-page>' +
                        '    <gs-header><center><h3>Choose An Icon</h3></center></gs-header>' +
                        '    <gs-body padded><gs-grid widths="1,1,1,1" reflow-at="767px">' + html + '</gs-grid></gs-body>' +
                        '    <gs-footer><gs-button dialogclose>Cancel</gs-button></gs-footer>' +
                        '</gs-page>';

                    GS.openDialog(templateElement, '', function (event, strAnswer) {
                        var propInput = document.getElementById('prop-icon-input');

                        if (strAnswer !== 'Cancel') {
                            propInput.value = strAnswer;
                            GS.triggerEvent(propInput, 'change');
                        }
                    });
                });

                       if (selectedElement.hasAttribute('iconleft'))   { strIconPos = 'iconleft';
                } else if (selectedElement.hasAttribute('iconright'))  { strIconPos = 'iconright';
                } else if (selectedElement.hasAttribute('icontop'))    { strIconPos = 'icontop';
                } else if (selectedElement.hasAttribute('iconbottom')) { strIconPos = 'iconbottom';
                } else if (selectedElement.hasAttribute('icononly'))   { strIconPos = 'icononly'; }

                addProp('Icon Position', true, '<gs-select class="target" value="' + strIconPos + '" mini>' +
                                                    '   <option value="">Default</option>' +
                                                    '   <option value="iconleft">Left</option>' +
                                                    '   <option value="iconright">Right</option>' +
                                                    '   <option value="icontop">Top</option>' +
                                                    '   <option value="iconbottom">Bottom</option>' +
                                                    '   <option value="icononly">Icononly</option>' +
                                                    '</gs-select>', function () {
                    selectedElement.removeAttribute('iconleft');
                    selectedElement.removeAttribute('iconright');
                    selectedElement.removeAttribute('icontop');
                    selectedElement.removeAttribute('iconbottom');
                    selectedElement.removeAttribute('icononly');

                    if (this.value) {
                        selectedElement.setAttribute(this.value, '');
                    }

                    return selectedElement;
                });

                       if (selectedElement.hasAttribute('iconrotateright')) { strIconRotation = 'iconrotateright';
                } else if (selectedElement.hasAttribute('iconrotatedown'))  { strIconRotation = 'iconrotatedown';
                } else if (selectedElement.hasAttribute('iconrotateleft'))  { strIconRotation = 'iconrotateleft'; }
                
                addProp('Icon&nbsp;Rotation', true, '<gs-select class="target" value="' + strIconRotation + '" mini>' +
                                                    '   <option value="">None</option>' +
                                                    '   <option value="iconrotateright">90 degrees</option>' +
                                                    '   <option value="iconrotatedown">180 degrees</option>' +
                                                    '   <option value="iconrotateleft">270 degrees</option>' +
                                                    '</gs-select>', function () {
                    selectedElement.removeAttribute('iconrotateright');
                    selectedElement.removeAttribute('iconrotatedown');
                    selectedElement.removeAttribute('iconrotateleft');
                    
                    if (this.value) {
                        selectedElement.setAttribute(this.value, '');
                    }
                    
                    return selectedElement;
                });
                
                addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
                    return setOrRemoveTextAttribute(selectedElement, 'column', this.value, false);
                });
                
                addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
                    return setOrRemoveTextAttribute(selectedElement, 'value', this.value, false);
                });
                
                addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
                    return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
                });
                
                addProp('Jumbo', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('jumbo')) + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'jumbo', (this.value === 'true'), true);
                });
                
                addProp('Focusable', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-focus')) + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'no-focus', (this.value === 'true'), false);
                });
                /* TODO: remove emphasis and add other colors
                addProp('Emphasis', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('emphasis')) + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'emphasis', (this.value === 'true'), true);
                });
                */


                //<gs-delete-button>

                // Font Color attributes
                strFontAttribute = '';
                if (selectedElement.hasAttribute('txt-primary'))  { strFontAttribute = 'txt-primary'; }
                if (selectedElement.hasAttribute('txt-success'))  { strFontAttribute = 'txt-success'; }
                if (selectedElement.hasAttribute('txt-info'))     { strFontAttribute = 'txt-info'; }
                if (selectedElement.hasAttribute('txt-warning'))  { strFontAttribute = 'txt-warning'; }
                if (selectedElement.hasAttribute('txt-danger'))   { strFontAttribute = 'txt-danger'; }
                
                addProp('Font Color', true, '<gs-select class="target" value="' + strFontAttribute + '" mini>' +
                                                '<option value="">Default</option>' +
                                                '<option value="txt-primary">Primary</option>' +
                                                '<option value="txt-success">Success</option>' +
                                                '<option value="txt-info">Info</option>' +
                                                '<option value="txt-warning">Warning</option>' +
                                                '<option value="txt-danger">Danger</option>' +
                                            '</gs-select>', function () {
                    selectedElement.removeAttribute('txt-primary');
                    selectedElement.removeAttribute('txt-success');
                    selectedElement.removeAttribute('txt-info');
                    selectedElement.removeAttribute('txt-warning');
                    selectedElement.removeAttribute('txt-danger');
                    
                    if (this.value) {
                        selectedElement.setAttribute(this.value, '');
                    }
                    
                    return selectedElement;
                });

                // Background Color attributes
                strBackgroundAttribute = '';
                if (selectedElement.hasAttribute('bg-primary'))  { strBackgroundAttribute = 'bg-primary'; }
                if (selectedElement.hasAttribute('bg-success'))  { strBackgroundAttribute = 'bg-success'; }
                if (selectedElement.hasAttribute('bg-info'))     { strBackgroundAttribute = 'bg-info'; }
                if (selectedElement.hasAttribute('bg-warning'))  { strBackgroundAttribute = 'bg-warning'; }
                if (selectedElement.hasAttribute('bg-danger'))   { strBackgroundAttribute = 'bg-danger'; }

                addProp('Background Color', true, '<gs-select class="target" value="' + strBackgroundAttribute + '" mini>' +
                                                '<option value="">Default</option>' +
                                                '<option value="bg-primary">Primary</option>' +
                                                '<option value="bg-success">Success</option>' +
                                                '<option value="bg-info">Info</option>' +
                                                '<option value="bg-warning">Warning</option>' +
                                                '<option value="bg-danger">Danger</option>' +
                                            '</gs-select>', function () {
                    selectedElement.removeAttribute('bg-primary');
                    selectedElement.removeAttribute('bg-success');
                    selectedElement.removeAttribute('bg-info');
                    selectedElement.removeAttribute('bg-warning');
                    selectedElement.removeAttribute('bg-danger');

                    if (this.value) {
                        selectedElement.setAttribute(this.value, '');
                    }

                    return selectedElement;
                });

                addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '0') + '" mini></gs-number>', function () {
                    return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
                });

                addProp('Inline', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('inline')) + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'inline', (this.value === 'true'), true);
                });
                addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
                });

                addProp('Key', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('key') || '') + '" mini></gs-text>', function () {
                    return setOrRemoveTextAttribute(selectedElement, 'key', this.value, false);
                });

                addProp('No Modifier Key For Hot Key', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-modifier-key') || '') + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'no-modifier-key', this.value === 'true', true);
                });

                // TITLE attribute
                addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
                    return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
                });

                // DISABLED attribute
                addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
                });

                // SUSPEND-INSERTED attribute
                addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
                });

                // visibility attributes
                if (selectedElement.hasAttribute('hidden'))          { strVisibilityAttribute = 'hidden'; }
                if (selectedElement.hasAttribute('hide-on-desktop')) { strVisibilityAttribute = 'hide-on-desktop'; }
                if (selectedElement.hasAttribute('hide-on-tablet'))  { strVisibilityAttribute = 'hide-on-tablet'; }
                if (selectedElement.hasAttribute('hide-on-phone'))   { strVisibilityAttribute = 'hide-on-phone'; }
                if (selectedElement.hasAttribute('show-on-desktop')) { strVisibilityAttribute = 'show-on-desktop'; }
                if (selectedElement.hasAttribute('show-on-tablet'))  { strVisibilityAttribute = 'show-on-tablet'; }
                if (selectedElement.hasAttribute('show-on-phone'))   { strVisibilityAttribute = 'show-on-phone'; }

                addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                                '<option value="">Visible</option>' +
                                                '<option value="hidden">Invisible</option>' +
                                                '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                                '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                                '<option value="hide-on-phone">Invisible at phone size</option>' +
                                                '<option value="show-on-desktop">Visible at desktop size</option>' +
                                                '<option value="show-on-tablet">Visible at tablet size</option>' +
                                                '<option value="show-on-phone">Visible at phone size</option>' +
                                            '</gs-select>', function () {
                    selectedElement.removeAttribute('hidden');
                    selectedElement.removeAttribute('hide-on-desktop');
                    selectedElement.removeAttribute('hide-on-tablet');
                    selectedElement.removeAttribute('hide-on-phone');
                    selectedElement.removeAttribute('show-on-desktop');
                    selectedElement.removeAttribute('show-on-tablet');
                    selectedElement.removeAttribute('show-on-phone');
                    
                    if (this.value) {
                        selectedElement.setAttribute(this.value, '');
                    }
                    
                    return selectedElement;
                });
                
                addProp('Corners', true,   '<div class="target">' +
                                                '<gs-grid>\n' +
                                                '    <gs-block>\n' +
                                                '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                            selectedElement.hasAttribute('remove-top') ||
                                                                            selectedElement.hasAttribute('remove-left') ||
                                                                            selectedElement.hasAttribute('remove-top-left'))).toString() + 
                                                            '" remove-right remove-bottom id="round-top-left-corner________"></gs-checkbox>' +
                                                        
                                                '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                            selectedElement.hasAttribute('remove-bottom') ||
                                                                            selectedElement.hasAttribute('remove-left') ||
                                                                            selectedElement.hasAttribute('remove-bottom-left'))).toString() + 
                                                            '" remove-right remove-top id="round-bottom-left-corner________"></gs-checkbox>' +
                                                '    </gs-block>\n' +
                                                '    <gs-block>\n' +
                                                '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                            selectedElement.hasAttribute('remove-top') ||
                                                                            selectedElement.hasAttribute('remove-right') ||
                                                                            selectedElement.hasAttribute('remove-top-right'))).toString() + 
                                                            '" remove-left remove-bottom id="round-top-right-corner________"></gs-checkbox>' +
                                                        
                                                '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                            selectedElement.hasAttribute('remove-bottom') ||
                                                                            selectedElement.hasAttribute('remove-right') ||
                                                                            selectedElement.hasAttribute('remove-bottom-right'))).toString() + 
                                                            '" remove-left remove-top id="round-bottom-right-corner________"></gs-checkbox>' +
                                                '    </gs-block>\n' +
                                                '</gs-grid>\n' +
                                            '</div>', function () {
                    var topLeft     = document.getElementById('round-top-left-corner________').value === 'true',
                        topRight    = document.getElementById('round-top-right-corner________').value === 'true',
                        bottomLeft  = document.getElementById('round-bottom-left-corner________').value === 'true',
                        bottomRight = document.getElementById('round-bottom-right-corner________').value === 'true',
                        arrStrAttr = [], i, len;
                    
                    selectedElement.removeAttribute('remove-all');
                    selectedElement.removeAttribute('remove-top');
                    selectedElement.removeAttribute('remove-bottom');
                    selectedElement.removeAttribute('remove-left');
                    selectedElement.removeAttribute('remove-right');
                    selectedElement.removeAttribute('remove-top-left');
                    selectedElement.removeAttribute('remove-top-right');
                    selectedElement.removeAttribute('remove-bottom-left');
                    selectedElement.removeAttribute('remove-bottom-right');
                    
                    if (!topLeft && !topRight && !bottomLeft && !bottomRight) {
                        arrStrAttr.push('remove-all');
                    } else if (!topLeft && !topRight) {
                        arrStrAttr.push('remove-top');
                    } else if (!bottomLeft && !bottomRight) {
                        arrStrAttr.push('remove-bottom');
                        
                    } else if (!topLeft && !bottomLeft) {
                        arrStrAttr.push('remove-left');
                    } else if (!topRight && !bottomRight) {
                        arrStrAttr.push('remove-right');
                    }
                    
                    if (!topLeft && !bottomLeft && arrStrAttr[0] !== 'remove-all') {
                        arrStrAttr.push('remove-left');
                    } else if (!topLeft && topRight) {
                        arrStrAttr.push('remove-top-left');
                    } else if (!bottomLeft && bottomRight) {
                        arrStrAttr.push('remove-bottom-left');
                    }

                    if (!topRight && !bottomRight && arrStrAttr[0] !== 'remove-all') {
                        arrStrAttr.push('remove-right');
                    } else if (topLeft && !topRight) {
                        arrStrAttr.push('remove-top-right');
                    } else if (bottomLeft && !bottomRight) {
                        arrStrAttr.push('remove-bottom-right');
                    }

                    for (i = 0, len = arrStrAttr.length; i < len; i += 1) {
                        selectedElement.setAttribute(arrStrAttr[i], '');
                    }

                    return selectedElement;
                });

                designAdditionalFunction(selectedElement);
            };
        });
        
        document.addEventListener('DOMContentLoaded', function () {
            function handleDisable(element) {
                var i, len;

                element.removeAttribute('disabled');

                for (i = 0, len = arrDisableWhenEmptyAttributes.length; i < len; i += 1) {
                    if (!element.getAttribute(arrDisableWhenEmptyAttributes[i])) {
                        element.setAttribute('disabled', '');
                        break;
                    }
                }
            }

            //function pushReplacePopHandler(element) {
            //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');

            //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
            //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
            //    }
            //}
            function saveDefaultAttributes(element) {
                var i;
                var len;
                var arrAttr;
                var jsnAttr;
        
                // we need a place to store the attributes
                element.internal.defaultAttributes = {};
        
                // loop through attributes and store them in the internal defaultAttributes object
                arrAttr = element.attributes;
                i = 0;
                len = arrAttr.length;
                while (i < len) {
                    jsnAttr = arrAttr[i];
        
                    element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');
        
                    i += 1;
                }
            }
        
            function pushReplacePopHandler(element) {
                var i;
                var len;
                var strQS = GS.getQueryString();
                var strQSCol = element.getAttribute('qs');
                var strQSValue;
                var strQSAttr;
                var arrQSParts;
                var arrAttrParts;
                var strOperator;

                if (strQSCol.indexOf('=') !== -1) {
                    arrAttrParts = strQSCol.split(',');
                    i = 0;
                    len = arrAttrParts.length;
                    while (i < len) {
                        strQSCol = arrAttrParts[i];

                        if (strQSCol.indexOf('!=') !== -1) {
                            strOperator = '!=';
                            arrQSParts = strQSCol.split('!=');
                        } else {
                            strOperator = '=';
                            arrQSParts = strQSCol.split('=');
                        }

                        strQSCol = arrQSParts[0];
                        strQSAttr = arrQSParts[1] || arrQSParts[0];

                        // if the key is not present or we've got the negator: go to the attribute's default or remove it
                        if (strOperator === '!=') {
                            // if the key is not present: add the attribute
                            if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                                element.setAttribute(strQSAttr, '');
                            // else: remove the attribute
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        } else {
                            // if the key is not present: go to the attribute's default or remove it
                            if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                                if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                    element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                                } else {
                                    element.removeAttribute(strQSAttr);
                                }
                            // else: set attribute to exact text from QS
                            } else {
                                element.setAttribute(strQSAttr, (
                                    GS.qryGetVal(strQS, strQSCol) ||
                                    element.internal.defaultAttributes[strQSAttr] ||
                                    ''
                                ));
                            }
                        }
                        i += 1;
                    }
                } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                    strQSValue = GS.qryGetVal(strQS, strQSCol);

                    if (element.internal.bolQSFirstRun !== true) {
                        if (strQSValue !== '' || !element.getAttribute('value')) {
                            element.setAttribute('value', strQSValue);
                        }
                    } else {
                        element.setAttribute('value', strQSValue);
                    }
                }

                element.internal.bolQSFirstRun = true;
            }

            // dont do anything that modifies the element here
            function elementCreated(element) {
                // if "created" hasn't been suspended: run created code
                if (!element.hasAttribute('suspend-created')) {

                }
            }

            //
            function elementInserted(element) {
                var strKey, strQSValue;

                if (element.tagName.toUpperCase() === 'GS-DELETE-BUTTON' && !element.hasAttribute('src')) {
                    console.warn(element, 'gs-delete-button needs a [src=""] attribute!');
                }

                // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
                if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    // if this is the first time inserted has been run: continue
                    if (!element.inserted) {
                        element.inserted = true;
                        element.internal = {};
                        saveDefaultAttributes(element);

                        if (element.getAttribute('qs')) {
                            //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                            //if (strQSValue !== '' || !element.getAttribute('value')) {
                            //    element.setAttribute('value', strQSValue);
                            //}
                            pushReplacePopHandler(element);
                            window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                            window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                            window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                        }

                        // add a tabindex to allow focus (if allowed)
                        if (!element.hasAttribute('no-focus')) {
                            if ((!element.tabIndex) || element.tabIndex === -1) {
                                element.tabIndex = 0;
                            }
                        } else {
                            element.removeAttribute('tabindex');
                        }
                        
                        if (!evt.touchDevice) {
                            element.addEventListener(evt.mousedown, function (event) {
                                element.classList.add('down');
                            });
                            
                            element.addEventListener(evt.mouseout, function (event) {
                                element.classList.remove('down');
                                element.classList.remove('hover');
                            });
                            
                            element.addEventListener(evt.mouseover, function (event) {
                                element.classList.remove('down');
                                element.classList.add('hover');
                            });
                            
                            element.addEventListener('keydown', function (event) {
                                if (!element.hasAttribute('disabled') && !element.classList.contains('down') &&
                                    (event.keyCode === 13 || event.keyCode === 32)) {
                                    
                                    element.classList.add('down');
                                }
                            });
                            
                            element.addEventListener('keyup', function (event) {
                                // if we are not disabled and we pressed return (13) or space (32): trigger click
                                if (!element.hasAttribute('disabled') && element.classList.contains('down') &&
                                    (event.keyCode === 13 || event.keyCode === 32)) {
                                    GS.triggerEvent(element, 'click');
                                }
                            });
                        }
                        
                        element.addEventListener('click', function (event) {
                            element.classList.remove('down');
                            clickFunction(element);
                        });
                        
                        element.addEventListener('keypress', function (event) {
                            // if we pressed return (13) or space (32): prevent default and stop propagation (to prevent scrolling of the page)
                            if (event.keyCode === 13 || event.keyCode === 32) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        });
                        
                        if (element.getAttribute('key')) {
                            strKey = element.getAttribute('key');
                            
                            if (GS.keyCode(strKey)) {
                                if (strKey.match(/[arfcvxzntypq]/gim)) {
                                    console.warn('gs-skype-button Warning: by setting the hot key of this button to "' + strKey + '" you may be overriding browser functionality.', element);
                                }
                                
                                window.addEventListener('keydown', function (event) {
                                    if (String(event.keyCode || event.which) === GS.keyCode(strKey) &&
                                        (
                                            (element.hasAttribute('no-modifier-key') && !event.metaKey && !event.ctrlKey) ||
                                            (!element.hasAttribute('no-modifier-key') && (event.metaKey || event.ctrlKey))
                                        )) {
                                        event.preventDefault();
                                        event.stopPropagation();
                                        
                                        element.focus();
                                        GS.triggerEvent(element, 'click');
                                    }
                                });
                                
                            } else if (strKey.length > 1) {
                                console.error('gs-skype-button Error: \'key="' + strKey + '"\' is not a valid hot-key.', element);
                            }
                        }
                        
                        handleDisable(element);
                    }
                }
            }
            
            xtag.register(strTagName, {
                lifecycle: {
                    created: function () {
                        elementCreated(this);
                    },
                    
                    inserted: function () {
                        elementInserted(this);
                    },
                    
                    attributeChanged: function (strAttrName, oldValue, newValue) {
                        // if "suspend-created" has been removed: run created and inserted code
                        if (strAttrName === 'suspend-created' && newValue === null) {
                            elementCreated(this);
                            elementInserted(this);
                            
                        // if "suspend-inserted" has been removed: run inserted code
                        } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                            elementInserted(this);
                            
                        } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                            if (strAttrName === 'no-focus') {
                                if (!this.hasAttribute('no-focus')) {
                                    if ((!this.tabIndex) || this.tabIndex === -1) {
                                        this.tabIndex = 0;
                                    }
                                } else {
                                    this.removeAttribute('tabindex');
                                }
                            } else if (strAttrName === 'disabled') {
                                this.classList.remove('down');
                            } else if (arrDisableWhenEmptyAttributes.indexOf(strAttrName) > -1) {
                                handleDisable(this);
                            }
                        }
                    }
                },
                accessors: {
                    value: {
                        get: function () {
                            return this.getAttribute('value');
                        },
                        set: function (newValue) {
                            this.setAttribute('value', newValue);
                        }
                    }
                }
            });
        });
    }
    
    
    
    defineButton('gs-email-button', '', ['value'], '', function (element) {
        var emailAddress = element.getAttribute('value'), linkIframe, mousedownHandler;
        
        if (emailAddress) {
            linkIframe = document.createElement('iframe');
            document.body.appendChild(linkIframe);
            
            linkIframe.setAttribute('src', 'mailto:' + emailAddress);
            
            mousedownHandler = function () {
                document.body.removeChild(linkIframe);
                window.removeEventListener('mousedown', mousedownHandler);
            };
            
            window.addEventListener('mousedown', mousedownHandler);
        }
    });
    
    defineButton('gs-facetime-button', '', ['value'], '', function (element) {
        var appleID = element.getAttribute('value');
        
        if (appleID) {
            window.open('facetime:' + appleID);
        }
    });
    
    defineButton('gs-map-button', '', ['value'], '', function (element) {
        var strLocation = encodeURIComponent(element.getAttribute('value'));
        
        if (strLocation) {
            if (element.hasAttribute('google') === true) {
                window.open('https://maps.google.com/maps?q=' + strLocation);
            } else if (element.hasAttribute('bing') === true) {
                window.open('http://www.bing.com/maps/default.aspx?q=' + strLocation);
            } else {
                window.open('https://maps.google.com/maps?q=' + strLocation);
            }
        }
    });
    
    defineButton('gs-phone-button', '', ['value'], '', function (element) {
        var phoneNumber = element.getAttribute('value');
        
        if (phoneNumber) {
            if (evt.deviceType === 'phone') {
                window.open('tel:' + phoneNumber);
                   
            } else {
                GS.msgbox('Phone Number', '<center>' + phoneNumber + '</center>', ['Done']);
            }
        }
    });
    
    defineButton('gs-tracking-button', '', ['value'], function (selectedElement) {
        var strService = '';
        
               if (selectedElement.hasAttribute('usps'))  { strService = 'usps';
        } else if (selectedElement.hasAttribute('ups'))   { strService = 'ups';
        } else if (selectedElement.hasAttribute('fedex')) { strService = 'fedex';
        } else if (selectedElement.hasAttribute('royal')) { strService = 'royal';
        } else if (selectedElement.hasAttribute('amz'))   { strService = 'amz'; }
        
        addProp('Service', true, '<gs-select class="target" value="' + strService + '" mini>' +
                                            '   <option value="">None</option>' +
                                            '   <option value="usps">USPS</option>' +
                                            '   <option value="ups">UPS</option>' +
                                            '   <option value="fedex">FEDEX</option>' +
                                            '   <option value="royal">Royal Mail</option>' +
                                            '   <option value="amz">Amazon</option>' +
                                            '</gs-select>', function () {
            selectedElement.removeAttribute('usps');
            selectedElement.removeAttribute('ups');
            selectedElement.removeAttribute('fedex');
            selectedElement.removeAttribute('royal');
            selectedElement.removeAttribute('amazon');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
    }, function (element) {
        var strTrackingNumber = element.getAttribute('value');
        
        if (strTrackingNumber) {
            if (element.hasAttribute('usps') === true) {
                window.open(' https://tools.usps.com/go/TrackConfirmAction?tLabels=' + strTrackingNumber);
                
            } else if (element.hasAttribute('ups') === true) {
                window.open('http://www.ups.com/WebTracking/processInputRequest?tracknum=' + strTrackingNumber);
                
            } else if (element.hasAttribute('fedex') === true) {
                window.open('https://www.fedex.com/apps/fedextrack/index.html?tracknumbers=' + strTrackingNumber);
                
            } else if (element.hasAttribute('royal') === true) {
                window.open('https://www.royalmail.com/track-your-item?trackNumber=' + strTrackingNumber);
                
            } else if (element.hasAttribute('amz') === true) {
                window.open(strTrackingNumber);
                
            } else {
                GS.msgbox('Please Choose...',
                          '<center>Please Choose UPS, USPS, Fedex, Royal Mail or Amazon</center>',
                          ['UPS', 'USPS', 'Fedex', 'Royal Mail', 'Amazon'],
                          function (strAnswer) {
                    if (strAnswer === 'UPS') {
                        window.open('http://www.ups.com/WebTracking/processInputRequest?tracknum=' + strTrackingNumber);
                    } else if (strAnswer === 'USPS') {
                         window.open('https://tools.usps.com/go/TrackConfirmAction?tLabels=' + strTrackingNumber);
                    } else if (strAnswer === 'Fedex') {
                         window.open('https://www.fedex.com/apps/fedextrack/index.html?tracknumbers=' + strTrackingNumber);
                    } else if (strAnswer === 'Royal Mail') {
                         window.open('https://www.royalmail.com/track-your-item?trackNumber' + strTrackingNumber);
                    } else if (strAnswer === 'Amazon') {
                         window.open(strTrackingNumber);
                    }
                });
            }
        }
    });
    
    defineButton('gs-skype-button', '', ['value'], '', function (element) {
        if (element.getAttribute('value')) {
            window.open('skype:' + element.getAttribute('value'));
        }
    });
    
    defineButton('gs-delete-button',
                 '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-delete-button.html',
                 ['value', 'src'],
                 function (selectedElement) {
        addProp('Source', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('src') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', this.value, false);
        });
        
        addProp('Delete Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-delete') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'action-delete', this.value);
        });
        
    }, function (element) {
        if (element.getAttribute('value')) {
            if (window.bolSocket === true) {
                var arrSrcParts = element.getAttribute('src').split('.')
                  , strSchema = arrSrcParts[0]
                  , strObject = arrSrcParts[1]
                  , strPkColumn, strLockColumn
                  , deleteRecordData, strHashColumns, strRoles, strColumns, strRecord
                  , strDeleteData, strHash, strPkValue, strLockValue;
                
                element.classList.remove('down');
                
                strPkColumn = element.getAttribute('column') || 'id';
                strLockColumn = strPkColumn;
                strHashColumns = strLockColumn;
                
                strPkValue = GS.encodeForTabDelimited(element.getAttribute('value') || '');
                strLockValue = element.getAttribute('value') || '';
                
                strRoles = 'pk\thash';
                strColumns = strPkColumn + '\thash';
                
                strHash = CryptoJS.MD5(strLockValue === 'NULL' ? '' : strLockValue).toString();
                
                strDeleteData = strPkValue + '\t' + strHash + '\n';
                strDeleteData = strRoles + '\n' + strColumns + '\n' + strDeleteData;
                
                // create delete transaction
                GS.addLoader(element, 'Creating Delete Transaction...');
                GS.requestDeleteFromSocket(
                    GS.envSocket, strSchema, strObject, strHashColumns, strDeleteData
                    , function (data, error, transactionID) {
                        if (error) {
                            GS.removeLoader(element);
                            GS.webSocketErrorDialog(data);
                        }
                    }
                    , function (data, error, transactionID, commitFunction, rollbackFunction) {
                        var arrElements, i, len, templateElement;
                        GS.removeLoader(element);
                        
                        if (!error) {
                            if (data !== 'TRANSACTION COMPLETED') {
                                
                            } else {
                                templateElement = document.createElement('template');
                                templateElement.innerHTML = ml(function () {/*
                                    <gs-page>
                                        <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                        <gs-body padded>
                                            <center>Are you sure you want to delete?</center>
                                        </gs-body>
                                        <gs-footer>
                                            <gs-grid>
                                                <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                                <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                            </gs-grid>
                                        </gs-footer>
                                    </gs-page>
                                */});
                                
                                GS.openDialog(templateElement, function () {
                                    document.getElementById('datasheet-focus-me').focus();
                                    
                                }, function (event, strAnswer) {
                                    if (strAnswer === 'Yes') {
                                        commitFunction();
                                        GS.addLoader(element, 'Commiting Delete Transaction...');
                                    } else {
                                        rollbackFunction();
                                        GS.addLoader(element, 'Rolling Back Delete Transaction...');
                                    }
                                });
                            }
                            
                        } else {
                            rollbackFunction();
                            GS.webSocketErrorDialog(data);
                        }
                    }
                    , function (strAnswer, data, error) {
                        var arrElements, i, len;
                        GS.removeLoader(element);
                        
                        if (!error) {
                            if (strAnswer === 'COMMIT') {
                                GS.triggerEvent(element, 'success');
                                if (element.hasAttribute('onsuccess')) {
                                    new Function(element.getAttribute('onsuccess')).apply(element);
                                }
                            }
                            
                        } else {
                            getData(element);
                            GS.webSocketErrorDialog(data);
                        }
                    }
                );
            } else {
                GS.msgbox('Are you sure...', '<center>Are you sure you want to delete?</center>', ['No', 'Yes'], function (strAnswer) {
                    if (strAnswer === 'Yes') {
                        GS.addLoader('gs-delete', 'Deleting Record...');
                        
                        GS.ajaxJSON('/' + (element.getAttribute('action-delete') || 'env/action_delete'),
                                    'src=' + encodeURIComponent(GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src')))) +
                                    '&id=' + element.getAttribute('value'),
                                    function (data, error) {
                            GS.removeLoader('gs-delete');
                            
                            if (!error) {
                                GS.triggerEvent(element, 'success');
                                if (element.hasAttribute('onsuccess')) {
                                    new Function(element.getAttribute('onsuccess')).apply(element);
                                }
                                
                            } else {
                                GS.ajaxErrorDialog(data);
                            }
                        });
                    }
                });
            }
        }
    });
    
    defineButton('gs-option',
                 '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-optionbox.html',
                 [],
                 function (selectedElement) {},
                 function (element) {});
    
    defineButton('gs-dialog-button',
        '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-dialog-button.html',
        [],
        function (selectedElement) { // design code
            addProp('Template', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('template') || '') + '" mini></gs-text>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'template', this.value, false);
            });
            
            addProp('Attach To Element', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('target-element') || '') + '" mini></gs-text>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'target-element', this.value, false);
            });
            
            addProp('Attachment Direction', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('direction') || '') + '" mini>' +
                                                        '<option value="">Default</option>' +
                                                        '<option value="left">Left</option>' +
                                                        '<option value="right">Right</option>' +
                                                        '<option value="up">Up</option>' +
                                                        '<option value="down">Down</option>' +
                                                  '</gs-select>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'direction', this.value, false);
            });
            
            addProp('Before Open JS', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('before-open') || '') + '" mini></gs-text>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'before-open', this.value, false);
            });
            
            addProp('After Open JS', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('after-open') || '') + '" mini></gs-text>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'after-open', this.value, false);
            });
            
            addProp('Before Close JS', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('before-close') || '') + '" mini></gs-text>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'before-close', this.value, false);
            });
            
            addProp('After Close JS', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('after-close') || '') + '" mini></gs-text>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'after-close', this.value, false);
            });
        },
        function (element) {// on click
            var targetElement
              , strTemplate = element.getAttribute('template')
              , templateElement
              , strTargetSelector = element.getAttribute('target')
              , strDirection = element.getAttribute('direction')
              , strBeforeOpen = element.getAttribute('before-open')
              , strAfterOpen = element.getAttribute('after-open')
              , strBeforeClose = element.getAttribute('before-close')
              , strAfterClose = element.getAttribute('after-close')
              , afterOpenFunction
              , beforeCloseFunction
              , afterCloseFunction;
            
            templateElement = (strTemplate ? document.getElementById(strTemplate) : xtag.queryChildren(element, 'template')[0]);
            //console.log(templateElement);
            
            if (templateElement) {
                if (strBeforeOpen) {
                    new Function(strBeforeOpen).apply(element);
                }
                GS.triggerEvent(element, 'before-open');
                
                afterOpenFunction = function () {
                    if (strAfterOpen) {
                        new Function(strAfterOpen).apply(this);
                    }
                    GS.triggerEvent(element, 'after-open');
                };
                
                beforeCloseFunction = function (event, strAnswer) {
                    // if there is a before close function: run the code
                    if (strBeforeClose) {
                        // append a definition for the "strAnswer" variable before the code (the replace calls are to make the string safe)
                        new Function('var strAnswer = \'' + strAnswer.replace(/'/g, 'donTGueSsThiSUniTokEN1975') + '\'' +
                                                    '.replace(/donTGueSsThiSUniTokEN1975/g, \'\\\'\');\n' + strBeforeClose).apply(this);
                    }
                    GS.triggerEvent(element, 'before-close', {'strAnswer': strAnswer});
                };
                
                afterCloseFunction = function (event, strAnswer) {
                    // if there is a after close function: run the code
                    if (strAfterClose) {
                        // append a definition for the "strAnswer" variable before the code (the replace calls are to make the string safe)
                        new Function('var strAnswer = \'' + strAnswer.replace(/'/g, 'donTGueSsThiSUniTokEN1975') + '\'' +
                                                    '.replace(/donTGueSsThiSUniTokEN1975/g, \'\\\'\');\n' + strAfterClose).apply(element);
                    }
                    GS.triggerEvent(element, 'after-close', {'strAnswer': strAnswer});
                };
                
                if (strTargetSelector || element.hasAttribute('target')) {
                    strTargetSelector = (strTargetSelector || 'this');
                    targetElement = (strTargetSelector === 'this' ? element : document.querySelector(strTargetSelector));
                    strDirection = (strDirection || 'down');
                    
                    GS.openDialogToElement(targetElement, templateElement, strDirection,
                                            afterOpenFunction, beforeCloseFunction, afterCloseFunction);
                    
                } else {
                    GS.openDialog(templateElement, afterOpenFunction, beforeCloseFunction, afterCloseFunction);
                }
            }
        });
})();














window.addEventListener('design-register-element', function () {
    
    registerDesignSnippet('<gs-button>', '<gs-button>', 'gs-button>${1}</gs-button>');
    
    designRegisterElement('gs-button', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-buttons-toggle.html');
    
    window.designElementProperty_GSBUTTON = function(selectedElement) {
        var strIconPos, strIconRotation;
        
        addProp('Icon', true, '<div flex-horizontal>' +
                              '     <gs-text id="prop-icon-input" class="target" value="' + (selectedElement.getAttribute('icon') || '') + '" mini flex></gs-text>' +
                              '     <gs-button id="prop-icon-picker-button" mini icononly icon="list"></gs-button>' +
                              '     <style>#prop-icon-picker-button:after {font-size: 1em;}</style>' +
                              '</div>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'icon', this.value);
        });
        
        document.getElementById('prop-icon-picker-button').addEventListener('click', function () {
            var i, len, html, arrIcons = GS.iconList(), strName, templateElement;
            
            for (i = 0, len = arrIcons.length, html = ''; i < len; i += 1) {
                strName = arrIcons[i].name;
                html += '<gs-block>' +
                            '<gs-button iconleft icon="' + strName + '" dialogclose>' + strName + '</gs-button>' +
                        '</gs-block>';
            }
            
            templateElement = document.createElement('template');
            templateElement.setAttribute('data-max-width', '1100px');
            
            templateElement.innerHTML = ml(function () {/*
                <gs-page>
                    <gs-header><center><h3>Choose An Icon</h3></center></gs-header>
                    <gs-body padded>
                        <gs-grid widths="1,1,1,1" reflow-at="767px">{{HTML}}</gs-grid>
                    </gs-body>
                    <gs-footer><gs-button dialogclose>Cancel</gs-button></gs-footer>
                </gs-page>
            */}).replace('{{HTML}}', html);
            
            GS.openDialog(templateElement, '', function (event, strAnswer) {
                var propInput = document.getElementById('prop-icon-input');
                
                if (strAnswer !== 'Cancel') {
                    propInput.value = strAnswer;
                    GS.triggerEvent(propInput, 'change');
                }
            });
        });
        
        // iconleft
        // iconright
        // icontop
        // iconbottom
        // icononly
               if (selectedElement.hasAttribute('iconleft'))   { strIconPos = 'iconleft';
        } else if (selectedElement.hasAttribute('iconright'))  { strIconPos = 'iconright';
        } else if (selectedElement.hasAttribute('icontop'))    { strIconPos = 'icontop';
        } else if (selectedElement.hasAttribute('iconbottom')) { strIconPos = 'iconbottom';
        } else if (selectedElement.hasAttribute('icononly'))   { strIconPos = 'icononly';
        } else { strIconPos = ''; }
        
        addProp('Icon Position', true, '<gs-select class="target" value="' + strIconPos + '" mini>' +
                                        '   <option value="">Default</option>' +
                                        '   <option value="iconleft">Left</option>' +
                                        '   <option value="iconright">Right</option>' +
                                        '   <option value="icontop">Top</option>' +
                                        '   <option value="iconbottom">Bottom</option>' +
                                        '   <option value="icononly">Icononly</option>' +
                                        '</gs-select>', function () {
            selectedElement.removeAttribute('iconleft');
            selectedElement.removeAttribute('iconright');
            selectedElement.removeAttribute('icontop');
            selectedElement.removeAttribute('iconbottom');
            selectedElement.removeAttribute('icononly');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        // None
        // 90 degrees  (iconrotateright)
        // 180 degrees (iconrotatedown)
        // 270 degrees (iconrotateleft)
               if (selectedElement.hasAttribute('iconrotateright')) { strIconRotation = 'iconrotateright';
        } else if (selectedElement.hasAttribute('iconrotatedown'))  { strIconRotation = 'iconrotatedown';
        } else if (selectedElement.hasAttribute('iconrotateleft'))  { strIconRotation = 'iconrotateleft';
        } else { strIconRotation = ''; }
        
        addProp('Icon&nbsp;Rotation', true, '<gs-select class="target" value="' + strIconRotation + '" mini>' +
                                            '   <option value="">None</option>' +
                                            '   <option value="iconrotateright">90 degrees</option>' +
                                            '   <option value="iconrotatedown">180 degrees</option>' +
                                            '   <option value="iconrotateleft">270 degrees</option>' +
                                            '</gs-select>', function () {
            selectedElement.removeAttribute('iconrotateright');
            selectedElement.removeAttribute('iconrotatedown');
            selectedElement.removeAttribute('iconrotateleft');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        addProp('Href', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('href') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'href', this.value, false);
        });
        if (selectedElement.getAttribute('href')) {
            addProp('Target', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('target') || '') + '" mini>' +
                                        '<option value="">New Window</option>' +
                                        '<option value="_self">Current Window</option>' +
                                    '</gs-select>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'target', this.value, false);
            });
        }
        
        addProp('Jumbo', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('jumbo')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'jumbo', (this.value === 'true'), true);
        });
        
        addProp('Focusable', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-focus')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-focus', (this.value === 'true'), false);
        });
        
        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '0') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });
        
        addProp('Inline', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('inline')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'inline', (this.value === 'true'), true);
        });
        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });
        /*
        addProp('Emphasis', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('emphasis')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'emphasis', (this.value === 'true'), true);
        });
        */
        
        //<gs-button txt-info bg-success>
        
        // Font Color attributes
        var strFontAttribute = '';
        if (selectedElement.hasAttribute('txt-primary'))  { strFontAttribute = 'txt-primary'; }
        if (selectedElement.hasAttribute('txt-success'))  { strFontAttribute = 'txt-success'; }
        if (selectedElement.hasAttribute('txt-info'))     { strFontAttribute = 'txt-info'; }
        if (selectedElement.hasAttribute('txt-warning'))  { strFontAttribute = 'txt-warning'; }
        if (selectedElement.hasAttribute('txt-danger'))   { strFontAttribute = 'txt-danger'; }
        
        addProp('Font Color', true, '<gs-select class="target" value="' + strFontAttribute + '" mini>' +
                                        '<option value="">Default</option>' +
                                        '<option value="txt-primary">Primary</option>' +
                                        '<option value="txt-success">Success</option>' +
                                        '<option value="txt-info">Info</option>' +
                                        '<option value="txt-warning">Warning</option>' +
                                        '<option value="txt-danger">Danger</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('txt-primary');
            selectedElement.removeAttribute('txt-success');
            selectedElement.removeAttribute('txt-info');
            selectedElement.removeAttribute('txt-warning');
            selectedElement.removeAttribute('txt-danger');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        // Background Color attributes
        var strBackgroundAttribute = '';
        if (selectedElement.hasAttribute('bg-primary'))  { strBackgroundAttribute = 'bg-primary'; }
        if (selectedElement.hasAttribute('bg-success'))  { strBackgroundAttribute = 'bg-success'; }
        if (selectedElement.hasAttribute('bg-info'))     { strBackgroundAttribute = 'bg-info'; }
        if (selectedElement.hasAttribute('bg-warning'))  { strBackgroundAttribute = 'bg-warning'; }
        if (selectedElement.hasAttribute('bg-danger'))   { strBackgroundAttribute = 'bg-danger'; }
        
        addProp('Background Color', true, '<gs-select class="target" value="' + strBackgroundAttribute + '" mini>' +
                                        '<option value="">Default</option>' +
                                        '<option value="bg-primary">Primary</option>' +
                                        '<option value="bg-success">Success</option>' +
                                        '<option value="bg-info">Info</option>' +
                                        '<option value="bg-warning">Warning</option>' +
                                        '<option value="bg-danger">Danger</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('bg-primary');
            selectedElement.removeAttribute('bg-success');
            selectedElement.removeAttribute('bg-info');
            selectedElement.removeAttribute('bg-warning');
            selectedElement.removeAttribute('bg-danger');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        addProp('Key', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('key') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'key', this.value, false);
        });
        
        addProp('No Modifier Key For Hot Key', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-modifier-key') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-modifier-key', this.value === 'true', true);
        });
        
        // TEXT CONTENT
        addProp('Text', true, '<gs-text class="target" value="' + (selectedElement.textContent || '') + '" mini></gs-text>', function () {
            selectedElement.textContent = this.value;
            
            return selectedElement;
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });
        
        // DIALOGCLOSE attribute
        addProp('Dialog Close', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('dialogclose') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'dialogclose', this.value === 'true', true);
        });
        
        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))          { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop')) { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))  { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))   { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop')) { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))  { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))   { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        addProp('Corners', true,   '<div class="target">' +
                                        '<gs-grid>\n' +
                                        '    <gs-block>\n' +
                                        '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                    selectedElement.hasAttribute('remove-top') ||
                                                                    selectedElement.hasAttribute('remove-left') ||
                                                                    selectedElement.hasAttribute('remove-top-left'))).toString() + 
                                                    '" remove-right remove-bottom id="round-top-left-corner________"></gs-checkbox>' +
                                                
                                        '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                    selectedElement.hasAttribute('remove-bottom') ||
                                                                    selectedElement.hasAttribute('remove-left') ||
                                                                    selectedElement.hasAttribute('remove-bottom-left'))).toString() + 
                                                    '" remove-right remove-top id="round-bottom-left-corner________"></gs-checkbox>' +
                                        '    </gs-block>\n' +
                                        '    <gs-block>\n' +
                                        '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                    selectedElement.hasAttribute('remove-top') ||
                                                                    selectedElement.hasAttribute('remove-right') ||
                                                                    selectedElement.hasAttribute('remove-top-right'))).toString() + 
                                                    '" remove-left remove-bottom id="round-top-right-corner________"></gs-checkbox>' +
                                                
                                        '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                    selectedElement.hasAttribute('remove-bottom') ||
                                                                    selectedElement.hasAttribute('remove-right') ||
                                                                    selectedElement.hasAttribute('remove-bottom-right'))).toString() + 
                                                    '" remove-left remove-top id="round-bottom-right-corner________"></gs-checkbox>' +
                                        '    </gs-block>\n' +
                                        '</gs-grid>\n' +
                                    '</div>', function () {
            var topLeft     = document.getElementById('round-top-left-corner________').value === 'true',
                topRight    = document.getElementById('round-top-right-corner________').value === 'true',
                bottomLeft  = document.getElementById('round-bottom-left-corner________').value === 'true',
                bottomRight = document.getElementById('round-bottom-right-corner________').value === 'true',
                arrStrAttr = [], i, len;
            
            selectedElement.removeAttribute('remove-all');
            selectedElement.removeAttribute('remove-top');
            selectedElement.removeAttribute('remove-bottom');
            selectedElement.removeAttribute('remove-left');
            selectedElement.removeAttribute('remove-right');
            selectedElement.removeAttribute('remove-top-left');
            selectedElement.removeAttribute('remove-top-right');
            selectedElement.removeAttribute('remove-bottom-left');
            selectedElement.removeAttribute('remove-bottom-right');
            
            if (!topLeft && !topRight && !bottomLeft && !bottomRight) {
                arrStrAttr.push('remove-all');
            } else if (!topLeft && !topRight) {
                arrStrAttr.push('remove-top');
            } else if (!bottomLeft && !bottomRight) {
                arrStrAttr.push('remove-bottom');
            } else if (!topLeft && !bottomLeft) {
                arrStrAttr.push('remove-left');
            } else if (!topRight && !bottomRight) {
                arrStrAttr.push('remove-right');
            }
            
            if (!topLeft && !bottomLeft && arrStrAttr[0] !== 'remove-all') {
                arrStrAttr.push('remove-left');
            } else if (!topLeft && topRight) {
                arrStrAttr.push('remove-top-left');
            } else if (!bottomLeft && bottomRight) {
                arrStrAttr.push('remove-bottom-left');
            }
            
            if (!topRight && !bottomRight && arrStrAttr[0] !== 'remove-all') {
                arrStrAttr.push('remove-right');
            } else if (topLeft && !topRight) {
                arrStrAttr.push('remove-top-right');
            } else if (bottomLeft && !bottomRight) {
                arrStrAttr.push('remove-bottom-right');
            }
            
            for (i = 0, len = arrStrAttr.length; i < len; i += 1) {
                selectedElement.setAttribute(arrStrAttr[i], '');
            }
            
            return selectedElement;
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
        
        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});





document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    function refreshAnchor(element) {
        var strLink = element.getAttribute('href') || element.getAttribute('value');
        
        if (element.anchorElement) {
            element.removeChild(element.anchorElement);
        }
        if (strLink) {
            element.anchorElement = document.createElement('a');
            element.anchorElement.setAttribute('gs-dynamic', '');
            element.anchorElement.setAttribute('target', element.getAttribute('target') || '_blank');
            element.anchorElement.setAttribute('href', strLink);
            
            if (element.getAttribute('onclick')) {
                element.anchorElement.setAttribute('onclick', element.getAttribute('onclick'));
            }
            
            if (element.hasAttribute('download')) {
                element.anchorElement.setAttribute('download', element.getAttribute('download'));
            }
            
            element.appendChild(element.anchorElement);
            
        }
    }
    
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.setAttribute('value', strQSValue);
            }
        }

        element.internal.bolQSFirstRun = true;
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            
        }
    }
    
    //
    function elementInserted(element) {
        var strKey;
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.getAttribute('qs')) {
                    //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.setAttribute('value', strQSValue);
                    //}
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }
                
                // add a tabindex to allow focus (if allowed)
                if (!element.hasAttribute('no-focus')) {
                    if ((!element.tabIndex) || element.tabIndex === -1) {
                        element.tabIndex = 0;
                    }
                } else {
                    element.removeAttribute('tabindex');
                }
                
                element.classList.remove('down');
                element.classList.remove('hover');
                
                if (!evt.touchDevice) {
                    element.addEventListener(evt.mousedown, function (event) {
                        element.classList.add('down');
                    });
                    
                    element.addEventListener(evt.mouseout, function (event) {
                        element.classList.remove('down');
                        element.classList.remove('hover');
                    });
                    
                    element.addEventListener(evt.mouseover, function (event) {
                        element.classList.remove('down');
                        element.classList.add('hover');
                    });
                    
                    element.addEventListener('keydown', function (event) {
                        if (!element.hasAttribute('disabled') &&
                            (event.keyCode === 13 || event.keyCode === 32)) {
                            element.classList.add('down');
                        }
                    });
                    
                    element.addEventListener('keyup', function (event) {
                        // if we are not disabled and we pressed return (13) or space (32): trigger click
                        if (!element.hasAttribute('disabled') && element.classList.contains('down') &&
                            (event.keyCode === 13 || event.keyCode === 32)) {
                            GS.triggerEvent(element, 'click');
                        }
                    });
                }
                
                refreshAnchor(element);
                
                element.addEventListener('click', function (event) {
                    element.classList.remove('down');
                });
                
                element.addEventListener('keypress', function (event) {
                    // if we pressed return (13) or space (32): prevent default and stop propagation (to prevent scrolling of the page)
                    if (event.keyCode === 13 || event.keyCode === 32) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                });
                
                strKey = element.getAttribute('key');
                
                if (strKey) {
                    if (GS.keyCode(strKey)) {
                        if (strKey.match(/[arfcvxzntypq]/gim)) {
                            console.warn('gs-button Warning: by setting the hot key of this button to "' + strKey + '" you may be overriding browser functionality.', element);
                        }
                        
                        window.addEventListener('keydown', function (event) {
                            if (
                                    String(event.keyCode || event.which) === GS.keyCode(strKey) &&
                                    (
                                        (
                                            element.hasAttribute('no-modifier-key') &&
                                            !event.metaKey &&
                                            !event.ctrlKey
                                        ) ||
                                        (
                                            !element.hasAttribute('no-modifier-key') &&
                                            (event.metaKey || event.ctrlKey)
                                        )
                                    )
                                ) {
                                event.preventDefault();
                                event.stopPropagation();
                                
                                element.focus();
                                GS.triggerEvent(element, 'click');
                            }
                        });
                        
                    } else if (strKey.length > 1) {
                        console.error('gs-button Error: \'key="' + strKey + '"\' is not a valid hot-key.', element);
                    }
                }
            }
        }
    }
    
    xtag.register('gs-button', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'no-focus') {
                        if (!this.hasAttribute('no-focus') && !this.hasAttribute('tabindex')) {
                            this.setAttribute('tabindex', 0);
                        } else if (this.hasAttribute('no-focus')) {
                            this.removeAttribute('tabindex');
                        }
                    } else if (strAttrName === 'disabled') {
                        this.classList.remove('down');
                        
                    } else if (strAttrName === 'href' || strAttrName === 'target' || strAttrName === 'onclick' || strAttrName === 'download') {
                        refreshAnchor(this);
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-checkbox>', '<gs-checkbox>', 'gs-checkbox type="smallint" column="${1:ready_to_ship}">${2}</gs-checkbox>');
    registerDesignSnippet('<gs-checkbox> With Label', '<gs-checkbox>',
                    'label for="${1:date-insert-ready_to_ship}">${2:Ready To Ship?}:</label>\n' +
                    '<gs-checkbox id="${1:date-insert-ready_to_ship}" type="smallint" column="${3:ready_to_ship}"></gs-checkbox>');

    designRegisterElement('gs-checkbox',
                            '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-checkbox.html');

    window.designElementProperty_GSCHECKBOX = function(selectedElement) {
        var strVisibilityAttribute;

        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Triple State', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('triplestate')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'triplestate', (this.value === 'true'), true);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        addProp('Inline', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('inline')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'inline', (this.value === 'true'), true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        addProp('Type', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('type') || '') + '" mini>' +
                                        '<option value="">Detect</option>' +
                                        '<option value="smallint">Smallint</option>' +
                                        '<option value="boolean">Boolean</option>' +
                                    '</gs-select>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'type', this.value);
        });

        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });
        
        addProp('Corners', true,   '<div class="target">' +
                    '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                selectedElement.hasAttribute('remove-top') ||
                                                selectedElement.hasAttribute('remove-left') ||
                                                selectedElement.hasAttribute('remove-top-left'))).toString() + 
                            '" remove-right remove-bottom id="round-top-left-corner________" inline></gs-checkbox>' +
                            
                    '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                selectedElement.hasAttribute('remove-top') ||
                                                selectedElement.hasAttribute('remove-right') ||
                                                selectedElement.hasAttribute('remove-top-right'))).toString() + 
                            '" remove-left remove-bottom id="round-top-right-corner________" inline></gs-checkbox><br />' +
                            
                    '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                selectedElement.hasAttribute('remove-bottom') ||
                                                selectedElement.hasAttribute('remove-left') ||
                                                selectedElement.hasAttribute('remove-bottom-left'))).toString() + 
                            '" remove-right remove-top id="round-bottom-left-corner________" inline></gs-checkbox>' +
                            
                    '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                selectedElement.hasAttribute('remove-bottom') ||
                                                selectedElement.hasAttribute('remove-right') ||
                                                selectedElement.hasAttribute('remove-bottom-right'))).toString() + 
                            '" remove-left remove-top id="round-bottom-right-corner________" inline></gs-checkbox>' +
                '</div>', function () {
            var topLeft =       document.getElementById('round-top-left-corner________').value === 'true',
                topRight =    document.getElementById('round-top-right-corner________').value === 'true',
                bottomLeft =    document.getElementById('round-bottom-left-corner________').value === 'true',
                bottomRight = document.getElementById('round-bottom-right-corner________').value === 'true',
                arrStrAttr = [], i, len;
            
            selectedElement.removeAttribute('remove-all');
            selectedElement.removeAttribute('remove-top');
            selectedElement.removeAttribute('remove-bottom');
            selectedElement.removeAttribute('remove-left');
            selectedElement.removeAttribute('remove-right');
            selectedElement.removeAttribute('remove-top-left');
            selectedElement.removeAttribute('remove-top-right');
            selectedElement.removeAttribute('remove-bottom-left');
            selectedElement.removeAttribute('remove-bottom-right');
            
            if (!topLeft && !topRight && !bottomLeft && !bottomRight) {
                arrStrAttr.push('remove-all');
                
            } else if (!topLeft && !topRight) {
                arrStrAttr.push('remove-top');
            } else if (!bottomLeft && !bottomRight) {
                arrStrAttr.push('remove-bottom');
                
            } else if (!topLeft && !bottomLeft) {
                arrStrAttr.push('remove-left');
            } else if (!topRight && !bottomRight) {
                arrStrAttr.push('remove-right');
            }
            
            if (!topLeft && !bottomLeft && arrStrAttr[0] !== 'remove-all') {
                arrStrAttr.push('remove-left');
            } else if (!topLeft && topRight) {
                arrStrAttr.push('remove-top-left');
            } else if (!bottomLeft && bottomRight) {
                arrStrAttr.push('remove-bottom-left');
            }
            
            if (!topRight && !bottomRight && arrStrAttr[0] !== 'remove-all') {
                arrStrAttr.push('remove-right');
            } else if (topLeft && !topRight) {
                arrStrAttr.push('remove-top-right');
            } else if (bottomLeft && !bottomRight) {
                arrStrAttr.push('remove-bottom-right');
            }
            
            for (i = 0, len = arrStrAttr.length; i < len; i += 1) {
                selectedElement.setAttribute(arrStrAttr[i], '');
            }
            
            return selectedElement;
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
        
        //// SUSPEND-CREATED attribute
        //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
        //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        //});
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }

        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                element.internal.bolQSFirstRun = true;
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};

                // save default attribute settings so that the qs code can access those values
                saveDefaultAttributes(element);

                // if this checkbox has the "qs" attribute: fill from querystring and bind to querystring
                if (element.hasAttribute('qs')) {
                    pushReplacePopHandler(element);

                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }

                // default value to false
                if (element.getAttribute('type') === 'smallint') {
                    element.value = element.getAttribute('value') || 0;
                } else {
                    element.value = element.getAttribute('value') || false;
                }

                // add a tabindex to allow focus
                if (!element.hasAttribute('tabindex')) {
                    element.tabIndex = 0;
                }
            }
        }
    }

    xtag.register('gs-checkbox', {
        lifecycle: {
            created: function () {
                // if the value was set before the "created" lifecycle code runs: set attribute
                //      (discovered when trying to set a value of a date control in the after_open of a dialog)
                //      ("delete" keyword added because of firefox)
                if (!this.getAttribute('value') &&
                    this.value !== null &&
                    this.value !== undefined &&
                    (
                        typeof this.value === 'boolean' ||
                        this.value === '-1' ||
                        this.value === '0' ||
                        this.value === 'true' ||
                        this.value === 'false' ||
                        this.value === 'null' ||
                        this.value === 'n'
                    )) {
                    this.setAttribute('value', this.value);
                    delete this.value;
                }

                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                }
            }
        },
        events: {
            'mousedown': function () {
                if (!this.hasAttribute('suspend-created') &&
                    !this.hasAttribute('suspend-inserted') &&
                    !this.hasAttribute('readonly')) {
                    this.classList.add('down');
                }
            },
            'mouseout': function () {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (this.classList.contains('down')) {
                        this.classList.remove('down');
                    }
                }
            },
            'click': function (event) {
                var bolTripleState;
                var strValue;
                var strType;

                if (!this.hasAttribute('suspend-created') &&
                    !this.hasAttribute('suspend-inserted') &&
                    !this.hasAttribute('readonly')) {
                    bolTripleState = this.hasAttribute('triplestate');
                    strValue = this.getAttribute('value').trim().toLowerCase();

                    // get type from type attribute
                    strType = this.getAttribute('type');

                    // if type is not valid, get type from current value
                    if (strType !== 'smallint' && strType !== 'boolean') {
                        if (strValue === 'false' || strValue === 'true' || strValue === 'null') {
                            strType = 'boolean';
                        } else if (strValue === '0' || strValue === '-1' || strValue === 'n') {
                            strType = 'smallint';
                    // else default to boolean (backwards compatibility)
                        } else {
                            strType = 'boolean';
                        }
                    }

                    // resolve current value to the correct type
                    if (strType === 'smallint') {
                        if (strValue === '0' || strValue === 'false') {
                            strValue = '0';
                        } else if (strValue === '-1' || strValue === 'true') {
                            strValue = '-1';
                        } else if (strValue === 'n' || strValue === 'null') {
                            strValue = 'n';
                        } else {
                            strValue = '0';
                        }
                    } else if (strType === 'boolean') {
                        if (strValue === '0' || strValue === 'false') {
                            strValue = 'false';
                        } else if (strValue === '-1' || strValue === 'true') {
                            strValue = 'true';
                        } else if (strValue === 'n' || strValue === 'null') {
                            strValue = 'null';
                        } else {
                            strValue = 'false';
                        }
                    }

                    // get new value based on current value
                    if (strType === 'smallint') {
                        if (strValue === '0') {
                            strValue = '-1';
                        } else if (strValue === '-1') {
                            if (bolTripleState) {
                                strValue = 'n';
                            } else {
                                strValue = '0';
                            }
                        } else if (strValue === 'n') {
                            strValue = '0';
                        }
                    } else if (strType === 'boolean') {
                        if (strValue === 'false') {
                            strValue = 'true';
                        } else if (strValue === 'true') {
                            if (bolTripleState) {
                                strValue = 'null';
                            } else {
                                strValue = 'false';
                            }
                        } else if (strValue === 'null') {
                            strValue = 'false';
                        }
                    }

                    // set new value
                    this.setAttribute('value', strValue);

                    //// here be dragons
                    //if (strValue === 'false') {
                    //    this.setAttribute('value', 'true');
                    //} else if (strValue === 'true') {
                    //    if (bolTripleState) {
                    //        this.setAttribute('value', 'null');
                    //    } else {
                    //        this.setAttribute('value', 'false');
                    //    }
                    //} else if (strValue === 'null') {
                    //    this.setAttribute('value', 'false');
                    //} else if (strValue === '0') {
                    //    this.setAttribute('value', '-1');
                    //} else if (strValue === '-1') {
                    //    if (bolTripleState) {
                    //        this.setAttribute('value', 'n');
                    //    } else {
                    //        this.setAttribute('value', '0');
                    //    }
                    //} else if (strValue === 'n') {
                    //    this.setAttribute('value', '0');
                    //} else if (strValue === 0) {
                    //    this.setAttribute('value', -1);
                    //} else if (strValue === -1) {
                    //    if (bolTripleState) {
                    //        this.setAttribute('value', 'n');
                    //    } else {
                    //        this.setAttribute('value', 0);
                    //    }
                    //} else if (strValue === 'n') {
                    //    this.setAttribute('value', 0);
                    //} else if (strValue === false) {
                    //    this.setAttribute('value', true);
                    //} else if (strValue === true) {
                    //    if (bolTripleState) {
                    //        this.setAttribute('value', null);
                    //    } else {
                    //        this.setAttribute('value', false);
                    //    }
                    //} else if (strValue === null) {
                    //    //this.setAttribute('value', false);
                    //    if (this.getAttribute('type') === 'smallint') {
                    //        this.setAttribute('value', '-1');
                    //    } else {
                    //        this.setAttribute('value', 'true');
                    //    }
                    //} else {
                    //    if (this.getAttribute('type') === 'smallint') {
                    //        this.setAttribute('value', '-1');
                    //    } else {
                    //        this.setAttribute('value', 'true');
                    //    }
                    //}

                    this.classList.remove('down');
                    xtag.fireEvent(this, 'change', {bubbles: true, cancelable: true});
                }
            },
            'keydown': function (event) {
                if (!this.hasAttribute('suspend-created') &&
                    !this.hasAttribute('suspend-inserted') &&
                    !this.hasAttribute('readonly')) {
                    // if we pressed return (13) or space (32)
                    if (event.keyCode === 13 || event.keyCode === 32) {
                        // prevent default and stop propagation (to prevent scrolling of the page)
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    // if we are not disabled and we pressed return (13) or space (32): trigger click
                    if (!this.attributes.disabled && (event.keyCode === 13 || event.keyCode === 32)) {
                        xtag.fireEvent(this, 'click', { bubbles: true, cancelable: true });
                    }
                }
            }
        },
        accessors: {
            value: {
                // get value straight from the attribute
                get: function () {
                    return this.getAttribute('value');
                },

                // set the value attribute
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                }
            },
            textValue: {
                // return a text representation of the value
                get: function () {
                    var currentValue = this.getAttribute('value');

                    // if value is true: return YES
                    if (currentValue === '-1' || currentValue === 'true') {
                        return 'YES';
                    }

                    // if value is false: return NO
                    if (currentValue === '0' || currentValue === 'false') {
                        return 'NO';
                    }

                    // if value is null: return empty string
                    return '';
                },

                // set the value attribute
                set: function (newValue) {
                    if (newValue === 'YES') {
                        newValue = 'true';
                    }
                    if (newValue === 'NO') {
                        newValue = 'false';
                    }
                    this.setAttribute('value', newValue);
                }
            }
        },
        methods: {

        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('<gs-combo>', '<gs-combo>', 'gs-combo src="${1:test.tpeople}" column="${2}"></gs-combo>');
    
    designRegisterElement('gs-combo', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-combo.html');
    
    window.designElementProperty_GSCOMBO = function (selectedElement) {
        addProp('Source', true,
                '<gs-memo class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('src') ||
                                                                        selectedElement.getAttribute('source') || '')) + '" mini></gs-memo>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
        });
        
        addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
        });
        
        addProp('Initialize Source', true,
                '<gs-memo class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('initialize') || '')) + '" mini></gs-memo>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'initialize', encodeURIComponent(this.value));
        });
        
        addProp('Hide Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('hide') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'hide', this.value);
        });
        
        addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('where') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'where', this.value);
        });
        
        addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
        });
        
        addProp('Limit', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
        });
        
        addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
        });
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });
        
        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });
        
        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });
        
        addProp('Allow Empty', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('allow-empty')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'allow-empty', (this.value === 'true'), true);
        });
        
        addProp('Limit&nbsp;To&nbsp;List', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('limit-to-list')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'limit-to-list', (this.value === 'true'), true);
        });
        
        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });
        
        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });
        
        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });
        
        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });
        
        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))          { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop')) { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))  { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))   { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop')) { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))  { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))   { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });
        
        addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
            this.removeAttribute('refresh-on-querystring-change');
            return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
        });
        
        addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
            this.removeAttribute('refresh-on-querystring-values');
            return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
        
        //// SUSPEND-CREATED attribute
        //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
        //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        //});
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    // scroll the dropdown to the selected record
    function scrollToSelectedRecord(element) {
        var positioningContainer, scrollingContainer, arrTrs, i, len, intScrollTop, bolFoundSelected = false;
        
        if (element.currentDropDownContainer) {
            positioningContainer = xtag.queryChildren(element.currentDropDownContainer, '.gs-combo-positioning-container')[0];
            scrollingContainer = xtag.queryChildren(positioningContainer, '.gs-combo-scroll-container')[0];
            arrTrs = xtag.query(element.dropDownTable, 'tr');
            
            for (i = 0, intScrollTop = 0, len = arrTrs.length; i < len; i += 1) {
                if (arrTrs[i].hasAttribute('selected')) {
                    intScrollTop += arrTrs[i].offsetHeight / 2;
                    
                    bolFoundSelected = true;
                    
                    break;
                } else {
                    intScrollTop += arrTrs[i].offsetHeight;
                }
            }
            
            if (bolFoundSelected) {
                intScrollTop = intScrollTop - scrollingContainer.offsetHeight / 2;
            } else {
                intScrollTop = 0;
            }
            
            scrollingContainer.scrollTop = intScrollTop;
        }
    }
    
    // removes selected class from old selected records
    function clearSelection(element) {
        var i, len, arrSelectedTrs;
        
        // clear previous selection
        arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr[selected]');
        
        for (i = 0, len = arrSelectedTrs.length; i < len; i += 1) {
            arrSelectedTrs[i].removeAttribute('selected');
        }
    }
    
    // clears old selection and adds selected class to record
    function highlightRecord(element, record) {
        // clear previous selection
        clearSelection(element);
        
        // select/highlight the record that was provided
        record.setAttribute('selected', '');
    }
    
    // loops through the records and finds a record using the parameter (if bolPartialMatchAllowed === true then only search the first td text)
    function findRecordFromString(element, strSearchString, bolPartialMatchAllowed) {
        var i, len, matchedRecord, arrTrs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr');
        
        // if bolPartialMatchAllowed is true: only search the first td text (case insensitive)
        if (bolPartialMatchAllowed === true) {
            strSearchString = strSearchString.toLowerCase();
            
            for (i = 0, len = arrTrs.length; i < len; i += 1) {
                if (xtag.queryChildren(arrTrs[i], 'td')[0].textContent.toLowerCase().indexOf(strSearchString) === 0) {
                    matchedRecord = arrTrs[i];
                    
                    break;
                }
            }
            
        // else: search exact text and search both the value attribute (if present) and the first td text
        } else {
            for (i = 0, len = arrTrs.length; i < len; i += 1) {
                if (arrTrs[i].getAttribute('value') === strSearchString ||
                    xtag.queryChildren(arrTrs[i], 'td')[0].textContent === strSearchString) {
                    matchedRecord = arrTrs[i];
                    
                    break;
                }
            }
        }
        
        return matchedRecord;
    }
    
    // highlights record, sets value of the combobox using record
    function selectRecord(element, record, bolChange) {
        // add the yellow selection to the record
        highlightRecord(element, record);
        
        handleChange(element, bolChange);
    }
    
    // highlights record, sets value of the combobox using value attribute
    //      if bolChange === true then:
    //          change event and check for limit to list
    function selectRecordFromValue(element, strValue, bolChange) {
        var record = findRecordFromString(element, strValue, false);
        
        // if a record was found: select it
        if (record) {
            selectRecord(element, record, bolChange);
            
        // else if limit to list (and no record was found):
        } else if (element.hasAttribute('limit-to-list') && bolChange) {
            if (strValue === '' && element.hasAttribute('allow-empty')) {
                handleChange(element, bolChange);
                
            } else {
                alert('The text you entered is not in the list');
                openDropDown(element);
                GS.setInputSelection(element.control, 0, strValue.length);
            }
            
        // else (not limit to list and no record found):
        } else {
            clearSelection(element);
            
            if (!element.hasAttribute('limit-to-list')) {
                element.control.value = strValue;
                element.innerValue = strValue;
            }
            
            handleChange(element, bolChange);
        }
    }
    
    function handleChange(element, bolChange) {
        var arrSelectedTrs, strHiddenValue = '', strTextValue = '', beforechangeevent, oldRecord,
            oldInnerValue = element.innerValue, oldControlValue = element.control.value;
        
        if (element.dropDownTable) {
            arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr[selected]');
            
            // if there is a selected record
            if (arrSelectedTrs.length > 0) {
                // gather values from the selected record
                strHiddenValue = arrSelectedTrs[0].getAttribute('value');
                var firstTd = xtag.queryChildren(arrSelectedTrs[0], 'td')[0],
                    lastChild = firstTd.lastElementChild;
                if (lastChild && lastChild.tagName.substring(0, 3) === 'GS-') {
                    strTextValue = lastChild.textValue || lastChild.value || lastChild.textContent;
                } else {
                    strTextValue = firstTd.textContent;
                }
                
            } else {
                strTextValue = element.control.value;
            }
            
        } else {
            strTextValue = element.control.value;
        }
        
        // set innervalue and control value using the values we gather from the record
        element.innerValue = strHiddenValue || strTextValue;
        element.control.value = strTextValue || strHiddenValue;
        
        if (bolChange) {
            if (document.createEvent) {
                beforechangeevent = document.createEvent('HTMLEvents');
                beforechangeevent.initEvent('beforechange', true, true);
            } else {
                beforechangeevent = document.createEventObject();
                beforechangeevent.eventType = 'beforechange';
            }
            
            beforechangeevent.eventName = 'beforechange';
            
            if (document.createEvent) {
                element.dispatchEvent(beforechangeevent);
            } else {
                element.fireEvent("on" + beforechangeevent.eventType, beforechangeevent);
            }
            
            // xtag.fireEvent(element, 'beforechange', { bubbles: true, cancelable: true });
            
            //console.log(beforechangeevent.defaultPrevented);
            if (beforechangeevent.defaultPrevented !== true) {
                xtag.fireEvent(element, 'change', { bubbles: true, cancelable: true });
                
            } else {
                element.innerValue = oldInnerValue;
                element.control.value = oldControlValue;
                
                oldRecord = findRecordFromString(element, oldInnerValue, false);
                
                if (oldRecord) {
                    highlightRecord(element, oldRecord);
                } else {
                    clearSelection(element);
                }
            }
            
            element.ignoreChange = false;
        }
    }
    
    // open dropdown
    function openDropDown(element) {
        // if we are not already dropping down
        if (!element.droppingDown) {
            // if there is a source attribute on the combobox: refresh data
            if (element.getAttribute('src') || element.getAttribute('source')) {
                getData(element, false, true, function () {
                    dropDown(element);
                });
            } else {
                dropDown(element);
            }
            element.droppingDown = true;
        }
    }
    
    function dropDown(element) {
        var dropDownContainer = document.createElement('div'), overlay, positioningContainer, scrollContainer, observer;
        
        // focus control
        element.control.focus();
        
        // create the dropdown element (and its children)
        dropDownContainer.classList.add('gs-combo-dropdown-container');
        dropDownContainer.setAttribute('gs-dynamic', '');
        dropDownContainer.innerHTML =   '<div class="gs-combo-positioning-container" gs-dynamic>' +
                                        '    <div class="gs-combo-scroll-container" gs-dynamic></div>' +
                                        '</div>';
        
        // append dropdown to the body
        document.body.appendChild(dropDownContainer);
        
        // set variables for the various elements that we will need for calculation
        positioningContainer = xtag.queryChildren(dropDownContainer, '.gs-combo-positioning-container')[0];
        scrollContainer =      xtag.queryChildren(positioningContainer, '.gs-combo-scroll-container')[0];
        
        element.currentDropDownContainer = dropDownContainer;
        
        //console.log(element.currentDropDownContainer);
        //console.log(element.dropDownTable);
        
        // fill dropdown with content
        if (element.dropDownTable) {
            //element.dropDownTable = GS.cloneElement(element.staticDropDownTable);
            scrollContainer.appendChild(element.dropDownTable);
            
        //} else if (element.tableTemplate) {
        //    scrollContainer.innerHTML = element.tableTemplate;
        //    
        } else {
            scrollContainer.innerHTML = element.initalHTML;
        }
        
        // create an observer instance
        observer = new MutationObserver(function(mutations) {
            dropDownSize(element);
        });
        
        // pass in the element node, as well as the observer options
        observer.observe(scrollContainer, {childList: true, subtree: true});
        
        //console.log(scrollContainer);
        
        dropDownSize(element);
    }
    
    function dropDownSize(element) {
        var dropDownContainer    = element.currentDropDownContainer,
            positioningContainer = xtag.queryChildren(dropDownContainer, '.gs-combo-positioning-container')[0],
            scrollContainer      = xtag.queryChildren(positioningContainer, '.gs-combo-scroll-container')[0],
            overlay, jsnComboOffset, intComboHeight, intComboWidth, intViewportWidth, intViewportHeight,
            intFromControlToBottomHeight, intFromControlToTopHeight, intContentHeight, intNewWidth,
            strWidth = '', strHeight = '', strLeft = '', strTop = '', strBottom = '';
        
        // set variables needed for position calculation
        intComboHeight               = element.offsetHeight;
        intComboWidth                = element.offsetWidth;
        intViewportHeight            = window.innerHeight;
        intViewportWidth             = window.innerWidth;
        jsnComboOffset               = GS.getElementOffset(element);
        intContentHeight             = scrollContainer.scrollHeight;
        intFromControlToBottomHeight = intViewportHeight - (jsnComboOffset.top + intComboHeight);
        intFromControlToTopHeight    = jsnComboOffset.top;
        
        
        //console.log(intFromControlToBottomHeight, intFromControlToTopHeight);
        
        
        // set position, height and (top or bottom) variables
        // if desktop:
        if (!evt.touchDevice) {
            // if viewport is too small go full page
            if (window.innerHeight < 500 &&
                intContentHeight > intFromControlToTopHeight &&
                intContentHeight > intFromControlToBottomHeight) {
                strHeight = window.innerHeight + 'px';
                strTop =  '0px';
                
            // try 200px
            } else if (intContentHeight < 500) {
                strHeight = '200px';
                
                if (intFromControlToBottomHeight > intFromControlToTopHeight || intFromControlToBottomHeight > 200) {
                    strTop = (intFromControlToTopHeight + intComboHeight) + 'px';
                } else {
                    strBottom = (intFromControlToBottomHeight + intComboHeight) + 'px';
                }
                
            // try height from control to bottom of viewport
            } else if (intFromControlToBottomHeight >= intFromControlToTopHeight) {
                strHeight = intFromControlToBottomHeight + 'px';
                strTop = (intFromControlToTopHeight + intComboHeight) + 'px';
                
            // else height from control to top of viewport
            } else {// if (intFromControlToTopHeight >= intFromControlToBottomHeight) {
                strHeight = intFromControlToTopHeight + 'px';
                strBottom = (intFromControlToBottomHeight + intComboHeight) + 'px';
            }
            
        // else mobile:
        } else {
            // try 200px bottom
            if (intFromControlToBottomHeight > 200 && intContentHeight < 500) {
                strHeight = intFromControlToBottomHeight + 'px';
                strTop = (intFromControlToTopHeight + intComboHeight) + 'px';
                
            // try 200px top
            } else if (intFromControlToTopHeight > 200 && intContentHeight < 500) {
                strHeight = intFromControlToTopHeight + 'px';
                strBottom = (intFromControlToBottomHeight + intComboHeight) + 'px';
            
            // else full page
            } else {
                strHeight = window.innerHeight + 'px';
                strTop =  '0px';
            }
        }
        
        
        // set width and left variables
        // try regular
        if (scrollContainer.scrollWidth <= scrollContainer.offsetWidth) {
            if (intComboWidth < 150) {
                intNewWidth = (window.innerWidth - jsnComboOffset.left) - 20;
                
                if (intNewWidth < 300) {
                    strWidth = intNewWidth + 'px';
                } else {
                    strWidth = '300px';
                }
                
            } else {
                strWidth = intComboWidth + 'px';
            }
            strLeft = jsnComboOffset.left + 'px';
            
        // else full width
        } else {
            strWidth = '100%';
            strLeft = '0px';
        }
        
        
        // set position and size using variables
        positioningContainer.style.left   = strLeft;
        positioningContainer.style.top    = strTop;
        positioningContainer.style.bottom = strBottom;
        positioningContainer.style.width  = strWidth;
        positioningContainer.style.height = strHeight;
        
        if (strTop) {
            dropDownContainer.classList.add('below');
        } else {
            dropDownContainer.classList.add('above');
        }
        
        
        // if the table is wider than the drop down: reflow
        if (scrollContainer.clientWidth < scrollContainer.scrollWidth &&
            xtag.query(scrollContainer, 'tbody tr:first-child td, tbody tr:first-child th').length > 1) {
            scrollContainer.classList.add('reflow');
        }
        
        
        // if the table is shorter than the drop down: resize the dropdown to be as short as the table
        if (intContentHeight < scrollContainer.clientHeight) {
            positioningContainer.style.height = intContentHeight + 'px';
        }
        
        
        // make combobox float over overlay so that you can focus into the input box
        element.classList.add('open');
        
        //// if there is already a placeholder: delete the old one
        //if (element.placeholderElement) {
        //    element.parentNode.removeChild(element.placeholderElement);
        //    element.placeholderElement = undefined;
        //    
        //    element.style.left   = element.oldLeft;
        //    element.style.right  = element.oldRight;
        //    element.style.top    = element.oldTop;
        //    element.style.bottom = element.oldBottom;
        //    element.style.width  = element.oldWidth;
        //    element.style.height = element.oldHeight;
        //}
        //
        //// save old styles
        //element.oldLeft   = element.style.left;
        //element.oldRight  = element.style.right;
        //element.oldTop    = element.style.top;
        //element.oldBottom = element.style.bottom;
        //element.oldWidth  = element.style.width;
        //element.oldHeight = element.style.height;
        //
        //element.style.left = '';
        //element.style.right = '';
        //element.style.top = '';
        //element.style.bottom = '';
        //element.style.width = '';
        //element.style.height = '';
        //
        //element.style.left   = jsnComboOffset.left + 'px';
        //element.style.top    = jsnComboOffset.top + 'px';
        //element.style.width  = intComboWidth + 'px';
        //element.style.height = intComboHeight + 'px';
        //
        //// put a placeholder element so that elements dont jump under where the combobox was
        //element.placeholderElement = document.createElement('div');
        //
        //element.placeholderElement.setAttribute('gs-dynamic', '');
        //element.placeholderElement.style.left   = element.oldLeft;
        //element.placeholderElement.style.right  = element.oldRight;
        //element.placeholderElement.style.top    = element.oldTop;
        //element.placeholderElement.style.bottom = element.oldBottom;
        //element.placeholderElement.style.width  = element.oldWidth;      // this will set the width of the placholder if
        //                                                                 //     the combobox had a set width
        //element.placeholderElement.style.height = intComboHeight + 'px'; // set the height of the placeholder to the
        //                                                                 //     actual height of the combobox
        //
        //element.parentNode.insertBefore(element.placeholderElement, element);
        
        // change element open state variable
        element.open = true;
        
        
        // bind drop down
        bindDropDown(element);
        
        
        // scroll to the selected record (if any)
        scrollToSelectedRecord(element);
    }
    
    // bind dropdown events
    function bindDropDown(element) {
        var selectableTrs, closeDropDownHandler, selectRecordHandler, i, len,
            unbindSelectRecordHandler, unbindDropDownEvents, wheelHandler;
        
        wheelHandler = function (event) {
            var tableElement = GS.findParentElement(event.target, '.gs-combo-dropdown-container');
            
            if (tableElement !== element.currentDropDownContainer) {
                closeDropDownHandler();
            }
        };
        
        // unbind function
        unbindDropDownEvents = function () {
            var i, len;
            
            for (i = 0, len = selectableTrs.length; i < len; i += 1) {
                selectableTrs[i].removeEventListener('click', selectRecordHandler);
            }
            
            window.removeEventListener('resize', closeDropDownHandler);
            window.removeEventListener('orientationchange', closeDropDownHandler);
            window.removeEventListener('mousewheel', wheelHandler);
            document.body.removeEventListener('click', closeDropDownHandler);
        };
        
        // handle record click
        selectableTrs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr');
        
        selectRecordHandler = function (event) {
            selectRecord(element, GS.findParentTag(event.target, 'tr'), true);
            closeDropDownHandler();
        };
        
        for (i = 0, len = selectableTrs.length; i < len; i += 1) {
            selectableTrs[i].addEventListener('click', selectRecordHandler);
        }
        
        // handle dropdown close
        closeDropDownHandler = function (event) {
            closeDropDown(element);
            unbindDropDownEvents();
        };
        
        window.addEventListener('resize', closeDropDownHandler);
        window.addEventListener('orientationchange', closeDropDownHandler);
        window.addEventListener('mousewheel', wheelHandler);
        document.body.addEventListener('click', closeDropDownHandler);
    }
    
    // remove dropdown from screen
    function closeDropDown(element) {
        // if there is a dropdown to remove: remove the dropdown
        if (element.currentDropDownContainer) {
            document.body.removeChild(element.currentDropDownContainer);
            element.currentDropDownContainer = undefined;
            
            element.classList.remove('open');
            element.open = false;
            element.droppingDown = false;
            
            //element.parentNode.removeChild(element.placeholderElement);
            //element.placeholderElement = undefined;
            //
            //element.style.left   = element.oldLeft;
            //element.style.right  = element.oldRight;
            //element.style.top    = element.oldTop;
            //element.style.bottom = element.oldBottom;
            //element.style.width  = element.oldWidth;
            //element.style.height = element.oldHeight;
        }
    }
    
    // handle behaviours on keydown
    function handleKeyDown(element, event) {
        var intKeyCode = event.keyCode || event.which, selectedTr, trs, i, len, selectedRecordIndex, firstTd, lastChild, strTextValue;
        
        if (!element.hasAttribute('disabled') && !element.hasAttribute('readonly')) {
            if ((intKeyCode === 40 || intKeyCode === 38) && !event.shiftKey && !event.metaKey && !event.ctrlKey && !element.error) {
                if (!element.open) {
                    openDropDown(element);
                    
                } else {
                    trs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr');
                    
                    for (i = 0, len = trs.length; i < len; i += 1) {
                        if (trs[i].hasAttribute('selected')) {
                            selectedRecordIndex = i;
                            selectedTr = trs[i];
                            trs[i].removeAttribute('selected');
                            
                            break;
                        }
                    }
                    
                    if (intKeyCode === 40) {// next record or circle to first record or start selection at the first
                        if (!selectedTr || selectedRecordIndex === trs.length - 1) {
                            highlightRecord(element, trs[0]);
                            selectedTr = trs[0];
                            
                        } else {
                            highlightRecord(element, trs[selectedRecordIndex + 1]);
                            selectedTr = trs[selectedRecordIndex + 1];
                        }
                        
                    } else if (intKeyCode === 38) {// prev record or circle to last record or start selection at the last
                        if (!selectedTr || selectedRecordIndex === 0) {
                            highlightRecord(element, trs[trs.length - 1]);
                            selectedTr = trs[trs.length - 1];
                            
                        } else {
                            highlightRecord(element, trs[selectedRecordIndex - 1]);
                            selectedTr = trs[selectedRecordIndex - 1];
                        }
                    }
                    scrollToSelectedRecord(element);
                }
                if (selectedTr) {
                    element.control.value = xtag.queryChildren(selectedTr, 'td')[0].textContent;
                }
                
                GS.setInputSelection(element.control, 0, element.control.value.length);
                
                event.preventDefault();
                event.stopPropagation();
                
            } else if ((intKeyCode === 39) && !event.shiftKey && !event.metaKey && !event.ctrlKey && !element.error) {
                selectedTr = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr[selected]')[0];
                
                if (selectedTr) {
                    firstTd = xtag.queryChildren(selectedTr, 'td')[0];
                    lastChild = firstTd.lastElementChild;
                    
                    if (lastChild && lastChild.tagName.substring(0, 3) === 'GS-') {
                        strTextValue = lastChild.textValue || lastChild.value || lastChild.textContent;
                    } else {
                        strTextValue = firstTd.textContent;
                    }
                    
                    //console.log(element.innerValue, element.control.value, selectedTr.getAttribute('value'), strTextValue);
                    
                    selectRecord(element, selectedTr,
                                element.innerValue !== (selectedTr.getAttribute('value') || strTextValue));
                }
                
                event.stopPropagation();
                
            } else if (event.keyCode === 13 || event.keyCode === 9) {
                if (element.dropDownTable && xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr[selected]').length > 0) {
                    selectRecordFromValue(element, element.control.value, true);
                    element.ignoreChange = true;
                }
                
                closeDropDown(element);
                
            } else if (!event.metaKey &&       // not command key
                       !event.ctrlKey &&       // not control key
                       event.keyCode !== 37 && // not arrow keys
                       event.keyCode !== 38 &&
                       event.keyCode !== 39 &&
                       event.keyCode !== 40 &&
                       event.keyCode !== 46 && // not forward delete key
                       event.keyCode !== 8) {  // not delete key
                element.attemptSearchOnNextKeyup = true;
            }
        } else {
            if (event.keyCode !== 9) {
                event.preventDefault();
                event.stopPropagation();
            }
        }
    }
    
    // search on keyup
    //      the reason we are using keyup for search is because on keydown the letter has not been typed in yet and
    //      it would be harder if we tried to use the keycode to get the letter that was typed. so on keydown
    //      (which is where we can tell if CMD or CTRL and other keys that we dont want to search on and pressed)
    //      if we didn't type something that we dont want to search on but we typed somthing else: set this.attemptSearchOnNextKeyup
    //      to true and on keyup we read that and if it is set to true then we do a search and set it back to false
    function handleKeyUp(element, event) {
        var intKeyCode = event.keyCode || event.which, strSearch = element.control.value, matchRecord;
        
        // if element.attemptSearchOnNextKeyup is true and
        //      there is a search string and
        //      the user has their text selection at the end of the of the input
        if (element.attemptSearchOnNextKeyup === true &&
            strSearch &&
            GS.getInputSelection(element.control).start === strSearch.length) {
            
            // ######### FOR CROSS
            // you need to comment the code inside this block.
            // you need an if statment for >2000 records.
            // you need to use the currently commented code for <=2000 records.
            // you need new code for >2000.
            // you need to get the template and put it inside a virtual template element.
            // a virtual template element is just a template element inside a javascript variable.
            //      var templateElement = document.createElement('template');
            // you need to fill templateElement with the record template string, don't use the thead. (you'll find most everything in element.tableTemplate)
            // you need to extract the contents of the first td and put that into a variable.
            // you need to extract the contents of the "value" attribute on the tr (if present).
            // because you extracted the contents before templating, the variables are untemplated.
            // you need to get the column name from the first td template.
            //      there are three things you need to try:
            //          do a regex for "row.something", cut off the row
            //              OR
            //          do a regex for "row['something']", cut off the row[' and ']
            //              OR
            //          do a regex for "row["something"]", cut off the row[" and "]
            //
            //      that should be good enough. if you can't get the column: stop and
            //          console.warn to tell the developer to stick <!-- row.column -->
            //          at the top of the first td 
            // you need to run an AJAX call on the postgres object in "src" with a where clause.
            // the where clause will be something like this:
            //          (OLDWHERE) AND COLUMN ILIKE $UnCOPYQTE$ strSearch%$UnCOPYQTE$
            // the ajax call should only get one record.
            // use the two templates to set the value (copy the original code).
            //
            // after you're done, leave these comments for future developers
            
            
            
            //<gs-combo src="test.tpeople" column="">
            //    <template>
            //        <table>
            //            <thead>
            //                <tr>
            //                    <th>asdf</th>
            //                    <th>fdsa</th>
            //                </tr>
            //            </thead>
            //            <tbody>
            //                <tr value="{{! row.id }}"> <--- hidden value, if present
            //                    <td>{{! row.asdf }}</td> <--- visible value
            //                    <td>{{! row.fdsa }}</td>
            //                </tr>
            //            </tbody>
            //        </table>
            //    </template>
            //</gs-combo>
            
            
            matchRecord = findRecordFromString(element, strSearch, true);
            
            // if we found a record and its was already selected: selected the matched record and dont 
            if (matchRecord) {
                highlightRecord(element, matchRecord);
                element.control.value = xtag.queryChildren(matchRecord, 'td')[0].textContent;
                GS.setInputSelection(element.control, strSearch.length, element.control.value.length);
                
                //if (strSearch.length === element.control.value.length) {
                //    selectRecord(element, matchRecord, true);
                //}
                
                scrollToSelectedRecord(element);
                
            } else {
                clearSelection(element);
                //selectRecordFromValue(element, strSearch, false);
                //GS.setInputSelection(element.control, strSearch.length, element.control.value.length);
            }
        }
        
        if (element.attemptSearchOnNextKeyup === true) {
            element.attemptSearchOnNextKeyup = false;
        }
    }
    
    // handles fetching the data
    //      if bolInitalLoad === true then
    //          use: initialize query COALESCE TO source query
    //      else
    //          use: source query
    function getData(element, bolInitalLoad, bolClearPrevious, callback) {
        if (window.bolSocket === true) {
            var srcParts   = GS.templateWithQuerystring(
                                (bolInitalLoad && element.getAttribute('initialize')
                                    ? element.getAttribute('initialize')
                                    : element.getAttribute('src')
                                )
                            ).split('.')
              , strSchema  = srcParts[0]
              , strObject  = srcParts[1]
              , strColumns = GS.templateWithQuerystring(element.getAttribute('cols') || '*').split(',').join('\t')
              , strWhere   = GS.templateWithQuerystring(element.getAttribute('where') || '')
              , strOrd     = GS.templateWithQuerystring(element.getAttribute('ord') || '')
              , strLimit   = GS.templateWithQuerystring(element.getAttribute('limit') || '')
              , strOffset  = GS.templateWithQuerystring(element.getAttribute('offset') || '')
              , response_i = 0, response_len = 0, arrTotalRecords = [];
            
            
            //GS.addLoader(element, 'Loading...');
            GS.requestCachingSelect(GS.envSocket, strSchema, strObject, strColumns
                                     , strWhere, strOrd, strLimit, strOffset
                                     , function (data, error) {
                var arrRecords, arrCells, envData
                  , i, len, cell_i, cell_len;
                
                if (!error) {
                    if (data.strMessage !== 'TRANSACTION COMPLETED') {
                        arrRecords = GS.trim(data.strMessage, '\n').split('\n');
                        
                        for (i = 0, len = arrRecords.length; i < len; i += 1) {
                            arrCells = arrRecords[i].split('\t');
                            
                            for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                                arrCells[cell_i] = GS.decodeFromTabDelimited(arrCells[cell_i]);
                            }
                            
                            arrTotalRecords.push(arrCells);
                        }
                    } else {
                        //GS.removeLoader(element);
                        element.arrColumnNames = data.arrColumnNames;
                        
                        envData = {'arr_column': element.arrColumnNames, 'dat': arrTotalRecords};
                        
                        handleData(element, bolInitalLoad, envData);
                        GS.triggerEvent(element, 'after_select');
                        if (typeof callback === 'function') {
                            callback();
                        }
                    }
                } else {
                    handleData(element, bolInitalLoad, data, error);
                    //GS.removeLoader(element);
                }
            }, bolClearPrevious);
            
        } else {
            var data, strLink, dataFunction,
                strInitalize = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('initialize') || '')),
                strSource = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') || element.getAttribute('source') || '')),
                strCols = element.getAttribute('cols') || '';
            
            // if there is a initial query and this is the inital load: prepare the parameters for a fetch that would use the initial query
            if (strInitalize && bolInitalLoad) {
                strLink = '/' + (element.getAttribute('action-select') || 'env/action_select') + '?src=' + encodeURIComponent(strInitalize);
                
            // else: use the source query and prepare the parameters for a fetch that would use the source query
            } else {
                strLink = '/' + (element.getAttribute('action-select') || 'env/action_select') + '?src=' + encodeURIComponent(strSource);
            }
            
            
            
            strLink += '&where='    + encodeURIComponent(GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('where') || ''))) +
                       '&limit='    + encodeURIComponent(GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('limit') || ''))) +
                       '&offset='   + encodeURIComponent(GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('offset') || ''))) +
                       '&order_by=' + encodeURIComponent(GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('ord') || ''))) +
                       '&cols='     + encodeURIComponent(strCols);
            
            
            if (GS.dataFetch(strLink, bolClearPrevious)) {
                data = GS.dataFetch(strLink, bolClearPrevious);
                
                handleData(element, bolInitalLoad, data.response, data.error); // (data.status === 'error' ? 'error' : null)
            } else {
                dataFunction = function (event) {
                    document.removeEventListener('dataready_' + encodeURIComponent(strLink), dataFunction);
                    handleData(element, bolInitalLoad, event.detail.response, event.detail.error);
                    if (typeof callback === 'function') {
                        callback();
                    }
                };
                
                document.addEventListener('dataready_' + encodeURIComponent(strLink), dataFunction);
            }
        }
    }
    
    // handles data result from method function: getData 
    //      success:  template
    //      error:    add error classes
    function handleData(element, bolInitalLoad, data, error) {
        var divElement, tableElement, theadElement, theadCellElements, tbodyElement, tbodyCellElements, lastRecordElement,
            currentCellLabelElement, template, i, len, arrHeaders = [], strTemplate, arrHide, strHeaderCells, strRecordCells,
            tableTemplateElement, recordElements, recordElement, jsnTemplate, strHTML;
        
        //GS.triggerEvent(this, 'after_select'); <== caused a MAJOR issue where code that was supposed to
        //                                              run after an envelope after_select caught all of
        //                                              the after selects of the comboboxes in the envelope
        
        // clear any old error status
        element.classList.remove('error');
        element.dropDownButton.setAttribute('title', '');
        element.dropDownButton.setAttribute('icon', 'angle-down');
        
        // if there was no error
        if (!error) {
            element.error = false;
            
            //console.log(this, this.tableTemplate);
            
            if (element.tableTemplate) {
                //tableTemplateElement = document.createElement('template');
                //tableTemplateElement.innerHTML = this.tableTemplate;
                //
                //theadElement = xtag.query(tableTemplateElement.content, 'thead')[0];
                //tbodyElement = xtag.query(tableTemplateElement.content, 'tbody')[0];
                //
                //console.log(theadElement, tbodyElement);
                
                strTemplate = element.tableTemplate; //this.initalHTML;
                
            } else { // if (data.arr_column)
                // create an array of hidden column numbers
                arrHide = (element.getAttribute('hide') || '').split(/[\s]*,[\s]*/);
                
                // build up the header cells variable and the record cells variable
                for (i = 0, len = data.arr_column.length, strHeaderCells = '', strRecordCells = ''; i < len; i += 1) {
                    // if this column is not hidden
                    if (arrHide.indexOf((i + 1) + '') === -1 && arrHide.indexOf(data.arr_column[i]) === -1) {
                        // append a new cell to each of the header cells and record cells variables
                        strHeaderCells += '<th gs-dynamic>' + encodeHTML(data.arr_column[i]) + '</th> ';
                        strRecordCells += '<td gs-dynamic>{{! row[\'' + data.arr_column[i] + '\'] }}</td> ';
                    }
                }
                
                // put everything together
                strTemplate =   '<table gs-dynamic>' +
                                    '<thead gs-dynamic>' +
                                        '<tr gs-dynamic>' +
                                            strHeaderCells +
                                        '</tr>' +
                                    '</thead>' +
                                    '<tbody gs-dynamic>' +
                                        '<tr value="{{! row[\'' + data.arr_column[0] + '\'] }}" gs-dynamic>' +
                                            strRecordCells +
                                        '</tr>' +
                                    '</tbody>' +
                                '<table>';
            }
            
            divElement = document.createElement('div');
            
            divElement.innerHTML = strTemplate;
            
            tableElement = xtag.queryChildren(divElement, 'table')[0];
            theadElement = xtag.queryChildren(tableElement, 'thead')[0];
            tbodyElement = xtag.queryChildren(tableElement, 'tbody')[0];
            
            // if there is a tbody
            if (tbodyElement) {
                recordElement = xtag.queryChildren(tbodyElement, 'tr')[0];
                
                // if there is a record: template
                if (recordElement) {
                    
                    // if there is a thead element: add reflow cell headers to the tds
                    if (theadElement) {
                        theadCellElements = xtag.query(theadElement, 'td, th');
                        tbodyCellElements = xtag.query(tbodyElement, 'td, th');
                        
                        for (i = 0, len = theadCellElements.length; i < len; i += 1) {
                            currentCellLabelElement = document.createElement('b');
                            currentCellLabelElement.classList.add('cell-label');
                            currentCellLabelElement.setAttribute('data-text', (theadCellElements[i].textContent || '') + ':');
                            currentCellLabelElement.setAttribute('gs-dynamic', '');
                            
                            if (tbodyCellElements[i].childNodes) {
                                tbodyCellElements[i].insertBefore(currentCellLabelElement, tbodyCellElements[i].childNodes[0]);
                            } else {
                                tbodyCellElements[i].insertChild(currentCellLabelElement);
                            }
                        }
                    }
                    
                    // template
                    jsnTemplate = GS.templateHideSubTemplates(tbodyElement.innerHTML, true);
                    strHTML = GS.templateWithEnvelopeData(tbodyElement.innerHTML, data);
                    tbodyElement.innerHTML = GS.templateShowSubTemplates(strHTML, jsnTemplate);
                    
                    element.dropDownTable = tableElement;
                    element.ready = true;
                }
            }
            
            //if (data.arr_column) {
            if (bolInitalLoad && element.getAttribute('value')) {
                selectRecordFromValue(element, element.getAttribute('value'), false);
                
            } else if (element.value) {
                selectRecordFromValue(element, element.value, false);
            }
            //}
            
        // else there was an error: add error class, title attribute
        } else {
            console.error(data);
            element.error = true;
            element.ready = false;
            element.classList.add('error');
            element.dropDownButton.setAttribute('title', 'This combobox has failed to load.');
            element.dropDownButton.setAttribute('icon', 'exclamation-circle');
            
            if (element.hasAttribute('limit-to-list')) {
                element.setAttribute('disabled', '');
            }
        }
    }
    
    function refreshControl(element) {
        var i, len, divElement, arrPassThroughAttributes = [
                'placeholder',
                'name',
                'maxlength',
                'autocorrect',
                'autocapitalize',
                'autocomplete',
                'autofocus',
                'spellcheck',
                'readonly'
            ];
        
        // if the gs-text element has a tabindex: save the tabindex and remov the attribute
        if (element.hasAttribute('tabindex')) {
            element.savedTabIndex = element.getAttribute('tabindex');
            element.removeAttribute('tabindex');
        }
        
        // clear out the combobox HTML
        element.innerHTML = '';
        
        // creating/setting root
        divElement = document.createElement('div');
        divElement.setAttribute('gs-dynamic', '');
        divElement.classList.add('root');
        
        element.appendChild(divElement);
        element.root = divElement;
        
        element.root.innerHTML = '<input gs-dynamic class="control" type="text" />' +
                                 '<gs-button gs-dynamic class="drop_down_button" icononly icon="angle-down" no-focus></gs-button>';
        
        element.control = xtag.query(element, '.control')[0];
        element.dropDownButton = xtag.query(element, '.drop_down_button')[0];
        
        // copy passthrough attrbutes to control
        for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
            if (element.hasAttribute(arrPassThroughAttributes[i])) {
                element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
            }
        }
        
        // if we saved a tabindex: apply the tabindex to the control
        if (element.savedTabIndex !== undefined && element.savedTabIndex !== null) {
            element.control.setAttribute('tabindex', element.savedTabIndex);
        }
        
        // bind change event to control
        //console.log('change bound');
        element.control.addEventListener('change', function (event) {
            event.preventDefault();
            event.stopPropagation();
            
            //console.log('change detected');
            if (!element.ignoreChange) {
                selectRecordFromValue(element, this.value, true);
            }
            element.ignoreChange = false;
        });
        
        
        //  on safari the change event doesn't occur if you click out while the autocomplete has
        //      completed the value (because the user technically didn't change after the javascript changed the value)
        //  to solve this the code below will mimic a change event if one does not occur at the right time
        
        // there are two ways that user's cause change events:
        //      1) after making a change to the value: taking the focus out of the field
        //      2) after making a change to the value: hitting return
        
        // this code counts on the fact that a browser will always emit a change event before a 'blur' or 'keyup'
        // the execution is as follows
        
        // this is the basic plan:
        //  change:
        //          // changeOccured tells the event code to not do anything because a change event did fire
        //          element.changeOccured to true
        //  focus:
        //          // element.lastValue allows us to compare the value to the old value, and if there's a difference: we need a change event
        //          set element.lastValue to current value of the control 
        //  blur:
        //          if element.changeOccured === true:
        //              set element.changeOccured = false
        //          else:
        //              if control.value !== lastValue: // if the value has been changed
        //                  trigger artificial change event on control
        //  keyup (on return key):
        //          if element.changeOccured === true:
        //              set element.changeOccured = false
        //          else:
        //              if control.value !== lastValue: // if the value has been changed
        //                  trigger artificial change event on control
        
        
        element.control.addEventListener('change', function (event) {
            element.changeOccured = true;
        });
        
        element.control.addEventListener('focus', function (event) {
            element.lastValue = element.control.value;
        });
        
        element.control.addEventListener('blur', function (event) {
            if (element.changeOccured === true) {
                element.changeOccured = false;
            } else if (element.control.value !== element.lastValue) {
                GS.triggerEvent(element.control, 'change');
            }
        });
        
        element.control.addEventListener('keyup', function (event) {
            // if the key was return
            if ((event.keyCode || event.which) === 13 && !element.hasAttribute('readonly')) {
                if (element.changeOccured === true) {
                    element.changeOccured = false;
                } else if (element.control.value !== element.lastValue) {
                    GS.triggerEvent(element.control, 'change');
                }
            }
        });
    }
    
    //function pushReplacePopHandler(element) {
    //    var i, len, arrPopKeys, currentValue, bolRefresh = false, strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //    
    //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //    
    //    if (element.hasAttribute('refresh-on-querystring-values')) {
    //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
    //        
    //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
    //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
    //            
    //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
    //                bolRefresh = true;
    //            }
    //            
    //            element.popValues[arrPopKeys[i]] = currentValue;
    //        }
    //        
    //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
    //        bolRefresh = true;
    //    }
    //    
    //    if (bolRefresh) {
    //        getData(element);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh;
        var strOperator;

        if (strQSCol) {
            if (strQSCol.indexOf('=') !== -1) {
                arrAttrParts = strQSCol.split(',');
                i = 0;
                len = arrAttrParts.length;
                while (i < len) {
                    strQSCol = arrAttrParts[i];
    
                    if (strQSCol.indexOf('!=') !== -1) {
                        strOperator = '!=';
                        arrQSParts = strQSCol.split('!=');
                    } else {
                        strOperator = '=';
                        arrQSParts = strQSCol.split('=');
                    }
    
                    strQSCol = arrQSParts[0];
                    strQSAttr = arrQSParts[1] || arrQSParts[0];
    
                    // if the key is not present or we've got the negator: go to the attribute's default or remove it
                    if (strOperator === '!=') {
                        // if the key is not present: add the attribute
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            element.setAttribute(strQSAttr, '');
                        // else: remove the attribute
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    } else {
                        // if the key is not present: go to the attribute's default or remove it
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        // else: set attribute to exact text from QS
                        } else {
                            element.setAttribute(strQSAttr, (
                                GS.qryGetVal(strQS, strQSCol) ||
                                element.internal.defaultAttributes[strQSAttr] ||
                                ''
                            ));
                        }
                    }
                    i += 1;
                }
            } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                strQSValue = GS.qryGetVal(strQS, strQSCol);
    
                if (element.internal.bolQSFirstRun !== true) {
                    if (strQSValue !== '' || !element.getAttribute('value')) {
                        element.setAttribute('value', strQSValue);
                    }
                } else {
                    element.value = strQSValue;
                }
            }
        }
        
        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                
                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);
                    
                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }
                    
                    element.popValues[arrPopKeys[i]] = currentValue;
                }
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            }
            
            if (bolRefresh && element.hasAttribute('src')) {
                getData(element);
            } else if (bolRefresh && !element.hasAttribute('src')) {
                console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                
                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                }
            }
        }
        
        element.internal.bolQSFirstRun = true;
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            
        }
    }
    
    //
    function elementInserted(element) {
        var tableTemplateElement, tableTemplateElementCopy, oldRootElement, i, len,
            recordElement, strQueryString = GS.getQueryString(), arrElement, currentElement, strQSValue;
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);
                
                element.open = false;
                element.error = false;
                element.ready = false;
                
                // handle "qs" attribute
                if (element.getAttribute('qs') ||
                        element.getAttribute('refresh-on-querystring-values') ||
                        element.hasAttribute('refresh-on-querystring-change')) {
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.setAttribute('value', strQSValue);
                    //}
                    
                    element.popValues = {};
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate', function () {    pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate', function () {     pushReplacePopHandler(element); });
                }
                
                //
                tableTemplateElement = xtag.queryChildren(element, 'template')[0];
                
                if (tableTemplateElement) {
                    tableTemplateElementCopy = document.createElement('template');
                    tableTemplateElementCopy.innerHTML = tableTemplateElement.innerHTML;
                    
                    recordElement = xtag.query(xtag.query(tableTemplateElementCopy.content, 'tbody')[0], 'tr')[0];
                    
                    if (recordElement) {
                        arrElement = xtag.query(recordElement, '[column]');
                        
                        for (i = 0, len = arrElement.length; i < len; i += 1) {
                            currentElement = arrElement[i];
                            
                            if ((!currentElement.getAttribute('value')) && currentElement.getAttribute('column')) {
                                currentElement.setAttribute('value', '{{! row.' + currentElement.getAttribute('column') + ' }}');
                            }
                        }
                        
                        element.tableTemplate = tableTemplateElementCopy.innerHTML;
                        
                        if (!element.getAttribute('src') && !element.getAttribute('source') && !element.getAttribute('initalize')) {
                            //element.staticDropDownTable = GS.cloneElement(tableTemplateElementCopy.content.children[0]);
                            //element.dropDownTable = GS.cloneElement(tableTemplateElementCopy.content.children[0]); //element.staticDropDownTable;
                            
                            element.dropDownTable = GS.cloneElement(xtag.query(tableTemplateElementCopy.content, 'table')[0]);
                        }
                    }
                }
                
                // filling root
                refreshControl(element);
                
                //
                element.addEventListener('click', function (event) {
                    var clickHandler;
                    
                    if (event.target.classList.contains('drop_down_button')) {
                        //console.log(element.open, element.error);
                        if (!element.open && !element.error) {
                            clickHandler = function () {
                                openDropDown(element);
                                window.removeEventListener('click', clickHandler);
                            };
                            
                            window.addEventListener('click', clickHandler);
                        } else {
                            //closeDropDown(element);
                        }
                    }
                });
                
                element.addEventListener('keydown', function (event) {
                    if (event.target.classList.contains('control')) {
                        handleKeyDown(element, event);
                    }
                });
                
                element.addEventListener('keyup', function (event) {
                    if (event.target.classList.contains('control')) {
                        handleKeyUp(element, event);
                    }
                });
                
                if (xtag.queryChildren(element, '.root').length < 1) {
                    refreshControl(element);
                }
                
                if (element.getAttribute('src') || element.getAttribute('source') || element.getAttribute('initalize')) {
                    getData(element, true);
                } else {
                    element.ready = true;
                    
                    if (element.getAttribute('value')) {
                        selectRecordFromValue(element, element.getAttribute('value'), false);
                        
                    } else if (element.value) {
                        selectRecordFromValue(element, element.value, false);
                    }
                }
            }
        }
    }
    
    xtag.register('gs-combo', {
        lifecycle: {
            created: function () {
                // if the value was set before the "created" lifecycle code runs: set attribute
                //      (discovered when trying to set a value of a date control in the after_open of a dialog)
                //      ("delete" keyword added because of firefox)
                if (this.value && !this.hasAttribute('value')) {
                    this.setAttribute('value', this.value);
                    delete this.value;
                }
                
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value' && oldValue !== newValue) {
                        this.value = newValue;
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    if (this.control || this.innerValue) {
                        return this.innerValue || this.control.value;
                    } else if (this.getAttribute('value')) {
                        return this.getAttribute('value');
                    }
                    return undefined;
                },
                
                // set the value of the input and set the value attribute
                set: function (newValue) {
                    
                    // if we have not yet templated: just stick the value in an attribute
                    if (this.ready === false) {
                        if (newValue !== this.getAttribute('value')) {
                            this.setAttribute('value', newValue);
                        }
                        
                    // else if the value is empty and allow-empty is present
                    } else if (newValue === '' && this.hasAttribute('allow-empty')) {
                        this.innerValue = '';
                        this.control.value = '';
                        
                    // else select the record using the string that was sent
                    } else {
                        selectRecordFromValue(this, newValue, false);
                    }
                }
            },
            textValue: {
                // get value straight from the input
                get: function () {
                    return this.control.value;
                },
                
                // set the value of the input and set the value attribute
                set: function (newValue) {
                    
                    // if we have not yet templated: just stick the value in an attribute
                    if (this.ready === false) {
                        this.setAttribute('value', newValue);
                        
                    // else select the record using the string that was sent
                    } else {
                        selectRecordFromValue(this, newValue, false);
                    }
                }
            }
        },
        methods: {
            focus: function () {
                this.control.focus();
            },
            
            'getData': function () {
                getData(this, undefined, true);
            },
            
            'refresh': function () {
                getData(this, undefined, true);
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('<gs-container>', '<gs-container>', 'gs-container min-width="${1:sml;med;lrg;}" ${2:padded}>\n' +
                                                                '    ${0}\n' +
                                                                '</gs-container>');
    
    designRegisterElement('gs-container', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-container-jumbo.html');
    
    window.designElementProperty_GSCONTAINER = function(selectedElement) {
        var strVisibilityAttribute;
        
        addProp('Min-Width Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('min-width') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'min-width', this.value);
        });
        
        addProp('Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('media') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'media', this.value);
        });
        
        addProp('Padded', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('padded')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'padded', (this.value === 'true'), true);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var arrTakenContainers = [], intScrollBarWidth;
    
    function getScrollBarWidth() {
        var inner = document.createElement('div'),
            outer = document.createElement('div'),
            intWidth;
        
        inner.style.height = '200px';
        
        outer.style.position = 'absolute';
        outer.style.top = '0';
        outer.style.left = '0';
        outer.style.visibility = 'hidden';
        outer.style.overflow = 'scroll';
        
        outer.style.width = '50px';
        outer.style.height = '100px';
        
        outer.appendChild(inner);
        document.body.appendChild(outer);
        
        intWidth = (outer.offsetWidth - inner.offsetWidth);
        
        document.body.removeChild(outer);
        
        return intWidth;
    };
    
    intScrollBarWidth = getScrollBarWidth();
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            
        }
    }
    
    //
    function elementInserted(element) {
        var styleElement;
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
                // if the style element for the container CSS doesn't exist: create it
                if (!document.getElementById('gs-dynamic-css')) {
                    styleElement = document.createElement('style');
                    styleElement.setAttribute('id', 'gs-dynamic-css');
                    styleElement.setAttribute('gs-dynamic', '');
                    document.head.appendChild(styleElement);
                }
                
                if (element.getAttribute('min-width')) {
                    element.handleMinWidthCSS();
                } else if (element.getAttribute('media')) {
                    element.handleMediaCSS();
                }
            }
        }
    }
    
    xtag.register('gs-container', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // if the "min-width" attribute changed
                    if (strAttrName === 'min-width') {
                        this.handleMinWidthCSS();
                        
                    // if the "media" attribute changed
                    } else if (strAttrName === 'media') {
                        this.handleMediaCSS();
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            handleMinWidthCSS: function () {
                var strMinWidth = this.getAttribute('min-width'), arrMinWidths, strCSS, i, len,
                    arrClassesToRemove, intContainerID, intWidthNumber, strWidthOperator, strNewWidth;
                
                // remove old classes
                arrClassesToRemove = String(this.classList).match(/container-id-[0-9]*/g) || [];
                
                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }
                
                // sml;med;lrg
                // medium
                // 100;200;300;400;500;600;700;800;900;1000;1100;1200
                
                // remove all whitespace, lowercase, trim off semicolons
                strMinWidth = GS.trim(strMinWidth.replace(/\s+/g, '').toLowerCase(), ';');
                
                // replace shortcuts (lrg => 1200px)
                strMinWidth = strMinWidth.replace(/small|sml/g, '768px').replace(/medium|med/g, '992px').replace(/large|lrg/g, '1200px');
                
                arrMinWidths = strMinWidth.split(';'); // seperate out layouts
                
                //console.log(strMinWidth, arrMinWidths);
                
                if (arrTakenContainers.indexOf(strMinWidth) === -1) {
                    arrTakenContainers.push(strMinWidth);
                    intContainerID = arrTakenContainers.length - 1;
                    strCSS = '';
                    
                    for (i = 0, len = arrMinWidths.length; i < len; i += 1) {
                        intWidthNumber = parseInt(arrMinWidths[i]);
                        strWidthOperator = arrMinWidths[i].replace(/[0-9]/g, '');
                        
                        if (strWidthOperator === 'px') {
                            intWidthNumber -= intScrollBarWidth;
                        } else if (strWidthOperator === 'em') {
                            intWidthNumber -= GS.pxToEm(this.parentNode, intScrollBarWidth);
                        }
                        
                        strNewWidth = intWidthNumber + strWidthOperator;
                        
                        strCSS +=   '\n@media (min-width:' + arrMinWidths[i] + ') {\n' +
                                    '    gs-container.container-id-' + intContainerID +
                                                ' { width:' + strNewWidth + '; margin-left:auto; margin-right:auto; }\n' +
                                    '}\n';
                    }
                    
                    //console.log(strCSS);
                    
                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML +=
                            '\n/* container #' + intContainerID + ' */\n' + strCSS;
                    
                } else {
                    intContainerID = arrTakenContainers.indexOf(strMinWidth);
                }
                
                this.classList.add('container-id-' + intContainerID);
            },
            
            handleMediaCSS: function () {
                var strMedia = this.getAttribute('media'), arrMedias, strCSS, i, len,
                    arrClassesToRemove, arrParts, strCurrentMedia, strWidth, intContainerID;
                
                // remove old classes
                arrClassesToRemove = String(this.classList).match(/container-id-[0-9]*/g) || [];
                
                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }
                
                // (min-width: 500) {small}; (max-width: 500) {50}
                // (max-width: small) {small}; (min-width: small) {small}
                // (max-width: small) {50}; (min-width: small) {500}
                
                // trim, remove all close curly braces, lowercase, trim off semicolons
                strMedia = GS.trim(strMedia.trim().replace(/\}/g, '').toLowerCase(), ';');
                
                // replace shortcuts (lrg => 1200px)
                strMedia = strMedia.replace(/small|sml/g, '768px').replace(/medium|med/g, '992px').replace(/large|lrg/g, '1200px');
                
                arrMedias = strMedia.split(';'); // seperate out layouts
                
                //console.log(strMedia, arrMedias);
                
                if (arrTakenContainers.indexOf(strMedia) === -1) {
                    arrTakenContainers.push(strMedia);
                    intContainerID = arrTakenContainers.length - 1;
                    strCSS = '';
                    
                    
                    for (i = 0, len = arrMedias.length; i < len; i += 1) {
                        arrParts = arrMedias[i].split('{');
                        strCurrentMedia = arrParts[0].trim() || 'all';
                        strWidth = arrParts[1].trim() || '900px';
                        
                        strCSS +=   '\n@media ' + strCurrentMedia + ' {\n' +
                                    '    gs-container.container-id-' + intContainerID + ' ' +
                                                '{ width:' + strWidth + '; margin-left:auto; margin-right:auto; }\n' +
                                    '}\n';
                    }
                    
                    //console.log(strCSS);
                    
                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* container #' + intContainerID + ' */\n' + strCSS;
                    
                } else {
                    intContainerID = arrTakenContainers.indexOf(strMinWidth);
                }
                
                this.classList.add('container-id-' + intContainerID);
            }
        }
    });
});//jslint browser:true, white:true, multivar:true, for:true
window.addEventListener('design-register-element', function (event) {
    'use strict';
    
    registerDesignSnippet('<gs-datasheet>', '<gs-datasheet>',
            'gs-datasheet src="${1:test.tpeople}">\n' +
            '    <template for="hud"></template>\n' +
            '    <template for="table">\n' +
            '        <table>\n' +
            '            <tbody>\n' +
            '                <tr>\n' +
            '                    <th heading="#"><gs-static column="row_number"></gs-static></th>\n' +
            '                    <td heading="">$0</td>\n' +
            '                </tr>\n' +
            '            </tbody>\n' +
            '        </table>\n' +
            '    </template>\n' +
            '    <template for="insert"></template>\n' +
            '</gs-datasheet>');
    
    designRegisterElement('gs-datasheet', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-datasheet.html');
    
    window.designElementProperty_GSDATASHEET = function (selectedElement) {
        addProp('Source', true,
                '<gs-memo class="target" autoresize rows="1" value="' +
                        encodeHTML(decodeURIComponent(selectedElement.getAttribute('src'))) + '" mini></gs-memo>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
        });
        
        addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
        });
        
        addProp('Lock Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('lock') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'lock', this.value);
        });
        
        addProp('Primary Keys', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('pk') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'pk', this.value);
        });
        
        addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('where') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'where', (this.value));
        });
        
        addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
        });
        
        addProp('Limit', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
        });
        
        addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
        });
        
        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });
        
        addProp('Parent&nbsp;Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });
        
        addProp('Line Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('child-column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'child-column', this.value);
        });
        
        addProp('Reflow At', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('reflow-at') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'reflow-at', this.value);
        });
        
        addProp('Scroll To Bottom', true, '<gs-checkbox class="target" value="' + encodeHTML(selectedElement.hasAttribute('scroll-to-bottom') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'scroll-to-bottom', (this.value === 'true'), true);
        });
        
        addProp('HUD Paginate', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudpaginate')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-hudpaginate', (this.value === 'true'), false);
        });
        
        addProp('HUD Refresh', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudrefresh')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-hudrefresh', (this.value === 'true'), false);
        });
        
        addProp('HUD Delete', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-huddelete')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-huddelete', (this.value === 'true'), false);
        });
        
        addProp('Expand&nbsp;To&nbsp;Content', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('expand-to-content')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'expand-to-content', (this.value === 'true'), true);
        });
        
        addProp('Null String', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('null-string') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'null-string', this.value);
        });
        
        addProp('Filter Popup', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-filter')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-filter', (this.value === 'true'), false);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
            this.removeAttribute('refresh-on-querystring-change');
            return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
        });
        
        addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
            this.removeAttribute('refresh-on-querystring-values');
            return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
        });
        
        //// SUSPEND-CREATED attribute
        //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
        //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        //});
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var KEY_RETURN = 13, KEY_TAB = 9, KEY_BACKSPACE = 8, KEY_DELETE = 46
      , KEY_UP = 38, KEY_RIGHT = 39, KEY_DOWN = 40, KEY_LEFT = 37;
    
    function deleteSelection(element) {
        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'))
          , strObject = GS.templateWithQuerystring(element.getAttribute('object'))
          , arrSelectRecords = element.selectedRecords, deleteRecord, deleteRecordData
          , arrPk, arrLock, strHashColumns, strRoles, strColumns, strRecord
          , strRecordToHash, strDeleteData, strTemp, i, len, col_i, col_len;
        
        // if the first record is the header: remove it from the selection
        if (arrSelectRecords[0] && arrSelectRecords[0].parentNode.nodeName === 'THEAD') {
            arrSelectRecords.splice(0, 1);
        }
        
        if (element.numberOfSelections === 1
                && arrSelectRecords.length > 0
                && arrSelectRecords[0].children[0].hasAttribute('selected')
                && !element.deleteButton.hasAttribute('disabled')) {
            
            // generate the information to send to the websocket
            arrPk = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
            arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);
            
            for (i = 0, len = arrPk.length, strRoles = '', strColumns = ''; i < len; i += 1) {
                strRoles += (strRoles ? '\t' : '') + 'pk';
                strColumns += (strColumns ? '\t' : '') + arrPk[i];
            }
            
            for (i = 0, len = arrLock.length, strHashColumns = ''; i < len; i += 1) {
                strHashColumns += (strHashColumns ? '\t' : '') + arrLock[i];
            }
            
            strRoles += (strRoles ? '\t' : '') + 'hash';
            strColumns += (strColumns ? '\t' : '') + 'hash';
            
            for (i = 0, len = arrSelectRecords.length, strDeleteData = ''; i < len; i += 1) {
                strRecord = '';
                deleteRecord = arrSelectRecords[i];
                deleteRecordData = element.internalData.arrRecords[parseInt(deleteRecord.getAttribute('data-index'), 10)];
                //console.log(deleteRecordData);
                
                // get 'pk' columns
                for (col_i = 0, col_len = arrPk.length; col_i < col_len; col_i += 1) {
                    strRecord += (strRecord ? '\t' : '');
                    strRecord += GS.encodeForTabDelimited(deleteRecordData[element.internalData.arrColumnNames.indexOf(arrPk[col_i])], element.nullString);
                }
                
                // get 'hash' columns
                strRecordToHash = '';
                for (col_i = 0, col_len = arrLock.length; col_i < col_len; col_i += 1) {
                    strRecordToHash += (strRecordToHash ? '\t' : '');
                    strTemp = deleteRecordData[element.internalData.arrColumnNames.indexOf(arrLock[col_i])];
                    
                    // I believe that this needs to use the null-string instead of 'NULL'
                    strRecordToHash += (strTemp === 'NULL' ? '' : strTemp);
                }
                
                strDeleteData += (strRecord + (strRecord ? '\t' : '') + GS.utfSafeMD5(strRecordToHash).toString() + '\n');
                arrSelectRecords[i].classList.add('bg-red');
            }
            
            strDeleteData = (strRoles + '\n' + strColumns + '\n' + strDeleteData);
            
            // create delete transaction
            GS.addLoader(element, 'Creating Delete Transaction...');
            GS.requestDeleteFromSocket(
                getSocket(element), strSchema, strObject, strHashColumns, strDeleteData
                , function (data, error, transactionID) {
                    if (error) {
                        getData(element);
                        GS.removeLoader(element);
                        GS.webSocketErrorDialog(data);
                    }
                }
                , function (data, error, transactionID, commitFunction, rollbackFunction) {
                    var arrElements, i, len, templateElement;
                    GS.removeLoader(element);
                    
                    if (!error) {
                        if (data !== 'TRANSACTION COMPLETED') {
                            arrElements = xtag.query(element, '.bg-red');
                            
                            for (i = 0, len = arrElements.length; i < len; i += 1) {
                                arrElements[i].classList.remove('bg-red');
                                arrElements[i].classList.add('bg-amber');
                            }
                            
                        // open confirm message box
                        } else {
                            templateElement = document.createElement('template');
                            templateElement.innerHTML = ml(function () {/*
                                <gs-page>
                                    <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                    <gs-body padded>
                                        <center>Are you sure you want to delete {{numberofrecords}} records?</center>
                                    </gs-body>
                                    <gs-footer>
                                        <gs-grid>
                                            <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                            <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                        </gs-grid>
                                    </gs-footer>
                                </gs-page>
                            */}).replace(/\{\{numberofrecords\}\}/gi, xtag.query(element, '.bg-amber').length);
                            
                            GS.openDialog(templateElement, function () {
                                document.getElementById('datasheet-focus-me').focus();
                                
                            }, function (event, strAnswer) {
                                if (strAnswer === 'Yes') {
                                    commitFunction();
                                    GS.addLoader(element, 'Commiting Delete Transaction...');
                                } else {
                                    rollbackFunction();
                                    GS.addLoader(element, 'Rolling Back Delete Transaction...');
                                }
                            });
                        }
                        
                    } else {
                        rollbackFunction();
                        getData(element);
                        GS.webSocketErrorDialog(data);
                    }
                }
                // final result callback, because we need to handle the commit/rollback response
                , function (strAnswer, data, error) {
                    var arrElements, i, len;
                    GS.removeLoader(element);
                    
                    if (!error) {
                        if (strAnswer === 'COMMIT') {
                            // remove amber records, because the amber records have now been deleted
                            removeRecords(element, 'bg-amber');
                            
                            // clear internal variables for selection now that the selected records have been deleted,
                            //      because if you try to shift-select to extend the selection and the origin cell has
                            //      been deleted this may cause an error
                            clearSelection(element);
                            
                            // trigger after_delete so that developers can react to a successful delete
                            GS.triggerEvent(element, 'after_delete');
                            
                        } else {
                            // clear bg-amber class and don't add a green fade
                            clearRecordColor(element, 'bg-amber', false);
                        }
                        
                        // update record selector numbers to reflect current record numbers
                        //      because after you delete records there may be a gap in the numbers and that is not acceptable
                        arrElements = xtag.query(element, 'tbody > tr');
                        
                        for (i = 0, len = arrElements.length; i < len; i += 1) {
                            if (!arrElements[i].classList.contains('insert-record')) {
                                arrElements[i].children[0].textContent = (i + 1);
                            }
                        }
                        
                    // if an error occurred
                    } else {
                        // get new data, because after an error we don't know the current state
                        //      of the data so a re-fetch will help mitigate inaccurate data errors
                        getData(element);
                        
                        // open an error dialog so that the user knows there was an error
                        GS.webSocketErrorDialog(data);
                    }
                }
            );
        }
    }
    
    function insertDialog(element) {
        var templateElement = document.createElement('template'), strAddin;
        
        // if there is a column attribute on this element: append child column (or column) and
        //      the value to the insert string so that we can have parent-child relationships
        if (element.getAttribute('column') || element.getAttribute('qs')) {
            strAddin =  (
                            element.getAttribute('child-column')
                         || element.getAttribute('column')
                         || element.getAttribute('qs')
                        ) +
                        '=' +
                        element.value;
        }
        
        templateElement.innerHTML = ml(function () {/*
            <gs-page gs-dynamic>
                <gs-header>
                    <center><h3>Insert</h3></center>
                </gs-header>
                <gs-body padded>
                    <gs-insert id="insert-dialog-content-container" src="{{SRC}}" addin="{{ADDIN}}">{{HTML}}</gs-insert>
                </gs-body>
                <gs-footer>
                    <gs-grid widths="1,1" class="width-2">
                        <gs-block width="1">
                            <gs-button dialogclose>Cancel</gs-button>
                        </gs-block>
                        <gs-block width="1">
                            <gs-button class="dialog-envelope-insert" listen-for-return bg-primary>Ok</gs-button>
                        </gs-block>
                    </gs-grid>
                </gs-footer>
            </gs-page>
        */}).replace('{{HTML}}', element.insertTemplate)
            .replace('{{SRC}}', encodeHTML(element.getAttribute('src')))
            .replace('{{ADDIN}}', encodeHTML(strAddin || ''));
        
        GS.openDialog(templateElement, function () {
            var dialog = this;
            
            // if gs-datasheet has sequence attribute: add sequence attribute to gs-insert
            if (element.getAttribute('seq')) {
                document.getElementById('insert-dialog-content-container').setAttribute('seq', element.getAttribute('seq'));
            }
            
            GS.triggerEvent(element, 'insert_dialog_open');
            
            xtag.query(dialog, '.dialog-envelope-insert')[0].addEventListener('click', function () {
                var insertContainer = document.getElementById('insert-dialog-content-container');
                
                insertContainer.submit(function (lastval, jsnRow) {
                    getData(element);
                    GS.triggerEvent(element, 'after_insert');
                    GS.closeDialog(dialog, 'Ok');
                });
            });
        });
    }
    
    function clearSelection(element) {
        element.savedSelection = [];
        element.savedSelectionCopy = [];
        element.dragOrigin = null;
        element.dragCurrentCell = null;
        element.selectionPreviousOrigin = null;
        element.numberOfSelections = 0;
        element.selectedCells = [];
    }
    
    function templateRecordsForInsert(element, strRecords, strClasses) {
        var arrRecords, arrCells, i, len, cell_i, cell_len, col_len, strHTML, intRowNumberAdd;
        
        // calculate the number of cells across
        if (element.getAttribute('cols')) {
            col_len = (element.getAttribute('cols') || '').split(/[\s]*,[\s]*/).length;
        }
        
        arrRecords = strRecords.split('\n');
        
        // calculate how much to add to the row numbers
        intRowNumberAdd = xtag.query(element, 'tr:not(.bg-red):not(.insert-record)').length - 1;
        
        for (i = 1, len = arrRecords.length - 1, strHTML = ''; i < len; i += 1) {
            arrCells = arrRecords[i].split('\t');
            
            strHTML += '<tr ' + (strClasses ? ' class="' + strClasses + '"' : '');
            
            for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                strHTML += 'data-' + element.internalData.arrColumnNames[cell_i] +
                                '="' + encodeHTML(GS.decodeFromTabDelimited(arrCells[cell_i], element.nullString)) + '"';
            }
            
            strHTML += '><th>' + (intRowNumberAdd + (i)) + '</th>';
            
            for (cell_i = 0, cell_len = (col_len || arrCells.length); cell_i < cell_len; cell_i += 1) {
                strHTML += '<td><textarea rows="1" column="' + element.internalData.arrColumnNames[cell_i] + '">' +
                                encodeHTML(GS.decodeFromTabDelimited(arrCells[cell_i], element.nullString) || '') +
                            '</textarea></td>';
            }
            
            strHTML += '</tr>';
        }
        
        
        //    strHTML = GS.templateWithEnvelopeData(element.tableTemplate.templateHTML, {
        //                        'arr_column': data.arrColumnNames
        //                      , 'dat': element.internalData.arrRecords
        //              }, intStart, element.internalData.arrRecords.length);
        //    
        //    strHTML = GS.templateShowSubTemplates(strHTML, element.tableTemplate);
        //
        //trMaker.children[0].classList.add('insert-record');
        
        return strHTML;
    }
    
    function handleData(element, data, bolFirstLoad, bolManualRefresh) {
        var strHTML, i, len, cell_i, cell_len, col_len, arrRecords
          , arrCells, disabled, arrColumns, arrElements, tbodyElement
          , trMaker, intStart, bolHeader, strWidth, numberOffset;
        
        // calculate the number of cells across
        if (element.getAttribute('cols')) {
            //col_len = (element.getAttribute('cols') || '').split(/[\s]*,[\s]*/).length;
            
            arrColumns = (element.getAttribute('cols') || '').split(/[\s]*,[\s]*/);
            
            for (i = 0, len = arrColumns.length; i < len; i += 1) {
                arrColumns[i] = data.arrColumnNames.indexOf(arrColumns[i]);
            }
        }
        
        disabled = element.hasAttribute('disabled') || !element.hasAttribute('pk');
        
        // if first callback: table and header
        if (data.intCallback === 0) {
            if (!element.hasAttribute('lock')) {
                element.setAttribute('lock', data.arrColumnNames.join(','));
            }
            if (!element.hasAttribute('cols')) {
                element.setAttribute('cols', data.arrColumnNames.join(','));
            }
            if (disabled) {
                element.deleteButton.setAttribute('disabled', '');
            } else {
                element.deleteButton.removeAttribute('disabled');
            }
            
            element.internalData = {
                'arrColumnNames': data.arrColumnNames || []
              , 'arrColumnTypes': data.arrColumnTypes || []
              , 'arrRecords': []
            };
            
            if (element.headerTemplateRecord) {
                strHTML = GS.templateWithQuerystring(element.headerTemplateRecord);
                element.scrollContainer.innerHTML = '<table><thead>' + strHTML + '</thead><tbody></tbody></table>';
                
            } else {
                arrElements = xtag.queryChildren(element.tableTemplateRecord, 'td, th');
                for (i = 0, len = arrElements.length, strHTML = ''; i < len; i += 1) {
                    strHTML += '<th>' + encodeHTML(arrElements[i].getAttribute('heading') || '') + '</th>';
                    
                    bolHeader = Boolean(arrElements[i].hasAttribute('heading') || '') || bolHeader;
                }
                strHTML = '<tr>' + strHTML + '</tr>';
                
                if (bolHeader) {
                    element.scrollContainer.innerHTML = '<table><thead>' + strHTML + '</thead><tbody></tbody></table>';
                } else {
                    element.scrollContainer.innerHTML = '<table><thead hidden>' + strHTML + '</thead><tbody></tbody></table>';
                }
            }
        }
        
        // if not last callback: append data to end of table
        if (data.strMessage !== 'TRANSACTION COMPLETED') {
            arrRecords = data.strMessage.split('\n');
            
            intStart = element.internalData.arrRecords.length;
            
            for (i = 0, len = arrRecords.length - 1, strHTML = ''; i < len; i += 1) {
                arrCells = arrRecords[i].split('\t');
                
                for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                    arrCells[cell_i] = GS.decodeFromTabDelimited(arrCells[cell_i], element.nullString);
                }
                
                element.internalData.arrRecords.push(arrCells);
            }
            
            if (element.paginated === true && !isNaN(element.getAttribute('offset'))) {
                numberOffset = parseInt(element.getAttribute('offset'), 10);
            } else {
                numberOffset = 0
            }
            
            strHTML = GS.templateWithEnvelopeData(
                        element.tableTemplate.templateHTML
                      , {
                            'arr_column': data.arrColumnNames
                          , 'dat': element.internalData.arrRecords
                        }
                      , intStart
                      , element.internalData.arrRecords.length
                      , numberOffset);
            
            strHTML = GS.templateShowSubTemplates(strHTML, element.tableTemplate);
            
            trMaker = document.createElement('tbody');
            trMaker.innerHTML = strHTML;
            tbodyElement = xtag.query(element.scrollContainer, 'tbody')[0];
            
            arrElements = xtag.toArray(trMaker.children);
            for (i = 0, len = arrElements.length; i < len; i += 1) {
                tbodyElement.appendChild(arrElements[i]);
            }
            //xtag.query(element.scrollContainer, 'tbody')[0].innerHTML += strHTML;
            
        // if last callback: insert record
        } else {
            arrElements = xtag.query(element.scrollContainer, 'tbody tr');
            
            if (arrElements[0] && arrElements[0].children[0].nodeName === 'TH' && !isNaN(arrElements[0].children[0].textContent)) {
                
                strWidth = (
                                GS.pxToEm(element.hudContainer,
                                    GS.getTextWidth(element.hudContainer,
                                        String(element.internalData.arrRecords.length + 1)
                                    )
                                ) + 1
                            ) + 'em';
                
                xtag.query(element.scrollContainer, 'thead th')[0].style.width = strWidth;
                xtag.query(element.scrollContainer, 'tbody th')[0].style.width = strWidth;
            }
            
            if (parseInt((element.getAttribute('limit') || '0'), 10) > arrElements.length) {
                element.pageRightButton.setAttribute('disabled', '');
            } else {
                element.pageRightButton.removeAttribute('disabled');
            }
            
            //if (element.insertRecordElement) {
            //    trMaker = document.createElement('tbody');
            //    trMaker.innerHTML = element.insertRecordElement.outerHTML;
            //    trMaker.children[0].classList.add('insert-record');
            //    tbodyElement = xtag.query(element.scrollContainer, 'tbody')[0];
            //    
            //    //if (tbodyElement.children[0]) {
            //    //    tbodyElement.insertBefore(trMaker.children[0], tbodyElement.children[0]);
            //    //} else {
            //    tbodyElement.appendChild(trMaker.children[0]);
            //    //}
            //}
            
            arrElements = xtag.query(element.scrollContainer, 'tr');
            
            if (arrElements[0].parentNode.hasAttribute('hidden')) {
                element.headerContainer.innerHTML = '<table><thead hidden>' + arrElements[0].outerHTML + '</thead></table>';
            } else {
                element.headerContainer.innerHTML = '<table><thead>' + arrElements[0].outerHTML + '</thead></table>';
            }
            
            element.headerTR = element.headerContainer.children[0].children[0].children[0];
            
            refreshReflow(element);
            refreshHeight(element);
            synchronize(element, undefined, true, bolManualRefresh);
            synchronizeHeaderWidths(element);
            synchronizeHeaderScroll(element);
            
            if (bolFirstLoad && element.hasAttribute('scroll-to-bottom')) {
                element.scrollContainer.scrollTop = element.scrollContainer.scrollHeight;
            }
            
            GS.triggerEvent(element, 'after_select');
        }
    }
    
    function synchronizeHeaderWidths(element) {
        'use strict';
        var guideTR, targetTR, arrChildren, i, len, subtractPadding;
        
        targetTR = element.headerTR;
        if (element.scrollContainer) {
            guideTR = xtag.query(element.scrollContainer, 'tr')[0];
            
            if (guideTR) {
                arrChildren = xtag.toArray(guideTR.children);
                subtractPadding = 0; //GS.emToPx(element.headerContainer, 0.2);
                
                if (element.scrollContainer.scrollHeight > element.scrollContainer.clientHeight) {
                    element.headerContainer.classList.add('scroll');
                } else {
                    element.headerContainer.classList.remove('scroll');
                }
                
                for (i = 0, len = arrChildren.length; i < len; i += 1) {
                    targetTR.children[i].style.width = (arrChildren[i].clientWidth - subtractPadding) + 'px';
                }
            }
        }
    }
    function synchronizeHeaderScroll(element) {
        'use strict';
        if (element.headerContainer && element.scrollContainer) {
            if (element.scrollContainer.scrollTop > 0) {
                element.headerContainer.classList.add('shadow');
            } else {
                element.headerContainer.classList.remove('shadow');
            }
            element.headerContainer.scrollLeft = element.scrollContainer.scrollLeft;
        }
    }
    
    
    // get return column list
    function getReturn(element) {
        var arrColumns = [], arrSupplementalColumns = [], arrColsAttr, strColumns, arrPK, arrLock, i, len;
        
        // pk
        arrPK = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
        
        for (i = 0, len = arrPK.length; i < len; i += 1) {
            if (arrPK[i]) {
                GS.listAdd(arrSupplementalColumns, arrPK[i]);
            }
        }
        
        // lock
        arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);
        
        for (i = 0, len = arrLock.length; i < len; i += 1) {
            if (arrLock[i]) {
                GS.listAdd(arrSupplementalColumns, arrLock[i]);
            }
        }
        
        if (element.internalData && element.internalData.arrColumnNames) {
            for (i = 0, len = element.internalData.arrColumnNames.length; i < len; i += 1) {
                GS.listAdd(arrColumns, element.internalData.arrColumnNames[i]);
            }
        } else if (element.getAttribute('cols')) {
            arrColsAttr = element.getAttribute('cols').split(/[\s]*,[\s]*/);
            
            for (i = 0, len = arrColsAttr.length; i < len; i += 1) {
                GS.listAdd(arrColumns, arrColsAttr[i]);
            }
        }
        
        if (arrColumns.length === 0 || (arrColumns.length === 1 && arrColumns[0] === '*')) {
            strColumns = '*';
            
        } else {
            for (i = 0, len = arrSupplementalColumns.length; i < len; i += 1) {
                GS.listAdd(arrColumns, arrSupplementalColumns[i]);
            }
            
            strColumns = arrColumns.join('\t');
        }
        
        return strColumns;
    }
    
    function valueListToHTML(valueText, fieldDelimiter, recordDelimiter, bolFirstContainsHeadings, quoteCharacter, decodeFunction) {
        var i = 0, len = valueText.length, col_i, col_len,
            arrHeadings = [], arrRecords = [], arrRecord = [],
            bolInQuote = false,
            strCell = '',
            strRecord,
            strHTML = '', strPreviousChar;
        
        // if there is a recordDelimiter at the beginning: add 1 to "i" to skip over it
        if (valueText[0] === recordDelimiter) {
            i += 1;
        }
        
        // make sure there is a recordDelimiter at the end
        if (valueText[len - 1] !== recordDelimiter) {
            valueText += recordDelimiter;
            len = valueText.length;
        }
        
        // looper
        for (; i < len; i += 1) {
            if (valueText[i] === quoteCharacter && bolInQuote === false
                && (
                    strPreviousChar === fieldDelimiter ||
                    strPreviousChar === recordDelimiter ||
                    strPreviousChar === undefined
                )) {
                bolInQuote = true;
                
            } else if (valueText[i] === quoteCharacter && bolInQuote === true) {
                bolInQuote = false;
                
            } else if (valueText[i] === fieldDelimiter && bolInQuote === false) {
                arrRecord.push(decodeFunction(strCell, element.nullString));
                strCell = '';
                
            } else if (valueText[i] === recordDelimiter && bolInQuote === false) {
                arrRecord.push(decodeFunction(strCell, element.nullString));
                strCell = '';
                
                arrRecords.push(arrRecord);
                arrRecord = [];
                
            } else {
                strCell += valueText[i];
            }
            
            strPreviousChar = valueText[i];
        }
        
        // data structure to html
        for (i = 0, len = arrRecords.length; i < len; i += 1) {
            for (col_i = 0, col_len = arrRecords[i].length, strRecord = ''; col_i < col_len; col_i += 1) {
                strRecord += '<td>' + encodeHTML(arrRecords[i][col_i]) + '</td>';
            }
            
            strHTML += '<tr>' + strRecord + '</tr>';
        }
        
        return '<table>' + strHTML + '</table>';
    }
    
    function quoteIdent(strValue) {
        strValue = strValue || '';
        
        // if first char is not a lowercase letter or there is a character that is not a lowercase letter, underscore or number
        if (!(/[a-z]/).test(strValue[0]) || (/[^a-z_]/).test(strValue)) {
            strValue = '"' + strValue.replace(/\"/gim, '""') + '"';
        }
        
        return strValue;
    }
    
    // disfated's answer at: http://stackoverflow.com/questions/202605/repeat-string-javascript
    function stringRepeat(pattern, count) {
        if (count < 1) return '';
        var result = '';
        while (count > 1) {
            if (count & 1) result += pattern;
            count >>= 1, pattern += pattern;
        }
        return result + pattern;
    }
    
    function getSocket(element) {
        if (element.getAttribute('socket')) {
            return GS[element.getAttribute('socket')];
        }
        return GS.envSocket;
    }
    
    function getData(element, refocusSelector, refocusSelection, bolFirstLoad, bolManualRefresh) {
        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema') || '')
          , strObject = GS.templateWithQuerystring(element.getAttribute('object') || '')
          , strReturn = getReturn(element) || ''
          , strWhere  = GS.templateWithQuerystring(element.getAttribute('where')  || '1=1')
          , strOrd    = GS.templateWithQuerystring(element.getAttribute('ord')    || '')
          , strLimit  = GS.templateWithQuerystring(element.getAttribute('limit')  || '')
          , strOffset = GS.templateWithQuerystring(element.getAttribute('offset') || '0')
          , strWhereColumn;
        
        // add in user where, if any
        if (element.getAttribute('user-where')) {
            strWhere = '(' + element.getAttribute('user-where') + ')' + (strWhere ? ' AND ' + strWhere : '');
        }
        
        // add in a column or qs where, if any
        
        // if there is a column attribute on element element: combine the where attribute with a where generated by value
        if ((element.getAttribute('column') || element.getAttribute('qs')) && element.value) {
            strWhereColumn = element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs');
            
            if (isNaN(element.value)) {
                strWhere =
                    'CAST(' + strWhereColumn + ' AS ' + GS.database.type.text + ') = ' +
                    'CAST($WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')' +
                    (strWhere !== '' ? ' AND (' + strWhere + ')' : '');
            } else {
                strWhere = strWhereColumn + '=' + (element.value) + (strWhere !== '' ? ' AND (' + strWhere + ')' : '');
            }
        }
        
        // disabled, hide or not the pageinate buttons
        if (strLimit === '') {
            element.pageLeftButton.setAttribute('hidden', '');
            element.pageRightButton.setAttribute('hidden', '');
        } else if (strOffset === '' || strOffset === '0') {
            element.pageLeftButton.setAttribute('disabled', '');
        }
        
        GS.addLoader(element, 'Loading...');
        GS.requestSelectFromSocket(
                        getSocket(element), strSchema, strObject, strReturn
                      , strWhere, strOrd, strLimit, strOffset
          , function (data, error) {
                var refocusElement;
                
                if (!error) {
                    handleData(element, data, bolFirstLoad, bolManualRefresh);
                    
                    if (data.strMessage === 'TRANSACTION COMPLETED') {
                        GS.removeLoader(element);
                    }
                    
                    if (data.strMessage === 'TRANSACTION COMPLETED' && refocusSelector) {
                        refocusElement = xtag.query(element, refocusSelector)[0];
                        
                        if (refocusElement) {
                            refocusElement.focus();
                            
                            if (refocusSelection) {
                                GS.setInputSelection(refocusElement, refocusSelection.start, refocusSelection.end);
                            }
                        }
                    }
                    
                } else {
                    GS.removeLoader(element);
                    if (!element.scrollContainer.innerHTML) {
                        element.scrollContainer.innerHTML = '<' + 'center><h2>Couldn\'t Load Data.</h2></' + 'center>';
                    }
                    GS.webSocketErrorDialog(data);
                }
            }
        );
    }
    
    
    function getSelectedCopyHTML(element) {
        var strHTMLCopyString, intFromRecord, intToRecord, intFromCell = 9999999, intToCell = 0
          , i, len, cell_i, cell_len, arrSelected, strCellHTML, arrRecords, arrCells
          , strHTMLRecordString;
        
        arrSelected = element.selectedCells;
        
        // loop through the selected cells and create an html string using the text of the cell
        if (arrSelected.length > 0) {
            intFromRecord = arrSelected[0].parentNode.rowIndex;
            intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;
            
            for (i = 0, len = arrSelected.length; i < len; i += 1) {
                if (arrSelected[i].cellIndex < intFromCell) {
                    intFromCell = arrSelected[i].cellIndex;
                    intFromCell = (intFromCell === 0 ? 1 : intFromCell);
                }
                if (arrSelected[i].cellIndex + 1 > intToCell) {
                    intToCell = arrSelected[i].cellIndex + 1;
                }
            }
            
            arrRecords = xtag.query(element, 'tr');
            strHTMLCopyString = '';
            
            for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                arrCells = arrRecords[i].children;
                strHTMLRecordString = '';
                
                if (!arrRecords[i].classList.contains('insert-record')) {
                    for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                        strCellHTML = '';
                        
                        if (arrCells[cell_i].hasAttribute('selected')) {
                            if (arrCells[cell_i].lastElementChild) { 
                                strCellHTML = arrCells[cell_i].lastElementChild.textValue ||
                                              arrCells[cell_i].lastElementChild.value ||
                                              (arrCells[cell_i].lastElementChild.checked || '').toString();
                            } else {
                                strCellHTML = arrCells[cell_i].textContent.trim();
                            }
                            
                            strCellHTML = encodeHTML(strCellHTML).replace(/\n/gim, '<br />');
                        }
                        
                        strCellHTML = '<' + 'td rowspan="1" colspan="1">' + (strCellHTML || '') + '</td>'
                        
                        strHTMLRecordString += (cell_i === intFromCell ? '<' + 'tr>' : '');
                        strHTMLRecordString += (strCellHTML || '');
                        strHTMLRecordString += (cell_i === (intToCell - 1) ? '<' + '/tr>' : '');
                    }
                }
                if (strHTMLRecordString.trim()) {
                    strHTMLCopyString += strHTMLRecordString;
                }
            }
            
            if (strHTMLCopyString) {
                strHTMLCopyString = '<' + 'style>' +
                                        'br { mso-data-placement:same-cell; } ' +
                                        'th, td { white-space: pre-wrap; }' +
                                    '<' + '/style>' +
                                    '<' + 'table border="0" cellpadding="0" cellspacing="0">' + strHTMLCopyString + '<' + '/table>';
            }
        }
        
        return strHTMLCopyString || '';
    }
    
    function getSelectedCopyText(element) {
        var strTextCopyString, intFromRecord, intToRecord, intFromCell = 9999999, intToCell = 0,
            i, len, cell_i, cell_len, arrSelected, strCellText, arrRecords, arrCells, arrCellIndexes, strTextRecordString;
        
        arrSelected = element.selectedCells;
        
        // loop through the selected cells and create a tsv string using the text of the cell
        if (arrSelected.length > 0) {
            intFromRecord = arrSelected[0].parentNode.rowIndex;
            intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;
            
            for (i = 0, len = arrSelected.length; i < len; i += 1) {
                if (arrSelected[i].cellIndex < intFromCell) {
                    intFromCell = arrSelected[i].cellIndex;
                    intFromCell = (intFromCell === 0 ? 1 : intFromCell);
                }
                if (arrSelected[i].cellIndex + 1 > intToCell) {
                    intToCell = arrSelected[i].cellIndex + 1;
                }
            }
            
            arrRecords = xtag.query(element, 'tr');
            strTextCopyString = '';
            
            for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                arrCells = arrRecords[i].children;
                strTextRecordString = '';
                
                for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                    if (!arrCells[cell_i].parentNode.classList.contains('insert-record')) {
                        strCellText = '';
                        
                        if (arrCells[cell_i].hasAttribute('selected')) {
                            if (arrCells[cell_i].lastElementChild) { 
                                strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                              arrCells[cell_i].lastElementChild.value ||
                                              (arrCells[cell_i].lastElementChild.checked || '').toString();
                            } else {
                                strCellText = arrCells[cell_i].textContent.trim();
                            }
                            
                            strCellText = strCellText.replace(/\"/gim, '""');
                        }
                        
                        strTextRecordString += (cell_i !== intFromCell ? '\t' : '');
                        strTextRecordString += (strCellText || '');
                    }
                }
                //if (strTextRecordString.trim()) {
                strTextCopyString += strTextRecordString;
                //}
                if (i + 1 !== len) { //&& strTextRecordString.trim()
                    strTextCopyString += '\n';
                }
            }
        }
        
        return strTextCopyString || '';
    }
    
    function handleClipboardData(event, strCopyString, strType) {
        var clipboardData = event.clipboardData || window.clipboardData, strMime;
        
        if (!clipboardData) { return; }
        if (!clipboardData.setData) { return; }
        
        if (strType === 'text') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = 'Text';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/plain';
            }
            
        } else if (strType === 'html') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = '';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/html';
            }
            
        } else {
            throw 'handleClipboardData Error: Type "' + strType + '" not recognized, recognized types are "text" and "html".';
        }
        
        if (strMime) {
            if (strCopyString && strMime) {
                return clipboardData.setData(strMime, strCopyString) !== false;
            } else {
                return clipboardData.getData(strMime);
            }
        }
    }
    
    
    function selectHandler(element, dragOriginCell, dragCurrentCell, dragMode) {
        var arrRecords = xtag.query(element, 'tr'), arrCells = xtag.query(element, 'td, th'),
            dragOriginRecord = dragOriginCell.parentNode,
            dragCurrentRecord = dragCurrentCell.parentNode,
            intStartRecordIndex, intStartCellIndex, intEndRecordIndex, intEndCellIndex,
            i, len, col_i, col_len, selectionIndex;
        
        // if origin & currentCell are both the top-left cell and the cell is a heading: select all cells
        if (dragOriginRecord.rowIndex === 0 && dragCurrentRecord.rowIndex === 0 &&
            dragOriginCell.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
            intStartRecordIndex = 0;
            intStartCellIndex = 0;
            intEndRecordIndex = arrRecords.length - 1;
            intEndCellIndex = arrRecords[0].children.length - 1;
            
        // else if origin is a first th: select the records from origin to currentCell
        } else if (dragOriginCell.cellIndex === 0) {
            intStartRecordIndex = Math.min(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
            intStartCellIndex = 0;
            intEndRecordIndex = Math.max(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
            intEndCellIndex = arrRecords[0].children.length - 1;
            
        // else if origin is a heading: select the columns from origin to currentCell
        } else if (dragOriginRecord.rowIndex === 0) {
            intStartRecordIndex = 0;
            intStartCellIndex = Math.min(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);
            intEndRecordIndex = arrRecords.length - 1;
            intEndCellIndex = Math.max(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);
            
        // else select cells from origin to currentCell
        } else {
            intStartRecordIndex = Math.min(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
            intStartCellIndex = Math.min(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);
            intEndRecordIndex = Math.max(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
            intEndCellIndex = Math.max(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);
        }
        
        element.savedSelection = element.savedSelectionCopy.slice(0);
        
        if (dragMode === 'select') {
            for (i = intStartRecordIndex, len = intEndRecordIndex + 1; i < len; i += 1) {
                for (col_i = intStartCellIndex, col_len = intEndCellIndex + 1; col_i < col_len; col_i += 1) {
                    if (element.savedSelection.indexOf(i + ',' + col_i) === -1) {
                        element.savedSelection.push(i + ',' + col_i);
                    }
                }
            }
            
        } else { // implied if: dragMode === 'deselect'
            for (i = intStartRecordIndex, len = intEndRecordIndex + 1; i < len; i += 1) {
                for (col_i = intStartCellIndex, col_len = intEndCellIndex + 1; col_i < col_len; col_i += 1) {
                    selectionIndex = element.savedSelection.indexOf(i + ',' + col_i);
                    
                    if (selectionIndex > -1) {
                        element.savedSelection.splice(selectionIndex, 1);
                    }
                }
            }
        }
        
        synchronize(element);
    }
    
    function synchronize(element, bolScroll, bolOnLoad, bolManualRefresh) {
        var arrRecords = xtag.query(element, 'tr'), selectCells = [], i, len,
            arrParts, arrTextareas, focusedElement, recordIndex, cellIndex;
        
        // selection
        if (element.savedSelection) {
            // loop through savedSelection
            for (i = 0, len = element.savedSelection.length; i < len; i += 1) {
                // any cell position that is in saved selection gets added to the selectCells
                arrParts = element.savedSelection[i].split(',');
                recordIndex = parseInt(arrParts[0], 10);
                cellIndex = parseInt(arrParts[1], 10);
                
                if (recordIndex < arrRecords.length && cellIndex < arrRecords[0].children.length) {
                    selectCells.push(arrRecords[recordIndex].children[cellIndex]);
                }
            }
            
            // select cells
            element.selectedCells = selectCells;
        }
        
        // focus
        if (element.lastFocusedControl) {
            element.lastFocusedControl.focus();
            focusedElement = element.lastFocusedControl;
        } else if (!bolOnLoad || bolManualRefresh) {
            focusedElement = element.copyControl;
            element.copyControl.focus();
        }
        
        // if there was no control to focus and
        //      there is a selection and
        //      bolScroll is true: scroll to selected
        if (!element.lastFocusedControl && element.selectedCells.length > 0 && bolScroll) {
            GS.scrollIntoView(element.selectedCells[0].parentNode);
        }
        
        // if there was a control and bolScroll is true: scroll to focused record
        if (focusedElement && bolScroll) {
            GS.scrollIntoView(GS.findParentElement(document.activeElement, 'tr'));
        }
        
        if (focusedElement && element.lastTextSelection) {
            GS.setInputSelection(focusedElement, element.lastTextSelection.start, element.lastTextSelection.end);
        }
    }
    
    function clearRecordColor(element, strClass, bolGreenFade) {
        var arrElements = xtag.query(element, 'tr.' + strClass), i, len;
        
        if (bolGreenFade) {
            for (i = 0, len = arrElements.length; i < len; i += 1) {
                arrElements[i].classList.remove(strClass);
                arrElements[i].classList.add('bg-green-fade');
            }
            
            setTimeout(function () {
                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    arrElements[i].classList.remove('bg-green-fade');
                }
            }, 1000);
            
        } else {
            for (i = 0, len = arrElements.length; i < len; i += 1) {
                arrElements[i].classList.remove(strClass);
            }
        }
    }
    
    function removeRecords(element, strClass) {
        var arrElements = xtag.query(element, 'tr.' + strClass), i, len;
        
        for (i = 0, len = arrElements.length; i < len; i += 1) {
            arrElements[i].parentNode.removeChild(arrElements[i]);
        }
    }
    
    function insertRecords(element, strColumns, strInsertData, strLocalData, bolDialog) {
        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'))
          , strObject = GS.templateWithQuerystring(element.getAttribute('object'))
          , templateElement, strSeq, arrSeq, strPk, arrPk
          , strColumn, arrColumns, i, len, col_i, col_len
          , tbodyElement, arrElements, insertRecord;
        
        arrSeq = (GS.templateWithQuerystring(element.getAttribute('seq') || '')).split(/[\s]*,[\s]*/);
        arrPk = (GS.templateWithQuerystring(element.getAttribute('pk') || '')).split(/[\s]*,[\s]*/);
        
        arrColumns = strColumns.split('\t');
        for (i = 0, len = arrColumns.length; i < len; i += 1) {
            strColumn = GS.decodeFromTabDelimited(arrColumns[i], element.nullString);
            
            if (arrSeq.indexOf(strColumn) > -1) {
                arrSeq[arrSeq.indexOf(strColumn)] = '';
            }
        }
        
        //console.log(getReturn(element) + '\n' + strLocalData);
        
        // template local record data
        tbodyElement = document.createElement('tbody');
        tbodyElement.innerHTML = templateRecordsForInsert(element, strColumns + '\n' + strLocalData, 'bg-red');
        
        // add local records to the table before the insert record
        arrElements = xtag.toArray(tbodyElement.children);
        insertRecord = xtag.query(element, 'tr.insert-record')[0];
        
        for (i = 0, len = arrElements.length; i < len; i += 1) {
            insertRecord.parentNode.insertBefore(arrElements[i], insertRecord);
        }
        
        // scroll all the way down
        element.scrollContainer.scrollTop = element.scrollContainer.scrollHeight;
        
        // get pk and sequence values
        for (i = 0, len = arrPk.length, strPk = ''; i < len; i += 1) {
            strPk += (strPk ? '\t' : '') + GS.encodeForTabDelimited(arrPk[i], element.nullString);
        }
        
        for (i = 0, len = arrSeq.length, strSeq = ''; i < len; i += 1) {
            if (arrColumns.indexOf(arrPk[i]) > -1) {
                strSeq += (i === 0 ? '' : '\t') + '';
            } else {
                strSeq += (i === 0 ? '' : '\t') + GS.encodeForTabDelimited(arrSeq[i], element.nullString);
            }
        }
        
        strInsertData = strColumns + '\n' + strInsertData;
        
        GS.addLoader(element, 'Creating Insert Transaction...');
        GS.requestInsertFromSocket(
            getSocket(element), strSchema, strObject, getReturn(element), strPk, strSeq, strInsertData
            , function (data, error) {
                if (error) {
                    removeRecords(element, 'bg-red');
                    GS.removeLoader(element);
                    GS.webSocketErrorDialog(data);
                }
            }
            , function (data, error, transactionID, commitFunction, rollbackFunction) {
                var tbodyElement, arrElements, arrReplaceElements, i, len, templateElement;
                
                GS.removeLoader(element);
                
                if (!error) {
                    if (data !== 'TRANSACTION COMPLETED') {
                        data = getReturn(element) + '\n' + data;
                        
                        // replace red records with amber records
                        tbodyElement = document.createElement('tbody');
                        tbodyElement.innerHTML = templateRecordsForInsert(element, data, 'bg-amber');
                        arrElements = xtag.toArray(tbodyElement.children);
                        arrReplaceElements = xtag.query(element, 'tr.bg-red');
                        
                        for (i = 0, len = arrElements.length; i < len; i += 1) {
                            arrReplaceElements[i].parentNode.replaceChild(arrElements[i], arrReplaceElements[i]);
                        }
                        
                    // open confirm message box
                    } else {
                        if (bolDialog) {
                            templateElement = document.createElement('template');
                            templateElement.innerHTML = ml(function () {/*
                                <gs-page>
                                    <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                    <gs-body padded>
                                        <center>Are you sure you want create {{numberofrecords}} records?</center>
                                    </gs-body>
                                    <gs-footer>
                                        <gs-grid>
                                            <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                            <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                        </gs-grid>
                                    </gs-footer>
                                </gs-page>
                            */}).replace(/\{\{numberofrecords\}\}/gi, xtag.query(element, '.bg-amber').length);
                            
                            GS.openDialog(templateElement, function () {
                                document.getElementById('datasheet-focus-me').focus();
                                
                            }, function (event, strAnswer) {
                                if (strAnswer === 'Yes') {
                                    commitFunction();
                                    GS.addLoader(element, 'Commiting Insert...');
                                } else {
                                    rollbackFunction();
                                    GS.addLoader(element, 'Rolling Back Insert...');
                                }
                            });
                        } else {
                            commitFunction();
                        }
                    }
                    
                } else {
                    removeRecords(element, 'bg-red');
                    rollbackFunction();
                    GS.webSocketErrorDialog(data);
                }
            }
            , function (strAnswer, data, error) {
                GS.removeLoader(element);
                
                if (!error) {
                    if (strAnswer === 'COMMIT') {
                        clearRecordColor(element, 'bg-amber', true);
                        GS.triggerEvent(element, 'after_insert');
                    } else {
                        removeRecords(element, 'bg-amber');
                    }
                } else {
                    removeRecords(element, 'bg-red');
                    GS.webSocketErrorDialog(data);
                }
            }
        );
    }
    
    
    function refreshRecordsAfterUpdate(element, arrRecordsToUpdate, data) {
        var arrColumns, arrRecords, arrValues, arrElements, arrColumnTypes,
            i, len, record_i, record_len, col_i, col_len, controlElement;
        
        // if last character is a \n: remove it
        if (data[data.length - 1] === '\n') {
            data = data.substring(0, data.length - 1);
        }
        
        // split records
        arrRecords = data.split('\n');
        
        // seperate first record (for column names)
        arrColumns = arrRecords[0].split('\t');
        arrRecords.splice(0, 1);
        
        // loop through each record
        len = arrRecordsToUpdate.length;
        record_len = arrRecords.length;
        i = 0;
        record_i = 0;
        while (i < len && record_i < record_len) {
            if (arrRecordsToUpdate[i].classList.contains('bg-red') && arrRecords[record_i]) {
                arrRecordsToUpdate[i].classList.remove('bg-red');
                arrRecordsToUpdate[i].classList.add('bg-amber');
                
                // build json row
                arrValues = arrRecords[record_i].split('\t');
                for (col_i = 0, col_len = arrValues.length; col_i < col_len; col_i += 1) {
                    arrRecordsToUpdate[i].setAttribute('data-' + arrColumns[col_i], GS.decodeFromTabDelimited(arrValues[col_i], element.nullString));
                    
                    controlElement = xtag.query(arrRecordsToUpdate[i], '[column="' + arrColumns[col_i] + '"]')[0];
                    if (controlElement) {
                        controlElement.value = GS.decodeFromTabDelimited(arrValues[col_i], element.nullString);
                    }
                }
                
                record_i += 1;
            }
            i += 1;
        }
    }
    
    function updateRecords(element, strHashColumns, strUpdateData, arrUpdateRecords, bolDialog) {
        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'))
          , strObject = GS.templateWithQuerystring(element.getAttribute('object'))
          , templateElement, i, len, refreshData;
        
        for (i = 0, len = arrUpdateRecords.length; i < len; i += 1) {
            arrUpdateRecords[i].classList.add('bg-red');
        }
        
        // create transaction
        GS.addLoader(element, 'Creating Update Transaction...');
        GS.requestUpdateFromSocket(
            getSocket(element), strSchema, strObject, getReturn(element), strHashColumns, strUpdateData
            , function (data, error, transactionID) {
                if (error) {
                    getData(element);
                    GS.removeLoader(element);
                    GS.webSocketErrorDialog(data);
                }
            }
            , function (data, error, transactionID, commitFunction, rollbackFunction) {
                GS.removeLoader(element);
                if (!error) {
                    if (data !== 'TRANSACTION COMPLETED') {
                        refreshData = data;
                        data = getReturn(element) + '\n' + data;
                        
                        // make the records amber and refresh their data
                        refreshRecordsAfterUpdate(element, arrUpdateRecords, data);
                        
                    // open confirm message box
                    } else {
                        if (bolDialog) {
                            templateElement = document.createElement('template');
                            templateElement.innerHTML = ml(function () {/*
                                <gs-page>
                                    <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                    <gs-body padded>
                                        <center>Are you sure you want to update {{numberofrecords}} records?</center>
                                    </gs-body>
                                    <gs-footer>
                                        <gs-grid>
                                            <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                            <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                        </gs-grid>
                                    </gs-footer>
                                </gs-page>
                            */}).replace(/\{\{numberofrecords\}\}/gi, xtag.query(element, '.bg-amber').length);
                            
                            GS.openDialog(templateElement, function () {
                                document.getElementById('datasheet-focus-me').focus();
                                
                            }, function (event, strAnswer) {
                                if (strAnswer === 'Yes') {
                                    commitFunction();
                                    GS.addLoader(element, 'Commiting Update...');
                                } else {
                                    rollbackFunction();
                                    GS.addLoader(element, 'Rolling Back Update...');
                                }
                            });
                        } else {
                            commitFunction();
                        }
                    }
                    
                } else {
                    rollbackFunction();
                    getData(element);
                    GS.webSocketErrorDialog(data);
                }
            }
            , function (strAnswer, data, error) {
                var arrRecords, arrCells, recordData, recordIndex, i, len, col_i, col_len;
                
                GS.removeLoader(element);
                
                if (!error) {
                    if (strAnswer === 'COMMIT') {
                        clearRecordColor(element, 'bg-amber', true);
                        
                        // refresh internal data
                        arrRecords = refreshData.split('\n');
                        
                        for (i = 0, len = arrUpdateRecords.length; i < len; i += 1) {
                            arrCells = arrRecords[i].split('\t');
                            recordIndex = parseInt(arrUpdateRecords[i].getAttribute('data-index'), 10);
                            
                            for (col_i = 0, col_len = arrCells.length; col_i < col_len; col_i += 1) {
                                element.internalData.arrRecords[recordIndex][col_i] = GS.decodeFromTabDelimited(arrCells[col_i], element.nullString)
                            }
                        }
                        GS.triggerEvent(element, 'after_update');
                        
                    } else {
                        getData(element);
                    }
                } else {
                    getData(element);
                    GS.webSocketErrorDialog(data);
                }
            }
        );
    }
    
    function pasteHandler(element, event) {
        var clipboardData = (event.clipboardData || window.clipboardData)
          , templateElement = document.createElement('template')
          , pasteHTML, pastePlain, arrPasteRecords, arrSelectRecords, arrSetColumns
          , strColumn, strColumns, i, len, col_i, col_len, cell, arrPk, arrLock
          , strRecord, strInsertData, strLocalData, strLeftPad, strRightPad
          , strTemp, strRecordToHash, strHashColumns, strRoles, strUpdateData
          , arrRecords, arrUpdateRecords, arrUpdateColumns, updateRecord
          , updateRecordData, pasteElement;
        
        if (window.clipboardData) {
            pastePlain = clipboardData.getData('Text');
        } else {
            pasteHTML = clipboardData.getData('text/html');
            pastePlain = clipboardData.getData('Text');
        }
        
        // if no html: build HTML using plain
        if (!pasteHTML || (pasteHTML.indexOf('<' + 'table') === -1 && pasteHTML.indexOf('<' + 'tr') === -1)) {
            pasteHTML = valueListToHTML(pastePlain, '\t', '\n', false, '"', GS.decodeFromTabDelimited);
        }
        
        //console.log('HTML:', pasteHTML);
        //console.log('PLAIN:', pastePlain);
        
        // put HTML into a template element for traversal
        templateElement.innerHTML = pasteHTML;
        
        arrPasteRecords = xtag.query(xtag.query(templateElement.content, 'table')[0], 'tr');
        arrSelectRecords = element.selectedRecords;
        
        // if the first record is the header: remove it from the selection
        if (arrSelectRecords[0] && arrSelectRecords[0].parentNode.nodeName === 'THEAD') {
            arrSelectRecords.splice(0, 1);
        }
        
        if (element.numberOfSelections === 1) {
            arrSetColumns = xtag.query(arrSelectRecords[0], 'td[selected]');
            
            // if the selection starts on the insert record
            if (arrSelectRecords[0].classList.contains('insert-record')) {
                strColumns = '';
                for (i = 0, len = Math.min(arrSetColumns.length, arrPasteRecords[0].children.length); i < len; i += 1) {
                    strColumn = arrSetColumns[i].children[0].getAttribute('column');
                    strColumns += (strColumns ? '\t' : '') + strColumn;
                }
                
                // extract data from paste HTML
                strLeftPad = stringRepeat('\t', arrSetColumns[0].cellIndex - 1);
                strRightPad = stringRepeat('\t', (element.internalData.arrColumnNames.length - ((arrSetColumns[0].cellIndex - 1) + arrSetColumns.length)));
                
                for (i = 0, len = arrPasteRecords.length, strInsertData = '', strLocalData = ''; i < len; i += 1) {
                    for (col_i = 0, col_len = arrSetColumns.length, strRecord = ''; col_i < col_len; col_i += 1) {
                        cell = arrPasteRecords[i].children[col_i];
                        strRecord += (strRecord ? '\t' : '') + GS.encodeForTabDelimited(cell.innerText || cell.textContent, element.nullString);
                    }
                    
                    strInsertData += strRecord + '\n';
                    strLocalData += strLeftPad + strRecord + strRightPad + '\n';
                }
                
                insertRecords(element, strColumns, strInsertData, strLocalData, (arrPasteRecords.length > 1));
                
            // else (if the selection starts on an update record)
            } else {
                // if the last record is the insert: remove it from the selection
                if (arrSelectRecords[arrSelectRecords.length - 1].parentNode.nodeName === 'THEAD') {
                    arrSelectRecords.pop();
                }
                
                arrPk = (GS.templateWithQuerystring(element.getAttribute('pk') || '')).split(/[\s]*,[\s]*/);
                arrLock = (GS.templateWithQuerystring(element.getAttribute('lock') || '')).split(/[\s]*,[\s]*/);
                
                // gathering update headers
                for (i = 0, len = arrPk.length, strRoles = '', strColumns = ''; i < len; i += 1) {
                    strRoles += (strRoles ? '\t' : '') + 'pk';
                    strColumns += (strColumns ? '\t' : '') + arrPk[i];
                }
                
                for (i = 0, len = arrLock.length, strHashColumns = ''; i < len; i += 1) {
                    strHashColumns += (strHashColumns ? '\t' : '') + arrLock[i];
                }
                strRoles += (strRoles ? '\t' : '') + 'hash';
                strColumns += (strColumns ? '\t' : '') + 'hash';
                
                arrUpdateColumns = [];
                for (i = 0, len = Math.min(arrSetColumns.length, arrPasteRecords[0].children.length); i < len; i += 1) {
                    pasteElement = xtag.query(arrSetColumns[i], '[column]')[0];//arrSetColumns[i].children[0];
                    
                    if (pasteElement) {
                        strColumn = pasteElement.getAttribute('column');
                        
                        strRoles += (strRoles ? '\t' : '') + 'set';
                        strColumns += (strColumns ? '\t' : '') + strColumn;
                        
                        arrUpdateColumns.push(strColumn);
                    }
                }
                
                arrUpdateRecords = [];
                for (i = 0, len = Math.min(arrSelectRecords.length, arrPasteRecords.length), strUpdateData = ''; i < len; i += 1) {
                    strRecord = '';
                    updateRecord = arrSelectRecords[i];
                    updateRecordData = element.internalData.arrRecords[parseInt(updateRecord.getAttribute('data-index'), 10)];
                    
                    // get 'pk' columns
                    for (col_i = 0, col_len = arrPk.length; col_i < col_len; col_i += 1) {
                        strRecord += (strRecord ? '\t' : '');
                        strRecord += GS.encodeForTabDelimited(updateRecordData[element.internalData.arrColumnNames.indexOf(arrPk[col_i])], element.nullString);
                    }
                    
                    // get 'hash' columns
                    strRecordToHash = '';
                    for (col_i = 0, col_len = arrLock.length; col_i < col_len; col_i += 1) {
                        strRecordToHash += (strRecordToHash ? '\t' : '');
                        strTemp = updateRecordData[element.internalData.arrColumnNames.indexOf(arrLock[col_i])];
                        strRecordToHash += (strTemp === 'NULL' ? '' : strTemp);
                    }
                    
                    strRecord += (strRecord ? '\t' : '') + GS.utfSafeMD5(strRecordToHash).toString();
                    
                    // get 'set' columns
                    for (col_i = 0, col_len = arrSetColumns.length; col_i < col_len; col_i += 1) {
                        pasteElement = xtag.query(arrSetColumns[col_i], '[column]')[0];
                        
                        if (pasteElement) {
                            cell = arrPasteRecords[i].children[col_i];
                            strRecord += (strRecord ? '\t' : '') + GS.encodeForTabDelimited(cell.innerText || cell.textContent, element.nullString);
                        }
                    }
                    
                    strUpdateData += strRecord + '\n';
                    arrUpdateRecords.push(arrSelectRecords[i]);
                }
                
                strUpdateData = (strRoles + '\n' + strColumns + '\n' + strUpdateData);
                updateRecords(element, strHashColumns, strUpdateData, arrUpdateRecords, (arrPasteRecords.length > 1));
            }
        }
    }
    
    function refreshHeight(element) {
        var intHeight;
        
        if (element.hasAttribute('expand-to-content') &&
                element.hudContainer &&
                element.scrollContainer &&
                element.scrollContainer.children[0]) {
            element.style.height = '';
            
            intHeight = (
                            element.hudContainer.scrollHeight +
                            element.scrollContainer.children[0].scrollHeight
                        );
            
            element.style.height = intHeight + 'px';
            element.style.height = (intHeight + (element.scrollContainer.scrollHeight - element.scrollContainer.clientHeight)) + 'px';
        }
    }
    
    function refreshReflow(element) {
        var strReflowAt = GS.templateWithQuerystring(element.getAttribute('reflow-at') || ''), intReflowAt, intElementWidth;
        
        if (strReflowAt) {
            intElementWidth = element.offsetWidth;
            intReflowAt = parseInt(strReflowAt, 10);
            
            if (intElementWidth < intReflowAt) {
                element.dataContainer.classList.add('grid-reflow');
            } else {
                element.dataContainer.classList.remove('grid-reflow');
            }
        } else {
            element.dataContainer.classList.remove('grid-reflow');
        }
    }
    
    
    // clean the slate and set initial html
    function prepareElement(element) {
        var tableTemplateElement, HUDTemplateElement, strHTML, recordElement, insertTemplateElement, arrParts
          , headerRecordElement;
        var i, len, arrElements, arrHeaderElements;
        var tempTemplateElement;
        
        // default pk and lock
        if (!element.hasAttribute('pk'))   { element.setAttribute('pk',   'id'); }
        if (!element.hasAttribute('lock')) { element.setAttribute('lock', 'change_stamp'); }
        
        // harvest the templates, error if problems
        tableTemplateElement = xtag.query(element, 'template[for="table"]')[0];
        HUDTemplateElement = xtag.query(element, 'template[for="hud"]')[0];
        insertTemplateElement = xtag.query(element, 'template[for="insert"]')[0];
        
        if (!tableTemplateElement || tableTemplateElement.nodeName !== 'TEMPLATE') {
            throw 'gs-datasheet error: No table template provided.';
        }
        
        // V----- cannot do .children on template.content
        //if (tableTemplateElement.content.children[0].nodeName !== 'TABLE') {
        //    throw 'gs-datasheet error: Table is not the first element in the provided table template.';
        //}
        
        // make header template
        headerRecordElement = xtag.query(tableTemplateElement.content, 'thead tr')[0];
        if (headerRecordElement) {
            
            arrHeaderElements = xtag.query(headerRecordElement, 'td, th');
            arrElements = xtag.query(tableTemplateElement.content, 'tbody td, tbody th');
            
            for (i = 0, len = arrHeaderElements.length; i < len; i += 1) {
                if (!arrElements[i].hasAttribute('heading')) {
                    arrElements[i].setAttribute('heading', arrHeaderElements[i].textContent);
                }
            }
            
            element.headerTemplateRecord = headerRecordElement.outerHTML;
        }
        
        // make table template
        recordElement = xtag.query(tableTemplateElement.content, 'tbody tr')[0];
        recordElement.setAttribute('data-index', '{{= i }}');
        strHTML = GS.templateColumnToValue(tableTemplateElement.innerHTML);
        tempTemplateElement = document.createElement('template');
        tempTemplateElement.innerHTML = strHTML;
        recordElement = xtag.query(tempTemplateElement.content, 'tbody tr')[0];
        
        element.tableTemplate = GS.templateHideSubTemplates(recordElement.outerHTML, true);
        element.tableTemplateRecord = recordElement;
        
        if (insertTemplateElement && insertTemplateElement.innerHTML) {
            element.insertTemplate = insertTemplateElement.innerHTML;
        }
        
        // split schema and object
        arrParts = GS.templateWithQuerystring(element.getAttribute('src')).split('.');
        
        element.setAttribute('schema', arrParts[0]);
        element.setAttribute('object', arrParts[1]);
        
        // replace element inner html and create element variables
        strHTML = ml(function () {/*
            <div class="root" flex-vertical flex-fill>
                <div class="hud-container">
                    <gs-button icon="refresh" remove-right icononly no-focus title="Refresh Data." class="refresh-button"></gs-button>
                    <gs-button icon="times" remove-left icononly no-focus title="Delete Selected Records." class="delete-button"></gs-button>
                    
                    <gs-button icon="plus" icononly no-focus title="Create Record." class="insert-button"></gs-button>
                    
                    <gs-button icon="backward" remove-right icononly no-focus title="Go to previous page." class="paginate-left"></gs-button>
                    <gs-button icon="forward" remove-left icononly no-focus title="Go to next page." class="paginate-right"></gs-button>
                    
                    {{HUDHTML}}
                    
                    <gs-button icon="filter" icononly no-focus title="Edit Filters." class="filter-button" hidden></gs-button>
                    <textarea class="hidden-focus-control">Focus Control</textarea>
                </div>
                <div class="data-container" flex>
                    <div class="data-flex-reset">
                        <div class="scroll-container"></div>
                        <div class="header-container"></div>
                        <div class="insert-container"></div>
                    </div>
                </div>
            </div>
        */});
        
        if (HUDTemplateElement) {
            strHTML = strHTML.replace(/\{\{HUDHTML\}\}/gi, HUDTemplateElement.innerHTML);
        } else {
            strHTML = strHTML.replace(/\{\{HUDHTML\}\}/gi, '');
        }
        
        element.innerHTML = strHTML;
        
        element.root = element.children[0];
        
        element.hudContainer    = element.root.children[0];
        element.dataContainer   = element.root.children[1];
        
        element.dataFlexReset   = element.dataContainer.children[0];
        
        element.scrollContainer = element.dataFlexReset.children[0];
        element.headerContainer = element.dataFlexReset.children[1];
        element.insertContainer = element.dataFlexReset.children[2];
        
        element.refreshButton   = xtag.queryChildren(element.hudContainer, '.refresh-button')[0];
        element.deleteButton    = xtag.queryChildren(element.hudContainer, '.delete-button')[0];
        element.insertButton    = xtag.queryChildren(element.hudContainer, '.insert-button')[0];
        element.pageLeftButton  = xtag.queryChildren(element.hudContainer, '.paginate-left')[0];
        element.pageRightButton = xtag.queryChildren(element.hudContainer, '.paginate-right')[0];
        element.copyControl     = xtag.queryChildren(element.hudContainer, '.hidden-focus-control')[0];
        element.filterButton    = xtag.queryChildren(element.hudContainer, '.filter-button')[0];
        
        if (element.hasAttribute('no-huddelete') && element.hasAttribute('no-hudrefresh')) {
            element.hudContainer.removeChild(element.refreshButton);//.setAttribute('hidden', '');
            element.hudContainer.removeChild(element.deleteButton);//.setAttribute('hidden', '');
            
        } else if (element.hasAttribute('no-huddelete')) {
            element.hudContainer.removeChild(element.deleteButton);//.setAttribute('hidden', '');
            element.refreshButton.removeAttribute('remove-right');
            
        } else if (element.hasAttribute('no-hudrefresh')) {
            element.hudContainer.removeChild(element.refreshButton);//.setAttribute('hidden', '');
            element.deleteButton.removeAttribute('remove-left');
        }
        
        if (element.hasAttribute('no-hudpaginate')) {
            element.hudContainer.removeChild(element.pageLeftButton);//.setAttribute('hidden', '');
            element.hudContainer.removeChild(element.pageRightButton);//.setAttribute('hidden', '');
        }
        
        if (!element.insertTemplate) {
            element.insertButton.setAttribute('hidden', '');
        }
    }
    
    //function pushReplacePopHandler(element) {
    //    var i, len, arrPopKeys, currentValue, bolRefresh = false, strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //    
    //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //    
    //    if (element.hasAttribute('refresh-on-querystring-values')) {
    //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
    //        
    //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
    //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
    //            
    //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
    //                bolRefresh = true;
    //            }
    //            
    //            element.popValues[arrPopKeys[i]] = currentValue;
    //        }
    //        
    //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
    //        bolRefresh = true;
    //    }
    //    
    //    if (bolRefresh) {
    //        getData(element);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh;
        var strOperator;

        if (strQSCol) {
            if (strQSCol.indexOf('=') !== -1) {
                arrAttrParts = strQSCol.split(',');
                i = 0;
                len = arrAttrParts.length;
                while (i < len) {
                    strQSCol = arrAttrParts[i];
    
                    if (strQSCol.indexOf('!=') !== -1) {
                        strOperator = '!=';
                        arrQSParts = strQSCol.split('!=');
                    } else {
                        strOperator = '=';
                        arrQSParts = strQSCol.split('=');
                    }
    
                    strQSCol = arrQSParts[0];
                    strQSAttr = arrQSParts[1] || arrQSParts[0];
    
                    // if the key is not present or we've got the negator: go to the attribute's default or remove it
                    if (strOperator === '!=') {
                        // if the key is not present: add the attribute
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            element.setAttribute(strQSAttr, '');
                        // else: remove the attribute
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    } else {
                        // if the key is not present: go to the attribute's default or remove it
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        // else: set attribute to exact text from QS
                        } else {
                            element.setAttribute(strQSAttr, (
                                GS.qryGetVal(strQS, strQSCol) ||
                                element.internal.defaultAttributes[strQSAttr] ||
                                ''
                            ));
                        }
                    }
                    i += 1;
                }
            } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                strQSValue = GS.qryGetVal(strQS, strQSCol);
    
                if (element.internal.bolQSFirstRun !== true) {
                    if (strQSValue !== '' || !element.getAttribute('value')) {
                        element.setAttribute('value', strQSValue);
                    }
                } else {
                    element.value = strQSValue;
                }
            }
        }
        
        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                
                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);
                    
                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }
                    
                    element.popValues[arrPopKeys[i]] = currentValue;
                }
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            }
            
            if (bolRefresh && element.hasAttribute('src')) {
                getData(element);
            } else if (bolRefresh && !element.hasAttribute('src')) {
                console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                
                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                }
            }
        }
        
        element.internal.bolQSFirstRun = true;
    }
    
    
    // bind delegating events
    function bindElement(element) {
        var strQSValue;
        
        // handle "qs" attribute
        if (element.getAttribute('qs') ||
                element.getAttribute('refresh-on-querystring-values') ||
                element.hasAttribute('refresh-on-querystring-change')) {
            //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
            //
            //if (strQSValue !== '' || !element.getAttribute('value')) {
            //    element.setAttribute('value', strQSValue);
            //}
            
            element.popValues = {};
            pushReplacePopHandler(element);
            window.addEventListener('pushstate', function () {    pushReplacePopHandler(element); });
            window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
            window.addEventListener('popstate', function () {     pushReplacePopHandler(element); });
        }
        
        // on focus control: set oldvalue for update
        element.addEventListener('focus', function (event) {
            if (event.target.hasAttribute('column')) {
                event.target.strOldValue = event.target.value;
            }
        }, true);
        
        if (!evt.touchDevice) {
            // focus copy control
            element.addEventListener('mousedown', function (event) {
                var parentDatasheet = GS.findParentTag(event.target, 'gs-datasheet');

                // we dont want to override the focus if the currently focused
                //      element is inside the gs-datasheet and is capable of being focus
                if (
                    !GS.isElementFocusable(event.target) ||
                    !parentDatasheet ||
                    parentDatasheet.nodeName !== 'GS-DATASHEET'
                ) {
                    element.copyControl.focus();
                }
            });
        }
        
        // copy
        element.copyControl.addEventListener('copy', function (event) {
            var strTextCopyString, strHTMLCopyString;
            
            if (document.activeElement.classList.contains('hidden-focus-control') ||
                document.activeElement.selectionStart === document.activeElement.selectionEnd) {
                
                GS.setInputSelection(document.activeElement, document.activeElement.value.length,
                                            document.activeElement.value.length);
                
                strTextCopyString = getSelectedCopyText(element);
                strHTMLCopyString = getSelectedCopyHTML(element);
                
                if (strTextCopyString && strHTMLCopyString) {
                    if (handleClipboardData(event, strTextCopyString, 'text')) {
                        event.preventDefault(event);
                    }
                    if (handleClipboardData(event, strHTMLCopyString, 'html')) {
                        event.preventDefault(event);
                    }
                }
                
                GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
            }
        });
        
        // focus
        window.addEventListener('focus', function (event) {//element
            if (GS.findParentTag(document.activeElement, 'gs-datasheet') === element) {
                element.lastFocusedControl = document.activeElement;
            } else {
                element.lastFocusedControl = null;
            }
        });//, true
        
        // paste
        element.addEventListener('paste', function (event) {
            if (document.activeElement === element.copyControl) {
                event.preventDefault();
                pasteHandler(element, event);
            }
        });
        
        // selection
        if (!evt.touchDevice) {
            element.dragAllowed = false;
            element.numberOfSelections = 0;
            
            // on mousedown (event delagation style)
            element.addEventListener('mousedown', function (event) {
                var target = GS.findParentElement(event.target, 'th,td'), originalTarget = event.target;
                
                // if target is a cell: begin selection
                if (target && (target.nodeName === 'TH' || target.nodeName === 'TD')) {
                    if (GS.findParentElement(target, 'div').classList.contains('header-container')) {
                        target = xtag.query(element.scrollContainer, 'th, td')[target.cellIndex];
                        originalTarget = target;
                    }
                    
                    // if shift key is down and there is currently a selection to connect to
                    element.dragOrigin = target;
                    if (event.shiftKey && xtag.query(element, '[selected]').length > 0) {
                        element.dragOrigin = element.selectionPreviousOrigin;
                    }
                    
                    // if ctrl and cmd are not down: deselect all cells
                    if (!event.metaKey && !event.ctrlKey) {
                        element.selectedCells = [];
                        element.savedSelection = [];
                        element.numberOfSelections = 0;
                    }
                    
                    element.savedSelectionCopy = element.savedSelection.slice(0);
                    element.dragAllowed = true;
                    element.dragCurrentCell = target;
                    element.numberOfSelections += 1;
                    
                    element.dragMode = 'select';
                    if (target.hasAttribute('selected')) {
                        element.dragMode = 'deselect';
                    }
                    
                    // if the original target is a cell or if the dragOrigin isn't the target cell or
                    //      if there are already selected cells: blur focused element and prevent default
                    if (originalTarget.nodeName === 'TH' || originalTarget.nodeName === 'TD' ||
                        element.dragOrigin !== target || element.selectedCells.length > 0) {
                        element.lastFocusedControl = null;
                        element.copyControl.focus();
                        GS.triggerEvent(element.copyControl, 'focus');
                        event.preventDefault();
                    }
                    
                    selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                }
            });
            
            element.addEventListener('mousemove', function (event) {
                var cellFromTarget;
                
                // if mouse is down
                if (event.which !== 0) {
                    cellFromTarget = GS.findParentElement(event.target, 'th,td');
                    
                    // if selection is allowed at this point and closestCell is different from element.dragCurrentCell
                    if (cellFromTarget && element.dragAllowed && element.dragCurrentCell !== cellFromTarget) {
                        element.lastFocusedControl = null;
                        element.copyControl.focus();
                        GS.triggerEvent(element.copyControl, 'focus');
                        
                        element.dragCurrentCell = cellFromTarget;
                        selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                        event.preventDefault();
                    }
                } else {
                    element.dragAllowed = false;
                    element.selectionPreviousOrigin = element.dragOrigin;
                }
            });
            
            element.addEventListener('mouseup', function (event) {
                if (element.dragAllowed) {
                    if (document.activeElement === element || document.activeElement === document.body) {
                        element.copyControl.focus();
                        GS.triggerEvent(element.copyControl, 'focus');
                    }
                    element.dragAllowed = false;
                    element.selectionPreviousOrigin = element.dragOrigin;
                }
            });
        }
        
        if (!element.hasAttribute('no-filter')) {
            // filter edit button
            element.filterButton.addEventListener('click', function () {
                var templateElement = document.createElement('template');
                
                templateElement.setAttribute('data-max-width', '300px');
                templateElement.setAttribute('data-overlay-close', 'true');
                
                templateElement.innerHTML = ml(function () {/*
                    <gs-body padded>
                        <label for="memo-datagrid-filters">Filters:</label>
                        <gs-memo id="memo-datagrid-filters" rows="6" no-resize-handle></gs-memo>
                        <br />
                        <gs-grid>
                            <gs-block><gs-button dialogclose remove-right>Cancel</gs-button></gs-block>
                            <gs-block><gs-button dialogclose remove-all style="border-left: 0 none;">Clear Filters</gs-button></gs-block>
                            <gs-block><gs-button dialogclose remove-left style="border-left: 0 none;">Update Filters</gs-button></gs-block>
                        </gs-grid>
                    </gs-body>
                */});
                
                GS.openDialogToElement(element.filterButton, templateElement, 'down', function () {
                    document.getElementById('memo-datagrid-filters').value = element.getAttribute('user-where').replace(/\sAND\s/gi, '\nAND ');
                    
                }, function (event, strAnswer) {
                    var strValue = document.getElementById('memo-datagrid-filters').value;
                    
                    if (strAnswer === 'Clear Filters' || (strAnswer === 'Update Filters' && strValue.trim() === '')) {
                        element.removeAttribute('user-where');
                        element.filterButton.setAttribute('hidden', '');
                        getData(element);
                        
                    } else if (strAnswer === 'Update Filters') {
                        element.setAttribute('user-where', strValue);
                        getData(element);
                    }
                });
            });
            
            // filter popup
            var cellFloatingButtonFunction = function (targetCell) {
                var jsnElementPosition = GS.getElementPositionData(targetCell), strHTML;
                
                // targetCell is a th or if targetCell doesn't have a child with the "column" attribute:
                //      remove the floating button if it exists
                if (targetCell.nodeName === 'TH' || xtag.query(targetCell, '[column]').length === 0) {
                    if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                        element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                        element.cellFloatingButtonContainer = null;
                    }
                    
                // else: add the floating button
                } else {
                    // if no floating button exists for this grid: create/append/bind one
                    if (!element.cellFloatingButtonContainer || !element.cellFloatingButtonContainer.parentNode) {
                        element.cellFloatingButtonContainer = document.createElement('div');
                        element.cellFloatingButtonContainer.classList.add('floating-button-container');
                        
                        element.cellFloatingButtonContainer.innerHTML =
                                        '<gs-button icononly icon="filter" inline bg-primary no-focus></gs-button>';
                        
                        //element.scrollContainer.appendChild(element.cellFloatingButtonContainer);
                        element.dataFlexReset.appendChild(element.cellFloatingButtonContainer);
                        
                        element.cellFloatingButtonContainer.addEventListener(evt.mousedown, function () {
                            element.cellFloatingButtonContainer.targetControl.bolSubstring =
                                document.activeElement === element.cellFloatingButtonContainer.targetControl;
                        });
                        
                        element.cellFloatingButtonContainer.addEventListener('click', function () {
                            var targetControl = element.cellFloatingButtonContainer.targetControl
                              , jsnSelection, strMatchText = targetControl.value || targetControl.textContent
                              , templateElement = document.createElement('template');
                            
                            //console.log(targetControl, targetControl.value, strMatchText);
                            
                            if (targetControl.nodeName === 'INPUT' || targetControl.nodeName === 'TEXTAREA') {
                                jsnSelection = GS.getInputSelection(element.cellFloatingButtonContainer.targetControl);
                            }
                            
                            if (targetControl.bolSubstring && jsnSelection && jsnSelection.start !== jsnSelection.end) {
                                strMatchText = strMatchText.substring(jsnSelection.start, jsnSelection.end);
                            }
                            
                            templateElement.setAttribute('data-max-width', '250px');
                            templateElement.setAttribute('data-overlay-close', 'true');
                            
                            strHTML = '<gs-body padded>';
                            
                            if (evt.touchDevice) {
                                strHTML += '<gs-button class="text-left" dialogclose>Select Range</gs-button>';
                                strHTML += '<gs-button class="text-left" dialogclose>Select Records</gs-button><hr />';
                            }
                            
                            strHTML +=
                                '<gs-button class="text-left" dialogclose>Equals "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Doesn\'t Equal "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Contains "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Doesn\'t Contain "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Starts With "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Ends With "<u>{{VALUE}}</u>"</gs-button>';
                            
                            strHTML += '</gs-body>';
                            
                            strHTML = strHTML.replace(/\{\{VALUE\}\}/gim, encodeHTML(strMatchText));
                            
                            templateElement.innerHTML = strHTML;
                            
                            GS.openDialogToElement(element.cellFloatingButtonContainer, templateElement, 'left', '',
                                                                                            function (event, strAnswer) {
                                var clickFunction
                                  , addUserWhere = function (strNewWhere) {
                                        var strWhere = element.getAttribute('user-where');
                                        
                                        strWhere = (strWhere ? (strWhere + ' AND ' + strNewWhere) : strNewWhere);
                                        
                                        element.setAttribute('user-where', strWhere);
                                        element.filterButton.removeAttribute('hidden');
                                        getData(element);
                                    }
                                  , control = element.cellFloatingButtonContainer.targetCell.children[0];
                                
                                if (strAnswer === 'Select Range' || strAnswer === 'Select Records') {
                                    if (strAnswer === 'Select Records') {
                                        element.dragOrigin = element.cellFloatingButtonContainer.targetCell.parentNode.children[0];
                                    } else if (strAnswer === 'Select Range') {
                                        element.dragOrigin = element.cellFloatingButtonContainer.targetCell;
                                    }
                                    
                                    element.selectedCells = [];
                                    clickFunction = function (event) {
                                        var target;
                                        
                                        if (strAnswer === 'Select Records') {
                                            target = GS.findParentElement(event.target, 'tr');
                                            element.dragCurrentCell = target.children[0];
                                            
                                        } else if (strAnswer === 'Select Range') {
                                            target = GS.findParentElement(event.target, 'td,th');
                                            element.dragCurrentCell = target;
                                        }
                                        
                                        if (target) {
                                            element.selectionPreviousOrigin = element.dragOrigin;
                                            element.savedSelection = [];
                                            element.savedSelectionCopy = [];
                                            element.numberOfSelections = 1;
                                            element.dragMode = 'select';
                                            
                                            selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                                            
                                            document.activeElement.blur();
                                            event.preventDefault();
                                            element.removeEventListener('click', clickFunction, true);
                                        }
                                    };
                                    
                                    element.addEventListener('click', clickFunction, true);
                                    
                                } else if (strAnswer.indexOf('Equals') === 0) {
                                    addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                        '= $$' + strMatchText + '$$');
                                    
                                } else if (strAnswer.indexOf('Doesn\'t Equal') === 0) {
                                    addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                        '!= $$' + strMatchText + '$$');
                                    
                                } else if (strAnswer.indexOf('Contains') === 0) {
                                    addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                        'LIKE $$%' + strMatchText + '%$$');
                                    
                                } else if (strAnswer.indexOf('Doesn\'t Contain') === 0) {
                                    addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                        'NOT LIKE $$%' + strMatchText + '%$$');
                                    
                                } else if (strAnswer.indexOf('Starts With') === 0) {
                                    addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                        'LIKE $$' + strMatchText + '%$$');
                                    
                                } else if (strAnswer.indexOf('Ends With') === 0) {
                                    addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                        'LIKE $$%' + strMatchText + '$$');
                                }
                            });
                        });
                    }
                    
                    // hover center next to the cell
                    element.cellFloatingButtonContainer.targetCell = targetCell;
                    element.cellFloatingButtonContainer.targetControl = xtag.query(targetCell, '[column]')[0];
                    element.cellFloatingButtonContainer.children[0].removeAttribute('remove-top-left');
                    element.cellFloatingButtonContainer.children[0].removeAttribute('remove-top-right');
                    element.cellFloatingButtonContainer.children[0].removeAttribute('remove-bottom-left');
                    element.cellFloatingButtonContainer.children[0].removeAttribute('remove-bottom-right');
                    
                    // top left
                    if (jsnElementPosition.intRoomAbove > element.cellFloatingButtonContainer.clientHeight &&
                        jsnElementPosition.intRoomLeft > element.cellFloatingButtonContainer.clientWidth) {
                        element.cellFloatingButtonContainer.setAttribute('style',
                                    'left: ' + ((jsnElementPosition.intElementLeft -
                                                    element.cellFloatingButtonContainer.clientWidth) + 4) + 'px;' +
                                    'top: ' + ((jsnElementPosition.intElementTop -
                                                    element.cellFloatingButtonContainer.clientHeight) + 4) + 'px;');
                        
                        element.cellFloatingButtonContainer.children[0].setAttribute('remove-bottom-right', '');
                        
                    // top right
                    } else if (jsnElementPosition.intRoomAbove > element.cellFloatingButtonContainer.clientHeight &&
                               jsnElementPosition.intRoomRight > element.cellFloatingButtonContainer.clientWidth) {
                        element.cellFloatingButtonContainer.setAttribute('style',
                                    'left: ' + ((jsnElementPosition.intElementLeft +
                                                    jsnElementPosition.intElementWidth) - 4) + 'px;' +
                                    'top: ' + ((jsnElementPosition.intElementTop -
                                                    element.cellFloatingButtonContainer.clientHeight) + 4) + 'px;');
                        
                        element.cellFloatingButtonContainer.children[0].setAttribute('remove-bottom-left', '');
                        
                    // bottom left
                    } else if (jsnElementPosition.intRoomBelow > element.cellFloatingButtonContainer.clientHeight &&
                               jsnElementPosition.intRoomLeft > element.cellFloatingButtonContainer.clientWidth) {
                        element.cellFloatingButtonContainer.setAttribute('style',
                                    'left: ' + ((jsnElementPosition.intElementLeft -
                                                    element.cellFloatingButtonContainer.clientWidth) + 4) + 'px;' +
                                    'top: ' + ((jsnElementPosition.intElementTop +
                                                    jsnElementPosition.intElementHeight) - 4) + 'px;');
                        
                        element.cellFloatingButtonContainer.children[0].setAttribute('remove-top-right', '');
                        
                    // bottom right
                    } else if (jsnElementPosition.intRoomBelow > element.cellFloatingButtonContainer.clientHeight &&
                               jsnElementPosition.intRoomRight > element.cellFloatingButtonContainer.clientWidth) {
                        element.cellFloatingButtonContainer.setAttribute('style',
                                    'left: ' + ((jsnElementPosition.intElementLeft +
                                                    jsnElementPosition.intElementWidth) - 4) + 'px;' +
                                    'top: ' + ((jsnElementPosition.intElementTop +
                                                    jsnElementPosition.intElementHeight) - 4) + 'px;');
                        
                        element.cellFloatingButtonContainer.children[0].setAttribute('remove-top-left', '');
                    }
                }
            };
            
            element.addEventListener('after_selection', function (event) {
                var arrSelected = element.selectedCells;
                
                if (arrSelected.length === 1) {
                    cellFloatingButtonFunction(element.dragCurrentCell || arrSelected[arrSelected.length - 1]);
                    
                } else if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                    element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                    element.cellFloatingButtonContainer = null;
                }
            });
            
            element.addEventListener('focus', function (event) {
                if (event.target.hasAttribute('column')) {
                    cellFloatingButtonFunction(event.target.parentNode);
                }
            }, true);// this true is for making it so that the focus event (which doesn't bubble) gets captured
            
            // on mousewheel: remove floating button (scroll version of this is in the handleData function)
            element.addEventListener('mousewheel', function (event) {
                if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                    element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                    element.cellFloatingButtonContainer = null;
                }
            });
            element.scrollContainer.addEventListener('scroll', function (event) {
                if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                    element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                    element.cellFloatingButtonContainer = null;
                }
            });
        }
        
        // ################################################################
        // #################### TOUCH DEVICE CLIPBOARD ####################
        // ################################################################
        
        if (evt.touchDevice) {
            var rangeFloatingButtonFunction = function (arrSelected) {
                var i, len, targetCell, arrSelectedRecords, bolCenter = true, jsnElementPosition,
                    intTopBoundry, intBottomBoundry, intLeftBoundry, intRightBoundry;
                
                // if no floating button exists for this grid: create/append/bind one
                if (!element.rangeFloatingButtonContainer || !element.rangeFloatingButtonContainer.parentNode) {
                    element.rangeFloatingButtonContainer = document.createElement('div');
                    element.rangeFloatingButtonContainer.classList.add('floating-button-container');
                    
                    element.rangeFloatingButtonContainer.innerHTML =
                                    '<gs-button icononly icon="clipboard" inline bg-primary no-focus></gs-button>' +
                                    '<div contenteditable="true" style=" position: fixed;  border: 0 none;' +
                                                                        'margin: 0;        padding: 0;' +
                                                                        'z-index: -5000;   opacity: 0.00000001;' +
                                                                        '-webkit-appearance: none;' +
                                                                        '-moz-appearance: none;"></div>';
                    
                    element.scrollContainer.appendChild(element.rangeFloatingButtonContainer);
                    
                    element.rangeFloatingButtonContainer.control = element.rangeFloatingButtonContainer.children[1];
                    
                    element.rangeFloatingButtonContainer.addEventListener('click', function () {
                        element.rangeFloatingButtonContainer.control.innerHTML = getSelectedCopyHTML(element) || 'Nothing To Copy';
                        element.rangeFloatingButtonContainer.control.focus();
                        document.execCommand('selectAll', false, null);
                    });
                    
                    element.rangeFloatingButtonContainer.control.addEventListener('cut', function () {
                        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'))
                          , strObject = GS.templateWithQuerystring(element.getAttribute('object'))
                          , strUpdateData = '', strRecord, arrSetColumnElements, strHashColumns
                          , arrSetColumns = [], arrPk, arrLock, arrLines, arrRecords, tbodyElement, arrElements
                          , tr_len, i, len, col_i, col_len, colIndex, arrRecordsToRefresh = [], updateFunction
                          , strColumns = '', strRoles = '', strColumn, strRecordToHash, strTemp;
                        
                        // gathering variables for select traversal
                        arrRecords = element.selectedRecords;
                        
                        // if the first record is the header: remove it
                        if (arrRecords[0] && arrRecords[0].parentNode.nodeName === 'THEAD') {
                            arrRecords[0].splice(0, 1);
                        }
                        
                        arrSetColumnElements = xtag.query(arrRecords[0], '[selected]:not(th)');
                        
                        arrPk = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
                        arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);
                        
                        // gathering update headers
                        for (i = 0, len = arrPk.length; i < len; i += 1) {
                            strRoles += (strRoles ? '\t' : '') + 'pk';
                            strColumns += (strColumns ? '\t' : '') + arrPk[i];
                        }
                        
                        for (i = 0, len = arrLock.length, strHashColumns = ''; i < len; i += 1) {
                            strHashColumns += (strHashColumns ? '\t' : '') + arrLock[i];
                        }
                        strRoles += (strRoles ? '\t' : '') + 'hash';
                        strColumns += (strColumns ? '\t' : '') + 'hash';
                        
                        for (i = 0, len = arrSetColumnElements.length; i < len; i += 1) {
                            strColumn = arrSetColumnElements[i].children[0].getAttribute('column');
                            
                            strRoles += (strRoles ? '\t' : '') + 'set';
                            strColumns += (strColumns ? '\t' : '') + strColumn;
                            arrSetColumns.push(strColumn);
                        }
                        
                        for (i = 0, len = arrRecords.length; i < len; i += 1) {
                            strRecord = '';
                            
                            // get 'pk' columns
                            for (col_i = 0, col_len = arrPk.length; col_i < col_len; col_i += 1) {
                                strRecord += (strRecord ? '\t' : '');
                                strRecord += GS.encodeForTabDelimited(arrRecords[i].getAttribute('data-' + arrPk[col_i]), element.nullString);
                            }
                            
                            // get 'hash' columns
                            strRecordToHash = '';
                            for (col_i = 0, col_len = arrLock.length; col_i < col_len; col_i += 1) {
                                strRecordToHash += (strRecordToHash ? '\t' : '');
                                strTemp = arrRecords[i].getAttribute('data-' + arrLock[col_i]);
                                strRecordToHash += (strTemp === 'NULL' ? '' : strTemp);
                            }
                            
                            strRecord += (strRecord ? '\t' : '') + GS.utfSafeMD5(strRecordToHash).toString();
                            
                            // get 'set' columns
                            for (col_i = 0, col_len = arrSetColumns.length; col_i < col_len; col_i += 1) {
                                strRecord += (strRecord ? '\t' : '');
                            }
                            
                            strRecord += '\n';
                            strUpdateData += strRecord;
                            arrRecordsToRefresh.push(arrRecords[i]);
                            
                            // make the records red
                            arrRecords[i].classList.add('bg-red');
                        }
                        
                        strUpdateData = (strRoles + '\n' + strColumns + '\n' + strUpdateData);
                        
                        // create update transaction
                        GS.addLoader(element, 'Creating Update Transaction...');
                        GS.requestUpdateFromSocket(
                            getSocket(element), strSchema, strObject, getReturn(element), strHashColumns, strUpdateData,
                            function (data, error, transactionID) {
                                if (error) {
                                    getData(element);
                                    GS.removeLoader(element);
                                    GS.webSocketErrorDialog(data);
                                }
                            }, function (data, error, transactionID, commitFunction, rollbackFunction) {
                                GS.removeLoader(element);
                                
                                if (!error) {
                                    if (data !== 'TRANSACTION COMPLETED') {
                                        data = getReturn(element) + '\n' + data;
                                        
                                        // make the records amber and refresh their data
                                        refreshRecordsAfterUpdate(element, arrRecordsToRefresh, data);////
                                    } else {
                                        commitFunction();
                                    }
                                    
                                } else {
                                    rollbackFunction();
                                    getData(element);
                                    GS.webSocketErrorDialog(data);
                                }
                            }, function (strAnswer, data, error) {
                                GS.removeLoader(element);
                                
                                if (!error) {
                                    if (strAnswer === 'COMMIT') {
                                        clearRecordColor(element, 'bg-amber', true);
                                        GS.triggerEvent(element, 'after_update');
                                    } else {
                                        getData(element);
                                    }
                                } else {
                                    getData(element);
                                    GS.webSocketErrorDialog(data);
                                }
                            }
                        );
                    });
                    element.rangeFloatingButtonContainer.control.addEventListener('copy', function (event) {
                        setTimeout(function () {
                            element.rangeFloatingButtonContainer.control.blur();
                            element.rangeFloatingButtonContainer.control.innerHTML = '';
                        }, 1);
                    });
                    element.rangeFloatingButtonContainer.control.addEventListener('paste', function (event) {
                        pasteHandler(element, event);
                        setTimeout(function () {
                            element.rangeFloatingButtonContainer.control.blur();
                            element.rangeFloatingButtonContainer.control.innerHTML = '';
                        }, 1);
                    });
                }
                
                // position button
                intTopBoundry = 99999999;
                intBottomBoundry = 99999999;
                intLeftBoundry = 99999999;
                intRightBoundry = 99999999;
                
                for (i = 0, len = arrSelected.length; i < len; i += 1) {
                    jsnElementPosition = GS.getElementPositionData(arrSelected[i]);
                    
                    if (jsnElementPosition.intElementTop < intTopBoundry) {
                        intTopBoundry = jsnElementPosition.intElementTop;
                    }
                    if (jsnElementPosition.intElementBottom < intBottomBoundry) {
                        intBottomBoundry = jsnElementPosition.intElementBottom;
                    }
                    if (jsnElementPosition.intElementLeft < intLeftBoundry) {
                        intLeftBoundry = jsnElementPosition.intElementLeft;
                    }
                    if (jsnElementPosition.intElementRight < intRightBoundry) {
                        intRightBoundry = jsnElementPosition.intElementRight;
                    }
                }
                
                // top right
                if (intTopBoundry >= 0 && intRightBoundry >= 0) {
                    element.rangeFloatingButtonContainer.style.top = (intTopBoundry + 4) + 'px';
                    element.rangeFloatingButtonContainer.style.right = (intRightBoundry + 4) + 'px';
                    
                // top left
                } else if (intTopBoundry >= 0 && intLeftBoundry >= 0) {
                    element.rangeFloatingButtonContainer.style.top = (intTopBoundry + 4) + 'px';
                    element.rangeFloatingButtonContainer.style.left = (intLeftBoundry + 4) + 'px';
                    
                // bottom right
                } else if (intBottomBoundry >= 0 && intRightBoundry >= 0) {
                    element.rangeFloatingButtonContainer.style.bottom = (intBottomBoundry + 4) + 'px';
                    element.rangeFloatingButtonContainer.style.right = (intRightBoundry + 4) + 'px';
                
                // bottom left
                } else if (intBottomBoundry >= 0 && intLeftBoundry >= 0) {
                    element.rangeFloatingButtonContainer.style.bottom = (intBottomBoundry + 4) + 'px';
                    element.rangeFloatingButtonContainer.style.left = (intLeftBoundry + 4) + 'px';
                }
            };
            
            element.addEventListener('after_selection', function (event) {
                var arrSelected = element.selectedCells;
                
                if (arrSelected.length > 0 && element.numberOfSelections === 1) {
                    rangeFloatingButtonFunction(arrSelected);
                    
                } else if (element.rangeFloatingButtonContainer && element.rangeFloatingButtonContainer.parentNode) {
                    element.rangeFloatingButtonContainer.parentNode.removeChild(element.rangeFloatingButtonContainer);
                    element.rangeFloatingButtonContainer = null;
                }
            });
            
            element.scrollContainer.addEventListener('scroll', function (event) {
                if (element.rangeFloatingButtonContainer && element.rangeFloatingButtonContainer.parentNode) {
                    element.rangeFloatingButtonContainer.parentNode.removeChild(element.rangeFloatingButtonContainer);
                    element.rangeFloatingButtonContainer = null;
                }
            });
        }
        
        // ######################################################################################################
        // ######################################################################################################
        // ######################################################################################################
        
        // delete, refresh, page left and page right buttons
        element.addEventListener('click', function (event) {
            var target = event.target, intOffset, intLimit
            
            // delete button
            if (target.classList.contains('delete-button')) {
                deleteSelection(element);
                
            // refresh button
            } else if (target.classList.contains('refresh-button')) {
                getData(element, undefined, undefined, undefined, true);
                
            // refresh button
            } else if (target.classList.contains('insert-button')) {
                insertDialog(element);
                
            } else if (target.classList.contains('paginate-left') || target.classList.contains('paginate-right')) {
                intLimit = parseInt(element.getAttribute('limit'), 10);
                intOffset = parseInt(element.getAttribute('offset') || '0', 10);
                
                if (target.classList.contains('paginate-left')) {
                    intOffset -= intLimit;
                } else {
                    intOffset += intLimit;
                }
                
                if (intOffset <= 0) {
                    intOffset = 0;
                    element.pageLeftButton.setAttribute('disabled', '');
                } else {
                    element.pageLeftButton.removeAttribute('disabled');
                }
                
                element.setAttribute('offset', intOffset);
                element.paginated = true;
                getData(element);
            }
        });
        
        if (!evt.touchDevice) {
            element.addEventListener('keydown', function (event) {
                var intKeyCode = (event.which || event.keyCode);
                
                if (!element.hasAttribute('no-huddelete')) {
                    if (event.target === element.copyControl && (intKeyCode === KEY_BACKSPACE || intKeyCode === KEY_DELETE)) {
                        deleteSelection(element);
                        event.preventDefault();
                    }
                }
            });
        }
        
        // manuel update
        var updateFromEntry = function (target) {
            
            var updateRecord = GS.findParentElement(target, 'tr')
              , updateRecordData = element.internalData.arrRecords[parseInt(updateRecord.getAttribute('data-index'), 10)]
              , arrPk, arrLock, i, len, col_i, col_len, strRoles, strColumns
              , strHashColumns, strRecordToHash, strTemp, strRecord, strUpdateData;
            
            arrPk = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
            arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);
            
            // gathering update headers
            for (i = 0, len = arrPk.length, strRoles = '', strColumns = ''; i < len; i += 1) {
                strRoles += (strRoles ? '\t' : '') + 'pk';
                strColumns += (strColumns ? '\t' : '') + arrPk[i];
            }
            
            for (i = 0, len = arrLock.length, strHashColumns = ''; i < len; i += 1) {
                strHashColumns += (strHashColumns ? '\t' : '') + arrLock[i];
            }
            strRoles += (strRoles ? '\t' : '') + 'hash';
            strColumns += (strColumns ? '\t' : '') + 'hash';
            
            strRoles += (strRoles ? '\t' : '') + 'set';
            strColumns += (strColumns ? '\t' : '') + target.getAttribute('column');
            
            // get update data
            strRecord = '';
            
            // get 'pk' columns
            for (col_i = 0, col_len = arrPk.length; col_i < col_len; col_i += 1) {
                strRecord += (strRecord ? '\t' : '');
                strRecord += GS.encodeForTabDelimited(updateRecordData[element.internalData.arrColumnNames.indexOf(arrPk[col_i])], element.nullString);
            }
            
            // get 'hash' columns
            strRecordToHash = '';
            for (col_i = 0, col_len = arrLock.length; col_i < col_len; col_i += 1) {
                strRecordToHash += (strRecordToHash ? '\t' : '');
                strTemp = updateRecordData[element.internalData.arrColumnNames.indexOf(arrLock[col_i])];
                strRecordToHash += (strTemp === 'NULL' ? '' : strTemp);
            }
            
            strRecord += (strRecord ? '\t' : '') + GS.utfSafeMD5(strRecordToHash).toString();
            
            // get 'set' column
            strRecord += (strRecord ? '\t' : '') + GS.encodeForTabDelimited(target.value, element.nullString);
            
            strUpdateData = (strRoles + '\n' + strColumns + '\n' + strRecord + '\n');
            updateRecords(element, strHashColumns, strUpdateData, [updateRecord], false);
        };
        
        element.addEventListener('change', function (event) {
            var target = event.target;

            if (
                target.hasAttribute('column') &&
                !GS.findParentElement(target, 'tr').classList.contains('insert-record') &&
                !event.shiftKey
            ) {
                updateFromEntry(target);
            }
        });
        
        // manuel insert
        var insertFromInsertRecord = function () {
            var arrElements = xtag.query(element, 'tr.insert-record > td > [column]')
              , i, len, strColumns, strInsertData, strLocalData;
            
            for (i = 0, len = arrElements.length, strColumns = '', strInsertData = '', strLocalData = ''; i < len; i += 1) {
                strColumns += (strColumns ? '\t' : '') + arrElements[i].getAttribute('column');
                strInsertData += (strInsertData ? '\t' : '') + GS.encodeForTabDelimited(arrElements[i].value || 'NULL', element.nullString);
                strLocalData += (strLocalData ? '\t' : '') + GS.encodeForTabDelimited(arrElements[i].value || '', element.nullString);
                arrElements[i].value = '';
            }
            
            //console.log('strColumns:    ', strColumns);
            //console.log('strInsertData: ', strInsertData);
            //console.log('strLocalData:  ', strLocalData);
            
            insertRecords(element, strColumns, strInsertData + '\n', strLocalData + '\n', false);
        };
        
        element.addEventListener('keydown', function (event) {
            var intKeyCode = (event.which || event.keyCode), target = event.target;
            
            if (target.hasAttribute('column') && GS.findParentElement(target, 'tr').classList.contains('insert-record') && !event.shiftKey) {
                if (intKeyCode === KEY_RETURN) {
                    insertFromInsertRecord();
                    event.preventDefault();
                }
            }
        });
        
        // arrow navigation, key selection
        if (!evt.touchDevice) {
            element.addEventListener('keydown', function (event) {
                var intKeyCode = (event.which || event.keyCode)
                  , target = event.target, targetValue = target.value || '', bolNavigateMode = false
                  , parentCell, parentRecord, parentTBody, jsnCursorPos, intCursorPosition, bolSelect
                  , bolFullSelection, bolCursorAtFirst, bolCursorAtTop, bolCursorAtLast, bolCursorAtBottom
                  , arrSelected, arrRecords, focusElement;
                
                // find out if we are in focus mode
                // if we are in a cell control: we might be in focus mode (we need to check further)
                if ((event.target.nodeName === 'INPUT' || event.target.nodeName === 'TEXTAREA') &&
                    !target.classList.contains('hidden-focus-control')) {
                    jsnCursorPos = GS.getInputSelection(event.target);
                    
                    // if fill text selection and shift is down: not focus mode
                    if (!(jsnCursorPos.start === 0 && jsnCursorPos.end === event.target.value.length && event.shiftKey)) {
                        bolNavigateMode = true;
                    }
                } else if (target.hasAttribute('column')) {
                    jsnCursorPos = {'start': 0, 'end': targetValue.length};
                    if (!event.shiftKey) {
                        bolNavigateMode = true;
                    }
                }
                
                // if we're in navigate mode: change focused cell
                if (bolNavigateMode) {
                    if (target.nodeName === 'INPUT' || target.nodeName === 'TEXTAREA') {
                        jsnCursorPos = GS.getInputSelection(target);
                    } else {
                        jsnCursorPos = {'start': 0, 'end': targetValue.length};
                    }
                    
                    parentCell = GS.findParentElement(target, 'th,td');
                    parentRecord = parentCell.parentNode;
                    parentTBody = parentRecord.parentNode;
                    
                    bolFullSelection = (jsnCursorPos.start === 0 && jsnCursorPos.end === targetValue.length);
                    
                    // if we don't have a full selection and the selection is one character position
                    if (!bolFullSelection && jsnCursorPos.start === jsnCursorPos.end) {
                        // find out where the cursor is
                        intCursorPosition = jsnCursorPos.start;
                        bolCursorAtFirst = (intCursorPosition === 0);
                        bolCursorAtTop = (intCursorPosition < (targetValue.indexOf('\n') === -1 ?
                                                                    targetValue.length + 1 :
                                                                    targetValue.indexOf('\n') + 1)) ||
                                         (intCursorPosition === 0);
                        bolCursorAtLast = (intCursorPosition === targetValue.length);
                        bolCursorAtBottom = (intCursorPosition > targetValue.lastIndexOf('\n'));
                    }
                    
                    // if left arrow and (full selection or the cursor is at the first character)
                    if (intKeyCode === KEY_LEFT && (bolFullSelection || bolCursorAtFirst)) {
                        if (parentCell.previousElementSibling && parentCell.previousElementSibling.nodeName !== 'TH') {
                            focusElement = parentCell.previousElementSibling;
                            bolSelect = true;
                            
                        } else if (parentRecord.previousElementSibling) {
                            focusElement = parentRecord.previousElementSibling.lastElementChild;
                            bolSelect = true;
                        }
                        
                    // if up arrow and (full selection or the cursor is in the top line)
                    } else if (intKeyCode === KEY_UP && (bolFullSelection || bolCursorAtTop)) {
                        if (parentRecord.previousElementSibling) {
                            focusElement = parentRecord.previousElementSibling.children[parentCell.cellIndex];
                            bolSelect = true;
                            
                        } else if (parentCell.previousElementSibling && parentCell.previousElementSibling.nodeName !== 'TH') {
                            focusElement = parentTBody.lastElementChild.children[parentCell.cellIndex - 1];
                            bolSelect = true;
                        }
                        
                    // if right arrow and (full selection or the cursor is at the last character)
                    } else if (intKeyCode === KEY_RIGHT && (bolFullSelection || bolCursorAtLast)) {
                        if (parentCell.nextElementSibling && parentCell.nextElementSibling.nodeName !== 'TH') {
                            focusElement = parentCell.nextElementSibling;
                            parentCell.nextElementSibling.children[0].focus();
                            bolSelect = true;
                            
                        } else if (parentRecord.nextElementSibling) {
                            focusElement = parentRecord.nextElementSibling.children[1];
                            bolSelect = true;
                        }
                        
                    // if down arrow  and (full selection or the cursor is in the last line)
                    } else if (intKeyCode === KEY_DOWN && (bolFullSelection || bolCursorAtBottom)) {
                        if (parentRecord.nextElementSibling) {
                            focusElement = parentRecord.nextElementSibling.children[parentCell.cellIndex];
                            bolSelect = true;
                            
                        } else if (parentCell.nextElementSibling && parentCell.nextElementSibling.nodeName !== 'TH') {
                            focusElement = parentTBody.firstElementChild.children[parentCell.cellIndex + 1];
                            bolSelect = true;
                        }
                    }
                    
                    // if something was selected
                    if (bolSelect) {
                        // set selected cells
                        element.savedSelection = [];
                        element.savedSelectionCopy = [];
                        element.dragOrigin = GS.findParentElement(focusElement, 'td, th');
                        element.dragCurrentCell = element.dragOrigin;
                        element.selectionPreviousOrigin = element.dragOrigin;
                        element.numberOfSelections = 1;
                        element.dragMode = 'select';
                        
                        selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                        
                        // this makes it so that the keyup doesn't happen,
                        //      allowing the new text selection to stay
                        event.preventDefault();
                        event.stopPropagation();
                    }
                    
                    if (focusElement) {
                        focusElement = xtag.query(focusElement, 'input, textarea, select, [tabindex]')[0];
                        if (focusElement) {
                            focusElement.focus();
                            
                            // select all the text and scroll into view
                            if (focusElement !== window) {
                                if (focusElement.nodeName === 'INPUT' || focusElement.nodeName === 'TEXTAREA') {
                                    GS.setInputSelection(focusElement, 0, focusElement.value.length);
                                }
                                parentRecord = GS.findParentTag(focusElement, 'tr');
                                
                                if (parentRecord && parentRecord.nodeName === 'TR') {
                                    GS.scrollIntoView(parentRecord);
                                }
                            }
                        }
                    }
                    
                // else: change selection
                } else if (event.target === element ||
                           event.target.hasAttribute('column') ||
                           event.target.classList.contains('hidden-focus-control')) {
                               
                    // if mouse selection is not happening right now
                    if (!element.dragAllowed) {
                        arrSelected = element.selectedCells;
                        
                        // if the key was tab
                        if (intKeyCode === KEY_TAB) {
                            // if is a selection origin: focus the inner control
                            if (element.dragOrigin) {
                                element.dragOrigin.children[0].focus();
                                
                                // this makes it so that the keyup doesn't happen,
                                //      allowing the new text selection to stay
                                event.preventDefault();
                            }
                            
                        // else if the key was return
                        } else if (intKeyCode === KEY_RETURN) {
                            // if there is only one cell selected: go into the cell control
                            if (arrSelected.length === 1) {
                                arrSelected[0].children[0].focus();
                            } else {
                                element.dragOrigin.children[0].focus();
                            }
                            
                            GS.setInputSelection(document.activeElement, document.activeElement.value.length);
                            GS.scrollIntoView(GS.findParentTag(document.activeElement, 'tr'));
                            
                            // this makes it so that the keyup doesn't happen,
                            //      allowing the new text selection to stay
                            event.preventDefault();
                            
                        // else if an arrow key was pressed
                        } else if (intKeyCode === KEY_UP || intKeyCode === KEY_DOWN || intKeyCode === KEY_LEFT || intKeyCode === KEY_RIGHT) {
                            arrRecords = xtag.query(element, 'tr');
                            element.dragMode = 'select';
                            
                            // if no selection: select first editable cell
                            if (arrSelected.length === 0) {
                                //console.log('2***');
                                element.savedSelection = [];
                                element.savedSelectionCopy = [];
                                element.dragOrigin = xtag.query(element, 'tbody td')[0];
                                element.dragCurrentCell = element.dragOrigin;
                                element.selectionPreviousOrigin = element.dragOrigin;
                                element.numberOfSelections = 1;
                                
                                bolSelect = true;
                                
                            // if shift: expand current selection
                            } else if (event.shiftKey) {
                                //console.log('3***', element.dragCurrentCell);
                                element.dragOrigin = element.selectionPreviousOrigin;
                                parentRecord = element.dragCurrentCell.parentNode;
                                
                                // if left arrow
                                if (intKeyCode === 37 && element.dragCurrentCell.previousElementSibling) {
                                    element.dragCurrentCell = element.dragCurrentCell.previousElementSibling;
                                    
                                // if up arrow
                                } else if (intKeyCode === 38 && arrRecords[parentRecord.rowIndex - 1]) {
                                    element.dragCurrentCell = arrRecords[parentRecord.rowIndex - 1]
                                                                    .children[element.dragCurrentCell.cellIndex];
                                    
                                // if right arrow
                                } else if (intKeyCode === 39 && element.dragCurrentCell.nextElementSibling) {
                                    element.dragCurrentCell = element.dragCurrentCell.nextElementSibling;
                                    
                                // if down arrow
                                } else if (intKeyCode === 40 && arrRecords[parentRecord.rowIndex + 1]) {
                                    element.dragCurrentCell = arrRecords[parentRecord.rowIndex + 1]
                                                                    .children[element.dragCurrentCell.cellIndex];
                                }
                                
                                bolSelect = true;
                                
                            // else: move selected cell based on origin cell
                            } else {
                                //console.log('4***', arrSelected.length);
                                if (arrSelected.length > 1) {
                                    element.dragCurrentCell = element.selectionPreviousOrigin;
                                }
                                
                                parentRecord = element.dragCurrentCell.parentNode;
                                
                                // if left arrow
                                if (intKeyCode === 37 && element.dragCurrentCell.previousElementSibling) {
                                    element.dragCurrentCell = element.dragCurrentCell.previousElementSibling;
                                    
                                // if up arrow
                                } else if (intKeyCode === 38 && arrRecords[parentRecord.rowIndex - 1]) {
                                    element.dragCurrentCell = arrRecords[parentRecord.rowIndex - 1]
                                                                    .children[element.dragCurrentCell.cellIndex];
                                    
                                // if right arrow
                                } else if (intKeyCode === 39 && element.dragCurrentCell.nextElementSibling) {
                                    element.dragCurrentCell = element.dragCurrentCell.nextElementSibling;
                                    
                                // if down arrow
                                } else if (intKeyCode === 40 && arrRecords[parentRecord.rowIndex + 1]) {
                                    element.dragCurrentCell = arrRecords[parentRecord.rowIndex + 1]
                                                                    .children[element.dragCurrentCell.cellIndex];
                                }
                                
                                element.savedSelection = [];
                                element.savedSelectionCopy = [];
                                element.dragOrigin = element.dragCurrentCell;
                                element.selectionPreviousOrigin = element.dragCurrentCell;
                                element.numberOfSelections = 1;
                                
                                bolSelect = true;
                            }
                            
                            // if the above code has produced the info for a selection: call the select handler
                            if (bolSelect) {
                                //console.log('5***', element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                                
                                element.lastFocusedControl = null;
                                element.copyControl.focus();
                                
                                selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                                GS.scrollIntoView(element.dragCurrentCell.parentNode);
                                event.preventDefault();
                            }
                        }
                    }
                }
            });
        }
        
        
        element.addEventListener('mousewheel', function (event) {
            synchronizeHeaderScroll(element);
        });
        element.scrollContainer.addEventListener('scroll', function (event) {
            synchronizeHeaderScroll(element);
        });
        window.addEventListener('resize', function (event) {
            refreshReflow(element);
            refreshHeight(element);
            synchronizeHeaderWidths(element);
        });
    }
    
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);
                
                if (element.hasAttribute('null-string')) {
                    element.nullString = element.getAttribute('null-string') || '';
                } else {
                    element.nullString = 'NULL';
                }
                
                prepareElement(element);
                bindElement(element);
                getData(element, '', '', true);
            }
        }
    }
    
    xtag.register('gs-datasheet', {
        lifecycle: {
            created: function () {},
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementInserted(element);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);
                    
                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value' && this.root) {
                        this.refresh();
                    }
                }
            }
        },
        events: {},
        accessors: {
            selectedCells: {
                
                /*
                    function synchronize(element, bolScroll) {
                        var arrRecords = xtag.query(element, 'tr'), selectCells = [], i, len,
                            arrParts, arrTextareas, focusedElement, recordIndex, cellIndex;
                        
                        // selection
                        if (element.savedSelection) {
                            // loop through savedSelection
                            for (i = 0, len = element.savedSelection.length; i < len; i += 1) {
                                // any cell position that is in saved selection gets added to the selectCells
                                arrParts = element.savedSelection[i].split(',');
                                recordIndex = parseInt(arrParts[0], 10);
                                cellIndex = parseInt(arrParts[1], 10);
                                
                                if (recordIndex < arrRecords.length && cellIndex < arrRecords[0].children.length) {
                                    selectCells.push(arrRecords[recordIndex].children[cellIndex]);
                                }
                            }
                            
                            // select cells
                            element.selectedCells = selectCells;
                        }
                        
                        // focus
                        if (element.lastFocusedControl) {
                            element.lastFocusedControl.focus();
                            focusedElement = element.lastFocusedControl;
                        } else {
                            focusedElement = element.copyControl;
                            focusedElement.focus();
                        }
                        
                        // if there was no control to focus and
                        //      there is a selection and
                        //      bolScroll is true: scroll to selected
                        if (!element.lastFocusedControl && element.selectedCells.length > 0 && bolScroll) {
                            GS.scrollIntoView(element.selectedCells[0].parentNode);
                        }
                        
                        // if there was a control and bolScroll is true: scroll to focused record
                        if (focusedElement && bolScroll) {
                            GS.scrollIntoView(GS.findParentElement(document.activeElement, 'tr'));
                        }
                        
                        if (focusedElement && element.lastTextSelection) {
                            GS.setInputSelection(focusedElement, element.lastTextSelection.start, element.lastTextSelection.end);
                        }
                    }
                    function clearSelection(element) {
                        element.savedSelection = [];
                        element.savedSelectionCopy = [];
                        element.dragOrigin = null;
                        element.dragCurrentCell = null;
                        element.selectionPreviousOrigin = null;
                        element.numberOfSelections = 0;
                        element.selectedCells = [];
                    }
                */
                
                get: function () {
                    return xtag.query(this.scrollContainer, '[selected]');
                },
                
                set: function (newValue) {
                    var i, len, intIdIndex, arrCells = xtag.query(this, '[selected]'),
                        cell_i, cell_len, arrRowIndexes = [], arrHeaderIndexes = [],
                        arrRecordSelectors, arrHeaders;
                    
                    // clear old selection
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected');
                    }
                    
                    arrCells = xtag.query(this, '[selected-secondary]');
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected-secondary');
                    }
                    
                    // if newValue is not an array: make it an array
                    if (typeof newValue === 'object' && newValue.length === undefined) {
                        arrCells = [newValue];
                    } else {
                        arrCells = newValue;
                    }
                    
                    // if this call is the result of a javascript ".selectedCells = ARRAY" call and there are more than zero cells to set
                    if (!this.dragAllowed && arrCells.length > 0) {
                        this.dragOrigin = arrCells[0];
                        this.dragCurrentCell = arrCells[arrCells.length - 1];
                    }
                    if (!this.savedSelection) { this.savedSelection = []; }
                    
                    // set new selection
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        GS.listAdd(arrRowIndexes, arrCells[i].parentNode.rowIndex);
                        GS.listAdd(arrHeaderIndexes, arrCells[i].cellIndex);
                        
                        this.savedSelection.push(arrCells[i].parentNode.rowIndex + ',' + arrCells[i].cellIndex);
                        
                        arrCells[i].setAttribute('selected', '');
                    }
                    
                    // highlight non-selected headers and row selectors
                    
                    arrRecordSelectors = xtag.query(this, 'tbody th, thead th:first-child');
                    for (i = 0, len = arrRecordSelectors.length; i < len; i += 1) {
                        if (arrRowIndexes.indexOf(i) !== -1 && !arrRecordSelectors[i].hasAttribute('selected')) {
                            arrRecordSelectors[i].setAttribute('selected-secondary', '');
                        }
                    }
                    
                    arrHeaders = xtag.query(this, 'thead th');
                    for (i = 0, len = arrHeaders.length; i < len; i += 1) {
                        if (arrHeaderIndexes.indexOf(i) !== -1 && !arrHeaders[i].hasAttribute('selected')) {
                            arrHeaders[i].setAttribute('selected-secondary', '');
                        }
                    }
                    
                    //console.log(arrRecordSelectors, arrHeaders, arrRowIndexes, arrHeaderIndexes);
                    
                    GS.triggerEvent(this, 'after_selection');
                }
            },
            
            selectedRecords: {
                get: function () {
                    var i, len, intRecordIndex = -1, arrRecord = [], selected = this.selectedCells;
                    
                    // loop through the selected cells and create an array of trs
                    for (i = 0, len = selected.length; i < len; i += 1) {
                        if (selected[i].parentNode.rowIndex > intRecordIndex && selected[i].parentNode.parentNode.nodeName !== 'THEAD') {
                            intRecordIndex = selected[i].parentNode.rowIndex;
                            
                            arrRecord.push(selected[i].parentNode);
                        }
                    }
                    
                    return arrRecord;
                },
                
                set: function (newValue) {
                    var i, len, cell_i, cell_len, intIdIndex, arrCells = this.selectedCells, arrRecords, arrCellChildren;
                    
                    // clear old selection
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected');
                    }
                    
                    arrCells = xtag.query(this, '[selected-secondary]');
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected-secondary');
                    }
                    
                    // if newValue is not an array: make it an array
                    if (typeof newValue === 'object' && newValue.length === undefined) {
                        arrRecords = [newValue];
                    } else {
                        arrRecords = newValue;
                    }
                    
                    // set new selection
                    for (i = 0, len = arrRecords.length, arrCells = []; i < len; i += 1) {
                        arrCellChildren = arrRecords[i].children;
                        
                        for (cell_i = 0, cell_len = arrCellChildren.length; cell_i < cell_len; cell_i += 1) {
                            arrCells.push(arrCellChildren[cell_i]);
                        }
                    }
                    
                    this.selectedCells = arrCells;
                }
            },
            
            value: {
                get: function () {
                    return this.getAttribute('value');
                },
                
                set: function (newValue) {
                    return this.setAttribute('value', newValue);
                }
            }
        },
        methods: {
            'refresh': function () {
                getData(this);
            }
            
          , 'refreshFixedHeader': function () {
                synchronizeHeaderScroll(this);
                synchronizeHeaderWidths(this);
            }
            
          , 'refreshReflow': function () {
                refreshReflow(this);
            }
        }
    });
});window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('<gs-date>', '<gs-date>', 'gs-date column="${1:name}"></gs-date>');
    registerDesignSnippet('<gs-date> With Label', '<gs-date>', 'label for="${1:date-insert-start_date}">${2:Start Date}:</label>\n' +
                                                               '<gs-date id="${1:date-insert-start_date}" column="${3:start_date}"></gs-date>');
    
    designRegisterElement('gs-date', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-date.html');
    
    window.designElementProperty_GSDATE = function(selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });
        
        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });
        
        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });
        
        addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
        });
        
        //console.log(selectedElement.hasAttribute('mini'));
        
        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });
        
        addProp('Date Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-picker')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-picker', (this.value === 'true'), false);
        });
        
        addProp('Format', true, '<gs-combo class="target" value="' + encodeHTML(selectedElement.getAttribute('format') || '') + '" mini>' + 
                        ml(function () {/*<template>
                                            <table>
                                                <tbody>
                                                    <tr value="">
                                                        <td hidden>Default</td>
                                                        <td><center>Default<br /> (01/01/2015)</center></td>
                                                    </tr>
                                                    <tr value="shortdate">
                                                        <td hidden>shortdate</td>
                                                        <td><center>shortdate<br /> (1/1/15)</center></td>
                                                    </tr>
                                                    <tr value="mediumdate">
                                                        <td hidden>mediumdate</td>
                                                        <td><center>mediumdate<br /> (Jan 1, 2015)</center></td>
                                                    </tr>
                                                    <tr value="longdate">
                                                        <td hidden>longdate</td>
                                                        <td><center>longdate<br /> (January 1, 2015)</center></td>
                                                    </tr>
                                                    <tr value="fulldate">
                                                        <td hidden>fulldate</td>
                                                        <td><center>fulldate<br /> (Thursday, January 1, 2015)</center></td>
                                                    </tr>
                                                    <tr value="isodate">
                                                        <td hidden>isodate</td>
                                                        <td><center>isodate<br /> (2015-01-01)</center></td>
                                                    </tr>
                                                    <tr value="isodatetime">
                                                        <td hidden>isodatetime</td>
                                                        <td><center>isodatetime<br /> (2015-01-01T00:00:00)</center></td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </template>
                                    </gs-combo>
                                */}), function () {
            return setOrRemoveTextAttribute(selectedElement, 'format', this.value);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });
        
        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });
        
        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });
        
        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });
        
        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
        
        //// SUSPEND-CREATED attribute
        //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
        //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        //});
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var singleLineTemplateElement = document.createElement('template'),
        singleLineTemplate;

    singleLineTemplateElement.innerHTML = '<input class="control" gs-dynamic type="text" />' +
                             '<gs-button class="date-picker-button" gs-dynamic inline icononly icon="calendar" no-focus></gs-button>';

    singleLineTemplate = singleLineTemplateElement.content;

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        //console.log('change event triggered');

        GS.triggerEvent(event.target.parentNode, 'change');

        handleFormat(event.target.parentNode, event);
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
    }

    function buttonClickFunction(event) {
        openDatePicker(event.target.parentNode);
    }

    //function pushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
    //    }
    //}

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // sync control value and resize to text
    function syncView(element) {
        if (element.control) {
            element.setAttribute('value', element.control.value);
        }
    }

    function openDatePicker(element, dteDate) {
        var divElement = document.createElement('div')
          , jsnOffset = GS.getElementOffset(element.datePickerButton)
          , jsnControlOffset = GS.getElementOffset(element)
          , datePickerContainer, datePicker, strHTML = '', intTop, bolSelectOrigin
          , i, len, dateClickHandler, arrDateButtons, dteCurrent, strInputValue = element.control.value;

        // if there is a day of the week in the value: remove it
        if (strInputValue.match(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim)) {
            strInputValue = strInputValue.replace(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim, '')
                                         .replace(/  /gim, ' ')
                                         .trim();
        }

        // fix date being off by one day by replacing the dashes with slashes
        strInputValue = strInputValue.replace(/-/, '/')  // replace first dash with forward slash
                                     .replace(/-/, '/'); // replace second dash with forward slash
        
        dteCurrent = new Date(strInputValue);
        
        if (isNaN(dteCurrent.getTime())) {
            dteCurrent = new Date();
        }
        
        element.datePickerButton.setAttribute('selected', '');
        
        // if no date was sent
        if (!dteDate) {
            // try using the value from the input
            if (element.control.value) {
                dteDate = dteCurrent;
                bolSelectOrigin = true;
                
            // else just use now
            } else {
                dteDate = new Date();
            }
        }
        
        //if we are in the current month and year, Highlight the day we are on
        if (dteDate.getMonth() === dteCurrent.getMonth() && dteDate.getFullYear() === dteCurrent.getFullYear()) {
            bolSelectOrigin = true;
        }
        
        // set html using date
        strHTML = getContentForDatePicker(dteDate, bolSelectOrigin);
        
        divElement.innerHTML =  '<div class="gs-date-date-picker-container" gs-dynamic>' +
                                    '<div class="gs-date-date-picker" gs-dynamic>' + strHTML + '</div>' +
                                '</div>';
        
        datePickerContainer = divElement.children[0];
        element.datePickerContainer = datePickerContainer;
        
        datePicker = datePickerContainer.children[0];
        
        document.body.appendChild(datePickerContainer);
        
        // position datePickerContainer
        intTop = jsnOffset.top + element.offsetHeight;
        
        if (intTop + datePicker.offsetHeight > window.innerHeight) {
            intTop -= datePicker.offsetHeight;
            intTop -= element.offsetHeight;
            
            if (intTop < 0) {
                intTop = 0;
            }
        }
        
        datePicker.style.top = intTop + 'px';
        
        // if window width is wider than 450 pixels width AND the date picker will not fall off of the screen:
        if (window.innerWidth > 450 && jsnOffset.left > 450) {
            // datepicker width: 450px; right: calculated;
            datePicker.style.width = '450px';
            datePicker.style.right = window.innerWidth - (jsnOffset.left + element.datePickerButton.offsetWidth) + 'px';
            
        // if window width is wider than 450 pixels width AND the date picker will not fall off of the screen:
        } else if (window.innerWidth > 450 && jsnOffset.left <= 450) {
            // datepicker width: 450px; right: calculated;
            datePicker.style.width = '450px';
            datePicker.style.left = jsnControlOffset.left + 'px';
            
        // else:
        } else {
            // datepicker width: 96%; right: 2%;
            datePicker.style.width = '96%';
            datePicker.style.right = '2%';
        }
        
        // next month, previous month, next year, previous year click events
        datePickerContainer.getElementsByClassName('prev-month')[0].addEventListener('click', function () {
            dteDate.setMonth((dteDate.getMonth() - 1 < 0 ? 11 : dteDate.getMonth() - 1));
            closeDatePicker(element);
            openDatePicker(element, dteDate);
        });
        datePickerContainer.getElementsByClassName('next-month')[0].addEventListener('click', function () {
            var i, oldMonth;
            
            oldMonth = dteDate.getMonth();
            dteDate.setMonth((oldMonth + 1 > 11 ? 0 : oldMonth + 1));
            
            // if a month is skipped (no need to worry about the loop back to january because december and january both seem to have 31 days)
            if (dteDate.getMonth() === oldMonth + 2) {
                // loop backwards until we reach the correct month
                i = 0;
                while (dteDate.getMonth() === oldMonth + 2 && i < 20) {
                    dteDate.setDate(dteDate.getDate() - 1);
                    i += 1;
                }
            }
            
            closeDatePicker(element);
            openDatePicker(element, dteDate);
        });
        datePickerContainer.getElementsByClassName('prev-year')[0].addEventListener('click', function () {
            dteDate.setFullYear(dteDate.getFullYear() - 1);
            closeDatePicker(element);
            openDatePicker(element, dteDate);
        });
        datePickerContainer.getElementsByClassName('next-year')[0].addEventListener('click', function () {
            dteDate.setFullYear(dteDate.getFullYear() + 1);
            closeDatePicker(element);
            openDatePicker(element, dteDate);
        });
        
        // background click event
        datePickerContainer.addEventListener('click', function (event) {
            if (event.target.classList.contains('gs-date-date-picker-container')) {
                closeDatePicker(element);
            }
        });
        
        // date click events
        dateClickHandler = function () {
            var dteNewDate = new Date(this.getAttribute('data-date'));
            
            closeDatePicker(element);
            
            element.value = (dteNewDate.getMonth() + 1) + '/' + dteNewDate.getDate() + '/' + dteNewDate.getFullYear();
            //console.trace('test', element.value);
            handleFormat(element);
            xtag.fireEvent(element, 'change', { bubbles: true, cancelable: true });
        };
        
        arrDateButtons = datePickerContainer.getElementsByClassName('day-marker');
        
        for (i = 0, len = arrDateButtons.length; i < len; i += 1) {
            arrDateButtons[i].addEventListener('click', dateClickHandler);
        }
    }
    
    function closeDatePicker(element) {
        element.datePickerButton.removeAttribute('selected');
        document.body.removeChild(element.datePickerContainer);
    }
    
    function getContentForDatePicker(originDate, bolSelectOrigin) {
        var strHTML = '', i, looperDate, lookaheadDate, intFirstDayOfWeek = 0, dteToday = new Date(),
            arrDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            arrShortDays = ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
            arrMonths = [
                'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
            ];
        
        looperDate = new Date(originDate);
        looperDate.setDate(1);
        
        strHTML =   '<div class="month-marker" flex-horizontal gs-dynamic>' +
                        '<gs-button class="prev-month" inline icononly icon="arrow-left" gs-dynamic>Prev</gs-button>' +
                        '<span flex gs-dynamic>' + arrMonths[originDate.getMonth()] + '</span>' +
                        '<gs-button class="next-month" inline icononly icon="arrow-right" gs-dynamic>Next</gs-button>' +
                    '</div>' +
                    '<div class="year-marker" flex-horizontal gs-dynamic>' +
                        '<gs-button class="prev-year" inline icononly icon="arrow-left" gs-dynamic>Prev</gs-button>' +
                        '<span flex gs-dynamic>' + originDate.getFullYear() + '</span>' +
                        '<gs-button class="next-year" inline icononly icon="arrow-right" gs-dynamic>Next</gs-button>' +
                    '</div>';
        
        if (!isNaN(looperDate.getTime())) {
            
            // reverse back to the previous intFirstDayOfWeek
            i = 0;
            while (looperDate.getDay() !== intFirstDayOfWeek && i < 20) {
                looperDate.setDate(looperDate.getDate() - 1);
                
                i += 1;
            }
            //console.log(looperDate);
            
            // add day of week markers
            strHTML += '<div class="date-picker-divider" gs-dynamic></div><div class="day-of-week-markers-container" gs-dynamic>';
            for (i = 0; i < 7; i += 1) {
                strHTML += '<div class="day-of-week-marker" gs-dynamic>' + arrShortDays[i] + '</div>';
            }
            strHTML += '</div>';
            
            // loop through till at least the end of the month (or further to find the day that is before the next intFirstDayOfWeek)
            i = 0;
            
            lookaheadDate = new Date(looperDate);
            lookaheadDate.setDate(lookaheadDate.getDate() + 1);
            
            while (!(looperDate.getDay()         === intFirstDayOfWeek &&
                    (looperDate.getMonth()       !== originDate.getMonth() && i > 0) &&
                     lookaheadDate.getFullYear() >=  originDate.getFullYear()) &&
                   i < 50) {
                
                strHTML +=  '<gs-button inline class="day-marker';
                
                if (looperDate.getMonth() !== originDate.getMonth()) {
                    strHTML += ' other-month';
                }
                if (looperDate.getFullYear() === dteToday.getFullYear() &&
                    looperDate.getMonth() === dteToday.getMonth() &&
                    looperDate.getDate() === dteToday.getDate()) {
                    strHTML += ' today';
                }
                strHTML += '"';
                
                if (looperDate.getTime() === originDate.getTime() && bolSelectOrigin) {
                    strHTML += ' selected ';
                }
                
                strHTML +=  'data-date="' + looperDate + '" gs-dynamic>';
                if (looperDate.getFullYear() === dteToday.getFullYear() &&
                    looperDate.getMonth() === dteToday.getMonth() &&
                    looperDate.getDate() === dteToday.getDate()) {
                    strHTML += 'T';
                } else {
                    strHTML += looperDate.getDate();
                }
                strHTML += '</gs-button>';
                
                //console.log(looperDate, lookaheadDate);
                
                lookaheadDate.setDate(lookaheadDate.getDate() + 1);
                looperDate.setDate(looperDate.getDate() + 1);
                i += 1;
            }
        }

        return strHTML;
    }

    function handleFormat(element, event, bolAlertOnError) {
        ///console.log(element.value);
        if (element.value) {
            var dteValue, strValueToFormat = element.value, tempSelection = GS.getInputSelection(element.control);
    
            // if there is a day of the week in the value: remove it
            if (strValueToFormat.match(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim)) {
                strValueToFormat = strValueToFormat.replace(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim, '')
                                                   .replace(/  /gim, ' ')
                                                   .trim();
            }
    
            if (strValueToFormat.indexOf(':') !== -1) {
                strValueToFormat = strValueToFormat.substring(0, strValueToFormat.indexOf(':'));
                strValueToFormat = strValueToFormat.substring(0, strValueToFormat.lastIndexOf(' '));
            }
    
            // if there are only six numbers in the field assume that
            //      the first  two are the month
            //      the second two are the day   and
            //      the third  two are the year  and make a date out of that
            if (strValueToFormat.length === 6 && strValueToFormat.match(/[0-9]/g).join('') === element.value) {
                dteValue = new Date(strValueToFormat.substring(0, 2) + '/' +
                                    strValueToFormat.substring(2, 4) + '/' +
                                    strValueToFormat.substring(4, 6));
            } else {
                //console.log(strValueToFormat.replace(/-/, '/').replace(/-/, '/').replace(/-.*/, ''));
                dteValue = new Date(strValueToFormat.replace(/-/, '/').replace(/-/, '/').replace(/-.*/, ''));
                //console.log(dteValue, dteValue.getFullYear());
            }
            
            //console.trace('test', element.value, strValueToFormat, dteValue);
            
            if (isNaN(dteValue.getTime())) {
                if (bolAlertOnError !== undefined && bolAlertOnError !== false) {
                    alert('Invalid Date: ' + element.value);
                }
                
                if (document.activeElement === element.control) {
                    GS.setInputSelection(element.control, tempSelection.start, tempSelection.end);
                    
                    if (event) {
                        if (event.keyCode === GS.keyCode('backspace')) {
                            GS.setInputSelection(element.control, tempSelection.start - 1, tempSelection.start - 1);
                        } else if (event.keyCode === GS.keyCode('delete')) {
                            GS.setInputSelection(element.control, tempSelection.start, tempSelection.start);
                        }
                        event.stopPropagation();
                        event.preventDefault();
                    }
                }
                
            } else {
                if (element.control) {
                    element.control.value = formatDate(dteValue, getFormatString(element));
                    if (document.activeElement === element.control) {
                        GS.setInputSelection(element.control, tempSelection.start, tempSelection.end);
                    }
                } else {
                    element.innerHTML = formatDate(dteValue, getFormatString(element));
                }
            }
        } else {
            return 'NULL';
        }
    }
    
    function getFormatString(element) {
        var strFormat;
        
        if (element.hasAttribute('format')) {
            strFormat = element.getAttribute('format');
        }
        
        if (!strFormat) {
            strFormat = 'MM/dd/yyyy';
        } else if (strFormat.toLowerCase() === 'shortdate') {
            strFormat = 'M/d/yy';
        } else if (strFormat.toLowerCase() === 'mediumdate') {
            strFormat = 'MMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'longdate') {
            strFormat = 'MMMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'fulldate') {
            strFormat = 'EEEE, MMMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'shorttime') {
            strFormat = 'h:mm a';
        } else if (strFormat.toLowerCase() === 'mediumtime') {
            strFormat = 'h:mm:ss a';
        } else if (strFormat.toLowerCase() === 'isodate') {
            strFormat = 'yyyy-MM-dd';
        } else if (strFormat.toLowerCase() === 'isotime') {
            strFormat = 'HH:mm:ss';
        } else if (strFormat.toLowerCase() === 'isodatetime') {
            strFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
        }
        
        return strFormat;
    }
    
    function formatDate(dteValue, strFormat) {
        /* (this function contains a (modified) substantial portion of code from another source
            here is the copyright for sake of legality) (Uses code by Matt Kruse)
        Copyright (c) 2006-2009 Rostislav Hristov, Asual DZZD
        
        Permission is hereby granted, free of charge, to any person obtaining a 
        copy of this software and associated documentation files 
        (the "Software"), to deal in the Software without restriction, 
        including without limitation the rights to use, copy, modify, merge, 
        publish, distribute, sublicense, and/or sell copies of the Software, 
        and to permit persons to whom the Software is furnished to do so, 
        subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included 
        in all copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/
        var i = 0, j = 0, l = 0, c = '', token = '', x, y, yearLen,
            formatNumber = function (n, s) {
                if (typeof s == 'undefined' || s == 2) {
                  return (n >= 0 && n < 10 ? '0' : '') + n;
                } else {
                    if (n >= 0 && n < 10) {
                       return '00' + n; 
                    }
                    if (n >= 10 && n <100) {
                       return '0' + n;
                    }
                    return n;
                }
            },
            locale = {
                monthsFull:   ['January','February','March','April','May','June', 'July','August','September','October','November','December'],
                monthsShort:  ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
                daysFull:     ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
                daysShort:    ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
                shortDateFormat: 'M/d/yyyy h:mm a',
                longDateFormat: 'EEEE, MMMM dd, yyyy h:mm:ss a'
            };

        y = dteValue.getFullYear();
        // Nunzio commented this out on Monday, October 19, 2015
        // It was causing an issue during typing in the year field
        /*if (y < 1000) {
            y = String(y + 1900);
        }*/

        var M = dteValue.getMonth() + 1,
            d = dteValue.getDate(),
            E = dteValue.getDay(),
            H = dteValue.getHours(),
            m = dteValue.getMinutes(),
            s = dteValue.getSeconds(),
            S = dteValue.getMilliseconds();
        
        //console.log(dteValue.getFullYear());
        
        yearLen = String(y).length;
        dteValue = {
            y: y,
            yyyy: y,
            yy: String(y).substring(yearLen - 2, yearLen),
            M: M,
            MM: formatNumber(M),
            MMM: locale.monthsShort[M-1],
            MMMM: locale.monthsFull[M-1],
            d: d,
            dd: formatNumber(d),
            EEE: locale.daysShort[E],
            EEEE: locale.daysFull[E],
            H: H,
            HH: formatNumber(H)
        };
        
        //console.log(dteValue);

        if (H === 0) {
            dteValue.h = 12;
        } else if (H > 12) {
            dteValue.h = H - 12;
        } else {
            dteValue.h = H;
        }

        dteValue.hh = formatNumber(dteValue.h);
        dteValue.k = H !== 0 ? H : 24;
        dteValue.kk = formatNumber(dteValue.k);

        if (H > 11) {
            dteValue.K = H - 12;
        } else {
            dteValue.K = H;
        }

        dteValue.KK = formatNumber(dteValue.K);

        if (H > 11) {
            dteValue.a = 'PM';
        } else {
            dteValue.a = 'AM';
        }

        dteValue.m = m;
        dteValue.mm = formatNumber(m);
        dteValue.s = s;
        dteValue.ss = formatNumber(s);
        dteValue.S = S;
        dteValue.SS = formatNumber(S);
        dteValue.SSS = formatNumber(S, 3);

        var result = '';

        i = 0;
        c = '';
        token = '';
        s = false;

        while (i < strFormat.length) {
            token = '';   
            c = strFormat.charAt(i);
            if (c == '\'') {
                i++;
                if (strFormat.charAt(i) == c) {
                    result = result + c;
                    i++;
                } else {
                    s = !s;
                }
            } else {
                while (strFormat.charAt(i) == c) {
                    token += strFormat.charAt(i++);
                }
                if (token.indexOf('MMMM') != -1 && token.length > 4) {
                    token = 'MMMM';
                }
                if (token.indexOf('EEEE') != -1 && token.length > 4) {
                    token = 'EEEE';
                }
                if (typeof dteValue[token] != 'undefined' && !s) {
                    result = result + dteValue[token];
                } else {
                    result = result + token;
                }
            }
        }
        
        return result;
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value && new Date(element.value).getTime()) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = undefined;
                //element.value = null;
            }
            
        }
    }
    
    //
    function elementInserted(element) {
        var today, strQSValue;
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element)
                
                if (element.hasAttribute('tabindex')) {
                    element.oldTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }
                
                if (element.hasAttribute('value') && element.getAttribute('value').trim().toLowerCase() === 'today') {
                    today = new Date();
                    element.setAttribute('value', GS.leftPad(today.getFullYear(), '0', 4) + '/' + GS.leftPad(today.getMonth() + 1, '0', 2) + '/' + GS.leftPad(today.getDate(), '0', 2));
                }
                
                // handle "qs" attribute
                if (element.getAttribute('qs')) {
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.setAttribute('value', strQSValue);
                    //}
                    
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }
                
                //if (element.hasAttribute('disabled')) {
                //    element.innerHTML = element.getAttribute('value') || element.getAttribute('placeholder') || '';
                //} else {
                element.innerHTML = '';
                element.appendChild(singleLineTemplate.cloneNode(true));
                if (element.oldTabIndex) {
                    xtag.query(element, '.control')[0].setAttribute('tabindex', element.oldTabIndex);
                }
                //}
                
                //if (element.innerHTML === '') {
                //    element.appendChild(singleLineTemplate.cloneNode(true));
                //    if (element.oldTabIndex) {
                //        xtag.query(element, '.control')[0].setAttribute('tabindex', element.oldTabIndex);
                //    }
                //}
                
                element.refresh();
            }
        }
    }
    
    function getControlState(element) {
        var jsnTextSelection, intStart, intEnd, strFormat = getFormatString(element),
            strValue = element.control.value, delimiter1index, delimiter2index,
            intCurrentSection, strCurrentSection, arrParts, intCurrentSectionSize;
        
        jsnTextSelection = GS.getInputSelection(element.control);
        intStart = jsnTextSelection.start;
        intEnd = jsnTextSelection.end;
        delimiter1index = (strValue.indexOf('-') === -1 ? strValue.indexOf('/') : strValue.indexOf('-'));
        delimiter2index = (strValue.lastIndexOf('-') === -1 ? strValue.lastIndexOf('/') : strValue.lastIndexOf('-'));
        arrParts = strFormat.split(/[-|/]/g);
        
        // calculate current section number
        if (intStart > delimiter2index) {
            intCurrentSection = 2;
        } else if (intStart > delimiter1index && intStart <= delimiter2index) {
            intCurrentSection = 1;
        } else {
            intCurrentSection = 0;
        }
        
        // calculate current part type
        if (arrParts[intCurrentSection].indexOf('y') !== -1) {
            strCurrentSection = 'year';
        } else if (arrParts[intCurrentSection].indexOf('M') !== -1) {
            strCurrentSection = 'month';
        } else {
            strCurrentSection = 'day';
        }
        
        // calculate current section size
        if (intCurrentSection === 2) {
            intCurrentSectionSize = (strValue.length) - (delimiter2index + 1);
        } else if (intCurrentSection === 1) {
            intCurrentSectionSize = delimiter2index - (delimiter1index + 1);
        } else {
            intCurrentSectionSize = delimiter1index;
        }
        
        return {
            'jsnTextSelection': jsnTextSelection,
            'intStart': intStart,
            'intEnd': intEnd,
            'strFormat': strFormat,
            'strValue': strValue,
            'delimiter1index': delimiter1index,
            'delimiter2index': delimiter2index,
            'intCurrentSection': intCurrentSection,
            'strCurrentSection': strCurrentSection,
            'arrParts': arrParts,
            'intCurrentSectionSize': intCurrentSectionSize
        };
    }
    
    xtag.register('gs-date', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'disabled' && newValue !== null) {
                        this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder');
                    } else if (strAttrName === 'disabled' && newValue === null) {
                        this.innerHTML = '';
                        this.appendChild(singleLineTemplate.cloneNode(true));
                        if (this.oldTabIndex) {
                            xtag.query(this, '.control')[0].setAttribute('tabindex', this.oldTabIndex);
                        }
                        this.refresh();
                    } else if (strAttrName === 'value') {
                        this.value = newValue;
                    }
                }
            }
        },
        events: {
            focus: function (event) {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    //console.log('1***', this.control, GS.getInputSelection(this.control));
                }
            },
            click: function (event) {
                var jsnTextSelection, intStart, strFormat, strValue, delimiter1index, delimiter2index;
                
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                    jsnTextSelection = GS.getInputSelection(this.control);
                    strFormat = getFormatString(this);
                    strValue = this.control.value;
                    
                    // if format is dash delimited or slash delimited and
                    //      we are not on a touch device
                    if ((/^[M|y]{1,}[/|-]{1}[M|d]{1,}[/|-]{1}[d|y]{1,}$/).test(strFormat) &&
                        (strValue.substring(jsnTextSelection.start, jsnTextSelection.end).match(/[-|/]/g) || []).length === 0 &&
                        !evt.touchDevice) {
                        
                        // if there is a date and it's dash or slash delimited: select date part
                        if ((/^[0-9]{1,}[-]{1}[0-9]{1,}[-]{1}[0-9]{1,}$/).test(strValue) ||
                            (/^[0-9]{1,}[/]{1}[0-9]{1,}[/]{1}[0-9]{1,}$/).test(strValue)) {
                            
                            intStart = jsnTextSelection.start;
                            delimiter1index = (strValue.indexOf('-') === -1 ? strValue.indexOf('/') : strValue.indexOf('-'));
                            delimiter2index = (strValue.lastIndexOf('-') === -1 ? strValue.lastIndexOf('/') : strValue.lastIndexOf('-'));
                            
                            // if greater than second delimeter
                            if (intStart > delimiter2index) {
                                //console.log('Section 3');
                                GS.setInputSelection(this.control, delimiter2index + 1, strValue.length);
                                
                            // if in between than first and second delimeter
                            } else if (intStart > delimiter1index && intStart <= delimiter2index) {
                                //console.log('Section 2');
                                GS.setInputSelection(this.control, delimiter1index + 1, delimiter2index);
                                
                            // else
                            } else {
                                //console.log('Section 1');
                                GS.setInputSelection(this.control, 0, delimiter1index);
                            }
                            
                            //console.log(intStart, delimiter1index, delimiter2index);
                        }
                    }
                }
            },
            keydown: function (event) { // tried "input" event
                var jsnTextSelection, intStart, intEnd, strFormat, strValue,
                    intKeyCode = (event.keyCode || event.which), delimiter1index, delimiter2index,
                    intCurrentSection, strCurrentSection, arrParts, dteDate, intCurrentSectionSize,
                    jsnState;
                
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                    jsnTextSelection = GS.getInputSelection(this.control);
                    strValue = this.control.value;
                    strFormat = getFormatString(this);
                    
                    // if format is dash delimited or slash delimited and
                    //      the selection doesn't encompass a delimeter and
                    //      we are not on a touch device
                    if ((/^[M|y]{1,}[/|-]{1}[M|d]{1,}[/|-]{1}[d|y]{1,}$/).test(strFormat) &&
                        (strValue.substring(jsnTextSelection.start, jsnTextSelection.end).match(/[-|/]/g) || []).length === 0 &&
                        !evt.touchDevice) {
                        
                        // if there is a date and it's dash or slash delimited
                        if ((/^[0-9]{1,}[-]{1}[0-9]{1,}[-]{1}[0-9]{1,}$/).test(strValue) ||
                            (/^[0-9]{1,}[/]{1}[0-9]{1,}[/]{1}[0-9]{1,}$/).test(strValue)) {
                            
                            // if shift, command and option keys are not down
                            if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
                                event.stopPropagation();
                                
                                jsnState = getControlState(this)
                                jsnTextSelection =      jsnState.jsnTextSelection
                                intStart =              jsnState.intStart
                                intEnd =                jsnState.intEnd
                                strFormat =             jsnState.strFormat
                                strValue =              jsnState.strValue
                                delimiter1index =       jsnState.delimiter1index
                                delimiter2index =       jsnState.delimiter2index
                                intCurrentSection =     jsnState.intCurrentSection
                                strCurrentSection =     jsnState.strCurrentSection
                                arrParts =              jsnState.arrParts
                                intCurrentSectionSize = jsnState.intCurrentSectionSize
                                
                                //// log
                                //console.log('intCurrentSectionSize: ' + intCurrentSectionSize + '\n' +
                                //            'intCurrentSection:     ' + intCurrentSection + '\n' +
                                //            'delimiter1index:       ' + delimiter1index + '\n' +
                                //            'delimiter2index:       ' + delimiter2index + '\n' +
                                //            'strValue.length:       ' + strValue.length + '\n' +
                                //            'strCurrentSection:     ' + strCurrentSection + '\n' +
                                //            'strValue:              ' + strValue + '\n' +
                                //            'Selection Start:       ' + jsnTextSelection.start + '\n' +
                                //            'Selection End:         ' + jsnTextSelection.end);
                                
                                // if number: replace current date part
                                if ((intKeyCode >= 96 && intKeyCode <= 105) || // numpad numbers
                                    (intKeyCode >= 48 && intKeyCode <= 57)) {  // other numbers
                                    this.keyupHandle = true;
                                    
                                // if (/|-):
                                } else if (intKeyCode === 111 || intKeyCode === 191 || // "/"
                                           intKeyCode === 109 || intKeyCode === 189) { // "-"
                                    // if first part: go to second part
                                    if (intCurrentSection === 0) {
                                        intCurrentSection = 1;
                                        
                                    // if second part: go to third part
                                    } else if (intCurrentSection === 1) {
                                        intCurrentSection = 2;
                                    }
                                    
                                // if horizontal arrow: move to a different date part
                                } else if (intKeyCode === 37 || // left arrow
                                           intKeyCode === 39) { // right arrow
                                    //console.log(intCurrentSection, intKeyCode);
                                    
                                    if (intCurrentSection === 2 && intKeyCode === 37) {
                                        intCurrentSection = 1;
                                        
                                    } else if (intCurrentSection === 1) {
                                        if (intKeyCode === 37) {
                                            intCurrentSection = 0;
                                        } else {
                                            intCurrentSection = 2;
                                        }
                                        
                                    } else if (intCurrentSection === 0 && intKeyCode === 39) {
                                        intCurrentSection = 1;
                                    }
                                    
                                // if vertical arrow: update current date part
                                } else if (intKeyCode === 38 || // up arrow
                                           intKeyCode === 40) { // down arrow
                                    dteDate = new Date(strValue);
                                    
                                    // if current part is year
                                    if (strCurrentSection === 'year') {
                                        //console.log(dteDate, dteDate.getFullYear(), dteDate.getYear(), (intKeyCode === 38 ? 1 : -1),
                                        //                        dteDate.getYear() + (intKeyCode === 38 ? 1 : -1));
                                        
                                        // We're using "getFullYear" here instead of "getYear" because "getYear" for some unknown reason
                                        //      worked fine before the 29th of october 2015 (that's the date of discovery anyway) but now
                                        //      throws a number over a thousand years off instead of the actual number.
                                        // Upon looking at the docs, "getYear" is apparently subject to the demons of y2k and no longer
                                        //      supported. Wouldn't it have been better to just make "getYear" do the dame thing as
                                        //      "getFullYear"?
                                        // Still unexplained is why when I tested not more than a week ago it worked without a hitch.
                                        dteDate.setFullYear(dteDate.getFullYear() + (intKeyCode === 38 ? 1 : -1));
                                        
                                        //console.log(dteDate);
                                        
                                    // if current part is month
                                    } else if (strCurrentSection === 'month') {
                                        dteDate.setMonth(dteDate.getMonth() + (intKeyCode === 38 ? 1 : -1));
                                        
                                    // if current part is day
                                    } else if (strCurrentSection === 'day') {
                                        dteDate.setDate(dteDate.getDate() + (intKeyCode === 38 ? 1 : -1));
                                    }
                                    
                                    // set the value
                                    strValue = formatDate(dteDate, strFormat);
                                    this.control.value = strValue;
                                    this.triggerChangeManually = true;
                                }
                                
                                if (this.keyupHandle !== true) {
                                    // reset the section selection in case something has changed it
                                    if (intCurrentSection === 2) {
                                        GS.setInputSelection(this.control, delimiter2index + 1, strValue.length);
                                        
                                    } else if (intCurrentSection === 1) {
                                        GS.setInputSelection(this.control, delimiter1index + 1, delimiter2index);
                                        
                                    } else {
                                        GS.setInputSelection(this.control, 0, delimiter1index);
                                    }
                                }
                                
                                // if not return or tab or number: prevent
                                if (!(intKeyCode >= 96 && intKeyCode <= 105) && // numpad numbers
                                    !(intKeyCode >= 48 && intKeyCode <= 57) &&
                                    intKeyCode !== 13 && // return/enter
                                    intKeyCode !== 9) {  // tab
                                    event.preventDefault();
                                }
                            }
                        }
                    }
                }
            },
            keyup: function (event) {
                var jsnTextSelection, intStart, intEnd, strFormat, strValue,
                    intKeyCode = (event.keyCode || event.which),
                    delimiter1index, delimiter2index, intCurrentSection, strCurrentSection,
                    arrParts, dteDate, intCurrentSectionSize, jsnState;
                
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                    strFormat = getFormatString(this);
                    
                    // if format is dash delimited or slash delimited and
                    //      keyup has been allowed and
                    //      we are not on a touch device
                    if ((/^[M|y]{1,}[/|-]{1}[M|d]{1,}[/|-]{1}[d|y]{1,}$/).test(strFormat) && this.keyupHandle && !evt.touchDevice) {
                        
                        // if shift, command and option keys are not down
                        if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
                            jsnState = getControlState(this)
                            jsnTextSelection =      jsnState.jsnTextSelection
                            intStart =              jsnState.intStart
                            intEnd =                jsnState.intEnd
                            strFormat =             jsnState.strFormat
                            strValue =              jsnState.strValue
                            delimiter1index =       jsnState.delimiter1index
                            delimiter2index =       jsnState.delimiter2index
                            intCurrentSection =     jsnState.intCurrentSection
                            strCurrentSection =     jsnState.strCurrentSection
                            arrParts =              jsnState.arrParts
                            intCurrentSectionSize = jsnState.intCurrentSectionSize
                            
                            //// log
                            //console.log('intCurrentSectionSize: ' + intCurrentSectionSize + '\n' +
                            //            'intCurrentSection:     ' + intCurrentSection + '\n' +
                            //            'delimiter1index:       ' + delimiter1index + '\n' +
                            //            'delimiter2index:       ' + delimiter2index + '\n' +
                            //            'strValue.length:       ' + strValue.length + '\n' +
                            //            'strCurrentSection:     ' + strCurrentSection + '\n' +
                            //            'strValue:              ' + strValue + '\n' +
                            //            'strFormat:             ' + strFormat);
                            
                            if ((strCurrentSection === 'day' && intCurrentSectionSize === 2) ||
                                (strCurrentSection === 'month' && intCurrentSectionSize === 2) ||
                                (strCurrentSection === 'year' && intCurrentSectionSize === strFormat.match(/y/g).length)) {
                                
                                if (intCurrentSection === 2) {
                                    GS.setInputSelection(this.control, delimiter2index + 1, strValue.length);
                                    
                                } else if (intCurrentSection === 1) {
                                    GS.setInputSelection(this.control, delimiter1index + 1, delimiter2index);
                                    
                                } else {
                                    GS.setInputSelection(this.control, 0, delimiter1index);
                                }
                            }
                        }
                    }
                    this.keyupHandle = false;
                    
                    //console.log(intKeyCode);
                    if (intKeyCode === 13 && this.triggerChangeManually) {
                        this.triggerChangeManually = false;
                        GS.triggerEvent(this, 'change');
                    }
                }
            },
            focusout: function () {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    //console.log(this.triggerChangeManually);
                    if (this.triggerChangeManually) {
                        this.triggerChangeManually = false;
                        GS.triggerEvent(this, 'change');
                    }
                }
            }
            
            
            /*// on keydown and keyup sync the value attribute and the control value
            keydown: function (event) {
                var element = this, currentDate, currentSelectionRange, currentSelectionText, currentSelectionNumber, currentSelectionFormatText,
                    currentValue, newValue, strDateFormat, formatDivider, arrMatch, currentFieldRange, newCursorPos, newFieldValue,
                    daysOfTheWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                    monthsOfTheYear = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                    strKeyCode = event.keyCode.toString();
                
                currentSelectionRange = GS.getInputSelection(element.control);
                
                if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (element.getAttribute('disabled') !== null && event.keyCode !== 9) {
                        event.preventDefault();
                        event.stopPropagation();
                    } else {
                        //console.log(strKeyCode === GS.keyCode('left arrow')  , GS.keyCode('left arrow') );
                        //console.log(strKeyCode === GS.keyCode('up arrow')    , GS.keyCode('up arrow'));
                        //console.log(strKeyCode === GS.keyCode('right arrow') , GS.keyCode('right arrow'));
                        //console.log(strKeyCode === GS.keyCode('down arrow')  , GS.keyCode('down arrow'));
                        
                        // When the user presses an arrow key:
                        // It finds the current number that the user has selected
                        //     If they pressed up or down
                        //         (inc/dec)rement the current number (handling day and month names of course)
                        //     If they pressed left or right
                        //         Move their selection to the left or right depending on what they pressed
                        // Then moves the selection to the current number (handling day/month name length differences)
                        
                        // Fix date format
                        strDateFormat = element.getAttribute('format');
                        //console.log(strDateFormat);
                        if (!strDateFormat) {
                            strDateFormat = 'MM/dd/yyyy';
                        } else if (strDateFormat.toLowerCase() === 'shortdate') {
                            strDateFormat = 'M/d/yy';
                        } else if (strDateFormat.toLowerCase() === 'mediumdate') {
                            strDateFormat = 'MMM d, yyyy';
                        } else if (strDateFormat.toLowerCase() === 'longdate') {
                            strDateFormat = 'MMMM d, yyyy';
                        } else if (strDateFormat.toLowerCase() === 'fulldate') {
                            strDateFormat = 'EEEE, MMMM d, yyyy';
                        } else if (strDateFormat.toLowerCase() === 'shorttime') {
                            strDateFormat = 'h:mm a';
                        } else if (strDateFormat.toLowerCase() === 'mediumtime') {
                            strDateFormat = 'h:mm:ss a';
                        } else if (strDateFormat.toLowerCase() === 'isodate') {
                            strDateFormat = 'yyyy-MM-dd';
                        } else if (strDateFormat.toLowerCase() === 'isotime') {
                            strDateFormat = 'HH:mm:ss';
                        } else if (strDateFormat.toLowerCase() === 'isodatetime') {
                            strDateFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
                        }
                        
                        formatDivider = strDateFormat.match(/[^mdyehmsa]/gi).join('');
                        
                        currentValue = element.control.value;
                        currentDate = new Date(currentValue.replace('\'T\'', ' ').replace(/-/g, '/'));
                        
                        if (strDateFormat.indexOf('M') === -1) {
                            currentDate = new Date('2015/6/15 ' + currentValue);
                        }
                        
                        arrMatch = strDateFormat.match(/(M|E)+/g);
                        if (arrMatch && arrMatch[0].length > 3) {
                            strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                            strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                        }
                        
                        // If it was an arrow that was pressed
                        if (strKeyCode === GS.keyCode('left arrow') ||
                            strKeyCode === GS.keyCode('up arrow') ||
                            strKeyCode === GS.keyCode('right arrow') ||
                            strKeyCode === GS.keyCode('down arrow')) {
                            
                            //console.log('test');
                            
                            // Prevent the browser from moving the cursor and prevent envelope from using arrows
                            event.preventDefault();
                            event.stopPropagation();
                            
                            //console.log(currentValue, formatDivider, currentSelectionRange.start, currentSelectionRange.end);
                            
                            // Encompass the field in which the cursor is inside
                            while (currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) {
                                currentSelectionRange.start -= 1;
                            }
                            
                            currentSelectionRange.end = currentSelectionRange.start;
                            while ( currentSelectionRange.end < currentValue.length &&
                                    formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0) {
                                currentSelectionRange.end += 1;
                            }
                            
                            //console.log(currentValue, currentSelectionRange.start, currentSelectionRange.end);
                            
                            GS.setInputSelection(element.control, currentSelectionRange.start, currentSelectionRange.end);
                            
                            currentSelectionText = currentValue.substring(currentSelectionRange.start, currentSelectionRange.end);
                            currentSelectionFormatText = strDateFormat.substring(currentSelectionRange.start, currentSelectionRange.end);
                            
                            // If it is up or down
                            if (strKeyCode === GS.keyCode('up arrow') ||
                                strKeyCode === GS.keyCode('down arrow')) {
                                var increment = strKeyCode === GS.keyCode('up arrow') ? 1 : -1;
                                
                                if (currentSelectionFormatText[0] === 'M') {
                                    currentDate.setMonth(currentDate.getMonth() +       increment);
                                    if ((currentSelectionRange.end - currentSelectionRange.start) > 2) {
                                        currentSelectionRange.end = currentSelectionRange.start + currentSelectionText.indexOf(' ');
                                    } else {
                                        currentSelectionRange.end = currentSelectionRange.start + currentDate.getMonth().toString().length;
                                    }
                                    
                                } else if (currentSelectionFormatText[0] === 'd') {
                                    currentDate.setDate(currentDate.getDate() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getDate().toString().length;
                                    
                                } else if (currentSelectionFormatText[0] === 'y') {
                                    currentDate.setFullYear(currentDate.getFullYear() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getFullYear().toString().length;
                                    
                                } else if (currentSelectionFormatText[0] === 'E') {
                                    currentDate.setDate(currentDate.getDate() + increment);
                                    currentSelectionRange.start = 0;
                                    currentSelectionRange.end = daysOfTheWeek[currentDate.getDay()].length;
                                    
                                } else if (currentSelectionFormatText[0] === 'h' || currentSelectionFormatText[0] === 'H') {
                                    currentDate.setHours(currentDate.getHours() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getHours().toString().length;
                                    
                                } else if (currentSelectionFormatText[0] === 'm') {
                                    currentDate.setMinutes(currentDate.getMinutes() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getMinutes().toString().length;
                                    
                                } else if (currentSelectionFormatText[0] === 's') {
                                    currentDate.setSeconds(currentDate.getSeconds() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getSeconds().toString().length;
                                    
                                } else if (currentSelectionFormatText[0] === 'a') {
                                    currentDate.setHours(currentDate.getHours() + 12);
                                }
                                
                                newValue = formatDate(currentDate, strDateFormat);
                                this.control.value = newValue;
                                currentValue = newValue;
                            } else if (strKeyCode === GS.keyCode('left arrow')) {
                                currentSelectionRange.end = currentSelectionRange.start - 2;
                                currentSelectionRange.start = currentSelectionRange.end;
                            } else if (strKeyCode === GS.keyCode('right arrow')) {
                                currentSelectionRange.end = currentSelectionRange.end + 2;
                                currentSelectionRange.start = currentSelectionRange.end;
                            }
                            
                            // Copied from above
                            arrMatch = strDateFormat.match(/(M|E)+/g);
                            if (arrMatch && arrMatch[0].length > 3) {
                                strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                                strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                            }
                            while (currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) {
                                currentSelectionRange.start -= 1;
                            }
                            currentSelectionRange.end = currentSelectionRange.start;
                            while ( currentSelectionRange.end < currentValue.length &&
                                    formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0) {
                                currentSelectionRange.end += 1;
                            }
                            
                            GS.setInputSelection(element.control, currentSelectionRange.start, currentSelectionRange.end);
                            
                        // All number keys
                        } else if (event.keyCode >= 96 && event.keyCode <= 105) {
                            //// HARK YE ONLOOKER:
                            //// This code caps the number that is inputed by the user to the length that the format allows,
                            //// this will dissallow anyone form entering a year that is > 4 characters unless the
                            //// page's developer allows it in a custom format.
                            //// 
                            //// This should be fixed around the year 9998 to have all default formats have 5 character years
                            
                            currentSelectionText = currentValue.substring(currentSelectionRange.start, currentSelectionRange.end);
                            currentSelectionFormatText = strDateFormat.substring(currentSelectionRange.start, currentSelectionRange.end);
                            
                            currentValue = element.value;
                            
                            // This is sort of copied from above
                            // There are only two differences:
                            //     the var name
                            //     the initialization on the next line
                            currentFieldRange = {
                                start: currentSelectionRange.start
                            };
                            while (currentFieldRange.start >= 0 && formatDivider.indexOf(currentValue[currentFieldRange.start - 1]) < 0) {
                                currentFieldRange.start -= 1;
                            }
                            currentFieldRange.end = currentFieldRange.start;
                            while ( currentFieldRange.end < currentValue.length &&
                                    formatDivider.indexOf(currentValue[currentFieldRange.end]) < 0) {
                                currentFieldRange.end += 1;
                            }
                            
                            //console.log(currentFieldRange);
                            
                            //console.log(currentValue.substring(0, currentSelectionRange.start));
                            //console.log(GS.charFromKeyCode(event), currentSelectionText, currentSelectionFormatText, currentDate);
                            //console.log(currentValue.substring(currentSelectionRange.end));
                            
                            // This error checking is probably unneeded, but what the hey
                            currentFieldRange.start = Math.max(currentFieldRange.start, 0);
                            arrMatch = strDateFormat.match(strDateFormat[currentFieldRange.start] + '+', 'g');
                            if (arrMatch) {
                                // Prevent the browser from putting the number in for us
                                event.preventDefault();
                                
                                // Get the character that they pressed
                                newFieldValue = GS.charFromKeyCode(event);
                                console.log(newFieldValue);
                                // Cap the length to the format field's length by using
                                // all characters in the field except the first one
                                newFieldValue = currentValue.substring(currentFieldRange.start + 1, currentFieldRange.start + arrMatch[0].length) + newFieldValue;
                                console.log(newFieldValue, currentValue);
                                
                                console.log(currentFieldRange.start + 1, currentFieldRange.start + arrMatch[0].length);
                                
                                // Build the value using the current field range and the new field value we built above
                                element.value = 
                                    currentValue.substring(0, currentFieldRange.start) +
                                    newFieldValue +
                                    currentValue.substring(currentFieldRange.end);
                                
                                
                                console.log(currentValue.substring(0, currentFieldRange.start), newFieldValue, currentValue.substring(currentFieldRange.end));
                            
                                // This is copied from above
                                currentFieldRange = {
                                    start: currentSelectionRange.start
                                };
                                while (currentFieldRange.start >= 0 && formatDivider.indexOf(currentValue[currentFieldRange.start - 1]) < 0) {
                                    currentFieldRange.start -= 1;
                                }
                                currentFieldRange.end = currentFieldRange.start;
                                while ( currentFieldRange.end < currentValue.length &&
                                        formatDivider.indexOf(currentValue[currentFieldRange.end]) < 0) {
                                    currentFieldRange.end += 1;
                                }
                                
                                //                                                                          This indexOf does not need to be checked for -1
                                //                                                                          Because we know for a fact that the match is in
                                //                                                                          the string we are searching
                                newCursorPos = Math.min(currentFieldRange.start + arrMatch[0].length, strDateFormat.indexOf(arrMatch[0]) + arrMatch[0].length);
                                newCursorPos = Math.max(newCursorPos, currentFieldRange.end);
                                //console.log(arrMatch[0].length, strDateFormat.indexOf(arrMatch[0]), newCursorPos, arrMatch[0]);
                                GS.setInputSelection(element.control, newCursorPos, newCursorPos);
                            }
                            
                        }
                        
                        //// All visible keys
                        //} else if ( event.keyCode >= 48 && event.keyCode <= 90 ||
                        //            event.keyCode >= 96 && event.keyCode <= 109 ||
                        //            event.keyCode >= 186 && event.keyCode <= 222 ||
                        //            event.keyCode === 32) {
                        //    //console.log('test');
                        //    
                        //    //GS.triggerEvent(element, 'change');
                        //    
                        //    if ((currentSelectionRange.end - currentSelectionRange.start) > 0) {
                        //        element.control.addEventListener('keyup', function ______self() {
                        //            GS.setInputSelection(this, currentSelectionRange.start + 1, currentSelectionRange.start) + 1;
                        //            this.removeEventListener('keyup', ______self);
                        //        });
                        //    }
                        //}
                        
                        //console.log(event.keyCode);
                        
                        syncView(element);
                    }
                }
            },
            keyup: function () {
                var element = this;
                if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    syncView(element);
                }
            },
            click: function () {
                var element = this, currentSelectionRange = GS.getInputSelection(element.control),
                    daysOfTheWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                    monthsOfTheYear = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                    arrMatch, strDateFormat, formatDivider, currentValue, currentDate;
                //console.log(currentSelectionRange.start, currentSelectionRange.end);
                
                ////// Copied from above until otherwise noted
                
                // Fix date format
                strDateFormat = element.getAttribute('format');
                //console.log(strDateFormat);
                if (!strDateFormat) {
                    strDateFormat = 'MM/dd/yyyy';
                } else if (strDateFormat.toLowerCase() === 'shortdate') {
                    strDateFormat = 'M/d/yy';
                } else if (strDateFormat.toLowerCase() === 'mediumdate') {
                    strDateFormat = 'MMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'longdate') {
                    strDateFormat = 'MMMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'fulldate') {
                    strDateFormat = 'EEEE, MMMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'shorttime') {
                    strDateFormat = 'h:mm a';
                } else if (strDateFormat.toLowerCase() === 'mediumtime') {
                    strDateFormat = 'h:mm:ss a';
                } else if (strDateFormat.toLowerCase() === 'isodate') {
                    strDateFormat = 'yyyy-MM-dd';
                } else if (strDateFormat.toLowerCase() === 'isotime') {
                    strDateFormat = 'HH:mm:ss';
                } else if (strDateFormat.toLowerCase() === 'isodatetime') {
                    strDateFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
                }
                
                formatDivider = strDateFormat.match(/[^mdyehmsa]/gi).join('');
                
                currentValue = element.control.value;
                currentDate = new Date(currentValue.replace('\'T\'', ' ').replace(/-/g, '/'));
                
                if (strDateFormat.indexOf('M') === -1) {
                    currentDate = new Date('2015/6/15 ' + currentValue);
                }
                
                arrMatch = strDateFormat.match(/(M|E)+/g);
                if (arrMatch && arrMatch[0].length > 3) {
                    strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                    strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                }
                
                while (currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) {
                    currentSelectionRange.start -= 1;
                }
                currentSelectionRange.end = currentSelectionRange.start;
                while ( currentSelectionRange.end < currentValue.length &&
                        formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0) {
                    currentSelectionRange.end += 1;
                }
                //console.log(currentSelectionRange.start, currentSelectionRange.end);
                
                ////// Not copied
                element.ignoreSelect = true;
                GS.setInputSelection(element.control, currentSelectionRange.start, currentSelectionRange.end);
                
                //console.log('CLICK EVENT FIRED');
            },
            focus: function () {
                GS.triggerEvent(this, 'click');
            },
            select: function () {
                //if (!this.ignoreSelect) {
                //    GS.triggerEvent(this, 'click');
                //    this.ignoreSelect = false;
                //}
                //console.log('SELECT EVENT FIRED', GS.getInputSelection(this.control));
                
                // Copied from click handler until otherwise noted
                var element = this, currentSelectionRange = GS.getInputSelection(element.control),
                    daysOfTheWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                    monthsOfTheYear = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                    arrMatch, strDateFormat, formatDivider, currentValue, currentDate;
                //console.log(currentSelectionRange.start, currentSelectionRange.end);
                
                ////// Copied from above until otherwise noted
                
                // Fix date format
                strDateFormat = element.getAttribute('format');
                //console.log(strDateFormat);
                if (!strDateFormat) {
                    strDateFormat = 'MM/dd/yyyy';
                } else if (strDateFormat.toLowerCase() === 'shortdate') {
                    strDateFormat = 'M/d/yy';
                } else if (strDateFormat.toLowerCase() === 'mediumdate') {
                    strDateFormat = 'MMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'longdate') {
                    strDateFormat = 'MMMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'fulldate') {
                    strDateFormat = 'EEEE, MMMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'shorttime') {
                    strDateFormat = 'h:mm a';
                } else if (strDateFormat.toLowerCase() === 'mediumtime') {
                    strDateFormat = 'h:mm:ss a';
                } else if (strDateFormat.toLowerCase() === 'isodate') {
                    strDateFormat = 'yyyy-MM-dd';
                } else if (strDateFormat.toLowerCase() === 'isotime') {
                    strDateFormat = 'HH:mm:ss';
                } else if (strDateFormat.toLowerCase() === 'isodatetime') {
                    strDateFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
                }
                
                formatDivider = strDateFormat.match(/[^mdyehmsa]/gi).join('');
                
                currentValue = element.control.value;
                currentDate = new Date(currentValue.replace('\'T\'', ' ').replace(/-/g, '/'));
                
                if (strDateFormat.indexOf('M') === -1) {
                    currentDate = new Date('2015/6/15 ' + currentValue);
                }
                
                arrMatch = strDateFormat.match(/(M|E)+/g);
                if (arrMatch && arrMatch[0].length > 3) {
                    strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                    strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                }
                
                // Condition copied only
                if ((currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) ||
                    (currentSelectionRange.end < currentValue.length && formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0)) {
                    GS.triggerEvent(this, 'click');
                    this.ignoreSelect = false;
                }
            }*/
        },
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    if (this.control) {
                        if (this.control.value.trim() === '') {
                            return 'NULL';
                        } else {
                            return this.control.value;
                        }
                    } else if (this.hasAttribute('disabled')) {
                        return this.innerHTML;
                    }
                    
                    return undefined;
                },
                
                // set the value of the input and set the value attribute
                set: function (newValue) {
                    var tempSelection = this.control ? GS.getInputSelection(this.control) : null;
                    
                    if (this.control) {
                        if (newValue && typeof newValue === 'object') {
                            this.control.value = newValue.toLocaleDateString();
                        } else {
                            this.control.value = newValue || '';
                        }
                        
                        if (document.activeElement === this.control) {
                           GS.setInputSelection(this.control, tempSelection.start, tempSelection.end);
                        }
                        
                    } else if (this.hasAttribute('disabled')) {
                        this.innerHTML = newValue;
                        
                    } else {
                        this.setAttribute('value', newValue);
                    }
                    
                    if (this.control) {
                        handleFormat(this);
                    }
                    syncView(this);
                }
            }
        },
        methods: {
            refresh: function () {
                var element = this, arrPassThroughAttributes, i, len;
                
                // set a variable for the control element for convenience and speed
                element.control = xtag.query(element, '.control')[0];
                
                // set a variable for the date picker button element for convenience and speed
                element.datePickerButton = xtag.query(element, '.date-picker-button')[0];
                
                //console.log(element.control, element.getAttribute('value'), element.getAttribute('column'));
                
                if (element.control) {
                    element.control.removeEventListener('change', changeFunction);
                    element.control.addEventListener('change', changeFunction);
                    
                    element.control.removeEventListener('focus', focusFunction);
                    element.control.addEventListener('focus', focusFunction);
                }
                if (element.datePickerButton) {
                    element.datePickerButton.addEventListener('click', buttonClickFunction);
                }
                
                // if there is a value already in the attributes of the element: set the control value
                if (element.control && element.hasAttribute('value')) {
                    element.control.value = element.getAttribute('value');
                    handleFormat(element, undefined, false);
                }
                
                if (element.control) {
                // copy passthrough attributes to control
                    arrPassThroughAttributes = [
                        'placeholder',
                        'name',
                        'maxlength',
                        'autocorrect',
                        'autocapitalize',
                        'autocomplete',
                        'autofocus',
                        'spellcheck',
                        'readonly'
                    ];
                    for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                        if (element.hasAttribute(arrPassThroughAttributes[i])) {
                            element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
                        }
                    }
                }
            },
            
            focus: function () {
                GS.triggerEvent(this, 'focus');
                this.control.focus();
            }
        }
    });
});

window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet('Dialog From Template', 'Dialog From Template', 'GS.openDialog(\'${1:templateID}\', function () {\n' +
                                                                          '    // after dialog open \n' +
                                                                          '}, function (event, strAnswer) {\n' +
                                                                          '    if (strAnswer === \'${2:Ok}\') {\n' +
                                                                          '        // before dialog close\n' +
                                                                          '        $0\n' +
                                                                          '    }\n' +
                                                                          '});');
    
    registerDesignSnippet('GS.openDialog', 'GS.openDialog', 'GS.openDialog(\'${1:templateID}\', function () {\n' +
                                                            '    // after dialog open \n' +
                                                            '}, function (event, strAnswer) {\n' +
                                                            '    if (strAnswer === \'${2:Ok}\') {\n' +
                                                            '        // beforedialog close\n' +
                                                            '        $0\n' +
                                                            '    }\n' +
                                                            '});');
    
    
    registerDesignSnippet('GS.closeDialog', 'GS.closeDialog', 'GS.closeDialog(${1:dialog}, ${2:\'Ok\'});');
    registerDesignSnippet('Close Dialog', 'Close Dialog', 'GS.closeDialog(${1:dialog}, ${2:\'Ok\'});');
    
    registerDesignSnippet('GS.msgbox', 'GS.msgbox', 'GS.msgbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                            '${3:[\'Cancel\', \'Ok\']}, function (strAnswer) {\n' +
                                                    '    if (strAnswer === ${4:\'Ok\'}) {\n' +
                                                    '        // before dialog close\n' +
                                                    '        $0\n' +
                                                    '    }\n' +
                                                    '});');
    registerDesignSnippet('Message Box', 'Message Box', 'GS.msgbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                                '${3:[\'Cancel\', \'Ok\']}, function (strAnswer) {\n' +
                                                        '    if (strAnswer === ${4:\'Ok\'}) {\n' +
                                                        '        // before dialog close\n' +
                                                        '        $0\n' +
                                                        '    }\n' +
                                                        '});');
    
    registerDesignSnippet('GS.inputbox', 'GS.inputbox', 'GS.inputbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                                'function (strInputValue) {\n' +
                                                        '    // before dialog close\n' +
                                                        '    $0\n' +
                                                        '});');
    registerDesignSnippet('Input Box', 'Input Box', 'GS.inputbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                            'function (strInputValue) {\n' +
                                                    '    // before dialog close\n' +
                                                    '    $0\n' +
                                                    '});');
    
    registerDesignSnippet('GS.openDialogToElement', 'GS.openDialogToElement',
                                        'GS.openDialogToElement(${1:document.getElementById(\'target\')}, \'${2:templateID}\', ' +
                                                                            '\'${3:right}\', function () {\n' +
                                        '    // after dialog open \n' +
                                        '}, function (event, strAnswer) {\n' +
                                        '    if (strAnswer === \'${4:Ok}\') {\n' +
                                        '        // beforedialog close\n' +
                                        '        $0\n' +
                                        '    }\n' +
                                        '});');
    registerDesignSnippet('Dialog For Element', 'Dialog For Element',
                                        'GS.openDialogToElement(${1:document.getElementById(\'target\')}, \'${2:templateID}\', ' +
                                                                            '\'${3:right}\', function () {\n' +
                                        '    // after dialog open \n' +
                                        '}, function (event, strAnswer) {\n' +
                                        '    if (strAnswer === \'${4:Ok}\') {\n' +
                                        '        // beforedialog close\n' +
                                        '        $0\n' +
                                        '    }\n' +
                                        '});');
});


(function () {
    'use strict';
    
    function buttonHTML(buttons) {
        var strHTML, i, len;
        
        buttons = buttons || ['Ok'];
        
        // change button parameter to array format if it is string format (and the string is recognized)
        if (typeof buttons === 'string') {
            if (buttons === 'okcancel' || buttons === 'cancelok') {
                buttons = ['Cancel', 'Ok'];
                
            } else if (buttons === 'ok' || buttons === 'okonly') {
                buttons = ['Ok'];
                
            } else if (buttons === 'cancel' || buttons === 'cancelonly') {
                buttons = ['Cancel'];
                
            } else if (buttons === 'yesno' || buttons === 'noyes') {
                buttons = ['No', 'Yes'];
                
            } else if (buttons === 'Yes' || buttons === 'yesonly') {
                buttons = ['Yes'];
                
            } else if (buttons === 'No' || buttons === 'noonly') {
                buttons = ['No'];
            }
        }
        
        if (typeof buttons === 'object') {
            if (buttons.length > 0) {
                strHTML = '<gs-grid gs-dynamic>';
                
                for (i = 0, len = buttons.length; i < len; i += 1) {
                    strHTML +=
                        '<gs-block gs-dynamic>' +
                            '<gs-button dialogclose ' + (i === len - 1 ? 'bg-primary listen-for-return' : '') + ' gs-dynamic>' +
                                encodeHTML(buttons[i]) +
                            '</gs-button>' +
                        '</gs-block>';
                }
                
                strHTML += '</gs-grid>';
                
            } else {
                strHTML = '<gs-button dialogclose>Done</gs-button>';
            }
        } else {
            strHTML = buttons;
        }
        
        return strHTML;
    }
    
    // GS.msgbox('test1', 'test2', ['cancel', 'ok'], function (strAnswer) { console.log(strAnswer); });
    GS.msgbox = function (strTitle, strMessage, buttons, callback) {
        var templateElement = document.createElement('template');
        
        templateElement.innerHTML = '<gs-page>' +
                                    '    <gs-header><center><h3>' + strTitle + '</h3></center></gs-header>' +
                                    '    <gs-body padded>' +
                                    '        ' + strMessage +
                                    '    </gs-body>' +
                                    '    <gs-footer>' + buttonHTML(buttons) + '</gs-footer>' +
                                    '</gs-page>';
        
        GS.openDialog(templateElement, '', function (event, strAnswer) {
            if (typeof callback === 'function') {
                callback(strAnswer);
            }
        });
    };
    
    // GS.inputbox('test1', 'test2', function (strAnswer) { console.log(strAnswer); });
    GS.inputbox = function (strTitle, strMessage, callback) {
        var templateElement = document.createElement('template');
        
        templateElement.innerHTML = '<gs-page>' +
                                    '    <gs-header><center><h3>' + strTitle + '</h3></center></gs-header>' +
                                    '    <gs-body padded>' +
                                    '        ' + strMessage +
                                    '        <gs-text id="dialog-inputbox-control"></gs-text>' +
                                    '    </gs-body>' +
                                    '    <gs-footer>' + buttonHTML(['Cancel', 'Ok']) + '</gs-footer>' +
                                    '</gs-page>';
        
        GS.openDialog(templateElement, '', function (event, strAnswer) {
            if (strAnswer === 'Ok') {
                callback(document.getElementById('dialog-inputbox-control').value);
            } else {
                callback('');
            }
        });
    };
})();

GS.dialogClose = function (dialog, strAnswer) {
    'use strict';
    console.warn('Please use "GS.closeDialog" instead of "GS.dialogClose".');
    dialog.destroy(strAnswer);
};

GS.closeDialog = function (dialog, strAnswer) {
    'use strict';
    
    if (typeof dialog === 'string') {
        dialog = document.getElementById('dialog-from-' + dialog);
    }
    
    if (dialog) {
        dialog.destroy(strAnswer);
    } else {
        console.warn('GS.closeDialog Warning: Dialog not found.');
    }
};

(function () {
    'use strict';
    
    // on focus: if the currently focus element is not in the frontmost dialog: focus first control of the frontmost dialog
    document.addEventListener('focus', function (event) {
        var arrDialog = document.getElementsByTagName('gs-dialog'), frontDialog, parentFind, arrElements, i, len; 
        
        //console.log('1*** focus: ', document.activeElement);
        if (arrDialog.length > 0) {
            frontDialog = arrDialog[arrDialog.length - 1];
            parentFind = GS.findParentElement(document.activeElement, frontDialog);
            
            //console.log('2***', parentFind, frontDialog);
            if (parentFind !== frontDialog) {
                arrElements = xtag.query(frontDialog, 'input, textarea, select, button, iframe, [tabindex], a');
                
                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    if (GS.isElementFocusable(arrElements[i])) {
                        arrElements[i].focus();
                        break;
                    }
                }
                //console.log('3***');
            }
        }
    }, true);
    
    
    // DEPRECATED
    GS.dialog = function (options) {
        var strHTML, dialogOverlay, dialog, strContent = '', strButtons = '', i, len, gridEach,
            arrElements, tapHandler, strHeader, sizingFunction, observer, returnTarget;
        
        // change button parameter to array format if it is string format (and the string is recognized)
        if (typeof options.buttons === 'string') {
            if (options.buttons === 'okcancel' || options.buttons === 'cancelok') {
                options.buttons = ['Cancel', 'Ok'];
                
            } else if (options.buttons === 'ok' || options.buttons === 'okonly') {
                options.buttons = ['Ok'];
                
            } else if (options.buttons === 'cancel' || options.buttons === 'cancelonly') {
                options.buttons = ['Cancel'];
                
            } else if (options.buttons === 'yesno' || options.buttons === 'noyes') {
                options.buttons = ['No', 'Yes'];
                
            } else if (options.buttons === 'Yes' || options.buttons === 'yesonly') {
                options.buttons = ['Yes'];
                
            } else if (options.buttons === 'No' || options.buttons === 'noonly') {
                options.buttons = ['No'];
            }
        }
        
        // option defaults
        options.theme      = options.theme        || 'regular';
        options.type       = options.type         || 'html';
        options.header     = options.header       || '';
        options.content    = options.content      || '';
        options.buttons    = options.buttons      || ['Ok']; // either array or string
        options.max_width  = options.max_width    || '700px';
        options.max_height = options.max_height   || '700px';
        options.mode       = options.mode         || 'detect'; // phone, touch, constrained, full, detect
        options.padded     = options.padded       || false;
        options.autofocus  = (options.autofocus === undefined ? true : false);
        
        // if type is html or, use content as is
        if (options.type === 'html') {
            strContent = options.content;
            strHeader = options.header;
            
        // if type is formatted-html, wrap content with a <pre>
        } else if (options.type === 'formatted-html') {
            strContent = '<pre gs-dynamic>' + options.content + '</pre>';
            strHeader = '<pre gs-dynamic>' + options.header + '</pre>';
            
        // if type is text, encode to be text only
        } else if (options.type === 'text') {
            strContent = encodeHTML(options.content);
            strHeader = encodeHTML(options.header);
            
        // if type is formatted-text, encode to be text only, and wrap with a <pre>
        } else if (options.type === 'formatted-text') {
            strContent = '<pre gs-dynamic>' + encodeHTML(options.content) + '</pre>';
            strHeader = '<pre gs-dynamic>' + encodeHTML(options.header) + '</pre>';
            
        // if type is unrecognized, use content as is
        } else {
            console.warn('Dialog type not recognized... Defaulting to \'html\'.');
            strContent = options.content;
            strHeader = options.header;
        }
        
        // if buttons is an array, build array into button html
        if (typeof options.buttons === 'object') {
            if (options.buttons.length > 0) {
                strButtons = '<gs-grid gs-dynamic>';
                
                for (i = 0, len = options.buttons.length; i < len; i += 1) {
                    strButtons +=
                        '<gs-block gs-dynamic>' +
                            '<gs-button dialogclose ' + (i === len - 1 ? 'bg-primary listen-for-return' : '') + ' gs-dynamic>' +
                                encodeHTML(options.buttons[i]) +
                            '</gs-button>' +
                        '</gs-block>';
                }
                strButtons += '</gs-grid>';
            } else {
                strButtons = '';
            }
        
        // if buttons is not an array, use as html
        } else {
            strButtons = options.buttons;
        }
        
        // append dialog overlay element
        dialogOverlay = GS.stringToElement('<gs-dialog-overlay gs-dynamic></gs-dialog-overlay>');
        document.body.appendChild(dialogOverlay);
        
        dialogOverlay.addEventListener(evt.mousedown, function (event) {
            event.preventDefault();
        });
        dialogOverlay.addEventListener(evt.mousemove, function (event) {
            event.preventDefault();
        });
        
        // build dialog html
        strHTML = '<gs-dialog class="' + encodeHTML(options.theme) + '" gs-dynamic ';
        
        // if mode is set to phone or touch and we are not on those types of devices: change mode to detect
        if ((options.mode === 'touch' && !evt.touchDevice) || (options.mode === 'phone' && evt.deviceType !== 'phone')) {
            options.mode = 'detect';
        }
        
        // deal with full page mode
        if ((options.mode === 'touch' && evt.touchDevice) || (options.mode === 'phone' && evt.deviceType === 'phone') || options.mode === 'full') {
            strHTML += 'style="width: 100%; height: 100%; top: 0;">';
            
        } else if (options.mode === 'constrained') {
            strHTML += 'style="max-width: ' + options.max_width + '; max-height: ' + options.max_height + '; width: 94%; height: 90%;">';// auto
                             //width: ' + options.width + '; ' +
                             //'height: ' + options.height + '; ' +
                             //'top: ' + options.top + '; ' +
                             //'margin-left: -' + ((parseInt(options.width, 10) / 2) + options.width.replace(/[0-9]/g, '')) + ';">' +
            
        } else { // if (options.mode === 'constrained')
            strHTML += 'style="max-width: ' + options.max_width + '; width: 94%;">';
        }
        
        strHTML +=      '<gs-page gs-dynamic>' +
                            (options.header ? '<gs-header gs-dynamic>' + strHeader + '</gs-header>' : '') +
                            '<gs-body' + (options.padded ? ' padded' : '') + ' gs-dynamic>' + strContent + '</gs-body>' +
                           (strButtons ? '<gs-footer gs-dynamic>' + strButtons + '</gs-footer>' : '') +
                        '</gs-page>' +
                    '</gs-dialog>';
        
        // append dialog
        dialog = GS.stringToElement(strHTML);
        document.body.appendChild(dialog);
        document.body.parentNode.classList.add('no-scroll-except-for-dialog');
        
        // bind dialog
        dialog.addEventListener('beforeclose', function (event) {
            if (typeof options.before_close === 'function') {
                options.before_close.apply(dialog, [event.originalEvent, event.data]);
            }
        });
        dialog.addEventListener('afterclose', function (event) {
            if (typeof options.after_close === 'function') {
                options.after_close.apply(dialog, [event.originalEvent, event.data]);
            }
        });
        
        
        // focus autofocus element if there is one
        arrElements = xtag.query(dialog, '[autofocus]');
        
        if (arrElements.length > 0) {
            arrElements[0].focus();
            
        // else if there is a listen-for-return: focus that
        } else {
            arrElements = xtag.query(dialog, '[listen-for-return]');
            
            if (arrElements.length > 0) {
                arrElements[0].focus();
            }
        }
        
        // bind listening for return if there is an element with the "listen-for-return"
        arrElements = xtag.query(dialog, '[listen-for-return]');
        
        if (arrElements.length > 0) {
            returnTarget = arrElements[0];
            
            dialog.addEventListener('keydown', function (event) {
                if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                    GS.triggerEvent(returnTarget, 'click');
                }
            });
            
            if (arrElements.length > 1) {
                console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
            }
        }
        
        // if mode is detect: do/bind detection
        if (options.mode === 'detect') {
            sizingFunction = function () {
                if (dialog.parentNode !== document.body) {
                    window.removeEventListener('resize', sizingFunction);
                    window.removeEventListener('orientationchange', sizingFunction);
                    observer.disconnect();
                    
                    return;
                }
                
                // if dialog is taller than 98% of the window: add max-height and height
                if (dialog.offsetHeight > ((window.innerHeight / 100) * 98)) {
                    dialog.style.height = '98%';
                    dialog.style.maxHeight = options.max_height;
                }
            };
            
            sizingFunction();
            
            window.addEventListener('resize', sizingFunction);
            window.addEventListener('orientationchange', sizingFunction);
            
            observer = new MutationObserver(sizingFunction);
            observer.observe(dialog, {childList: true, subtree: true, attributes: true});
        }
        
        // after open function call
        if (typeof options.after_open === 'function') {
            options.after_open.apply(dialog, []);
        }
        
        return dialog;
    };
    
    
    GS.openDialog = function (templateLink, afterOpenFunction, beforeCloseFunction, afterCloseFunction) {
        var template, templateID, strHTML, dialogOverlay, dialog, i, len, arrCloseButtons, clickHandler, sizingFunction,
            observer, arrElements, strTag, returnTarget, strTheme, strMaxWidth, strMaxHeight, strMode, refocusElement,
            scrollTarget, jsnInitalMousePos, scrollProtectorTouchStart, scrollProtectorTouchMove, scrollProtectorMouseWheel,
            strTag, xtagSelector, intervalID, intervalI;
        
        // save and blur currently focused element
        refocusElement = document.activeElement;
        refocusElement.blur();
        
        // get template
        if (typeof templateLink === 'string') {
            template = document.getElementById(templateLink);
        } else {
            template = templateLink;
        }
        
        // save template ID
        templateID = template.getAttribute('id');
        
        // warn if a dialog already uses this ID
        if (templateID && document.getElementById('dialog-from-' + templateID)) {
            console.warn('GS.openDialog Warning: A dialog using the ID "' + templateID + '" is already open.');
        }
        
        // handle autofocus
        arrElements = xtag.query(template.content, '[autofocus]');
        
        // if there are not autofocus elements: add autofocus to first control in the template
        if (arrElements.length === 0) {
            arrElements = xtag.query(template.content, '*');
            
            if (arrElements.length > 0) {
                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    strTag = arrElements[i].nodeName.toLowerCase();
                    
                    if (GS.isElementFocusable(arrElements[i]) ||
                        (
                            xtag.tags[strTag] &&
                            xtag.tags[strTag].methods &&
                            xtag.tags[strTag].methods.focus
                        )) {
                        arrElements[i].setAttribute('autofocus', '');
                        break;
                    }
                }
            }
            
        // warn if there are too many autofocus elements
        } else if (arrElements.length > 1) {
            for (i = 1, len = arrElements.length; i < len; i += 1) {
                arrElements[i].removeAttribute('autofocus');
            }
            
            console.warn('dialog Warning: Too many [autofocus] elements, defaulting to the first one. Please have only one [autofocus] element per dialog.');
        }
        
        // get and default parameters
        strTheme     = (template.getAttribute('data-theme') === 'error' ? 'error' : 'regular');
        strMaxWidth  = template.getAttribute('data-max-width')  || '700px';
        strMaxHeight = template.getAttribute('data-max-height') || '700px';
        strMode      = template.getAttribute('data-mode')       || 'detect'; // phone, touch, constrained, full, detect
        
        // build full dialog html
        strHTML = '<gs-dialog ' + (templateID ? 'id="dialog-from-' + templateID + '" ' : '') + 'class="' + strTheme + '" gs-dynamic ';
        
        // if mode is set to phone or touch and we are not on those types of devices: change mode to detect
        if ((strMode === 'touch' && !evt.touchDevice) || (strMode === 'phone' && evt.deviceType !== 'phone')) {
            strMode = 'detect';
        }
        
        // deal with full page mode
        if ((strMode === 'touch' && evt.touchDevice) || (strMode === 'phone' && evt.deviceType === 'phone') || strMode === 'full') {
            strHTML += 'style="width: 100%; height: 100%; top: 0;">';
            
        } else if (strMode === 'constrained') {
            strHTML += 'style="max-width: ' + strMaxWidth + '; max-height: ' + strMaxHeight + '; width: 94%; height: 90%;">';
            
        } else {
            strHTML += 'style="max-width: ' + strMaxWidth + '; width: 94%;">';
        }
        
        strHTML +=      '<gs-page gs-dynamic>' +
                            template.innerHTML +
                        '</gs-page>' +
                    '</gs-dialog>';
        
        // get elements
        dialogOverlay = GS.stringToElement('<gs-dialog-overlay gs-dynamic></gs-dialog-overlay>');
        dialog = GS.stringToElement(strHTML);
        
        // append overlay element
        document.body.appendChild(dialogOverlay);
        
        // if the template has: data-overlay-close="true": bind overlay
        if (template.getAttribute('data-overlay-close') === 'true') {
            dialogOverlay.addEventListener(evt.mousedown, function (event) {
                GS.closeDialog(dialog, 'overlay');
            });
        }
        
        // bind overlay element
        dialogOverlay.addEventListener(evt.mousedown, function (event) {
            event.preventDefault();
        });
        dialogOverlay.addEventListener(evt.mousemove, function (event) {
            event.preventDefault();
        });
        dialogOverlay.addEventListener('mousewheel', function (event) {
            event.preventDefault();
        });
        
        // append dialog
        document.body.appendChild(dialog);
        //document.body.parentNode.classList.add('no-scroll-except-for-dialog');
        
        // bind dialog
        scrollProtectorTouchStart = function (event) {
            if (dialog.parentNode !== document.body) {
                dialog.removeEventListener('touchstart', scrollProtectorTouchStart);
                return true;
            }
            
            scrollTarget = GS.scrollParent(event.target);
            
            //console.log(scrollTarget);
            
            if (!scrollTarget || !GS.findParentTag(scrollTarget, 'gs-dialog')) {
                scrollTarget = dialog;
            }
            
            //console.log(scrollTarget);
            
            jsnInitalMousePos = GS.mousePosition(event);
        };
        
        scrollProtectorTouchMove = function (event) {
            var jsnMousePos = GS.mousePosition(event), bolVertical, bolHorizontal;
            
            if (dialog.parentNode !== document.body) {
                dialog.removeEventListener('touchmove', scrollProtectorTouchMove);
                return true;
            }
            
            //console.log('2***', scrollTarget, jsnInitalMousePos, jsnMousePos);
            
            if (Math.abs(jsnInitalMousePos.top - jsnMousePos.top) > Math.abs(jsnInitalMousePos.left - jsnMousePos.left)) {
                bolVertical = true;
            } else {
                bolHorizontal = true;
            }
            
            //console.log(bolVertical, bolHorizontal);
            
            // if down  AND we are already at the top
            // if up    AND we are already at the bottom
            // if right AND we are already at the left
            // if left  AND we are already at the right
            
            if ((bolVertical && (
                    (jsnInitalMousePos.top < jsnMousePos.top && scrollTarget.scrollTop <= 0) ||
                    (jsnInitalMousePos.top > jsnMousePos.top &&
                        (scrollTarget.scrollTop + scrollTarget.clientHeight) >= scrollTarget.scrollHeight))) ||
                (bolHorizontal && (
                    (jsnInitalMousePos.left < jsnMousePos.left && scrollTarget.scrollLeft <= 0) ||
                    (jsnInitalMousePos.left > jsnMousePos.left &&
                        (scrollTarget.scrollLeft + scrollTarget.clientWidth) >= scrollTarget.scrollWidth)))) {
                event.preventDefault();
                event.stopPropagation();
            }
        };
        
        scrollProtectorMouseWheel = function (event) {
            var target = GS.scrollParent(event.target); //event.target;
            
            //console.log(target);
            
            if (dialog.parentNode !== document.body) {
                dialog.removeEventListener('mousewheel', scrollProtectorMouseWheel);
                return true;
            }
            
            //console.log(event.deltaY, event.deltaX,
            //            target.scrollTop, target.scrollLeft,
            //            target.scrollHeight, target.scrollWidth,
            //            target.clientHeight, target.clientWidth);
            
            // if event.deltaY < 0 AND we are already at the top
            // if event.deltaY > 0 AND we are already at the bottom
            // if event.deltaX < 0 AND we are already at the left
            // if event.deltaX > 0 AND we are already at the right
            
            if ((event.deltaY < 0 && target.scrollTop <= 0) ||
                (event.deltaY > 0 && (target.scrollTop + target.clientHeight) >= target.scrollHeight) ||
                (event.deltaX < 0 && target.scrollLeft <= 0) ||
                (event.deltaX > 0 && (target.scrollLeft + target.clientWidth) >= target.scrollWidth)) {
                //console.log('prevented');
                
                event.preventDefault();
                event.stopPropagation();
            }
        };
        
        if (evt.touchDevice) {
            window.addEventListener('touchstart', scrollProtectorTouchStart);
            window.addEventListener('touchmove', scrollProtectorTouchMove);
        }
        
        dialog.addEventListener('mousewheel', scrollProtectorMouseWheel);
        
        dialog.addEventListener('beforeclose', function (event) {
            if (typeof beforeCloseFunction === 'function') {
                beforeCloseFunction.apply(dialog, [event.originalEvent, event.data]);
            }
        });
        
        dialog.addEventListener('afterclose', function (event) {
            refocusElement.focus();
            if (typeof afterCloseFunction === 'function') {
                afterCloseFunction.apply(dialog, [event.originalEvent, event.data]);
            }
        });
        
        
        // if mode equals 'detect'
        //console.log(strMode);
        if (strMode === 'detect') {
            // do/bind size detection
            sizingFunction = function () {
                if (dialog.parentNode !== document.body) {
                    window.removeEventListener('resize', sizingFunction);
                    window.removeEventListener('orientationchange', sizingFunction);
                    observer.disconnect();
                    
                    return;
                }
                
                // if dialog is taller than 98% of the window: add max-height and height
                if (dialog.offsetHeight > ((window.innerHeight / 100) * 98)) {
                    dialog.style.height = '98%';
                    dialog.style.maxHeight = strMaxHeight;
                }
            };
            
            sizingFunction();
            
            window.addEventListener('resize', sizingFunction);
            window.addEventListener('orientationchange', sizingFunction);
            
            observer = new MutationObserver(sizingFunction);
            observer.observe(dialog, {childList: true, subtree: true, attributes: true});
        }
        
        
        var elementReadyCallback = function () {
            // focus autofocus element if there is one
            arrElements = xtag.query(dialog, '[autofocus]');
            
            if (arrElements.length > 0) {
                arrElements[0].focus();
                
            // else if there is a listen-for-return: focus that
            } else {
                arrElements = xtag.query(dialog, '[listen-for-return]');
                
                if (arrElements.length > 0) {
                    arrElements[0].focus();
                }
            }
            
            // bind listening for return if there is an element with the "listen-for-return"
            arrElements = xtag.query(dialog, '[listen-for-return]');
            
            if (arrElements.length > 0) {
                returnTarget = arrElements[0];
                
                dialog.addEventListener('keydown', function (event) { // keydown, keyup, keypress
                    if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                        //event.stopPropagation();
                        GS.triggerEvent(returnTarget, 'click');
                    }
                });
                
                if (arrElements.length > 1) {
                    console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
                }
            }
            
            if (typeof afterOpenFunction === 'function') {
                afterOpenFunction.apply(dialog, []);
            }
        };
        
        
        // get a list of all the xtag elements
        // if they are not all instantiated check: on an interval until they are all instantiated
        
        
        // if element registration is shimmed: we need to wait to run the callback
        //      until after the elements are ready. to do this we'll get a list of
        //      the current elements that are xtag-defined and on a 30ms loop we'll
        //      check their __upgraded__ property until they are all true
        if (shimmed.registerElement === true) {
            // build selector to get all xtag elements
            xtagSelector = '';
            for (strTag in xtag.tags) {
                xtagSelector += (xtagSelector ? ',' : '');
                xtagSelector += strTag;
            }
            
            // get all xtag elements
            var elem_wait = xtag.query(dialog, xtagSelector);
            var elem_i;
            var elem_len;
            
            // begin interval (max out at 1 second)
            intervalI = 0;
            intervalID = setInterval(function () {
                if (elem_wait.length === 0 || intervalI >= 30) {
                    clearInterval(intervalID);
                    elementReadyCallback();
                } else {
                    elem_i = 0;
                    elem_len = elem_wait.length;
                    while (elem_i < elem_len) {
                        if (elem_wait[elem_i].__upgraded__ === true) {
                            elem_wait.splice(elem_i, 1);
                            elem_i -= 1;
                            elem_len -= 1;
                        }
                        elem_i += 1;
                    }
                }
                intervalI += 1;
            }, 30);
            
        // else: element instantiation blocks JS execution until the elements
        //      are ready, so we don't need to wait to run the after open callback
        } else {
            elementReadyCallback();
        }
        
        
        //// after open function call
        //if (typeof afterOpenFunction === 'function') {
        //    if (dialog.inserted === true) {
        //        console.log('1***');
        //        afterOpenFunction.apply(dialog, []);
        //    } else {
        //        console.log('2***', new Date().getTime());
        //        dialog.addEventListener('dialog-inserted', function () {
        //            console.log('3***', new Date().getTime());
        //            afterOpenFunction.apply(dialog, []);
        //        });
        //    }
        //    
        //    
        //}
        
        return dialog;
    };
    
    GS.openDialogToElement = function (elementTarget, templateLink, strDirectionRequest, afterOpenFunction, beforeCloseFunction, afterCloseFunction) {
        'use strict';
        var positionHandlingFunction, jsnPositionData, divElement = document.createElement('div'), dialogElement, observer,
            intDialogResolvedWidth, intDialogResolvedHeight, strResolvedDirection, intMargin = 5, intElementMidPoint,
            intDialogMidPoint, i, len, arrTests, arrCloseButtons, clickHandler, arrElements, template, strTheme, strMaxWidth,
            strMaxHeight, strTag, dialogOverlay, refocusElement, jsnInitalMousePos, scrollTarget, returnTarget,
            scrollProtectorTouchStart, scrollProtectorTouchMove, scrollProtectorMouseWheel, templateID,
            strTag, xtagSelector, intervalID, intervalI;
        
        // save and blur currently focused element
        refocusElement = document.activeElement;
        refocusElement.blur();
        
        // get template
        if (typeof templateLink === 'string') {
            template = document.getElementById(templateLink);
        } else {
            template = templateLink;
        }
        
        // save template ID
        templateID = template.getAttribute('id');
        
        // warn if a dialog already uses this ID
        if (templateID && document.getElementById('dialog-from-' + templateID)) {
            console.warn('GS.openDialog Warning: A dialog using the ID "' + templateID + '" is already open.');
        }
        
        // handle autofocus
        arrElements = xtag.query(template.content, '[autofocus]');
        
        // if there are not autofocus elements: add autofocus to first control in the template
        if (arrElements.length === 0) {
            arrElements = xtag.query(template.content, '*');
            
            if (arrElements.length > 0) {
                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    strTag = arrElements[i].nodeName.toLowerCase();
                    
                    if (GS.isElementFocusable(arrElements[i]) ||
                        (
                            xtag.tags[strTag] &&
                            xtag.tags[strTag].methods &&
                            xtag.tags[strTag].methods.focus
                        )) {
                        arrElements[i].setAttribute('autofocus', '');
                        break;
                    }
                }
            }
            
        // warn if there are too many autofocus elements
        } else if (arrElements.length > 1) {
            for (i = 1, len = arrElements.length; i < len; i += 1) {
                arrElements[i].removeAttribute('autofocus');
            }
            
            console.warn('dialog Warning: Too many [autofocus] elements, defaulting to the first one. Please have only one [autofocus] element per dialog.');
        }
        
        // get and default parameters
        strTheme     = (template.getAttribute('data-theme') === 'error' ? 'error' : 'regular');
        strMaxWidth  = template.getAttribute('data-max-width')  || '700px';
        strMaxHeight = template.getAttribute('data-max-height') || '700px';
        
        // create dialog element
        divElement.innerHTML =  '<gs-dialog ' + (templateID ? 'id="dialog-from-' + templateID + '" ' : '') + 'class="' + strTheme + '" style="width: 94%; max-width: ' + strMaxWidth + ';" no-window-listen gs-dynamic>' +
                                    '<gs-page gs-dynamic>' +
                                        template.innerHTML +
                                    '</gs-page>' +
                                '</gs-dialog>';
        
        dialogElement = divElement.children[0];
        
        // append dialog overlay element to the body
        dialogOverlay = GS.stringToElement('<gs-dialog-overlay gs-dynamic></gs-dialog-overlay>');
        document.body.appendChild(dialogOverlay);
        
        // if the template has: data-overlay-close="true": bind overlay
        if (template.getAttribute('data-overlay-close') === 'true') {
            dialogOverlay.addEventListener('click', function (event) {
                GS.closeDialog(dialogElement, 'overlay');
            });
        }
        
        // bind dialog overlay
        dialogOverlay.addEventListener('mousewheel', function (event) {
            event.preventDefault();
        });
        
        // append dialog element to the body
        document.body.appendChild(dialogElement);
        
        // bind dialog
        scrollProtectorTouchStart = function (event) {
            if (dialogElement.parentNode !== document.body) {
                dialogElement.removeEventListener('touchstart', scrollProtectorTouchStart);
                return true;
            }
            
            scrollTarget = GS.scrollParent(event.target);
            
            //console.log(scrollTarget);
            
            if (!scrollTarget || !GS.findParentTag(scrollTarget, 'gs-dialog')) {
                scrollTarget = dialogElement;
            }
            
            //console.log(scrollTarget);
            
            jsnInitalMousePos = GS.mousePosition(event);
        };
        
        scrollProtectorTouchMove = function (event) {
            var jsnMousePos = GS.mousePosition(event), bolVertical, bolHorizontal;
            
            if (dialogElement.parentNode !== document.body) {
                dialogElement.removeEventListener('touchmove', scrollProtectorTouchMove);
                return true;
            }
            
            //console.log('2***', scrollTarget, jsnInitalMousePos, jsnMousePos);
            
            if (Math.abs(jsnInitalMousePos.top - jsnMousePos.top) > Math.abs(jsnInitalMousePos.left - jsnMousePos.left)) {
                bolVertical = true;
            } else {
                bolHorizontal = true;
            }
            
            //console.log(bolVertical, bolHorizontal);
            
            // if down  AND we are already at the top
            // if up    AND we are already at the bottom
            // if right AND we are already at the left
            // if left  AND we are already at the right
            
            if ((bolVertical && (
                    (jsnInitalMousePos.top < jsnMousePos.top && scrollTarget.scrollTop <= 0) ||
                    (jsnInitalMousePos.top > jsnMousePos.top &&
                        (scrollTarget.scrollTop + scrollTarget.clientHeight) >= scrollTarget.scrollHeight))) ||
                (bolHorizontal && (
                    (jsnInitalMousePos.left < jsnMousePos.left && scrollTarget.scrollLeft <= 0) ||
                    (jsnInitalMousePos.left > jsnMousePos.left &&
                        (scrollTarget.scrollLeft + scrollTarget.clientWidth) >= scrollTarget.scrollWidth)))) {
                event.preventDefault();
                event.stopPropagation();
            }
        };
        
        scrollProtectorMouseWheel = function (event) {
            var target = GS.scrollParent(event.target); //event.target;
            
            if (dialogElement.parentNode !== document.body) {
                dialogElement.removeEventListener('mousewheel', scrollProtectorMouseWheel);
                return true;
            }
            
            //console.log(event.deltaY, event.deltaX,
            //            target.scrollTop, target.scrollLeft,
            //            target.scrollHeight, target.scrollWidth,
            //            target.clientHeight, target.clientWidth);
            
            // if event.deltaY < 0 AND we are already at the top
            // if event.deltaY > 0 AND we are already at the bottom
            // if event.deltaX < 0 AND we are already at the left
            // if event.deltaX > 0 AND we are already at the right
            
            if ((event.deltaY < 0 && target.scrollTop <= 0) ||
                (event.deltaY > 0 && (target.scrollTop + target.clientHeight) >= target.scrollHeight) ||
                (event.deltaX < 0 && target.scrollLeft <= 0) ||
                (event.deltaX > 0 && (target.scrollLeft + target.clientWidth) >= target.scrollWidth)) {
                event.preventDefault();
                event.stopPropagation();
            }
        };
        
        if (evt.touchDevice) {
            window.addEventListener('touchstart', scrollProtectorTouchStart);
            window.addEventListener('touchmove', scrollProtectorTouchMove);
        }
        
        dialogElement.addEventListener('mousewheel', scrollProtectorMouseWheel);
        
        dialogElement.addEventListener('beforeclose', function (event) {
            if (typeof beforeCloseFunction === 'function') {
                beforeCloseFunction.apply(dialogElement, [event.originalEvent, event.data]);
            }
        });
        dialogElement.addEventListener('afterclose', function (event) {
            refocusElement.focus();
            if (typeof afterCloseFunction === 'function') {
                afterCloseFunction.apply(dialogElement, [event.originalEvent, event.data]);
            }
        });
        
        // focus autofocus element if there is one
        arrElements = xtag.query(dialogElement, '[autofocus]');
        
        if (arrElements.length > 0) {
            arrElements[0].focus();
            
        // else if there is a listen-for-return: focus that
        } else {
            arrElements = xtag.query(dialogElement, '[listen-for-return]');
            
            if (arrElements.length > 0) {
                arrElements[0].focus();
            }
        }
        
        // bind listening for return if there is an element with the "listen-for-return"
        arrElements = xtag.query(dialogElement, '[listen-for-return]');
        
        if (arrElements.length > 0) {
            returnTarget = arrElements[0];
            
            dialogElement.addEventListener('keydown', function (event) {
                if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                    GS.triggerEvent(returnTarget, 'click');
                }
            });
            
            if (arrElements.length > 1) {
                console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
            }
        }
        
        // if no direction was sent: set direction to down
        strDirectionRequest = strDirectionRequest || 'down';
        
        // make strDirectionRequest lowercase
        strDirectionRequest.toLowerCase();
        
        // if the direction does not match any valid direction: set direction to down and warn
        if (!strDirectionRequest.match(/^up$|^down$|^left$|^right$|^full$/)) {
            console.warn('GS.openDialogToElement Error: ' +
                                'Direction \'' + strDirectionRequest + '\' not recognized. ' +
                                'Please use \'up\', \'down\', \'left\', \'right\' or \'full\'.');
            strDirectionRequest = 'down';
        }
        
        positionHandlingFunction = function () {
            var intDialogTop = '', intDialogLeft = '', intDialogMarginTop = '', intDialogMarginLeft = '', strOldStyle,
                arrElements, arrScrollingElements, i, len, strOverflow;
            
            // if the dialog is not in the DOM: unbind and skip the contents of the function using return
            if (dialogElement.parentNode !== document.body) {
                window.removeEventListener('resize', positionHandlingFunction);
                window.removeEventListener('orientationchange', positionHandlingFunction);
                observer.disconnect();
                return;
            }
            
            // save old style attribute
            strOldStyle = dialogElement.getAttribute('style');
            
            // save scroll numbers
            arrElements = xtag.query(dialogElement, '*');
            arrScrollingElements = [];
            
            for (i = 0, len = arrElements.length; i < len; i += 1) {
                strOverflow = GS.getStyle(arrElements[i], 'overflow');
                
                if (strOverflow === 'scroll' ||
                    (strOverflow === 'auto' && arrElements[i].clientHeight < arrElements[i].scrollHeight)) {
                    arrScrollingElements.push(arrElements[i]);
                }
            }
            
            for (i = 0, len = arrScrollingElements.length; i < len; i += 1) {
                arrScrollingElements[i].oldScrollTop = arrScrollingElements[i].scrollTop;
                arrScrollingElements[i].oldScrollLeft = arrScrollingElements[i].scrollLeft;
            }
            
            // clear dialog CSS
            dialogElement.style.top        = '';
            dialogElement.style.left       = '';
            dialogElement.style.marginTop  = '';
            dialogElement.style.marginLeft = '';
            dialogElement.style.width      = '94%';
            dialogElement.style.height     = '';
            dialogElement.style.maxHeight  = '';
            
            //console.log(dialogElement.oldHeight, dialogElement.offsetHeight);
            
            // if height hasn't changed: restore style
            if (dialogElement.oldHeight === dialogElement.offsetHeight) {
                dialogElement.setAttribute('style', strOldStyle);
                
                for (i = 0, len = arrScrollingElements.length; i < len; i += 1) {
                    arrScrollingElements[i].scrollTop = arrScrollingElements[i].oldScrollTop;
                    arrScrollingElements[i].scrollLeft = arrScrollingElements[i].oldScrollLeft;
                }
                
            // else: recalculate style
            } else {
                dialogElement.oldHeight = dialogElement.offsetHeight;
                
                // resolve dialog width and height
                
                // if dialog is taller than: window height - (intMargin * 2): add max-height and height
                if (dialogElement.clientHeight > ((window.innerHeight / 100) * 94)) {
                    dialogElement.style.height = '94%';
                    dialogElement.style.maxHeight = strMaxHeight;
                }
                
                intDialogResolvedWidth  = dialogElement.offsetWidth;
                intDialogResolvedHeight = dialogElement.offsetHeight + 1; // + 1 added to fix occasional scrollbar issue
                
                // set dialog width and height to resolved width and height
                dialogElement.style.width  = intDialogResolvedWidth  + 'px';
                dialogElement.style.height = intDialogResolvedHeight + 'px';
                
                // get target position data
                jsnPositionData = GS.getElementPositionData(elementTarget);
                
                // order of tests depending on direction
                if (strDirectionRequest === 'up') { // up: up, down, left, right, full
                    arrTests = ['up', 'down', 'left', 'right'];
                    
                } else if (strDirectionRequest === 'down') { // down: down, up, left, right, full
                    arrTests = ['down', 'up', 'left', 'right'];
                    
                } else if (strDirectionRequest === 'left') { // left: left, right, down, up, full
                    arrTests = ['left', 'right', 'down', 'up'];
                    
                } else if (strDirectionRequest === 'right') { // right: right, left, down, up, full
                    arrTests = ['right', 'left', 'down', 'up'];
                    
                } else { // full: no tests (just go to full)
                    arrTests = [];
                }
                
                // up: compare room above to dialog resolved height
                //      pass: display
                //      fail: next test
                for (i = 0, len = arrTests.length; i < len; i += 1) {
                    if ((arrTests[i] ===    'up' && (intDialogResolvedHeight + intMargin) <= jsnPositionData.intRoomAbove) ||
                        (arrTests[i] ===  'down' && (intDialogResolvedHeight + intMargin) <= jsnPositionData.intRoomBelow) ||
                        (arrTests[i] ===  'left' && (intDialogResolvedWidth  + intMargin) <=  jsnPositionData.intRoomLeft) ||
                        (arrTests[i] === 'right' && (intDialogResolvedWidth  + intMargin) <= jsnPositionData.intRoomRight)) {
                        strResolvedDirection = arrTests[i];
                        break;
                    }
                }
                
                // if we could not resolve to a particular direction: set direction to full screen
                strResolvedDirection = strResolvedDirection || 'full';
                //console.log(strResolvedDirection);
                
                // if up or down: get as close to horizontally centered on the element as possible
                if (strResolvedDirection === 'up' || strResolvedDirection === 'down') {
                    intElementMidPoint = (jsnPositionData.intElementLeft + (jsnPositionData.intElementWidth / 2));
                    intDialogMidPoint = (intDialogResolvedWidth / 2);
                    //console.log(intElementMidPoint, jsnPositionData.left, jsnPositionData.intElementWidth);
                    
                    // if centered goes past intMargin of the left edge of the screen: go to intMargin from the bottom
                    if (intElementMidPoint - intDialogMidPoint < intMargin) {
                        intDialogLeft = intMargin;
                        //console.log('1***', intMargin);
                        
                    // else if centered goes past intMargin of the right edge of the screen: go to intMargin less than the width of the viewport
                    } else if (intElementMidPoint + intDialogMidPoint > window.innerWidth - intMargin) {
                        intDialogLeft = ((window.innerWidth - intDialogResolvedWidth) - intMargin);
                        //console.log('2***', window.innerWidth, intDialogResolvedWidth, intMargin);
                        
                    // else centered does not go past intMargin of either edge of the screen: center
                    } else {
                        intDialogLeft = (intElementMidPoint - intDialogMidPoint);
                        //console.log('3***', intElementMidPoint, intDialogMidPoint, (intElementMidPoint - intDialogMidPoint) + 'px');
                    }
                    
                // else if left or right: get as close to vertically centered next to the element as possible
                } else if (strResolvedDirection === 'left' || strResolvedDirection === 'right') {
                    intElementMidPoint = (jsnPositionData.intElementTop + (jsnPositionData.intElementHeight / 2));
                    intDialogMidPoint = (intDialogResolvedHeight / 2);
                    
                    //console.log('0***', intElementMidPoint, intDialogMidPoint, window.innerHeight, intMargin, intDialogResolvedHeight);
                    
                    // if centered goes past intMargin of the top edge of the screen: go to intMargin from the bottom
                    if (intElementMidPoint - intDialogMidPoint < intMargin) {
                        intDialogTop = intMargin;
                        //console.log('1***', intMargin);
                        
                    // else if centered goes past intMargin of the bottom edge of the screen: go to intMargin less than the height of the viewport
                    } else if (intElementMidPoint + intDialogMidPoint > window.innerHeight - intMargin) {
                        intDialogTop = ((window.innerHeight - intDialogResolvedHeight) - intMargin);
                        //console.log('2***', window.innerHeight, intDialogResolvedHeight, intMargin);
                        
                    // else centered does not go past intMargin of either edge of the screen: center
                    } else {
                        intDialogTop = (intElementMidPoint - intDialogMidPoint);
                        //console.log('3***', intElementMidPoint, intDialogMidPoint, (intElementMidPoint - intDialogMidPoint) + 'px');
                    }
                    
                // else full: use dialog logic to get width and height and center both vertically and horizontally
                } else {
                    intDialogTop        = '50%';
                    intDialogLeft       = '50%';
                    intDialogMarginTop  = '-' + (intDialogResolvedHeight / 2) + 'px';
                    intDialogMarginLeft = '-' + (intDialogResolvedWidth / 2) + 'px';
                }
                
                // if direction is up: connect the bottom of the dialog to the top of the element
                if (strResolvedDirection === 'up') {
                    intDialogTop = (jsnPositionData.intElementTop - intDialogResolvedHeight);
                    
                // if direction is down: connect the top of the dialog to the bottom of the element
                } else if (strResolvedDirection === 'down') {
                    intDialogTop = (jsnPositionData.intElementTop + jsnPositionData.intElementHeight);
                    
                // if direction is left: connect the right of the dialog to the left of the element
                } else if (strResolvedDirection === 'left') {
                    intDialogLeft = (jsnPositionData.intElementLeft - intDialogResolvedWidth);
                    
                // if direction is right: connect the left of the dialog to the right of the element
                } else if (strResolvedDirection === 'right') {
                    intDialogLeft = (jsnPositionData.intElementLeft + jsnPositionData.intElementWidth);
                }
                
                // prevent the dialog from vertically going outside the viewport
                if (intDialogTop + intDialogResolvedHeight > window.innerHeight) {
                    intDialogTop -= (intDialogTop + intDialogResolvedHeight) - window.innerHeight;
                    
                }
                
                // prevent the dialog from horizontally going outside the viewport
                if (intDialogLeft + intDialogResolvedWidth > window.innerWidth) {
                    intDialogLeft -= (intDialogLeft + intDialogResolvedWidth) - window.innerWidth;
                }
                
                // apply CSS to the dialog
                dialogElement.style.top        = intDialogTop + 'px';
                dialogElement.style.left       = intDialogLeft + 'px';
                dialogElement.style.marginTop  = intDialogMarginTop + 'px';
                dialogElement.style.marginLeft = intDialogMarginLeft + 'px';
            }
        };
        
        positionHandlingFunction();
        window.addEventListener('resize', positionHandlingFunction);
        window.addEventListener('orientationchange', positionHandlingFunction);
        
        // observer: on childlist update: recalculate positioning/sizing
        observer = new MutationObserver(positionHandlingFunction);
        
        // the observer is on "dialogElement.children[0]" because when we refresh the position of the dialog:
        //      the "style" attribute is changed which causes the observer to run again ergo: infinite loop
        observer.observe(dialogElement.children[0], {childList: true, subtree: true, attributes: true});
        
        
        var elementReadyCallback = function () {
            // focus autofocus element if there is one
            arrElements = xtag.query(dialogElement, '[autofocus]');
            
            if (arrElements.length > 0) {
                arrElements[0].focus();
                
            // else if there is a listen-for-return: focus that
            } else {
                arrElements = xtag.query(dialogElement, '[listen-for-return]');
                
                if (arrElements.length > 0) {
                    arrElements[0].focus();
                }
            }
            
            // bind listening for return if there is an element with the "listen-for-return"
            arrElements = xtag.query(dialogElement, '[listen-for-return]');
            
            if (arrElements.length > 0) {
                returnTarget = arrElements[0];
                
                dialogElement.addEventListener('keydown', function (event) { // keydown, keyup, keypress
                    if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                        //event.stopPropagation();
                        GS.triggerEvent(returnTarget, 'click');
                    }
                });
                
                if (arrElements.length > 1) {
                    console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
                }
            }
            
            if (typeof afterOpenFunction === 'function') {
                afterOpenFunction.apply(dialogElement, []);
            }
        };
        
        // if element registration is shimmed: we need to wait to run the callback
        //      until after the elements are ready. to do this we'll get a list of
        //      the current elements that are xtag-defined and on a 30ms loop we'll
        //      check their __upgraded__ property until they are all true
        if (shimmed.registerElement === true) {
            // build selector to get all xtag elements
            xtagSelector = '';
            for (strTag in xtag.tags) {
                xtagSelector += (xtagSelector ? ',' : '');
                xtagSelector += strTag;
            }
            
            // get all xtag elements
            var elem_wait = xtag.query(dialogElement, xtagSelector);
            var elem_i;
            var elem_len;
            
            // begin interval (max out at 1 second)
            intervalI = 0;
            intervalID = setInterval(function () {
                if (elem_wait.length === 0 || intervalI >= 30) {
                    clearInterval(intervalID);
                    elementReadyCallback();
                } else {
                    elem_i = 0;
                    elem_len = elem_wait.length;
                    while (elem_i < elem_len) {
                        if (elem_wait[elem_i].__upgraded__ === true) {
                            elem_wait.splice(elem_i, 1);
                            elem_i -= 1;
                            elem_len -= 1;
                        }
                        elem_i += 1;
                    }
                }
                intervalI += 1;
            }, 30);
            
        // else: element instantiation blocks JS execution until the elements
        //      are ready, so we don't need to wait to run the after open callback
        } else {
            elementReadyCallback();
        }
        
        //// after open function call
        //if (typeof afterOpenFunction === 'function') {
        //    afterOpenFunction.apply(dialogElement, []);
        //}
        
        return dialogElement;
    };
})();

(function () {
    'use strict';
    
    xtag.register('gs-dialog', {
        lifecycle: {
            created: function () {
                document.body.focus();
                
                //document.body.parentNode.classList.add('no-scroll-except-for-dialog');
            },
            
            inserted: function () {
                if (this.inserted !== true) {
                    this.inserted = true;
                    
                    if (!this.hasAttribute('no-window-listen')) {
                        this.bind();
                        
                        this.windowResizeHandler();
                    }
                    
                    GS.triggerEvent(this, 'dialog-inserted');
                }
            },
            
            removed: function () {
                this.unbind();
            }
        },
        events: {
            'click:delegate([dialogclose])': function (event) {
                var dialogcloseElement = GS.findParentElement(event.target, '[dialogclose]');
                
                GS.findParentTag(event.target, 'gs-dialog')
                        .destroy(dialogcloseElement.textContent, event);
            }
        },
        accessors: {},
        methods: {
            bind: function () {
                var element = this;
                
                if (!element.hasAttribute('no-window-listen')) {
                    element.windowResizeHandler = function () {
                        element.style.left = (window.innerWidth / 2) - (element.offsetWidth / 2) + 'px';
                    };
                    
                    window.addEventListener('resize', element.windowResizeHandler);
                    window.addEventListener('orientationchange', element.windowResizeHandler);
                }
            },
            
            unbind: function () {
                window.removeEventListener('resize', this.windowResizeHandler);
                window.removeEventListener('orientationchange', this.windowResizeHandler);
                
                GS.triggerEvent(window, 'resize');
            },
            
            destroy: function (strAnswer, originalEvent) {
                var beforeCloseEvent;
                
                if (this.parentNode === document.body) {
                    beforeCloseEvent = GS.triggerEvent(this, 'beforeclose', {'data': strAnswer, 'originalEvent': originalEvent});
                    
                    if (!beforeCloseEvent.defaultPrevented && (!originalEvent || !originalEvent.defaultPrevented)) {
                        document.body.removeChild(this.previousElementSibling);
                        document.body.removeChild(this);
                        
                        GS.triggerEvent(this, 'afterclose', {'data': strAnswer, 'originalEvent': originalEvent});
                        
                        if (document.getElementsByTagName('gs-dialog').length === 0) {
                            document.body.parentNode.classList.remove('no-scroll-except-for-dialog');
                        }
                    }
                }
            }
        }
    });
    
    xtag.register('gs-dialog-overlay', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
})();window.addEventListener('design-register-element', function (event) {
    'use strict';
    
    registerDesignSnippet('<gs-envelope>', '<gs-envelope>', 'gs-envelope src="${1:test.tpeople}">\n' +
                                                            '    <template for="hud"></template>\n' +
                                                            '    <template for="table">\n' +
                                                            '        <table>\n' +
                                                            '            <tbody>\n' +
                                                            '                <tr>\n' +
                                                            '                    <th heading="#"><gs-static column="row_number"></gs-static></th>\n' +
                                                            '                    <td heading="">$0</td>\n' +
                                                            '                </tr>\n' +
                                                            '            </tbody>\n' +
                                                            '        </table>\n' +
                                                            '    </template>\n' +
                                                            '    <template for="insert"></template>\n' +
                                                            '</gs-envelope>');
    
    designRegisterElement('gs-envelope', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-envelope.html');
    
    window.designElementProperty_GSENVELOPE = function (selectedElement) {
        var intIdNumber = (Math.floor(Math.random() * 1000)) + (Math.floor(new Date().getTime() / (Math.random() * 100000)));
        
        addProp('Source', true,
                '<gs-memo class="target" autoresize rows="1" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('src') ||
                                                                        selectedElement.getAttribute('source') || '')) + '" mini></gs-memo>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
        });
        
        addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
        });
        
        addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('where') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'where', this.value);
        });
        
        addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
        });
        
        addProp('Limit', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
        });
        
        addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
        });
        
        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });
        
        addProp('Parent&nbsp;Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });
        
        addProp('Line Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('child-column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'child-column', this.value);
        });
        
        addProp('Reflow At', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('reflow-at') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'reflow-at', this.value);
        });
        
        addProp('Scroll To Bottom', true, '<gs-checkbox class="target" value="' + encodeHTML(selectedElement.hasAttribute('scroll-to-bottom') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'scroll-to-bottom', (this.value === 'true'), true);
        });
        
        addProp('HUD Orderby', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudorderby')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-hudorderby', (this.value === 'true'), false);
        });
        
        addProp('HUD Limit', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudlimit')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-hudlimit', (this.value === 'true'), false);
        });
        
        addProp('HUD Refresh', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudrefresh')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-hudrefresh', (this.value === 'true'), false);
        });
        
        addProp('HUD Delete', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-huddelete')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-huddelete', (this.value === 'true'), false);
        });
        
        addProp('Expand&nbsp;To&nbsp;Content', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('expand-to-content')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'expand-to-content', (this.value === 'true'), true);
        });
        
        addProp('Primary Keys', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('primary-keys') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'primary-keys', this.value);
        });
        
        addProp('Select Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-select') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'action-select', this.value);
        });
        
        addProp('Insert Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-insert') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'action-insert', this.value);
        });
        
        addProp('Update Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-update') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'action-update', this.value);
        });
        
        addProp('Delete Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-delete') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'action-delete', this.value);
        });
        
        // Disable insert/update
        addProp('Disable Insert', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-insert') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-insert', this.value === 'true', true);
        });
        
        addProp('Disable Update', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-update') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-update', this.value === 'true', true);
        });
        
        // TEMPLATE attribute
        addProp('Record Template', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('template') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'template', this.value);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
            this.removeAttribute('refresh-on-querystring-change');
            return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
        });
        
        addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
            this.removeAttribute('refresh-on-querystring-values');
            return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
        });
        
        //// SUSPEND-CREATED attribute
        //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
        //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        //});
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    // ####################################################################
    // ############################## LOADER ##############################
    // ####################################################################
    
    function addLoader(element, strText) {
        element.loaderContainer = GS.stringToElement('<div class="loader-container" style="top: ' + element.scrollContainerElement.scrollTop + 'px;"></div>');
        element.scrollContainerElement.appendChild(element.loaderContainer);
        
        GS.addLoader(element.loaderContainer, strText);
    }
    
    function removeLoader(element) {
        if (element.loaderContainer && element.loaderContainer.parentNode === element.scrollContainerElement) {
            element.scrollContainerElement.removeChild(element.loaderContainer);
        }
        GS.removeLoader(element.loaderContainer);
    }
    
    // ###################################################################
    // ########################## DRAG HANDLING ##########################
    // ###################################################################
    
    function selectHandler(element, dragOrigin, dragCurrentCell, dragMode) {
        var bolThead, bolFirstTh, arrRecords, arrCells, arrRecordsToAffect = [], arrCellsToAffect = [],
            arrNewSelection = [], arrCellsToRemoveFromSelection = [], i, len, intFrom, intTo;
        
        arrRecords = xtag.query(element.scrollContainerElement, 'tr');
        arrCells = xtag.query(element.scrollContainerElement, 'td, th');
        
        if (arrRecords.length > 0) {
            bolThead = Boolean(element.theadElement);
            
            if ((bolThead && arrRecords.length > 1) || (!bolThead && arrRecords > 0)) {
                if (bolThead) {
                    bolFirstTh = arrRecords[1].children[0].nodeName === 'TH';
                } else {
                    bolFirstTh = arrRecords[0].children[0].nodeName === 'TH';
                }
            }
            
            // if origin & currentCell are both the top-left cell and the cell is a heading: select all cells
            if (bolThead && bolFirstTh &&
                dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0 &&
                dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                arrCellsToAffect = arrCells;
                
            // else if origin & currentCell are both first ths: select the records from origin to currentCell
            } else if (bolFirstTh && dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                arrRecordsToAffect =
                    arrRecords.slice(Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                                     Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1);
                
                for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
                }
                
            // else if origin & currentCell are both headings: select the columns from origin to currentCell
            } else if (bolThead && dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0) {
                intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                intTo   = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;
                
                for (i = 0, len = arrRecords.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecords[i].children).slice(intFrom, intTo));
                }
                
            //// else if origin & currentCell are the same cell: select the record
            //} else if (dragOrigin === dragCurrentCell) {
            //    arrRecordsToAffect = arrRecords.slice(dragOrigin.parentNode.rowIndex, dragOrigin.parentNode.rowIndex + 1);
            //    
            //    for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
            //        Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
            //    }
                
            // else select cells from origin to currentCell
            } else {
                arrRecordsToAffect =
                    arrRecords.slice(Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                                     Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1);
                
                intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                intTo   = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;
                
                for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children).slice(intFrom, intTo));
                }
            }
            
            if (dragOrigin !== dragCurrentCell) {
                element.scrollContainerElement.removeAttribute('allow-text-selection');
                element.copyFocusTargetElement.focus();
                GS.setInputSelection(element.copyFocusTargetElement, 0, 'firefox...'.length);
            } else {
                element.scrollContainerElement.setAttribute('allow-text-selection', '');
            }
            
            if (dragMode === 'select') {
                
                // add new cells to element.selectionSelectedCells
                for (i = 0, len = element.selectionSelectedCells.length; i < len; i += 1) {
                    if (arrCellsToAffect.indexOf(element.selectionSelectedCells[i]) === -1) {
                        arrCellsToRemoveFromSelection.push(element.selectionSelectedCells[i]);
                    }
                }
                element.selectionSelectedCells = arrCellsToAffect;
                
                // add new cells to element.selectedCells
                arrNewSelection = element.selectedCells;
                for (i = 0, len = arrCellsToAffect.length; i < len; i += 1) {
                    GS.listAdd(arrNewSelection, arrCellsToAffect[i]);
                }
                for (i = 0, len = arrCellsToRemoveFromSelection.length; i < len; i += 1) {
                    arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToRemoveFromSelection[i]), 1);
                }
                element.selectedCells = arrNewSelection;
                
                //element.selectionSelectedCells = arrCellsToAffect;
                //element.selectedCells = arrCellsToAffect;
                
            } else { // implied if: dragMode === 'deselect'
                // deselect cells from arrCellsToAffect
                arrNewSelection = element.selectedCells;
                
                for (i = 0, len = arrCellsToAffect.length; i < len; i += 1) {
                    if (arrNewSelection.indexOf(arrCellsToAffect[i]) > -1) {
                        arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToAffect[i]), 1);
                    }
                }
                element.selectedCells = arrNewSelection;
            }
        }
    }
    
    // #######################################################################
    // ############################ DATA HANDLING ############################
    // #######################################################################
    
    
    // get data and send it off to be templated
    function getData(element) {
        var data, strLink, strOrderBy = '', strWhere, strWhereColumn, strSelectAction,
            strWhereAttribute = GS.templateWithQuerystring((element.getAttribute('where') || '')),
            strSource = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') ||
                                                                    element.getAttribute('source') || '')),
            strCols = GS.templateWithQuerystring(element.getAttribute('cols') || ''), callbackFunction, i, len;
        
        strLink = '/' + (element.getAttribute('action-select') || 'env/action_select') + '?src=' + encodeURIComponent(strSource);
        
        // if there is a column attribute on element element: combine the where attribute with a where generated by value
        if ((element.getAttribute('column') || element.getAttribute('qs')) && element.value) {
            strWhereColumn = element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs');
            
            if (isNaN(element.value)) {
                strWhere =  'CAST(' + strWhereColumn + ' AS ' + GS.database.type.text + ') = ' +
                            'CAST($WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')' +
                            (strWhereAttribute !== '' ? ' AND (' + strWhereAttribute + ')' : '');
            } else {
                strWhere = strWhereColumn + '=' + (element.value) + (strWhereAttribute !== '' ? ' AND (' + strWhereAttribute + ')' : '');
            }
            
        // else: just use the where attribute
        } else {
            strWhere = strWhereAttribute;
        }
        
        // if the user has set an order by: use the user order bys
        if (element.user_order_bys && element.user_order_bys.columns.length > 0) {
            for (i = 0, len = element.user_order_bys.columns.length, strOrderBy = ''; i < len; i += 1) {
                strOrderBy += (strOrderBy !== '' ? ', ' : '') + element.user_order_bys.columns[i] + ' ' + element.user_order_bys.directions[i].toUpperCase();
            }
            
        // else: use the order by attribute
        } else {
            strOrderBy = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('ord') || ''));
        }
        
        //console.log(strOrderBy);
        
        // append the rest of the parameters to the link
        strLink += '&where='    + encodeURIComponent(strWhere) +
                   '&limit='    + encodeURIComponent(GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('limit') || ''))) +
                   '&offset='   + encodeURIComponent(GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('offset') || ''))) +
                   '&order_by=' + encodeURIComponent(strOrderBy) +
                   '&cols='     + encodeURIComponent(strCols);
        
        // save the old scrolltop (so that we can scroll back to it)
        element.oldScrollTop = element.scrollContainerElement.scrollTop;
        
        //// clear out scroll container element
        //element.scrollContainerElement.innerHTML = '';
        
        //// hide fixed header container
        //element.fixedHeaderContainerElement.style.display = 'none';
        
        // get the data
        GS.dataFetch(strLink, true);
        
        callbackFunction = function (event) {
            //// show fixed header container
            //element.fixedHeaderContainerElement.style.display = '';
            
            //GS.addLoader('envelope-select', 'Loading...');
            
            // send data to data handler function
            //console.log('test');
            handleData(element, event.detail.response, event.detail.error);
            
            // remove loader
            removeLoader(element);
            
            // remove this listener
            document.removeEventListener('dataready_' + encodeURIComponent(strLink), callbackFunction);
        };
        
        addLoader(element, 'Loading...');
        document.addEventListener('dataready_' + encodeURIComponent(strLink), callbackFunction);
    }
    
    function handleData(element, data, error) {
        var strHeaderHTML, strFixedHeaderHTML, tableElement, theadElement, tbodyElement,
            strBodyHTML, tableTemplateElement, arrCells, i, len,
            bolHeaderTextFound = false, strCurrentHeadingText, bolInitalSuccess;
        
        if (!error) {
            bolInitalSuccess = !element.lastSuccessData;
            
            // remove old error class
            element.classList.remove('error');
            
            // save data
            element.lastSuccessData = data;
            
            // create HTMl for header
            tableTemplateElement = document.createElement('template');
            tableTemplateElement.innerHTML = element.tableTemplate;
            
            tableElement = xtag.query(tableTemplateElement.content, 'table')[0];
            theadElement = xtag.queryChildren(tableElement, 'thead')[0];
            tbodyElement = xtag.queryChildren(tableElement, 'tbody')[0];
            
            // if there is a limit button
            if (element.limitButtonElement) {
                element.limitButtonElement.textContent = data.dat.length + ' of ' + data.row_count;
                element.limitButtonElement.setAttribute('class', 'row_count_btn');
            }
            
            //console.log(tableTemplateElement, element.tableTemplate, theadElement, tbodyElement);
            
            if (!theadElement) {
                arrCells = tbodyElement.getElementsByTagName('tr')[0].children;
                
                for (i = 0, len = arrCells.length, strHeaderHTML = '', strFixedHeaderHTML = ''; i < len; i += 1) {
                    strCurrentHeadingText = encodeHTML(GS.templateWithQuerystring(arrCells[i].getAttribute('heading') || ''));
                    
                    if (strCurrentHeadingText) {
                        bolHeaderTextFound = true;
                    }
                    
                    strHeaderHTML += '<th gs-dynamic>' + strCurrentHeadingText + '</th>';
                    strFixedHeaderHTML += '<div class="fixed-header-cell" gs-dynamic>' + strCurrentHeadingText + '</div>';
                }
                
                if (bolHeaderTextFound) {
                    strHeaderHTML = '<thead gs-dynamic><tr gs-dynamic>' + strHeaderHTML + '</tr></thead>';
                    
                } else {
                    strHeaderHTML = '';
                    strFixedHeaderHTML = '';
                }
            } else {
                strHeaderHTML = theadElement.outerHTML;
                arrCells = theadElement.getElementsByTagName('tr')[0].children;
                
                for (i = 0, len = arrCells.length, strFixedHeaderHTML = ''; i < len; i += 1) {
                    strFixedHeaderHTML += '<div class="fixed-header-cell" gs-dynamic>' + encodeHTML(arrCells[i].textContent || '') + '</div>';
                }
            }
            
            element.fixedHeaderContainerElement.innerHTML = strFixedHeaderHTML;
            
            // create HTMl for body using the templated data
            strBodyHTML = '<tbody gs-dynamic>' + dataTemplateRecords(element, data) + '</tbody>';
            
            
            
            // this following observer code was added so that firefox would adjust it's headers at the right time
            //      I belive that the problem firefox had was that comboboxes were changing their width after
            //      refreshFixedHeader was being called, so this observer will call it after the childlist of the
            //      scrollcontainer changes
            // if there is already an observer: disconnect it
            if (element.headerRefreshObserver) {
                element.headerRefreshObserver.disconnect();
                element.headerRefreshObserver = undefined;
            }
            
            // fixed header mutation observer
            element.headerRefreshObserver = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    //console.log('1***');
                    element.refreshFixedHeader();
                });    
            });
            
            // pass in the target node, as well as the observer options
            element.headerRefreshObserver.observe(element.scrollContainerElement, {'childList': true});
            
            
            // set scroll container html
            element.scrollContainerElement.innerHTML = '<table gs-dynamic>' +
                                                        strHeaderHTML +
                                                        strBodyHTML +
                                                    '</table>';
            
            element.theadElement = xtag.query(element.scrollContainerElement, 'thead')[0];
            element.tbodyElement = xtag.query(element.scrollContainerElement, 'tbody')[0];
            
            element.refreshFixedHeader();
            
            // refresh height and reflow status
            element.refreshHeight();
            element.refreshReflow();
            
            // set scrolltop to the old scrolltop
            element.scrollContainerElement.scrollTop = element.oldScrollTop;
            
            if (element.hasAttribute('scroll-to-bottom')) {
                element.scrollContainerElement.scrollTop = element.scrollContainerElement.scrollHeight;
            }
            
            // this is triggered after the scrolling is set so that if someone wants to scroll
            // to a record after select they aren't going to encounter a problem
            GS.triggerEvent(element, 'after_select');
            
        } else {
            // add error class
            element.classList.add('error');
            
            // error dialog
            GS.ajaxErrorDialog(data, function () {
                getData(element);
            });
        }
    }
    
    
    function updateRecord(element, record, strColumn, newValue) {
        var data, strLink, strWhere = '', len, i, strUpdateAction, callbackFunction,
            strSource = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') ||
                                                                    element.getAttribute('source') || ''));
        
        for (i = 0, len = element.arrWhereColumns.length; i < len; i += 1) {
            if (strWhere.length > 0) {
                strWhere = strWhere + '&';
            }
            strWhere = strWhere + element.arrWhereColumns[i] + '=' + record.getAttribute('data-' + element.arrWhereColumns[i]);
        }
        
        strLink = '/' + (element.getAttribute('action-update') || 'env/action_update') + '?src=' + encodeURIComponent(strSource);
        
        strLink +=  '&where=' +  encodeURIComponent(strWhere) +
                    '&column=' + strColumn +
                    '&value=' +  encodeURIComponent(newValue);
        
        addLoader(element, 'Updating Record...');
        
        if (window.asdfasdf) {
            throw '';
        }
        
        // run ajax
        GS.dataFetch(strLink, true);
        
        callbackFunction = function (event) {
            var jsnData, i, len, idIndex, tbodyElement, recordIndex, focusElement = document.activeElement
              , focusElementTag, focusElementRecord, focusElementCell, focusElementRecordIndex, focusElementCellIndex
              , focusElementIndex, focusElementCell, elementWalkResult, arrElements, arrSelection, newRecord, jsnTextSelection
              , newRecordData;
            
            removeLoader(element);
            
            focusElementCell = getCellFromTarget(focusElement);
            
            if (focusElementCell) {
                focusElementTag = focusElement.nodeName.toLowerCase();
                focusElementRecord = GS.findParentTag(focusElementCell, 'tr'); // getParentRecord(focusElementCell);
                
                focusElementRecordIndex = focusElementRecord.rowIndex;
                focusElementCellIndex = focusElementCell.cellIndex;
                focusElementIndex = xtag.query(focusElementRecord, focusElement.nodeName.toLowerCase()).indexOf(focusElement);
                
                //console.log(focusElementRecord,
                //            xtag.query(focusElementRecord, '*'),
                //            xtag.query(focusElementRecord, '*').indexOf(focusElement),
                //            xtag.query(focusElementRecord, focusElement.nodeName.toLowerCase()).indexOf(focusElement));
            }
            
            // if no error: refresh just the updated record
            if (!event.detail.error) {
                GS.triggerEvent(element, 'after_update');
                newRecordData = JSON.parse(JSON.stringify(event.detail.response))
                
                if (newRecordData.length > 0) {
                    // refresh record in lastSuccessData
                    idIndex = element.lastSuccessData.arr_column.indexOf('id');
                    
                    for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                        if (String(element.lastSuccessData.dat[i][idIndex]) === String(record.getAttribute('data-id'))) {
                            recordIndex = i;
                            element.lastSuccessData.dat[i] = JSON.parse(JSON.stringify(event.detail.response));
                            
                            break;
                        }
                    }
                    
                    // save text selection status
                    if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                        jsnTextSelection = GS.getInputSelection(document.activeElement);
                    }
                    
                    // save selection status of the cells in "record"
                    arrElements = xtag.query(record, 'td, th');
                    arrSelection = [];
                    
                    for (i = 0, len = arrElements.length; i < len; i += 1) {
                        if (arrElements[i].hasAttribute('selected-secondary')) {
                            arrSelection.push('selected-secondary');
                        } else if (arrElements[i].hasAttribute('selected')) {
                            arrSelection.push('selected');
                        } else {
                            arrElements.push('');
                        }
                    }
                    
                    // replace "record" with new templated record
                    tbodyElement = document.createElement('tbody');
                    tbodyElement.innerHTML = dataTemplateRecords(element, element.lastSuccessData, recordIndex, 1); // jsnData // dataTemplate
                    newRecord = xtag.queryChildren(tbodyElement, 'tr')[0];
                    record.parentNode.replaceChild(newRecord, record);
                    
                    // use saved selection status to select the cells in the new record
                    arrElements = xtag.query(newRecord, 'td, th');
                    
                    for (i = 0, len = arrElements.length; i < len; i += 1) {
                        if (arrSelection[i]) {
                            arrElements[i].setAttribute(arrSelection[i], '');
                        }
                    }
                    
                    // refocus
                    if (focusElementCell) {
                        elementWalkResult = xtag.query(element.scrollContainerElement, 'tr')[focusElementRecordIndex];
                        
                        if (elementWalkResult) {
                            elementWalkResult = xtag.query(elementWalkResult, focusElementTag)[focusElementIndex];
                            
                            if (elementWalkResult) {
                                elementWalkResult.focus();
                            }
                            
                            //elementWalkResult = xtag.queryChildren(elementWalkResult, 'th, td')[focusElementCellIndex];
                            //
                            //if (elementWalkResult) {
                            //    elementWalkResult = xtag.query(elementWalkResult, '*')[1];
                            //    
                            //    if (elementWalkResult) {
                            //        elementWalkResult.focus();
                            //    }
                            //}
                        }
                    }
                    
                    // use saved text selection status to select active element
                    if (jsnTextSelection) {
                        GS.setInputSelection(document.activeElement, jsnTextSelection.start, jsnTextSelection.end);
                    }
                } else {
                    element.selectedCells = [];
                    record.parentNode.removeChild(record);
                }
                
                element.refreshFixedHeader();
                element.refreshHeight();
                
            // else: errorDialog
            } else {
                // create addin to error response
                event.detail.response.error_addin = '<b gs-dynamic>Your Unsaved Value:</b> "' + newValue + '"';
                
                GS.ajaxErrorDialog(event.detail.response, function () {
                    updateRecord(element, record, strColumn, newValue);
                }, function () {
                    // revert
                    idIndex = element.lastSuccessData.arr_column.indexOf('id');
                    
                    for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                        if (String(element.lastSuccessData.dat[i][idIndex]) === String(record.getAttribute('data-id'))) {
                            recordIndex = i;
                            break;
                        }
                    }
                    
                    tbodyElement = document.createElement('tbody');
                    tbodyElement.innerHTML = dataTemplateRecords(element, element.lastSuccessData, recordIndex, 1);
                    record.parentNode.replaceChild(xtag.queryChildren(tbodyElement, 'tr')[0], record);
                });
            }
            
            document.removeEventListener('dataready_' + encodeURIComponent(strLink), callbackFunction);
        };
        
        // when the ajax is finished
        document.addEventListener('dataready_' + encodeURIComponent(strLink), callbackFunction);
    }
            
    function deleteRecords(element, arrID, arrRecord) {
        var strIDs = arrID.join(','), strDeleteAction, callbackFunction, strLink,
            strSource = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') ||
                                                                       element.getAttribute('source') || ''));
        
        strLink = '/' + (element.getAttribute('action-delete') || 'env/action_delete') +
                                    '?src=' + encodeURIComponent(strSource) + '&id=' + strIDs;
        
        addLoader(element, 'Deleting Record...');
        
        GS.dataFetch(strLink, true);
        
        callbackFunction = function (event) {
            var i, len, idColIndex, response = event.detail.response, error = event.detail.error, deleteIndex;
            
            removeLoader(element);
            
            if (!error) {
                GS.triggerEvent(element, 'after_delete');
                
                for (i = 0, len = arrRecord.length; i < len; i += 1) {
                    arrRecord[i].parentNode.removeChild(arrRecord[i]);
                }

                
                /*if (element.limitButtonElement) {
                    var btn_text_content = element.limitButtonElement.textContent;
                    var row_num1, row_num2;
                    
                    row_num1 = btn_text_content.substring(0, btn_text_content.indexOf(' '));
                    row_num2 = btn_text_content.substring(btn_text_content.lastIndexOf(' '), btn_text_content.length);
                    element.limitButtonElement.innerHTML = (row_num1 - arrRecord.length) + ' of ' + (row_num2 - arrRecord.length);
                    
                    console.log(element.limitButtonElement, element.limitButtonElement.textContent);
                }*/
                
                idColIndex = element.lastSuccessData.arr_column.indexOf('id');
                
                if (element.hasAttribute('limit') || element.lastSuccessData.dat.length === arrID.length) {
                    element.refresh();
                    
                } else {
                    
                    // remove the record data from our stored data and
                    //      stop looping when we have deleted all the ones we are supposed to
                    for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                        deleteIndex = arrID.indexOf(String(element.lastSuccessData.dat[i][idColIndex]));
                        
                        // (arrID should only have strings so we cast the current id to string)
                        if (deleteIndex > -1) {
                            element.lastSuccessData.dat.splice(i, 1);
                            arrID.splice(deleteIndex, 1);
                            len -= 1;
                            i -= 1;
                        }
                        
                        if (arrID.length === 0) {
                            break;
                        }
                    }
                    // this updates the second row count number
                    element.lastSuccessData.row_count = element.lastSuccessData.row_count - arrRecord.length;
                    
                    handleData(element, element.lastSuccessData);
                }
                
            } else {
                GS.ajaxErrorDialog(response, function () {
                    deleteRecords(element, arrID, arrRecord);
                });
            }
            
            document.removeEventListener('dataready_' + encodeURIComponent(strLink), callbackFunction);
        };
        
        document.addEventListener('dataready_' + encodeURIComponent(strLink), callbackFunction);
    }
            
    function insertRecord(element, dialog, strInsertString) {
        var strInsertAction, callbackFunction, strLink,
            strSource = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') || element.getAttribute('source') || ''));
        
        // if there is a column attribute on this element: append child column (or column) and the value to the insert string
        if (element.getAttribute('column') || element.getAttribute('qs')) {
            strInsertString += (strInsertString ? '&' : '') + (element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs')) + '=' + (element.value);
        }
        
        strLink = '/' + (element.getAttribute('action-insert') || 'env/action_insert') + '?src=' + encodeURIComponent(strSource) +
                                                                                        '&data=' + encodeURIComponent(strInsertString);
        
        addLoader(element, 'Inserting Record...');
        
        GS.dataFetch(strLink, true);
        
        callbackFunction = function (event) {
            var response = event.detail.response, error = event.detail.error;
            
            removeLoader(element);
            
            if (!error) {
                GS.triggerEvent(element, 'after_insert');
                GS.closeDialog(dialog, 'Ok');
                getData(element, true);
                
            } else {
                GS.ajaxErrorDialog(response);
            }
            
            document.removeEventListener('dataready_' + encodeURIComponent(strLink), callbackFunction);
        };
        
        document.addEventListener('dataready_' + encodeURIComponent(strLink), callbackFunction);
    }
    
    
    // ##################################################################
    // ########################### UI REFRESH ###########################
    // ##################################################################
    
    
    function refreshHud(element) {
        var elementHudTopContainer, elementHudBottomContainer, divElement = document.createElement('div'),
            hudInsertButton, hudRefreshButton, hudDeleteButton, hudOrderbyButton, hudLimitButton, intOffset, intLimit,
            jsnOrderByCopy, i, len, customHudTemplate, customHudElements;
        
        elementHudTopContainer    = element.hudTopElement;
        elementHudBottomContainer = element.hudBottomElement;
                        
        elementHudTopContainer.innerHTML = '';
        elementHudBottomContainer.innerHTML = '';
        
        // insert hud button
        if (element.insertTemplate && !element.hasAttribute('no-insert')) {
            divElement.innerHTML = '<gs-button inline icononly icon="plus" no-focus gs-dynamic>Insert</gs-button>';
            
            hudInsertButton = divElement.childNodes[0];
            
            elementHudTopContainer.appendChild(hudInsertButton);
        }
        
        // refresh hud button
        if (!element.hasAttribute('no-hudrefresh')) {
            divElement.innerHTML = '<gs-button inline icononly icon="refresh" no-focus gs-dynamic>Refresh</gs-button>';
            
            hudRefreshButton = divElement.childNodes[0];
            
            elementHudTopContainer.appendChild(hudRefreshButton);
        }
        
        // delete hud button
        if (!element.hasAttribute('no-huddelete')) {
            divElement.innerHTML = '<gs-button inline icononly icon="times" no-focus gs-dynamic>Delete</gs-button>';
            
            hudDeleteButton = divElement.childNodes[0];
            
            elementHudTopContainer.appendChild(hudDeleteButton);
        }
        
        // custom hud buttons (trim so that just whitespace doesn't count)
        if (element.hudTemplate && element.hudTemplate.trim()) {
            customHudTemplate = document.createElement('template');
            customHudTemplate.innerHTML = element.hudTemplate;
            
            elementHudTopContainer.appendChild(customHudTemplate.content.cloneNode(true));
            
            // V------ you can't use .children on a template.content
            //customHudElements = customHudTemplate.content.childNodes;
            //
            //for (i = 0, len = customHudElements.length; i < len; i += 1) {
            //    //customHudElements[i].setAttribute('inline', '');
            //    elementHudTopContainer.appendChild(customHudElements[0]);
            //}
            //elementHudTopContainer.innerHTML += element.hudTemplate; <-- this causes events to be lost in the hud-top container
        }
        
        // order by hud button
        if (!element.hasAttribute('no-hudorderby')) {
            divElement.innerHTML = '<gs-button inline icononly icon="sort-amount-asc" no-focus gs-dynamic>Order By</gs-button>';
            
            hudOrderbyButton = divElement.childNodes[0];
            
            elementHudBottomContainer.appendChild(hudOrderbyButton);
        }
        
        // limit hud button
        element.limitButtonElement = '';
        if (!element.hasAttribute('no-hudlimit')) {
            //console.log(element, element.lastSuccessData);
            divElement.innerHTML = '<span flex></span><gs-button inline no-focus>Limit</gs-button>';
            
            hudLimitButton = divElement.childNodes[1];
            
            element.limitButtonElement = hudLimitButton;
            
            elementHudBottomContainer.appendChild(divElement.childNodes[0]);
            elementHudBottomContainer.appendChild(divElement.childNodes[0]);
        }
        
        if (elementHudTopContainer.innerHTML === '') {
            elementHudTopContainer.style.display = 'none';
        } else {
            elementHudTopContainer.style.display = '';
        }
        
        if (elementHudBottomContainer.innerHTML === '') {
            elementHudBottomContainer.style.display = 'none';
        } else {
            elementHudBottomContainer.style.display = '';
        }
        
        
        // bind hud buttons
        if (hudInsertButton) {
            hudInsertButton.addEventListener('click', function (event) {
                var templateElement = document.createElement('template');
                
                templateElement.innerHTML = ml(function () {/*
                    <gs-page gs-dynamic>
                        <gs-header gs-dynamic><center gs-dynamic><h3 gs-dynamic>Insert</h3></center></gs-header>
                        <gs-body padded gs-dynamic>
                            <div id="insert-dialog-content-container" gs-dynamic>{{HTML}}</div>
                        </gs-body>
                        <gs-footer gs-dynamic>
                            <gs-grid gs-dynamic widths="1,1" class="width-2">
                                <gs-block gs-dynamic width="1">
                                    <gs-button dialogclose gs-dynamic>Cancel</gs-button>
                                </gs-block>
                                <gs-block gs-dynamic width="1">
                                    <gs-button class="dialog-envelope-insert" listen-for-return bg-primary gs-dynamic>Ok</gs-button>
                                </gs-block>
                            </gs-grid>
                        </gs-footer>
                    </gs-page>
                */}).replace('{{HTML}}', element.insertTemplate);
                
                GS.openDialog(templateElement, function () {
                    var dialog = this;
                    
                    GS.triggerEvent(element, 'insert_dialog_open');
                    
                    xtag.query(dialog, '.dialog-envelope-insert')[0].addEventListener('click', function () {
                        var insertContainer = document.getElementById('insert-dialog-content-container'),
                            controls, i, len, strInsertString, currentValue;
                        
                        controls = xtag.query(insertContainer, '[column]');
                        
                        for (i = 0, len = controls.length, strInsertString = ''; i < len; i += 1) {
                            currentValue = controls.checked !== undefined ? controls.checked : controls[i].value;
                            
                            if (currentValue === undefined || currentValue === null) {
                                currentValue = '';
                            }
                            
                            currentValue = encodeURIComponent(currentValue);
                            
                            if (currentValue !== undefined && currentValue !== null && currentValue !== '') {
                                strInsertString += (strInsertString === '' ? '' : '&') +
                                                    controls[i].getAttribute('column') + '=' + currentValue;
                            }
                        }
                        
                        insertRecord(element, dialog, strInsertString);
                    });
                });
            });
        }
        
        if (hudRefreshButton) {
            element.hudRefreshButton = hudRefreshButton;
            hudRefreshButton.addEventListener('click', function (event) {
                getData(element, true);
            });
        }
        
        if (hudDeleteButton) {
            element.hudDeleteButton = hudDeleteButton;
            //console.log('binding click on', hudDeleteButton);
            hudDeleteButton.addEventListener('click', function (event) {
                var i, len, arrRecord = element.selectedRecords, arrID = [];
                
                // loop through the selected cells and create an array of ids
                for (i = 0, len = arrRecord.length; i < len; i += 1) {
                    arrID.push(String(arrRecord[i].dataset.id));
                }
                
                if (arrID.length > 0) {
                    GS.msgbox(  'Are you sure...',
                                    '<br gs-dynamic />' +
                                    '<center gs-dynamic>' +
                                        'Are you sure you want to delete ' + (arrID.length > 1 ? 'these records' : 'this record') + '?' +
                                    '</center>' +
                                    '<br gs-dynamic />',
                                ['No', 'Yes'],
                                function (strAnswer) {
                                    if (strAnswer === 'Yes') {
                                        deleteRecords(element, arrID, arrRecord);
                                    }
                                });
                    
                } else {
                    GS.msgbox('Nothing Selected.',
                              '<br gs-dynamic /><center gs-dynamic>Nothing is selected. Please select something to delete.</center><br />',
                              ['Ok']);
                }
            });
        }
        
        if (hudOrderbyButton) {
            element.hudOrderbyButton = hudOrderbyButton;
            hudOrderbyButton.addEventListener('click', function (event) {
                var templateElement = document.createElement('template');
                
                jsnOrderByCopy = JSON.parse(JSON.stringify(element.user_order_bys));
                
                // TESTING LINE!!! COMMENT OUT WHEN NOT IN USE!!!
                //jsnOrderByCopy = {'columns': ['billable', 'taxable', 'id', 'user_name'], 'directions': ['asc', 'desc', 'asc', 'asc']};
                // TESTING LINE!!! COMMENT OUT WHEN NOT IN USE!!!
                
                templateElement.setAttribute('data-mode', 'touch');
                templateElement.innerHTML = ml(function () {/*
                    <gs-page gs-dynamic>
                        <gs-header gs-dynamic>
                            <center gs-dynamic><h3 gs-dynamic>Sorted Columns</h3></center>
                            <gs-button id="order-by-dialog-add-column" gs-dynamic>Add A Column To Sort</gs-button>
                        </gs-header>
                        <gs-body padded gs-dynamic>
                            <div id="order-by-dialog-ghost-container" gs-dynamic></div>
                            <div id="order-by-dialog-used-columns" gs-dynamic></div>
                        </gs-body>
                        <gs-footer gs-dynamic>
                            <gs-grid>
                                <gs-block><gs-button gs-dynamic dialogclose>Cancel</gs-button></gs-block>
                                <gs-block><gs-button gs-dynamic dialogclose>Ok</gs-button></gs-block>
                            </gs-grid>
                        </gs-footer>
                    </gs-page>
                */});
                
                GS.openDialog(templateElement, function () {
                    document.getElementById('order-by-dialog-add-column').addEventListener('click', function (event) {
                        var dialog, dialogButtons, templateElement = document.createElement('template');
                        
                        templateElement.innerHTML = ml(function () {/*
                            <gs-page gs-dynamic>
                                <gs-header gs-dynamic>
                                    <center gs-dynamic><h3 gs-dynamic>Unsorted Columns</h3></center>
                                </gs-header>
                                <gs-body padded gs-dynamic>
                                    <div id="order-by-dialog-unused-columns" gs-dynamic></div>
                                </gs-body>
                                <gs-footer gs-dynamic>
                                    <gs-button dialogclose gs-dynamic>Cancel</gs-button>
                                </gs-footer>
                            </gs-page>
                        */});
                        
                        dialog = GS.openDialog(templateElement, function () {
                                    var unusedColumnsContainer = document.getElementById('order-by-dialog-unused-columns'),
                                        unusedColumnTapHandler, columnElements, i, len, strHTML;
                                    
                                    for (i = 0, len = element.lastSuccessData.arr_column.length, strHTML = ''; i < len; i += 1) {
                                        if (jsnOrderByCopy.columns.indexOf(element.lastSuccessData.arr_column[i]) === -1) {
                                            strHTML +=  '<div class="order_by_column" dialogclose data-column="' + element.lastSuccessData.arr_column[i] + '" gs-dynamic>' +
                                                            '<div class="column_name" gs-dynamic>' + GS.strToTitle(element.lastSuccessData.arr_column[i]) + '</div>' +
                                                        '</div>';
                                        }
                                    }
                                    
                                    unusedColumnsContainer.innerHTML = strHTML;
                                    
                                    unusedColumnTapHandler = function (event) {
                                        if (event.target.classList.contains('column_name')) {
                                            jsnOrderByCopy.columns.push(event.target.parentNode.getAttribute('data-column'));
                                        } else {
                                            jsnOrderByCopy.columns.push(event.target.getAttribute('data-column'));
                                        }
                                        jsnOrderByCopy.directions.push('asc');
                                        
                                        // refresh the column list
                                        refreshOrderBys();
                                    };
                                    
                                    columnElements = unusedColumnsContainer.getElementsByClassName('order_by_column');
                                    
                                    for (i = 0, len = columnElements.length; i < len; i += 1) {
                                        columnElements[i].addEventListener('click', unusedColumnTapHandler);
                                    }
                                });
                        
                        dialogButtons = dialog.getElementsByTagName('gs-button');
                    });
                    
                    var refreshOrderBys = function () {
                        var usedColumnsElement = document.getElementById('order-by-dialog-used-columns'),
                            ghostContainerElement = document.getElementById('order-by-dialog-ghost-container'),
                            strHTML, i, len, sortButtons, sortMousedownHandler, deleteButtons,
                            deleteTapHandler, directionButtons, directionTapHandler;
                        
                        
                        for (i = 0, len = jsnOrderByCopy.columns.length, strHTML = ''; i < len; i += 1) {
                            strHTML +=  '<div class="order_by_column" flex-horizontal data-column="' + jsnOrderByCopy.columns[i] + '" data-direction="' + jsnOrderByCopy.directions[i] + '" gs-dynamic>' +
                                            '<gs-button inline remove-all icononly icon="bars" class="sort" gs-dynamic></gs-button>' +
                                            '<div class="column_name" flex gs-dynamic>' + GS.strToTitle(jsnOrderByCopy.columns[i]) + '</div>' +
                                            '<gs-button inline remove-all icononly icon="times" class="delete" gs-dynamic></gs-button>' +
                                            '<gs-button inline remove-all icononly icon="sort-amount-' + jsnOrderByCopy.directions[i] + '" class="direction" gs-dynamic></gs-button>' +
                                        '</div>';
                        }
                        
                        usedColumnsElement.innerHTML = strHTML;
                        
                        // bind sort buttons
                        sortMousedownHandler = function () {
                            var columns = usedColumnsElement.getElementsByClassName('order_by_column'), offsetsCache = [], i, len,
                                currentElement = this.parentNode, currentlyMarkedElement, markerElement, bolLast = false, intToIndex,
                                currentElementClone, intCloneoffset, intFromIndex, sortMousemoveHandler, sortMouseupHandler, 
                                strColumn = currentElement.getAttribute('data-column'),
                                strDirection = currentElement.getAttribute('data-direction');
                            
                            markerElement = document.createElement('div');
                            markerElement.classList.add('drop_marker');
                            markerElement.setAttribute('gs-dynamic', '');
                            
                            currentElementClone = currentElement.cloneNode(true);
                            ghostContainerElement.appendChild(currentElementClone);
                            intCloneoffset = GS.getElementOffset(ghostContainerElement).top + (currentElementClone.offsetHeight / 2);
                            
                            
                            for (i = 0, len = columns.length; i < len; i += 1) {
                                offsetsCache.push({
                                    'element': columns[i],
                                    'top': GS.getElementOffset(columns[i]).top,
                                    'height': columns[i].offsetHeight//, 'iscurrentelement': columns[i] === currentElement
                                });
                                
                                if (columns[i] === currentElement) {
                                    intFromIndex = i;
                                }
                            }
                            
                            sortMousemoveHandler = function (event) {
                                var i, len, matchedElement, bolNewLast, intTop;
                                
                                event.preventDefault();
                                event.stopPropagation();
                                
                                if (event.which === 0 && !evt.touchDevice) {
                                    sortMouseupHandler();
                                    
                                } else {
                                    intTop = GS.mousePosition(event).top + usedColumnsElement.parentNode.scrollTop;
                                    
                                    currentElementClone.style.top = (intTop - intCloneoffset) + 'px';
                                    
                                    //console.log('mousemove', GS.mousePosition(event).top, usedColumnsElement.parentNode.scrollTop);
                                    
                                    if (offsetsCache[0].top > intTop) {
                                        matchedElement = offsetsCache[0].element;
                                        bolNewLast = false;
                                        
                                    } else {
                                        for (i = 0, len = offsetsCache.length; i < len; i += 1) {
                                            if (offsetsCache[i + 1]) {
                                                if (offsetsCache[i].top <= intTop &&
                                                    offsetsCache[i].top + ((offsetsCache[i + 1].top - offsetsCache[i].top) / 2) > intTop) {
                                                    
                                                    matchedElement = offsetsCache[i].element;
                                                    bolNewLast = false;
                                                    intToIndex = i;
                                                    break;
                                                    
                                                } else if (offsetsCache[i].top <= intTop &&
                                                            offsetsCache[i].top + ((offsetsCache[i + 1].top - offsetsCache[i].top) / 2) <= intTop &&
                                                            offsetsCache[i + 1].top > intTop) {
                                                    
                                                    matchedElement = offsetsCache[i + 1].element;
                                                    bolNewLast = false;
                                                    intToIndex = i + 1;
                                                    break;
                                                }
                                            } else {
                                                if (offsetsCache[i].top + (offsetsCache[i].height / 2) >= intTop) {
                                                    matchedElement = offsetsCache[i].element;
                                                    bolNewLast = false;
                                                    intToIndex = i;
                                                    break;
                                                    
                                                } else if (offsetsCache[i].top + (offsetsCache[i].height / 2) <= intTop) {
                                                    matchedElement = offsetsCache[i].element;
                                                    bolNewLast = true;
                                                    intToIndex = i;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    
                                    if (matchedElement !== currentlyMarkedElement || bolNewLast !== bolLast) {
                                        if (bolNewLast === true) {
                                            if (markerElement) {
                                                markerElement.parentNode.removeChild(markerElement);
                                            }
                                            matchedElement.parentNode.appendChild(markerElement);
                                            
                                        } else {
                                            matchedElement.parentNode.insertBefore(markerElement, matchedElement);
                                        }
                                        
                                        currentlyMarkedElement = matchedElement;
                                        bolLast = bolNewLast;
                                        
                                        //console.log(currentlyMarkedElement, bolLast);
                                    }
                                    
                                    //console.log('mousemove', intTop);
                                }
                            };
                            
                            document.body.addEventListener(evt.mousemove, sortMousemoveHandler);
                            
                            sortMouseupHandler = function (event) {
                                intToIndex = (intToIndex > intFromIndex ? intToIndex - 1: intToIndex);
                                
                                // if we have valid to and from indexes:
                                if (intFromIndex !== intToIndex && intToIndex !== undefined) {
                                    
                                    if (intFromIndex !== undefined && intFromIndex !== '') {
                                        jsnOrderByCopy.columns.splice(intFromIndex, 1);
                                        jsnOrderByCopy.directions.splice(intFromIndex, 1);
                                    }
                                    
                                    jsnOrderByCopy.columns.splice(intToIndex, 0, strColumn);
                                    jsnOrderByCopy.directions.splice(intToIndex, 0, strDirection);
                                    
                                    // refresh the column list
                                    refreshOrderBys();
                                } else {
                                    markerElement.parentNode.removeChild(markerElement);
                                }
                                
                                //console.log(intFromIndex, intToIndex);
                                ghostContainerElement.innerHTML = '';
                                document.body.removeEventListener(evt.mousemove, sortMousemoveHandler);
                                document.body.removeEventListener(evt.mouseup, sortMouseupHandler);
                            };
                            
                            document.body.addEventListener(evt.mouseup, sortMouseupHandler);
                            
                            //console.log('sortMousedownHandler');
                        };
                        sortButtons = usedColumnsElement.getElementsByClassName('sort');
                        
                        for (i = 0, len = sortButtons.length; i < len; i += 1) {
                            sortButtons[i].addEventListener(evt.mousedown, sortMousedownHandler);
                        }
                        //console.log(usedColumnsElement.getElementsByClassName('sort'));
                        
                        // bind delete buttons
                        deleteTapHandler = function () {
                            var indexToDelete = jsnOrderByCopy.columns.indexOf(this.parentNode.getAttribute('data-column'));
                            
                            jsnOrderByCopy.columns.splice(indexToDelete, 1);
                            jsnOrderByCopy.directions.splice(indexToDelete, 1);
                            
                            refreshOrderBys();
                            //console.log('deleteTapHandler');
                        };
                        deleteButtons = usedColumnsElement.getElementsByClassName('delete');
                        
                        for (i = 0, len = deleteButtons.length; i < len; i += 1) {
                            deleteButtons[i].addEventListener('click', deleteTapHandler);
                        }
                        //console.log(usedColumnsElement.getElementsByClassName('delete'));
                        
                        
                        // bind direction buttons
                        directionTapHandler = function () {
                            var indexToFlip = jsnOrderByCopy.columns.indexOf(this.parentNode.getAttribute('data-column'));
                            
                            if (jsnOrderByCopy.directions[indexToFlip] === 'asc') {
                                jsnOrderByCopy.directions[indexToFlip] = 'desc';
                            } else {
                                jsnOrderByCopy.directions[indexToFlip] = 'asc';
                            }
                            
                            refreshOrderBys();
                            //console.log('directionTapHandler');
                        };
                        directionButtons = usedColumnsElement.getElementsByClassName('direction');
                        
                        for (i = 0, len = directionButtons.length; i < len; i += 1) {
                            directionButtons[i].addEventListener('click', directionTapHandler);
                        }
                        //console.log(usedColumnsElement.getElementsByClassName('direction'));
                    }
                    
                    refreshOrderBys();
                }, function (event, strAnswer) {
                    if (strAnswer === 'Ok') {
                        element.user_order_bys = JSON.parse(JSON.stringify(jsnOrderByCopy));
                        getData(element, true);
                    }
                });
            });
        }
        
        if (hudLimitButton) {
            element.hudLimitButton = hudLimitButton;
            hudLimitButton.addEventListener('click', function (event) {
                var intLimit, intOffset, bolShowAll, fromValue, toValue,
                    templateElement = document.createElement('template');
                
                if (element.getAttribute('limit') && element.getAttribute('offset')) {
                    intOffset = parseInt(element.getAttribute('offset'), 10);
                    intLimit = parseInt(element.getAttribute('limit'), 10);
                    
                    fromValue = intOffset;
                    toValue = intOffset + intLimit;
                    bolShowAll = false;
                    
                } else if (element.getAttribute('limit')) {
                    fromValue = '0';
                    toValue = element.getAttribute('limit');
                    bolShowAll = false;
                    
                } else if (element.old_offset && element.old_limit) {
                    intOffset = parseInt(element.old_offset, 10);
                    intLimit = parseInt(element.old_limit, 10);
                    
                    fromValue = intOffset;
                    toValue = intOffset + intLimit;
                    bolShowAll = true;
                    
                } else if (element.old_limit) {
                    fromValue = '0';
                    toValue = element.old_limit;
                    bolShowAll = true;
                    
                } else {
                    fromValue = '0';
                    toValue = element.lastSuccessData.row_count;
                    bolShowAll = true;
                }
                
                templateElement.setAttribute('id', 'template-envelope-limit');
                templateElement.innerHTML = ml(function () {/*
                    <gs-page gs-dynamic>
                        <gs-header><center><h3>Limit</h3></center></gs-header>
                        <gs-body padded>
                            <gs-optionbox id="limit-dialog-choice" value="{{OPTION}}">
                                <gs-option value="range">
                                    Show Range:
                                    <gs-grid gutter>
                                        <gs-block>
                                            <b>From:</b>
                                            <gs-text id="limit-dialog-from" value="{{FROM}}" {{DISABLE}}></gs-text>
                                        </gs-block>
                                        <gs-block>
                                            <b>To:</b>
                                            <gs-text id="limit-dialog-to" value="{{TO}}" {{DISABLE}}></gs-text>
                                        </gs-block>
                                    </gs-grid>
                                </gs-option>
                                <gs-option value="all">Show All</gs-option>
                            </gs-optionbox>
                        </gs-body>
                        <gs-footer>
                            <gs-grid>
                                <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                                <gs-block><gs-button dialogclose listen-for-return bg-primary>Ok</gs-button></gs-block>
                            </gs-grid>
                        </gs-footer>
                    </gs-page>
                */}).replace('{{OPTION}}', (bolShowAll === true ? 'all' : 'range'))
                    .replace(/\{\{DISABLE\}\}/gim, (bolShowAll === true ? 'disabled' : ''))
                    .replace('{{FROM}}', fromValue)
                    .replace('{{TO}}', toValue);
                
                GS.openDialog(templateElement, function () {
                    var choiceElement, showAllElement, fromElement, toElement, intLimit, intOffset, bolShowAll, fromValue, toValue;
                    
                    choiceElement = document.getElementById('limit-dialog-choice');
                    fromElement = document.getElementById('limit-dialog-from');
                    toElement = document.getElementById('limit-dialog-to');
                    
                    choiceElement.addEventListener('change', function (event) {
                        if (this.value === 'all') {
                            fromElement.setAttribute('disabled', '');
                            toElement.setAttribute('disabled', '');
                            GS.closeDialog('template-envelope-limit', 'Ok');
                        } else {
                            fromElement.removeAttribute('disabled');
                            toElement.removeAttribute('disabled');
                        }
                    });
                    
                }, function (event, strAnswer) {
                    var dialog = this, choiceElement, showAllElement, fromElement, toElement, intLimit, intOffset;
                    
                    if (strAnswer === 'Ok') {
                        choiceElement = document.getElementById('limit-dialog-choice');
                        showAllElement = document.getElementById('limit-dialog-show-all');
                        fromElement = document.getElementById('limit-dialog-from');
                        toElement = document.getElementById('limit-dialog-to');
                        
                        if (choiceElement.value === 'all') {
                            if (element.getAttribute('limit')) {
                                element.old_limit = element.getAttribute('limit');
                                element.removeAttribute('limit');
                            }
                            if (element.getAttribute('offset')) {
                                element.old_offset = element.getAttribute('offset');
                                element.removeAttribute('offset');
                            }
                            
                        } else {
                            if (fromElement.value) {
                                element.setAttribute('offset', fromElement.value);
                            }
                            if (toElement.value) {
                                element.setAttribute('limit', parseInt(toElement.value, 10) - parseInt(fromElement.value, 10));
                            }
                        }
                        
                        getData(element);
                    }
                });
            });
        }
    }
    
    
    // #################################################################
    // ########################### UTILITIES ###########################
    // #################################################################
    
    function handleClipboardData(event, strCopyString) {
        var clipboardData = event.clipboardData || window.clipboardData, strMime;
        
        if (!clipboardData) {
            return;
        }
        if (!clipboardData.setData) {
            return;
        }
        
        if (window.clipboardData && window.clipboardData.getData) { // IE
            strMime = 'Text';
        } else if (event.clipboardData && event.clipboardData.getData) {
            strMime = 'text/plain';
        }
        
        if (strCopyString) {
            return clipboardData.setData(strMime, strCopyString) !== false;
        } else {
            return clipboardData.getData(strMime);
        }
    }
    
    function dataTemplateRecords(element, data, intStartRecordNumber, intNumberOfRecords) {
        var tableTemplateElement = document.createElement('template'), jsnTemplate, strRet, strStart, strEnd;
        
        tableTemplateElement.innerHTML = element.tableTemplate;
        
        //strStart = '<table><tbody>';
        //strEnd = '</tbody></table>';
        //jsnTemplate = GS.templateHideSubTemplates(strStart + xtag.query(tableTemplateElement.content, 'tbody')[0].innerHTML + strEnd);
        jsnTemplate = GS.templateHideSubTemplates(xtag.query(tableTemplateElement.content, 'tbody')[0].innerHTML, true);
        
        //jsnTemplate.templateHTML = jsnTemplate.templateHTML.substring(strStart.length, jsnTemplate.templateHTML.length - strEnd.length);
        //console.log(jsnTemplate.templateHTML);
        
        strRet = GS.templateWithEnvelopeData(jsnTemplate.templateHTML, data, intStartRecordNumber, intStartRecordNumber + intNumberOfRecords);
        
        strRet = GS.templateShowSubTemplates(strRet, jsnTemplate);
        
        return strRet;
    }
    
    
    
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    
    function getCellFromTarget(element) {
        var currentElement = element;
        
        while (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH' && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }
        
        if (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH') {
            return undefined;
        }
        
        return currentElement;
    }
    
    //function pushReplacePopHandler(element) {
    //    var i, len, arrPopKeys, bolRefresh = false, currentValue, strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //    
    //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //    
    //    if (element.hasAttribute('refresh-on-querystring-values')) {
    //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(',');
    //        
    //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
    //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
    //            
    //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
    //                bolRefresh = true;
    //            }
    //            
    //            element.popValues[arrPopKeys[i]] = currentValue;
    //        }
    //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
    //        bolRefresh = true;
    //    }
    //    
    //    if (bolRefresh) {
    //        element.refresh();
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh;
        var strOperator;

        if (strQSCol) {
            if (strQSCol.indexOf('=') !== -1) {
                arrAttrParts = strQSCol.split(',');
                i = 0;
                len = arrAttrParts.length;
                while (i < len) {
                    strQSCol = arrAttrParts[i];
    
                    if (strQSCol.indexOf('!=') !== -1) {
                        strOperator = '!=';
                        arrQSParts = strQSCol.split('!=');
                    } else {
                        strOperator = '=';
                        arrQSParts = strQSCol.split('=');
                    }
    
                    strQSCol = arrQSParts[0];
                    strQSAttr = arrQSParts[1] || arrQSParts[0];
    
                    // if the key is not present or we've got the negator: go to the attribute's default or remove it
                    if (strOperator === '!=') {
                        // if the key is not present: add the attribute
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            element.setAttribute(strQSAttr, '');
                        // else: remove the attribute
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    } else {
                        // if the key is not present: go to the attribute's default or remove it
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        // else: set attribute to exact text from QS
                        } else {
                            element.setAttribute(strQSAttr, (
                                GS.qryGetVal(strQS, strQSCol) ||
                                element.internal.defaultAttributes[strQSAttr] ||
                                ''
                            ));
                        }
                    }
                    i += 1;
                }
            } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                strQSValue = GS.qryGetVal(strQS, strQSCol);
    
                if (element.internal.bolQSFirstRun !== true) {
                    if (strQSValue !== '' || !element.getAttribute('value')) {
                        element.setAttribute('value', strQSValue);
                    }
                } else {
                    element.value = strQSValue;
                }
            }
        }
        
        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                
                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);
                    
                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }
                    
                    element.popValues[arrPopKeys[i]] = currentValue;
                }
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            }
            
            if (bolRefresh && element.hasAttribute('src')) {
                console.log('pushReplacePopHandler: getData', element);
                getData(element);
            } else if (bolRefresh && !element.hasAttribute('src')) {
                console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                
                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                }
            }
        }
        
        element.internal.bolQSFirstRun = true;
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            
        }
    }
    
    //
    function elementInserted(element) {
        var hudTemplateElement, tableTemplateElement, tableTemplateElementCopy, insertTemplateElement,
            recordElement, divElement, oldRootElement, i, len, arrElement, arrColumnElement, arrTemplates, arrWhereColumns,
            strQueryString = GS.getQueryString(), currentElement, strQSValue;
            
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);
                
                GS.addBeforeUnloadEvent(function () {
                    document.activeElement.blur();
                });
                
                // handle "qs" attribute
                if (element.getAttribute('qs') ||
                        element.getAttribute('refresh-on-querystring-values') ||
                        element.hasAttribute('refresh-on-querystring-change')) {
                    element.popValues = {};
                    //strQSValue = GS.qryGetVal(strQueryString, element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.setAttribute('value', strQSValue);
                    //}
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }
                
                // primary keys attribute and defaulting
                if (element.getAttribute('primary-keys')) {
                    arrWhereColumns = element.getAttribute('primary-keys').split(/\s*,\s*/gim);
                    if (arrWhereColumns.length === 0) {
                        arrWhereColumns = ['id', 'change_stamp'];
                    }
                } else {
                    arrWhereColumns = ['id', 'change_stamp'];
                }
                element.arrWhereColumns = arrWhereColumns;
                
                // set user order bys to default to empty
                element.user_order_bys = {
                    'columns': [],
                    'directions': []
                };
                
                // if there is an old root element: delete it
                oldRootElement = xtag.queryChildren(element, '.root');
                
                if (oldRootElement.length > 0) {
                    for (i = 0, len = oldRootElement.length; i < len; i += 1) {
                        element.removeChild(oldRootElement[i]);
                    }
                }
                
                // selecting for template elements
                hudTemplateElement    = xtag.queryChildren(element, 'template[for="hud"]')[0];
                tableTemplateElement  = xtag.queryChildren(element, 'template[for="table"]' + (element.hasAttribute('template') ? '[id="' + element.getAttribute('template') + '"': ''))[0];
                if (!tableTemplateElement && element.hasAttribute('template')) {
                    console.warn('ENVELOPE WARNING: Hey! You used the name of a non-existant record template!');
                    tableTemplateElement  = xtag.queryChildren(element, 'template[for="table"]')[0];
                }
                insertTemplateElement = xtag.queryChildren(element, 'template[for="insert"]')[0];
                
                element.templates = {};
                xtag.queryChildren(element, 'template[for="table"]').forEach(function (cur, i) {
                    if (i === 0) {
                        element.templates['default'] = cur;
                    }
                    if (cur.hasAttribute('id')) {
                        element.templates[cur.getAttribute('id')] = cur;
                    }
                });
                
                // checking/saving template elements
                if (hudTemplateElement) {
                    element.hudTemplate = hudTemplateElement.innerHTML;
                }
                
                if (tableTemplateElement) {
                    tableTemplateElementCopy = document.createElement('template');
                    tableTemplateElementCopy.innerHTML = tableTemplateElement.innerHTML;
                    
                    recordElement = xtag.query(xtag.query(tableTemplateElementCopy.content, 'tbody')[0], 'tr')[0];
                    
                    if (recordElement) {
                        // add a data- attribute for all where columns (most of the time: id and change_stamp)
                        for (i = 0, len = element.arrWhereColumns.length; i < len; i += 1) {
                            recordElement.setAttribute('data-' + element.arrWhereColumns[i], '{{! row.' + element.arrWhereColumns[i] + ' }}');
                        }
                        
                        // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                        element.tableTemplate = GS.templateColumnToValue(tableTemplateElementCopy.innerHTML);
                    }
                } else {
                    throw 'Envelope error: table template is required.';
                }
                if (insertTemplateElement) {
                    element.insertTemplate = insertTemplateElement.innerHTML;
                }
                
                // clear element content
                element.innerHTML = '';
                
                // creating/setting root
                divElement = document.createElement('div');
                divElement.classList.add('root');
                divElement.setAttribute('flex-fill', '');
                divElement.setAttribute('flex-vertical', '');
                divElement.setAttribute('gs-dynamic', '');
                
                element.appendChild(divElement);
                element.root = divElement;
                
                // filling root with containers
                element.root.innerHTML = '<div class="hud-container-top" gs-dynamic></div>' +
                                         '<div class="fixed-header-container" gs-dynamic></div>' +
                                         '<div class="scroll-container" flex gs-dynamic></div>' +
                                         '<div class="hud-container-bottom" flex-horizontal gs-dynamic></div>' +
                                         '<input class="gs-envelope-copy-focus-target" value="Firefox compatibility input" gs-dynamic />';
                
                element.hudTopElement =                 xtag.queryChildren(element.root, '.hud-container-top')[0];
                element.fixedHeaderContainerElement =   xtag.queryChildren(element.root, '.fixed-header-container')[0];
                element.scrollContainerElement =        xtag.queryChildren(element.root, '.scroll-container')[0];
                element.hudBottomElement =              xtag.queryChildren(element.root, '.hud-container-bottom')[0];
                element.copyFocusTargetElement =        xtag.queryChildren(element.root, '.gs-envelope-copy-focus-target')[0];
                
                element.scrollContainerElement.setAttribute('allow-text-selection', '');
                
                ////REFPOINT
                //element.addEventListener('focus', function (event) {
                //    //console.log(document.activeElement, element, event.target, element.copyFocusTargetElement);
                //    if (document.activeElement === element) { // event.target
                //        element.copyFocusTargetElement.focus();
                //        GS.setInputSelection(element.copyFocusTargetElement, 0, 'firefox...'.length);
                //    }
                //});
                
                // binding events
                element.scrollContainerElement.addEventListener('change', function (event) {
                    var newValue, parentTr;

                    if (event.target.getAttribute('column')) {
                        if (event.target.value !== null) {
                            newValue = event.target.value;
                        } else {
                            newValue = event.target.checked;
                        }
                        
                        parentTr = GS.findParentTag(event.target, 'tr');
                        
                        // if the control is a direct child of this envelope (fixes sub envelope update)
                        if (
                            parentTr.parentNode.parentNode.parentNode === element.scrollContainerElement &&
                            !element.hasAttribute('no-update')
                        ) {
                            updateRecord(element, parentTr, event.target.getAttribute('column'), newValue);
                        }
                    }
                });
                
                // META-SHIFT-CLICK
                if (!evt.touchDevice) {
                    element.addEventListener('click', function (event) {
                        var templateElement;
                        
                        if (event.metaKey && event.shiftKey) {
                            templateElement = document.createElement('template');
                            
                            
                            var strOrderBy = '', strRelWhere = '', strElemWhere, strWhereColumn, strUserOrderBy = '', strLimit, strOffset,
                                strSource = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') || '')),
                                strCols = GS.templateWithQuerystring(element.getAttribute('cols') || ''), strElemOrderBy;
                            
                            // if there is a column attribute on element element: combine the where attribute with a where generated by value
                            if ((element.getAttribute('column') || element.getAttribute('qs')) && element.value) {
                                strWhereColumn = element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs');
                                
                                if (isNaN(element.value)) {
                                    strRelWhere =
                                        'CAST(' + strWhereColumn + ' AS ' + GS.database.type.text + ') = ' +
                                        'CAST($WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')';
                                } else {
                                    strRelWhere = strWhereColumn + '=' + (element.value);
                                }
                            }
                            
                            strElemWhere = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('where') || ''));
                            strLimit = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('limit') || ''));
                            strOffset = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('offset') || ''));
                            
                            // if the user has set an order by: use the user order bys
                            if (element.user_order_bys && element.user_order_bys.columns.length > 0) {
                                for (i = 0, len = element.user_order_bys.columns.length, strUserOrderBy; i < len; i += 1) {
                                    strUserOrderBy += (strUserOrderBy !== '' ? ', ' : '') + element.user_order_bys.columns[i] + ' ' + element.user_order_bys.directions[i].toUpperCase();
                                }
                            }
                            
                            strElemOrderBy = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('ord') || ''));
                            
                            
                            templateElement.innerHTML = ml(function () {/*
                                <gs-page>
                                    <gs-header><h3>GS-Envelope Details</h3></gs-header>
                                    <gs-body padded>
                                        <b>Source: </b>{{SOURCE}}<br />
                                        <b>Columns: </b>{{COLS}}<br />
                                        <b>Element Where: </b>{{ELEMWHERE}}<br />
                                        <b>Relationship Where: </b>{{RELWHERE}}<br />
                                        <b>Limit: </b>{{LIMIT}}<br />
                                        <b>Offset: </b>{{OFFSET}}<br />
                                        <b>Element Order By: </b>{{ELEMORD}}<br />
                                        <b>User Order By: </b>{{USERORD}}
                                    </gs-body>
                                    <gs-footer>
                                        <gs-button dialogclose>Done</gs-button>
                                    </gs-footer>
                                </gs-page>
                            */}).replace(/\{\{SOURCE\}\}/gi, strSource)
                                .replace(/\{\{COLS\}\}/gi, strCols)
                                .replace(/\{\{ELEMWHERE\}\}/gi, strElemWhere)
                                .replace(/\{\{RELWHERE\}\}/gi, strRelWhere)
                                .replace(/\{\{LIMIT\}\}/gi, strLimit)
                                .replace(/\{\{OFFSET\}\}/gi, strOffset)
                                .replace(/\{\{ELEMORD\}\}/gi, strElemOrderBy)
                                .replace(/\{\{USERORD\}\}/gi, strUserOrderBy);
                            
                            GS.openDialog(templateElement);
                        }
                    });
                }
                
                // if we are not on a touch device: cell by cell selection
                if (!evt.touchDevice) {
                    // mousedown (on selected and unselected) + drag
                    //      clear previous selection(s)
                    //      select cells from origin cell to current cell
                    //
                    // shift + mousedown (on selected and unselected) + drag
                    //      alter previous selection
                    //      select cells from previous origin cell to current cell
                    //
                    // command + mousedown (on unselected) + drag
                    //      maintain previous selection(s)
                    //      select cells from origin cell to current cell
                    //
                    // command + mousedown (on selected) + drag
                    //      maintain previous selection(s)
                    //      deselect cells from origin cell to current cell
                    //
                    // collision handling
                    //      when colliding with previous selections: dont treat them different
                    //
                    // copy handling
                    //      selection ("X" marks selected cells (imagine all cells contain the letter "a")):
                    //          1  2  3  4  5
                    //          -------------
                    //          a  a  a  a  a
                    //          a  X  X  a  a
                    //          a  a  X  X  a
                    //          a  a  a  a  a
                    //
                    //      yields ("'" marks an empty cell):
                    //          2  3  4 
                    //          --------
                    //          a  a  ' 
                    //          '  a  a 
                    
                    element.addEventListener(evt.mousedown, function (event) {
                        var target = event.target, cellFromTarget = getCellFromTarget(target), closestCell, arrSelectedCells, i, len;
                        
                        if (GS.findParentTag(event.target, 'table') || target.classList.contains('fixed-header-cell')) {
                            if (cellFromTarget) {
                                closestCell = cellFromTarget;
                            } else if (target.classList.contains('fixed-header-cell')) {
                                closestCell = element.theadElement.children[0].children[xtag.toArray(target.parentNode.children).indexOf(target)];
                            }
                            
                            if (closestCell) {
                                element.dragAllowed = true;
                                element.dragCurrentCell = closestCell;
                                element.selectionSelectedCells = [];
                                
                                // if shift is down and there is a previous origin: use previous origin for current origin
                                if (event.shiftKey && element.selectionPreviousOrigin) {
                                    
                                    // if there are previously selected cells: deselect the previous selected cells
                                    if (element.selectionPreviousSelectedCells) {
                                        arrSelectedCells = element.selectedCells;
                                        
                                        for (i = 0, len = element.selectionPreviousSelectedCells.length; i < len; i += 1) {
                                            arrSelectedCells.splice(arrSelectedCells.indexOf(element.selectionPreviousSelectedCells[i]), 1);
                                        }
                                        
                                        element.selectedCells = arrSelectedCells;
                                    }
                                    
                                    element.dragOrigin = element.selectionPreviousOrigin;
                                    element.dragMode = 'select';
                                    
                                // else if ctrl or cmd is down and the target cell is not selected: select cells from target cell to current cell
                                } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && !closestCell.hasAttribute('selected')) {
                                    element.dragOrigin = closestCell;
                                    element.dragMode = 'select';
                                    
                                // else if ctrl or cmd is down and the target cell is selected: deselect cells from target cell to current cell
                                } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && closestCell.hasAttribute('selected')) {
                                    element.dragOrigin = closestCell;
                                    element.dragMode = 'deselect';
                                    
                                // else: deselect all cells and start new selection
                                } else {
                                    element.selectedCells = [];
                                    element.dragOrigin = closestCell;
                                    element.dragMode = 'select';
                                }
                                
                                selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                            }
                        }
                    });
                    element.addEventListener(evt.mousemove, function (event) {
                        var target, closestCell, cellFromTarget;
                        
                        // if mouse is down
                        if (event.which !== 0) {
                            target = event.target;
                            cellFromTarget = getCellFromTarget(target);
                            
                            if (cellFromTarget) {
                                closestCell = cellFromTarget;
                            } else if (target.classList.contains('fixed-header-cell')) {
                                closestCell =
                                    element.theadElement.children[0].children[xtag.toArray(target.parentNode.children).indexOf(target)];
                            }
                            
                            // if selection is allowed at this point and closestCell is different from element.dragCurrentCell
                            if (closestCell && element.dragAllowed && element.dragCurrentCell !== closestCell) {
                                element.dragCurrentCell = getCellFromTarget(closestCell);
                                selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                            }
                        } else {
                            element.dragAllowed = false;
                            element.selectionPreviousOrigin = element.dragOrigin;
                            element.selectionPreviousSelectedCells = element.selectionSelectedCells;
                        }
                    });
                    element.addEventListener(evt.mouseup, function (event) {
                        element.dragAllowed = false;
                        
                        if (element.dragMode === 'select') {
                            element.selectionPreviousOrigin = element.dragOrigin;
                            element.selectionPreviousSelectedCells = element.selectionSelectedCells;
                        }
                    });
                    
                // else we are on a touch device: record selection
                } else {
                    element.root.addEventListener(evt.mousedown, function (event) {
                        if (event.target.nodeName === 'TD' || event.target.nodeName === 'TH' || getCellFromTarget(event.target)) {
                            element.selectedCells = [];
                            
                            // if there is a parent record to the target: select all of the cells in the record
                            if (GS.findParentTag(event.target, 'tr')) {
                                element.selectedCells = GS.findParentTag(event.target, 'tr').children;
                            }
                        }
                    });
                }
                
                window.addEventListener('resize', function () {
                    element.refreshFixedHeader();
                    element.refreshHeight();
                    element.refreshReflow();
                });
                window.addEventListener('orientationchange', function () {
                    element.refreshFixedHeader();
                    element.refreshHeight();
                    element.refreshReflow();
                });
                element.addEventListener('size-changed', function (event) {
                    element.refreshFixedHeader();
                    element.refreshHeight();
                    //element.refreshReflow();
                });
                
                // key navigation
                element.addEventListener('keydown', function (event) {
                    var target = event.target, intKeyCode = event.which || event.keyCode, jsnSelection, bolCursorElement, i, len,
                        focusElement, tbodyElement, recordElement, cellElement, cellElements, tempElement;
                    
                    if (target !== element) {
                        bolCursorElement = target.nodeName === 'INPUT' || target.nodeName === 'TEXTAREA';
                        
                        if (bolCursorElement) {
                            jsnSelection = GS.getInputSelection(target);
                        } else {
                            jsnSelection = {};
                        }
                        
                        // up arrow
                        if (intKeyCode === 38) {
                            //console.log('if there is a record before this one: focus the same column in the previous record');
                            
                            cellElement = getCellFromTarget(target);
                            recordElement = cellElement.parentNode;
                            tbodyElement = recordElement.parentNode;
                            
                            if (recordElement.rowIndex > 1) { // recordIndex > 0
                                recordElement = tbodyElement.children[recordElement.rowIndex - 2];
                                
                                focusElement = xtag.query(recordElement.children[cellElement.cellIndex], '[column]')[0];
                            }
                            
                        // down arrow
                        } else if (intKeyCode === 40) {
                            //console.log('if there is another record after this one: focus the same column in the next record');
                            
                            cellElement = getCellFromTarget(target);
                            recordElement = cellElement.parentNode;
                            tbodyElement = recordElement.parentNode;
                            
                            if (recordElement.rowIndex < tbodyElement.children.length) {
                                recordElement = tbodyElement.children[recordElement.rowIndex];
                                
                                //focusElement = recordElement.children[cellElement.cellIndex].children[0];
                                focusElement = xtag.query(recordElement.children[cellElement.cellIndex], '[column]')[0];
                            }
                            
                        // if left or right arrow
                        } else if (intKeyCode === 37 || intKeyCode === 39) {
                            // left arrow and (at the beginning of the target OR target has no selected)
                            if (intKeyCode === 37 && (bolCursorElement === false || jsnSelection.start === 0)) {
                                //console.log('previous control if possible');
                                
                                cellElement = getCellFromTarget(target);
                                recordElement = cellElement.parentNode;
                                tbodyElement = recordElement.parentNode;
                                
                                cellElements = xtag.query(tbodyElement, 'tr > td, tr > th');
                                
                                // loop through previous cells looking for something focusable
                                for (i = cellElements.indexOf(cellElement) - 1; i > -1; i -= 1) {
                                    //console.log(i);
                                    
                                    tempElement = xtag.query(cellElements[i], '[column]')[0];
                                    
                                    if (tempElement && GS.isElementFocusable(tempElement)) { // tempElement.control
                                        focusElement = tempElement; // tempElement.control
                                        
                                        break;
                                    }
                                }
                                
                            // right arrow and (at the end of the target OR target has no selected)
                            } else if (intKeyCode === 39 && (bolCursorElement === false || jsnSelection.end === target.value.length)) {
                                cellElement = getCellFromTarget(target);
                                recordElement = cellElement.parentNode;
                                tbodyElement = recordElement.parentNode;
                                
                                cellElements = xtag.query(tbodyElement, 'tr > td, tr > th');
                                
                                // loop through previous cells looking for something focusable
                                for (i = cellElements.indexOf(cellElement) + 1, len = cellElements.length; i < len; i += 1) { // - 1
                                    tempElement = xtag.query(cellElements[i], '[column]')[0];
                                    
                                    if (tempElement && GS.isElementFocusable(tempElement)) { // tempElement.control
                                        focusElement = tempElement; // tempElement.control
                                        
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (focusElement && GS.isElementFocusable(focusElement)) {
                            event.preventDefault();
                            
                            focusElement.focus();
                            
                            if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                                GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
                            }
                            
                            element.selectedRecords = GS.findParentTag(focusElement, 'TR');
                        }
                    }
                });
                
                // copy event
                element.tabIndex = 0;
                document.body.addEventListener('copy', function (event) {//console.log('test');
                    var elementClosestEnvelope = GS.findParentTag(document.activeElement, 'gs-envelope'), strCopyString,
                        i, len, cell_i, cell_len, arrSelected, intFromRecord = 9999999, intFromCell = 9999999, intToRecord = 0, intToCell = 0,
                        strCellText, arrRecords, arrCells, strRecordString;
                    
                    if (elementClosestEnvelope === element &&
                        (
                            document.activeElement.classList.contains('gs-envelope-copy-focus-target') ||
                            document.activeElement.selectionStart === document.activeElement.selectionEnd
                        )) {
                        arrSelected = element.selectedCells;
                        
                        // loop through the selected cells and create a tsv string using the text of the cell
                        if (arrSelected.length > 0) {
                            for (i = 0, len = arrSelected.length; i < len; i += 1) {
                                if (arrSelected[i].parentNode.rowIndex < intFromRecord) {
                                    intFromRecord = arrSelected[i].parentNode.rowIndex;
                                }
                                if (arrSelected[i].cellIndex < intFromCell) {
                                    intFromCell = arrSelected[i].cellIndex;
                                }
                                if (arrSelected[i].parentNode.rowIndex + 1 > intToRecord) {
                                    intToRecord = arrSelected[i].parentNode.rowIndex + 1;
                                }
                                if (arrSelected[i].cellIndex + 1 > intToCell) {
                                    intToCell = arrSelected[i].cellIndex + 1;
                                }
                            }
                            
                            arrRecords = xtag.query(element.scrollContainerElement, 'tr');
                            strCopyString = '';
                            
                            for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                                arrCells = arrRecords[i].children;
                                
                                for (cell_i = intFromCell, cell_len = intToCell, strRecordString = ''; cell_i < cell_len; cell_i += 1) {
                                    if (arrCells[cell_i].hasAttribute('selected')) {
                                        if (arrCells[cell_i].lastElementChild) { 
                                            strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                                          arrCells[cell_i].lastElementChild.value ||
                                                          (arrCells[cell_i].lastElementChild.checked || '').toString();
                                        } else {
                                            strCellText = arrCells[cell_i].textContent.trim();
                                        }
                                    } else {
                                        strCellText = '';
                                    }
                                    
                                    strRecordString += (cell_i !== intFromCell ? '\t' : '') + (strCellText || '');
                                }
                                if (strRecordString.trim()) {
                                    strCopyString += strRecordString;
                                }
                                if (i + 1 !== len && strRecordString.trim()) {
                                    strCopyString += '\n';
                                }
                            }
                        }
                        
                        if (strCopyString) {
                            if (handleClipboardData(event, strCopyString)) {
                                event.preventDefault(event);
                            }
                        }
                    }
                });
                
                // getData
                refreshHud(element);
                getData(element);
            }
        }
    }
    
    xtag.register('gs-envelope', {
        lifecycle: {
            created: function () {
                //console.log(this.outerHTML);
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (strAttrName === 'template') {
                    var tableTemplateElement, tableTemplateElementCopy, recordElement, element = this, i, len;
                    tableTemplateElement  = element.templates[element.getAttribute('template') || 'default'];
                    console.log(tableTemplateElement);
                    if (!tableTemplateElement && element.hasAttribute('template')) {
                        console.warn('ENVELOPE WARNING: Hey! You used the name of a non-existant record template!');
                        tableTemplateElement = element.templates['default'];
                    }
                    console.log(tableTemplateElement);
                    
                    if (tableTemplateElement) {
                        console.log(tableTemplateElement);
                        tableTemplateElementCopy = document.createElement('template');
                        tableTemplateElementCopy.innerHTML = tableTemplateElement.innerHTML;
                        
                        recordElement = xtag.query(xtag.query(tableTemplateElementCopy.content, 'tbody')[0], 'tr')[0];
                        
                        if (recordElement) {
                            // add a data- attribute for all where columns (most of the time: id and change_stamp)
                            for (i = 0, len = element.arrWhereColumns.length; i < len; i += 1) {
                                recordElement.setAttribute('data-' + element.arrWhereColumns[i], '{{! row.' + element.arrWhereColumns[i] + ' }}');
                            }
                            
                            // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                            element.tableTemplate = GS.templateColumnToValue(tableTemplateElementCopy.innerHTML);
                        }
                    } else {
                        throw 'Envelope error: table template is required.';
                    }
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'no-hudlimit' ||
                        strAttrName === 'no-hudorderby' ||
                        strAttrName === 'no-huddelete' ||
                        strAttrName === 'no-hudrefresh') {
                        refreshHud(this);
                        
                    // this.root is here becuase of an issue where refresh was called before the envelope was initialized
                    } else if (strAttrName === 'value' && this.root) {
                        this.refresh();
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    return this.getAttribute('value');
                },
                
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                    getData(this);
                }
            },
            selectedCells: {
                get: function () {
                    return xtag.query(this.scrollContainerElement, '[selected]');
                },
                
                set: function (newValue) {
                    var i, len, intIdIndex, arrCells = xtag.query(this.scrollContainerElement, '[selected]'), arrRecords, cell_i, cell_len,
                        fixedHeaderCells = xtag.queryChildren(this.fixedHeaderContainerElement, '.fixed-header-cell');
                    
                    //console.log(arrRecords);
                    
                    // clear old selection
                    for (i = 0, len = fixedHeaderCells.length; i < len; i += 1) {
                        fixedHeaderCells[i].removeAttribute('selected');
                    }
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected');
                    }
                    
                    arrCells = xtag.query(this.scrollContainerElement, '[selected-secondary]');
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected-secondary');
                    }
                    
                    // if newValue is not an array: make it an array
                    if (typeof newValue === 'object' && newValue.length === undefined) {
                        arrCells = [newValue];
                    } else {
                        arrCells = newValue;
                    }
                    
                    // set new selection
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].setAttribute('selected', '');
                        
                        if (arrCells[i].parentNode.parentNode.nodeName === 'THEAD') {
                            fixedHeaderCells[arrCells[i].cellIndex].setAttribute('selected', '');
                        }
                    }
                    
                    arrRecords = this.selectedRecords;
                    
                    for (i = 0, len = arrRecords.length; i < len; i += 1) {
                        arrCells = arrRecords[i].children;
                        
                        for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                            if (!arrCells[cell_i].hasAttribute('selected')) {
                                arrCells[cell_i].setAttribute('selected-secondary', '');
                            }
                        }
                    }
                    
                    GS.triggerEvent(this, 'after_selection');
                }
            },
            selectedRecords: {
                get: function () {
                    var i, len, intRecordIndex = -1, arrRecord = [], selected = this.selectedCells;
                    
                    // loop through the selected cells and create an array of trs
                    for (i = 0, len = selected.length; i < len; i += 1) {
                        if (selected[i].parentNode.rowIndex > intRecordIndex && selected[i].parentNode.parentNode.nodeName !== 'THEAD') {
                            intRecordIndex = selected[i].parentNode.rowIndex;
                            
                            arrRecord.push(selected[i].parentNode);
                        }
                    }
                    
                    return arrRecord;
                },
                
                set: function (newValue) {
                    var i, len, cell_i, cell_len, intIdIndex, arrCells = this.selectedCells, arrRecords, arrCellChildren,
                        fixedHeaderCells = xtag.queryChildren(this.fixedHeaderContainerElement, '.fixed-header-cell');
                    
                    // clear old selection
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected');
                        
                        if (arrCells[i].parentNode.parentNode.nodeName === 'THEAD') {
                            fixedHeaderCells[arrCells[i].cellIndex].removeAttribute('selected', '');
                        }
                    }
                    
                    arrCells = xtag.query(this.scrollContainerElement, '[selected-secondary]');
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected-secondary');
                    }
                    
                    // if newValue is not an array: make it an array
                    if (typeof newValue === 'object' && newValue.length === undefined) {
                        arrRecords = [newValue];
                    } else {
                        arrRecords = newValue;
                    }
                    
                    // set new selection
                    for (i = 0, len = arrRecords.length, arrCells = []; i < len; i += 1) {
                        arrCellChildren = arrRecords[i].children;
                        
                        for (cell_i = 0, cell_len = arrCellChildren.length; cell_i < cell_len; cell_i += 1) {
                            arrCells.push(arrCellChildren[cell_i]);
                        }
                    }
                    
                    this.selectedCells = arrCells;
                    
                    GS.triggerEvent(this, 'after_selection');
                }
            },
            selectedIds: {
                get: function () {
                    var i, len, arrID = [], selected = this.selectedRecords;
                    
                    // loop through the selected records and create an array of ids
                    for (i = 0, len = selected.length; i < len; i += 1) {
                        arrID.push(String(selected[i].dataset.id));
                        //arrID.push(String(selected[i].parentNode.dataset.id));
                    }
                    
                    return arrID;
                },
                
                set: function (newValue) {
                    var i, len, cell_i, cell_len, arrCells = this.selectedCells, // intIdIndex,
                        arrRecords = xtag.query(this.scrollContainerElement, 'tbody > tr');
                    
                    //console.log(arrRecords);
                    
                    // clear old selection
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected');
                    }
                    
                    arrCells = xtag.query(this.scrollContainerElement, '[selected-secondary]');
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected-secondary');
                    }
                    
                    // if newValue is not an array: make it an array
                    if (typeof newValue !== 'object') {
                        newValue = [String(newValue)];
                        
                    // else: cast all new values to strings
                    } else {
                        for (i = 0, len = newValue.length; i < len; i += 1) {
                            newValue[i] = String(newValue[i]);
                        }
                    }
                    
                    // set new selection
                    for (i = 0, len = arrRecords.length; i < len; i += 1) {
                        
                        if (newValue.indexOf(arrRecords[i].getAttribute('data-id')) > -1) {//String(.dataset.id) === String()
                            arrCells = arrRecords[i].children;
                            
                            for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                                arrCells[cell_i].setAttribute('selected', '');
                            }
                        }
                    }
                    
                    GS.triggerEvent(this, 'after_selection');
                }
            }
        },
        methods: {
            // just a semantic alias to the getData function
            refresh: function () {
                getData(this);
            },
            
            refreshReflow: function () {
                var intEnvelopeWidth = this.scrollContainerElement.clientWidth + 1,
                    bolCurrentlyReflowed,
                    intWindowWidth = window.innerWidth,
                    intReflowAt = parseInt(this.getAttribute('reflow-at'), 10);
                
                if (this.reflowBreakPoint === undefined) {
                    this.reflowBreakPoint = 0;
                }
                
                //console.log('check for reflow', window.innerWidth, this.reflowBreakPoint,
                // this.scrollContainerElement.clientWidth < this.scrollContainerElement.scrollWidth);
                
                bolCurrentlyReflowed = this.classList.contains('reflow');
                this.classList.remove('reflow');
                
                //console.log(intEnvelopeWidth, this.scrollContainerElement.scrollWidth);
                //console.log('envWidth    ', intEnvelopeWidth);
                //console.log('scrollWidth ', this.scrollContainerElement.scrollWidth);
                //console.log('reflowAt    ', this.hasAttribute('reflow-at'));
                //console.log('intReflowAt ', intReflowAt);
                
                //if (intWindowWidth > this.reflowBreakPoint) {
                if ((
                        intEnvelopeWidth < this.scrollContainerElement.scrollWidth &&
                        !this.hasAttribute('reflow-at')
                    ) || 
                    (
                        !isNaN(intReflowAt) &&
                        intEnvelopeWidth < intReflowAt
                    )) {
                    if (!bolCurrentlyReflowed) {
                        this.selectedCells = [];
                    }
                    
                    this.reflowBreakPoint = intWindowWidth;
                    this.classList.add('reflow');
                    
                } else {
                    if (bolCurrentlyReflowed) {
                        this.selectedCells = [];
                    }
                    
                    this.reflowBreakPoint = 0;
                    this.classList.remove('reflow');
                }
            },
            
            refreshFixedHeader: function () {
                var elementFixedHeaderCells = xtag.queryChildren(this.fixedHeaderContainerElement, '.fixed-header-cell'),
                    theadCellElements, i, len, intLeft;
                
                if (this.theadElement && GS.getStyle(this.theadElement, 'display') !== 'none') {
                    //Why isn't this after we set the widths of the fixed header? -Joseph 10-01-15
                    this.fixedHeaderContainerElement.removeAttribute('hidden');
                    theadCellElements = xtag.query(this.theadElement, 'th, td');
                    
                    for (i = 0, len = theadCellElements.length, intLeft = 0; i < len; i += 1) {
                        elementFixedHeaderCells[i].style.height = (theadCellElements[i].offsetHeight + 1) + 'px';
                        elementFixedHeaderCells[i].style.width = theadCellElements[i].offsetWidth + 'px';
                        elementFixedHeaderCells[i].style.left = (intLeft - this.scrollContainerElement.scrollLeft) + 'px';
                        
                        intLeft += theadCellElements[i].offsetWidth;
                    }
                } else {
                    this.fixedHeaderContainerElement.setAttribute('hidden', '');
                }
            },
            
            refreshHeight: function () {
                var intHeight = 0;
                
                //console.log('1*** refreshHeight');
                
                // if this envelope is zero height: add expand to content automatically
                if (this.clientHeight === 0) {
                    this.setAttribute('expand-to-content', '');
                }
                
                //console.log('1-1*', this);
                //console.log('1-2*', this.hasAttribute('expand-to-content'));
                if (this.hasAttribute('expand-to-content')) {
                    //console.log('2***');
                    this.style.height = '';
                    
                    intHeight += this.hudTopElement.scrollHeight;
                    //console.log('3***');
                    //intHeight += this.fixedHeaderContainerElement.scrollHeight;
                    intHeight += this.scrollContainerElement.scrollHeight;
                    intHeight += this.hudBottomElement.scrollHeight;
                    //console.log('4***', intHeight);
                    
                    this.style.height = (intHeight + 5) + 'px'; // used to add 2
                    //console.log('5***', this.style.height);
                }
            }
        }
    });
});//global GS, window, ml
//jslint white:true multivar:true

window.addEventListener('design-register-element', function () {
    window.designElementProperty_GSFILEMANAGER = function(selectedElement) {
        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });
        
        addProp('Path', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('path') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'path', this.value);
        });
        
        addProp('Folder', true, '<gs-select class="target" value="' + (selectedElement.getAttribute('folder') || '') + '" mini>' +
                                    '<option value="role">Role (user files)</option>' +
                                    '<option value="web_root">Public (developer editable files)</option>' +
                                    '<option value="dev">App/Dev (developer editable files)</option>' +
                                '</gs-select>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'folder', this.value);
        });
        
        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });
    };
    
    registerDesignSnippet('<gs-file-manager>', '<gs-file-manager>', 'gs-file-manager path="${0:/}" folder="${1:role}"></gs-file-manager>');
    
    designRegisterElement('gs-file-manager', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-file-manager.html');
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    //function pushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //    
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        if (element.getAttribute('folder') === 'dev') {
    //            element.innerPath = 'app/' + GS.templateWithQuerystring(GS.trim(element.getAttribute('path'), '/') + '/');
    //        } else {
    //            element.innerPath = element.getAttribute('folder') + '/' + GS.templateWithQuerystring(GS.trim(element.getAttribute('path'), '/') + '/');
    //        }
    //        element.getFiles();
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            if (element.internal.bolQSFirstRun === true) {
                if (element.getAttribute('folder') === 'dev') {
                    element.innerPath = 'app/' + GS.templateWithQuerystring(GS.trim(element.getAttribute('path'), '/') + '/');
                } else {
                    element.innerPath = element.getAttribute('folder') + '/' +
                                        GS.templateWithQuerystring(GS.trim(element.getAttribute('path'), '/') + '/');
                }
                element.getFiles();
            }
        }

        element.internal.bolQSFirstRun = true;
    }
    
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            
        }
    }
    
    //
    function elementInserted(element) {
        var styleElement;
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);
                
                if (element.getAttribute('folder') !== 'dev' &&
                    element.getAttribute('folder') !== 'role' &&
                    element.getAttribute('folder') !== 'web_root') {
                    throw 'gs-file-manager Error: Invalid Folder. Please set the folder attribute to "dev", "role" or "web_root".';
                }
                
                if (!element.getAttribute('path')) {
                    throw 'gs-file-manager Error: Invalid Path. Please set the path attribute.';
                }
                
                // bind/handle query string
                if (element.getAttribute('qs')) {
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }
                
                if (element.getAttribute('folder') === 'dev') {
                    element.innerPath = 'app/' + GS.templateWithQuerystring(GS.trim(element.getAttribute('path'), '/') + '/');
                } else {
                    element.innerPath = element.getAttribute('folder') + '/' + GS.templateWithQuerystring(GS.trim(element.getAttribute('path'), '/') + '/');
                }
                element.getFiles();
                
                element.innerHTML = 
                    '<div class="root" gs-dynamic flex-vertical flex-fill>' +
                        '<div class="file-manager-list" gs-dynamic flex></div>' +
                        (element.hasAttribute('no-upload') ? '' : '<gs-button class="file-manager-upload" gs-dynamic>New File</gs-button>') +
                        '<iframe class="file-manager-upload-response-iframe" name="upload_response_' +
                                    (document.getElementsByClassName('file-manager-upload-response-iframe').length + 1) + '" hidden></iframe>' +
                    '</div>';
                
                element.fileListElement       = xtag.query(element, '.file-manager-list')[0];
                element.uploadButtonElement   = xtag.query(element, '.file-manager-upload')[0];
                element.responseIframeElement = xtag.query(element, '.file-manager-upload-response-iframe')[0];
                
                element.fileListElement.addEventListener('click', function (event) {
                    //console.log(event.target);
                    
                    if (event.target.classList.contains('edit-file')) {
                        element.editFile(event.target.parentNode.getAttribute('data-link'));
                        
                    } else if (event.target.classList.contains('delete-file')) {
                        element.deleteFile(event.target.parentNode.getAttribute('data-link'));
                    }
                });
                
                element.uploadButtonElement.addEventListener('click', function () {
                    element.newFile();
                });
                
                element.responseIframeElement.addEventListener('load', function (event) {
                    var strResponseText = element.responseIframeElement.contentWindow.document.body.textContent,
                        jsnResponse, strResponse, bolError, strError;
                    
                    if (element.responseIframeElement.loadListen === true) {
                        // get error text
                        try {
                            jsnResponse = JSON.parse(strResponseText);
                            
                        } catch (err) {
                            strResponse = strResponseText;
                        }
                        
                        if (jsnResponse) {
                            if (jsnResponse.stat === true) {
                                bolError = false;
                            } else {
                                bolError = true;
                                if (jsnResponse.dat && jsnResponse.dat.error) {
                                    strError = jsnResponse.dat.error;
                                } else {
                                    strError = jsnResponse.dat;
                                }
                            }
                        } else {
                            bolError = true;
                            strError = strResponse;
                        }
                        
                        // if no error destroy new file popup
                        if (!bolError) {
                            GS.closeDialog(element.currentUploadDialog, 'cancel');
                            
                        // if error open error popup
                        } else {
                            GS.msgbox('Error', strError, 'okonly');
                        }
                        
                        element.getFiles(true);
                        GS.removeLoader('file-upload');
                    }
                });
                
                //console.log(element.fileListElement, element.uploadButtonElement);
            }
        }
    }
    
    xtag.register('gs-file-manager', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'path' || strAttrName === 'folder') {
                        
                        if (this.getAttribute('folder') === 'dev') {
                            this.innerPath = 'app/' + GS.templateWithQuerystring(GS.trim(this.getAttribute('path'), '/') + '/');
                        } else {
                            this.innerPath = this.getAttribute('folder') + '/' + GS.templateWithQuerystring(GS.trim(this.getAttribute('path'), '/') + '/');
                        }
                        this.getFiles();
                    }
                }
            }
        },
        events: {},
        accessors: {
            'value': {
                get: function () {
                    return this.arrFileLinks || [];
                }
            }
        },
        methods: {
            newFile: function () {
                var element = this, templateElement = document.createElement('template');
                
                templateElement.innerHTML = ml(function () {/*
                    <gs-page>
                        <gs-header><center><h3>Upload a File</h3></center></gs-header>
                        <gs-body padded>
                            <form class="upload-form" action="/env/action_upload" method="POST" target="{{TARGETNAME}}"
                                        enctype="multipart/form-data">
                                <label>File:</label>
                                <gs-text class="upload-file" name="file_content" type="file"></gs-text>
                                <br />
                                <label>File Name:</label>
                                <gs-text class="upload-name"></gs-text><br />
                                
                                <input class="upload-path" name="file_name" hidden />
                            </form>
                        </gs-body>
                        <gs-footer>
                            <gs-grid>
                                <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                                <gs-block><gs-button class="upload-button">Upload File</gs-button></gs-block>
                            </gs-grid>
                        </gs-footer>
                    </gs-page>
                */}).replace(/\{\{TARGETNAME\}\}/gim, this.responseIframeElement.getAttribute('name'));
                
                GS.openDialog(templateElement, function () {
                    var formElement = xtag.query(this, '.upload-form')[0],
                        fileControl = xtag.query(this, '.upload-file')[0],
                        nameControl = xtag.query(this, '.upload-name')[0],
                        pathControl = xtag.query(this, '.upload-path')[0],
                        uploadButton = xtag.query(this, '.upload-button')[0];
                    
                    element.currentUploadDialog = this;
                    
                    // upload existing file
                    uploadButton.addEventListener('click', function(event) {
                        var strFile = fileControl.value, strName = nameControl.value;
                        
                        //console.log(element.innerPath + nameControl.value);
                        pathControl.setAttribute('value', element.innerPath + nameControl.value);
                        
                        if (strName === '' && strFile === '') { // no values (no file and no file name)
                            GS.msgbox('Error', 'No values in form. Please fill in the form.', 'okonly');
                            
                        } else if (strFile === '') { // one value missing (no file)
                            GS.msgbox('Error', 'No file selected. Please select a file using the file input.', 'okonly');
                            
                        } else if (strName === '') { // one value missing (no file name)
                            GS.msgbox('Error', 'No value in file path textbox. Please fill in file name textbox.', 'okonly');
                            
                        } else { // values are filled in submit the form
                            element.responseIframeElement.loadListen = true;
                            formElement.submit();
                            GS.addLoader('file-upload', 'Uploading file...');
                        }
                    });
                    
                    fileControl.addEventListener('change', function(event) {
                        var strValue = this.value;
                        
                        nameControl.value = strValue.substring(strValue.lastIndexOf('\\') + 1);
                        nameControl.focus();
                    });
                    
                    nameControl.addEventListener('keydown', function(event) {
                        if (event.keyCode === 13) {
                            GS.triggerEvent('click', uploadButton);
                        }
                    });
                });
            },
            
            editFile: function (strPath) {
                var element = this, strFolder = this.getAttribute('folder'), strLink;
                
                /*
                //console.log('editFile: ', strPath);
                if (strFolder === 'dev') {
                    strLink = '/v1/dev/developer_g/greyspots-' + GS.version() + '/tools/file_manager/file_edit.html';
                    
                } else if (strFolder === 'role') {
                    strLink = '/env/app/all/file_manager/file_edit.html';
                    
                } else {
                    strLink = '/v1/dev/developer_g/greyspots-' + GS.version() + '/tools/file_manager/file_edit.html';
                }
                */
                strLink = '/env/app/all/file_manager/file_edit.html';
                
                GS.msgbox('Update File',
                          '<gs-button jumbo dialogclose>Rename File</gs-button>' +
                          '<gs-button jumbo dialogclose href="' + strLink + '?folder=' + strFolder +
                                                                        '&link=' + encodeURIComponent(strPath) + '">' +
                              'Edit File' +
                          '</gs-button>',
                          ['Cancel'],
                          function (strAnswer) {
                    if (strAnswer === 'Rename File') {
                        element.renameFile(strPath);
                    }
                });
                
            },
            
            renameFile: function (strPath) {
                var element = this, templateElement = document.createElement('template'), strFolder = this.getAttribute('folder');
                
                //console.log('renameFile: ', strPath);
                
                templateElement.innerHTML = ml(function () {/*
                    <gs-page>
                        <gs-header><center><h3>Rename File</h3></center></gs-header>
                        <gs-body padded>
                            <label>File Name:</label>
                            <gs-text class="text-update-name" value="{{FILENAME}}"></gs-text>
                        </gs-body>
                        <gs-footer>
                            <gs-grid>
                                <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                                <gs-block><gs-button dialogclose listen-for-return bg-primary>Rename</gs-button></gs-block>
                            </gs-grid>
                        </gs-footer>
                    </gs-page>
                */}).replace('{{FILENAME}}', strPath.substring(strPath.lastIndexOf('/') + 1));
                
                GS.openDialog(templateElement, '', function (event, strAnswer) {
                    var strNewFileName;
                    
                    if (strAnswer === 'Rename') {
                        strNewFileName = xtag.query(this, '.text-update-name')[0].value;
                        
                        GS.addLoader('file-rename', 'Renaming File...');
                        GS.ajaxJSON('/env/action_file', 'action=mv_file&folder=' + strFolder +
                                        '&paths_from=' + encodeURIComponent('["' + strPath + '"]') +
                                        '&paths_to=' + encodeURIComponent('["' + strPath.substring(0, strPath.lastIndexOf('/') + 1) + strNewFileName + '"]'),
                                        function (data, error) {
                            GS.removeLoader('file-rename');
                            
                            if (!error) {
                                element.getFiles(true);
                                
                            } else {
                                GS.ajaxErrorDialog(data, function() {
                                    updateFile(strFileName);
                                });
                            }
                        });
                    }
                });
            },
            
            deleteFile: function (strPath) {
                var element = this, strFolder = this.getAttribute('folder');
                
                //console.log('deleteFile: ', strPath);
                
                GS.msgbox('Are you sure...', 'Are you sure you want to delete this file?', ['No', 'Yes'], function (strAnswer) {
                    if (strAnswer === 'Yes') {
                        GS.addLoader('file-delete', 'Deleting File...');
                        GS.ajaxJSON('/env/action_file', 'action=rm&folder=' + strFolder +
                                                         '&paths=' + encodeURIComponent('["' + strPath + '"]'),
                                                         function (data, error) {
                            GS.removeLoader('file-delete');
                            
                            if (!error) {
                                element.getFiles(true);
                                
                            } else {
                                GS.ajaxErrorDialog(data, function() {
                                    deleteFile(strFileName);
                                });
                            }
                        });
                    }
                });
            },
            
            getFiles: function (bolChange) {
                var element = this, strFolder = this.getAttribute('folder');
                
                //app,role,web_root
                
                GS.ajaxJSON('/env/action_file', 'action=list&folder=' + strFolder + '&path=' + encodeURIComponent(this.innerPath),
                                function (response, error) {
                    var i, len, strHTML = '', data, strFileName, strCurrentPath, strAnchorPath;
                    
                    if (!error && response.dat.files.length > 0) {
                        data = response.dat;
                        data.files = data.files || [];
                        data.files.sort();
                        
                        element.arrFileLinks = data.files;
                        
                        for (i = 0, len = data.files.length; i < len; i += 1) {
                            strFileName = encodeHTML(data.files[i]);
                            strCurrentPath = GS.trim(element.innerPath, '/') + '/' + strFileName;
                            
                            //if (strFolder === 'dev') {
                            //    if (strAnchorPath.indexOf('developer_g') === 0) {
                            //        strAnchorPath = encodeHTML('/v1/dev/' + strCurrentPath);
                            //    } else {
                            //        strAnchorPath = encodeHTML('/env/app/' + strCurrentPath);
                            //    }
                            //    
                            //} else if (strFolder === 'role') {
                            //    strAnchorPath = encodeHTML('/env/role/' + strCurrentPath);
                            //    
                            //} else {
                            //    strAnchorPath = encodeHTML('/' + strCurrentPath);
                            //}
                            
                            if (strFolder === 'web_root') {
                                strAnchorPath = encodeHTML('/' + strCurrentPath);
                                
                            } else {
                                strAnchorPath = encodeHTML('/v1/' + strCurrentPath);
                            }
                            
                            strHTML += 
                                '<div flex-horizontal flex-fill data-link="' + strCurrentPath + '">' +
                                    '<gs-button class="goto-file" href="' + strAnchorPath + '" remove-all flex>' + strFileName + '</gs-button>' +
                                    '<gs-button class="edit-file" icononly icon="pencil" remove-all></gs-button>' +
                                    '<gs-button class="delete-file" icononly icon="times" remove-all></gs-button>' +
                                '</div>';
                        }
                    } else {
                        element.arrFileLinks = [];
                        strHTML = '<center><span class="h1 hint">No Files</span></center>';
                    }
                    
                    if (bolChange) {
                        GS.triggerEvent(element, 'change');
                    }
                    
                    element.fileListElement.innerHTML = strHTML;
                });
            },
            
            refresh: function () {
                this.getFiles();
            }
        }
    });
});//jslint white:true, multivar:true


window.addEventListener('design-register-element', function () {
    window.designElementProperty_GSFOLDER = function(selectedElement) {
        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });
        
        addProp('Path', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('path') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'path', this.value);
        });
        
        addProp('Hide Folders', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-folders')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-folders', (this.value === 'true'), true);
        });
        
        addProp('Hide Files', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-files')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-files', (this.value === 'true'), true);
        });
        
        addProp('Side-By-Side', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('horizontal')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'horizontal', (this.value === 'true'), true);
        });
        
        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });
        
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', (this.value === 'true'), true);
        });
    };
    
    registerDesignSnippet('<gs-folder>', '<gs-folder>', 'gs-folder path="${0:/}" folder="${1:role}"></gs-folder>');
    
    designRegisterElement('gs-folder', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-folder.html');
});

(function () {
    'use strict';
    
    // #################################################################################################
    // ############################################ UTILITY ############################################
    // #################################################################################################
    
    function getPath(element) {
        var strAttributePath = GS.trim(GS.templateWithQuerystring(element.getAttribute('path') || ''), '/')
          , strInnerPath = element.arrPath.join('/'), strRet;
        
        if (strAttributePath && strInnerPath) {
            strRet = '/' + strAttributePath + '/' + strInnerPath + '/';
        } else if (strAttributePath) {
            strRet = '/' + strAttributePath + '/';
        } else if (strInnerPath) {
            strRet = '/' + strInnerPath + '/';
        }
        
        return strRet || '/';
    }
    function getRealPath(element) {
        var strAttributePath = GS.trim(GS.templateWithQuerystring(element.getAttribute('path') || ''), '/')
          , arrPath = element.arrPath, strInnerPath, strRet, strPrefix;
        
        if (element.arrPath[0] === 'app' || strAttributePath.indexOf('app') === 0) {
            strPrefix = '/env';
        } else if (element.arrPath[0] === 'role' || strAttributePath.indexOf('role') === 0) {
            strPrefix = '/env';
        } else if (element.arrPath[0] === 'web_root' || strAttributePath.indexOf('web_root') === 0) {
            strPrefix = '';
            arrPath.splice(0, 1);
        }
        
        strInnerPath = arrPath.join('/');
        
        if (strAttributePath && strInnerPath) {
            strRet = '/' + strAttributePath + '/' + strInnerPath + '/';
        } else if (strAttributePath) {
            strRet = '/' + strAttributePath + '/';
        } else if (strInnerPath) {
            strRet = '/' + strInnerPath + '/';
        }
        
        return (strPrefix || '') + (strRet || '/');
    }
    function getData(element) {
        var strPath = getPath(element)
          , bolFolders = !element.hasAttribute('no-folders')
          , bolFiles = !element.hasAttribute('no-files')
          , strHeader
          , intResponseNumber;
        
        element.folderList.innerHTML = '';
        element.fileList.innerHTML = '';
        
        strHeader = GS.trim('/' + element.arrPath.join('/'), '/');
        
        // if there is something in the header: wrap it with slashes
        if (strHeader) {
            strHeader = '/' + strHeader + '/';
        }
        
        element.pathTitle.textContent = strHeader;
        
        if (element.arrPath.length > 0) {
            element.backButton.removeAttribute('disabled');
        } else {
            element.backButton.setAttribute('disabled', '');
        }
        element.arrFile = [];
        element.arrFolder = [];
        intResponseNumber = 0;
        GS.requestFromSocket(GS.envSocket, 'FILE\tLIST\t' + GS.encodeForTabDelimited(strPath), function (data, error, errorData) {
            var arrPaths, strName, strType, arrCells, i, len, divElement
              , arrFiles = [], arrFolders = [];
            
            if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                if (data !== 'TRANSACTION COMPLETED') {
                    arrPaths = GS.trim(data, '\n').split('\n');
                    if (intResponseNumber === 0) {
                        element.folderList.innerHTML = '';
                        element.fileList.innerHTML = '';
                    }
                    
                    for (i = 0, len = arrPaths.length; i < len; i += 1) {
                        arrCells = arrPaths[i].split('\t');
                        strType = GS.decodeFromTabDelimited(arrCells[1]);
                        strName = GS.trim(GS.decodeFromTabDelimited(arrCells[0]), '/');
                        
                        if ((strType === 'folder' && bolFolders) || (strType === 'file' && bolFiles)) {
                            divElement = document.createElement('div');
                            divElement.setAttribute('flex-horizontal', '');
                            divElement.setAttribute('flex-fill', '');
                            divElement.setAttribute('class', strType + '-line');
                            divElement.setAttribute('data-name', strName);
                            
                            if (strType === 'file') {
                                arrFiles.push(element.arrPath.join('/') + '/' + strName);
                                divElement.innerHTML =
                                    '<gs-button class="more-file" icononly icon="bars" remove-right></gs-button>'
                                  + '<gs-button class="open-file" flex remove-left>' + encodeHTML(strName) + '</gs-button>';
                                
                                element.fileList.appendChild(divElement);
                            }
                            
                            if (strType === 'folder') {
                                arrFolders.push(element.arrPath.join('/') + '/' + strName);
                                divElement.innerHTML =
                                    '<gs-button class="more-folder" icononly icon="bars" remove-right></gs-button>'
                                  + '<gs-button class="open-folder" flex remove-left>' + encodeHTML(strName) + '</gs-button>';
                                
                                element.folderList.appendChild(divElement);
                            }
                        }
                    }
                    
                    element.arrFile = arrFiles;
                    element.arrFolder = arrFolders;
                    GS.triggerEvent(element, 'change');
                    
                } else {
                    if (element.folderList.innerHTML === '') {
                        element.folderList.innerHTML = '<center prevent-text-selection><h4><small>No Folders.</small></h4></center>';
                    }
                    
                    if (element.fileList.innerHTML === '') {
                        element.fileList.innerHTML = '<center prevent-text-selection><h4><small>No Files.</small></h4></center>';
                    }
                }
            } else if (error) {
                if (!element.hasAttribute('no-list-error')) {
                    GS.webSocketErrorDialog(errorData);
                }
            }
            
            intResponseNumber += 1;
        });
    }
    
    function prepareElement(element) {
        var bolFolders = !element.hasAttribute('no-folders')
          , bolFiles = !element.hasAttribute('no-files');
        
        element.innerHTML = ml(function () {/*
            <div class="root" flex-vertical flex-fill gs-dynamic>
                <span class="path-title"></span>
                <div class="list-container" flex-fill>
                    <div class="folder-list-container" flex-vertical flex-fill flex>
                        <div class="folder-list-header" flex-horizontal>
                            <b flex prevent-text-selection>Folders:</b>
                            <gs-button class="button-back-folder" icon="long-arrow-left" icononly remove-bottom disabled no-focus></gs-button>
                            <gs-button class="button-new-folder" icon="plus" icononly remove-bottom no-focus></gs-button>
                        </div>
                        <div class="folder-list" flex></div>
                    </div>
                    <div class="file-list-container" flex-vertical flex-fill flex>
                        <div class="file-list-header" flex-horizontal>
                            <b flex prevent-text-selection>Files:</b>
                            <gs-button class="button-new-file" icon="plus" icononly remove-bottom no-focus></gs-button>
                            <gs-button class="button-upload-file" icon="upload" icononly remove-bottom no-focus></gs-button>
                        </div>
                        <div class="file-list" flex></div>
                    </div>
                </div>
            </div>
        */});
        //remove-right
        //remove-left
        
        element.root             = xtag.queryChildren(element, '.root')[0];
        element.folderListHeader = xtag.query(element.root, '.folder-list-header')[0];
        element.fileListHeader   = xtag.query(element.root, '.file-list-header')[0];
        
        element.folderList       = xtag.query(element.root, '.folder-list')[0];
        element.fileList         = xtag.query(element.root, '.file-list')[0];
        
        element.newFolderButton  = xtag.query(element.root, '.button-new-folder')[0];
        element.newFileButton    = xtag.query(element.root, '.button-new-file')[0];
        element.uploadFileButton = xtag.query(element.root, '.button-upload-file')[0];
        element.backButton       = xtag.query(element.root, '.button-back-folder')[0];
        
        element.pathTitle        = xtag.query(element.root, '.path-title')[0];
        
        element.arrPath = [];
    }
    
    //function pushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //    
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        getData(element);
    //    }
    //}
    
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol && strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun === true && GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                //console.trace(element, 'test');
                getData(element);
            }
        }

        element.internal.bolQSFirstRun = true;
    }
    
    function bindElement(element) {
        if (element.hasAttribute('qs')) {
            pushReplacePopHandler(element);
            window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
            window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
            window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
        }
        
        element.addEventListener('click', function (event) {
            var target = event.target;
            
            if (target.classList.contains('button-new-folder')) {
                newFolder(element, target);
                
            } else if (target.classList.contains('button-new-file')) {
                newFile(element, target);
                
            } else if (target.classList.contains('open-file')) {
                fileOpen(element, target);
                
            } else if (target.classList.contains('open-folder')) {
                folderOpen(element, target);
                
            } else if (target.classList.contains('button-back-folder')) {
                backFolder(element, target);
                
            } else if (target.classList.contains('more-folder')) {
                folderMenu(element, target);
                
            } else if (target.classList.contains('more-file')) {
                fileMenu(element, target);
                
            } else if (target.classList.contains('button-upload-file')) {
                fileUpload(element, target);
            }
        });
    }
    
    
    // ################################################################################################
    // ####################################### FOLDER FUNCTIONS #######################################
    // ################################################################################################
    
    function folderMenu(element, target) {
        'use strict';
        var lineElement = GS.findParentElement(target, '.folder-line')
          , strFolderName = lineElement.getAttribute('data-name')
          , strPath = (getPath(element) + strFolderName)
          , templateElement = document.createElement('template');
        
        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <gs-button dialogclose remove-bottom style="border-bottom: 0 none;">Rename Folder</gs-button>
                <gs-button dialogclose remove-top>Delete Folder</gs-button>
                <hr />
                <gs-button dialogclose>Cancel</gs-button>
            </gs-body>
        */});
        
        GS.openDialogToElement(target, templateElement, 'right', '', function (event, strAnswer) {
            if (strAnswer === 'Rename Folder') {
                folderRename(element, target, strPath, strFolderName);
                
            } else if (strAnswer === 'Delete Folder') {
                folderDelete(element, target, strPath, strFolderName);
            }
        });
    }
    
    function folderRename(element, target, strOldPath, strFolderName) {
        'use strict';
        var templateElement = document.createElement('template');
        
        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <label for="gs-file-manager-text-folder-name">Folder Name:</label>
                <gs-text id="gs-file-manager-text-folder-name"></gs-text>
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Rename</gs-button></gs-block>
                </gs-grid>
            </gs-body>
        */});
        
        GS.openDialogToElement(target, templateElement, 'right', function () {
            document.getElementById('gs-file-manager-text-folder-name').value = strFolderName;
            
        }, function (event, strAnswer) {
            var strNewPath;
            
            if (strAnswer === 'Rename') {
                strNewPath = getPath(element) + document.getElementById('gs-file-manager-text-folder-name').value;
                
                //console.log('strOldPath:', strOldPath);
                //console.log('strNewPath:', strNewPath);
                
                GS.requestFromSocket(GS.envSocket
                                   , 'FILE\tMOVE\t' + GS.encodeForTabDelimited(strOldPath) + '\t' +
                                                      GS.encodeForTabDelimited(strNewPath) + '\n'
                                   , function (data, error, errorData) {
                    if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                        if (data === 'TRANSACTION COMPLETED') {
                            getData(element);
                        }
                    } else if (error) {
                        GS.webSocketErrorDialog(errorData);
                    }
                });
            }
        });
    }
    
    function folderDelete(element, target, strPath, strFolderName) {
        'use strict';
        var templateElement = document.createElement('template');
        
        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                Are you sure you want to delete the folder: "<b>{{STRPATH}}</b>"?
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose remove-right style="border-right: 0 none;">No</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Yes</gs-button></gs-block>
                </gs-grid>
            </gs-body>
        */}).replace(/\{\{STRPATH\}\}/gi, strFolderName);
        
        GS.openDialogToElement(target, templateElement, 'right', '', function (event, strAnswer) {
            if (strAnswer === 'Yes') {
                //console.log('Delete:', strPath);
                
                GS.requestFromSocket(GS.envSocket
                                   , 'FILE\tDELETE\t' + GS.encodeForTabDelimited(strPath) + '\n'
                                   , function (data, error, errorData) {
                    if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                        if (data === 'TRANSACTION COMPLETED') {
                            getData(element);
                        }
                    } else if (error) {
                        GS.webSocketErrorDialog(errorData);
                    }
                });
            }
        });
    }
    
    function newFolder(element, target) {
        'use strict';
        var templateElement = document.createElement('template');
        
        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <label for="gs-file-manager-text-folder-name">New Folder Name:</label>
                <gs-text id="gs-file-manager-text-folder-name"></gs-text>
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Create</gs-button></gs-block>
                </gs-grid>
            </gs-body>
        */});
        
        GS.openDialogToElement(target, templateElement, 'down', '', function (event, strAnswer) {
            var strPath;
            
            if (strAnswer === 'Create') {
                strPath = getPath(element) + document.getElementById('gs-file-manager-text-folder-name').value;
                //console.log('Create:', strPath);
                
                GS.requestFromSocket(GS.envSocket
                                   , 'FILE\tCREATE_FOLDER\t' + GS.encodeForTabDelimited(strPath) + '\n'
                                   , function (data, error, errorData) {
                    if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                        if (data === 'TRANSACTION COMPLETED') {
                            getData(element);
                        }
                    } else if (error) {
                        GS.webSocketErrorDialog(errorData);
                    }
                });
            }
        });
    }
    
    function folderOpen(element, target) {
        'use strict';
        var lineElement = GS.findParentElement(target, '.folder-line');
        
        element.arrPath.push(lineElement.getAttribute('data-name'));
        getData(element);
    }
    
    function backFolder(element, target) {
        'use strict';
        element.arrPath.pop();
        getData(element);
    }
    
    // ################################################################################################
    // ######################################## FILE FUNCTIONS ########################################
    // ################################################################################################
    
    function fileMenu(element, target) {
        'use strict';
        var lineElement = GS.findParentElement(target, '.file-line')
          , strFileName = lineElement.getAttribute('data-name')
          //, intPeriodIndex = strFileName.indexOf('.')
          //, strFileExtension = strFileName.substring(intPeriodIndex)
          , strPath = getPath(element) + strFileName
          , templateElement = document.createElement('template');
        
        //console.log(strFileExtension);
        
        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <gs-button dialogclose remove-bottom style="border-bottom: 0 none;">Rename File</gs-button>
                <gs-button dialogclose remove-all style="border-bottom: 0 none;">Delete File</gs-button>
                <gs-button dialogclose remove-top>Edit File</gs-button>
                <hr />
                <gs-button dialogclose>Cancel</gs-button>
            </gs-body>
        */});
        
        GS.openDialogToElement(target, templateElement, 'right', '', function (event, strAnswer) {
            if (strAnswer === 'Rename File') {
                fileRename(element, target, strPath, strFileName);
                
            } else if (strAnswer === 'Delete File') {
                fileDelete(element, target, strPath, strFileName);
                
            } else if (strAnswer === 'Edit File') {
                fileEdit(element, target, strPath, strFileName);
            }
        });
    }
    
    function fileRename(element, target, strOldPath, strFileName) {
        'use strict';
        var templateElement = document.createElement('template');
        
        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <label for="gs-file-manager-text-file-name">File Name:</label>
                <gs-text id="gs-file-manager-text-file-name"></gs-text>
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Rename</gs-button></gs-block>
                </gs-grid>
            </gs-body>
        */});
        
        GS.openDialogToElement(target, templateElement, 'right', function () {
            document.getElementById('gs-file-manager-text-file-name').value = strFileName;
            
        }, function (event, strAnswer) {
            var strNewPath;
            
            if (strAnswer === 'Rename') {
                strNewPath = getPath(element) + document.getElementById('gs-file-manager-text-file-name').value;
                
                //console.log('strOldPath:', strOldPath);
                //console.log('strNewPath:', strNewPath);
                
                GS.requestFromSocket(GS.envSocket
                                   , 'FILE\tMOVE\t' + GS.encodeForTabDelimited(strOldPath) + '\t' +
                                                      GS.encodeForTabDelimited(strNewPath) + '\n'
                                   , function (data, error, errorData) {
                    if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                        if (data === 'TRANSACTION COMPLETED') {
                            getData(element);
                        }
                    } else if (error) {
                        GS.webSocketErrorDialog(errorData);
                    }
                });
            }
        });
    }
    
    function fileDelete(element, target, strPath, strFileName) {
        'use strict';
        var templateElement = document.createElement('template');
        
        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                Are you sure you want to delete the file: "<b>{{STRPATH}}</b>"?
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>No</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Yes</gs-button></gs-block>
                </gs-grid>
            </gs-body>
        */}).replace(/\{\{STRPATH\}\}/gi, strFileName);
        
        GS.openDialogToElement(target, templateElement, 'right', '', function (event, strAnswer) {
            if (strAnswer === 'Yes') {
                //console.log('Delete:', strPath);
                
                GS.requestFromSocket(GS.envSocket
                                   , 'FILE\tDELETE\t' + GS.encodeForTabDelimited(strPath) + '\n'
                                   , function (data, error, errorData) {
                    if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                        if (data === 'TRANSACTION COMPLETED') {
                            getData(element);
                        }
                    } else if (error) {
                        GS.webSocketErrorDialog(errorData);
                    }
                });
            }
        });
    }
    
    function fileEdit(element, target, strPath, strFileName) {
        'use strict';
        window.open('/env/app/all/file_manager/file_edit.html?socket=true&link=' + encodeURIComponent(strPath));
    }
    
    function newFile(element, target) {
        'use strict';
        var templateElement = document.createElement('template');
        
        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <label for="gs-file-manager-text-file-name">New File Name:</label>
                <gs-text id="gs-file-manager-text-file-name"></gs-text>
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Create</gs-button></gs-block>
                </gs-grid>
            </gs-body>
        */});
        
        GS.openDialogToElement(target, templateElement, 'down', '', function (event, strAnswer) {
            var strPath;
            var strName = document.getElementById('gs-file-manager-text-file-name').value || '';
            
            //console.log('Name:', strName);
            
            if (strAnswer === 'Create' && strName) {
                strPath = getPath(element) + strName;
                //console.log('Create:', strPath);
                
                if (document.getElementById('gs-file-manager-text-file-name').value.trim()) {
                    GS.requestFromSocket(GS.envSocket
                                       , 'FILE\tCREATE_FILE\t' + GS.encodeForTabDelimited(strPath) + '\n'
                                       , function (data, error, errorData) {
                        if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                            if (data === 'TRANSACTION COMPLETED') {
                                getData(element);
                            }
                        } else if (error) {
                            GS.webSocketErrorDialog(errorData);
                        }
                    });
                }
            }
        });
    }
    
    function fileOpen(element, target) {
        'use strict';
        var lineElement = GS.findParentElement(target, '.file-line');
        
        window.open(location.protocol + '//' + location.host + getRealPath(element) + '' + lineElement.getAttribute('data-name'));
    }
    
    function fileUpload(element, target) {
        var templateElement = document.createElement('template');
        var strHTML;
        
        strHTML = ml(function () {/*
            <gs-page>
                <gs-header><center><h3>Upload a File</h3></center></gs-header>
                <gs-body padded>
                    <form class="upload-form" action="/env/upload" method="POST" target="upload_response_gs_folder"
                                enctype="multipart/form-data">
                        <label>File:</label>
                        <gs-text class="upload-file" name="file_content" type="file"></gs-text>
                    */});
        
        if (element.hasAttribute('upload-choose-file-name')) {
            strHTML += ml(function () {/*
                        <br />
                        <label>File Name:</label>
                        <gs-text class="upload-name" disabled autocorrect="off" autocapitalize="off" autocomplete="off" spellcheck="false"></gs-text>
            */});
        } else {
            strHTML += ml(function () {/*
                        <gs-text class="upload-name" hidden></gs-text>
            */});
        }
        
        strHTML +=  ml(function () {/*
                        <input class="upload-path" name="file_name" hidden />
                    </form>
                    <iframe class="upload-frame" name="upload_response_gs_folder" hidden></iframe>
                </gs-body>
                <gs-footer>
                    <gs-grid>
                        <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                        <gs-block><gs-button class="upload-button">Upload File</gs-button></gs-block>
                    </gs-grid>
                </gs-footer>
            </gs-page>
        */});

        templateElement.innerHTML = strHTML;

        GS.openDialog(templateElement, function () {
            var dialog = this,
                formElement = xtag.query(dialog, '.upload-form')[0],
                fileControl = xtag.query(dialog, '.upload-file')[0],
                nameControl = xtag.query(dialog, '.upload-name')[0],
                pathControl = xtag.query(dialog, '.upload-path')[0],
                uploadButton = xtag.query(dialog, '.upload-button')[0],
                responseFrame = xtag.query(dialog, '.upload-frame')[0],
                strFileExtension;
            
            // upload existing file
            uploadButton.addEventListener('click', function(event) {
                var strFile = fileControl.value
                  , strName = nameControl.value;
                
                //console.log(element.innerPath + nameControl.value);
                pathControl.setAttribute('value', getPath(element) + nameControl.value + '.' + strFileExtension);
                
                if (strName === '' && strFile === '') { // no values (no file and no file name)
                    GS.msgbox('Error', 'No values in form. Please fill in the form.', 'okonly');
                    
                } else if (strFile === '') { // one value missing (no file)
                    GS.msgbox('Error', 'No file selected. Please select a file using the file input.', 'okonly');
                    
                } else if (strName === '') { // one value missing (no file name)
                    GS.msgbox('Error', 'No value in file path textbox. Please fill in file name textbox.', 'okonly');
                    
                } else { // values are filled in submit the form
                    responseFrame.loadListen = true;
                    formElement.submit();
                    GS.addLoader('file-upload', 'Uploading file...');
                }
            });
            
            fileControl.addEventListener('change', function(event) {
                var strValue = this.value;
                
                strFileExtension = strValue.substring(strValue.lastIndexOf('.') + 1);
                
                nameControl.removeAttribute('disabled');
                nameControl.value = strValue.substring(strValue.lastIndexOf('\\') + 1, strValue.lastIndexOf('.')) || 'filename';
                nameControl.focus();
            });
            
            nameControl.addEventListener('keydown', function(event) {
                if (event.keyCode === 13) {
                    GS.triggerEvent('click', uploadButton);
                }
            });
            
            // response frame binding
            responseFrame.addEventListener('load', function (event) {
                var strResponseText = responseFrame.contentWindow.document.body.textContent,
                    jsnResponse, strResponse, bolError, strError;
                
                if (responseFrame.loadListen === true) {
                    // get error text
                    try {
                        jsnResponse = JSON.parse(strResponseText);
                        
                    } catch (err) {
                        strResponse = strResponseText;
                    }
                    
                    if (strResponse.trim() === 'Upload Succeeded') {
                        GS.closeDialog(dialog, 'cancel');
                    } else {
                        if (jsnResponse) {
                            if (jsnResponse.stat === true) {
                                bolError = false;
                            } else {
                                bolError = true;
                                if (jsnResponse.dat && jsnResponse.dat.error) {
                                    strError = jsnResponse.dat.error;
                                } else {
                                    strError = jsnResponse.dat;
                                }
                            }
                        } else {
                            bolError = true;
                            strError = strResponse;
                        }
                        
                        // if no error destroy new file popup
                        if (!bolError) {
                            GS.closeDialog(dialog, 'cancel');
                            
                        // if error open error popup
                        } else {
                            GS.msgbox('Error', strError, 'okonly');
                        }
                    }
                    
                    getData(element);
                    GS.removeLoader('file-upload');
                }
            });
        });
    }
    
    // ################################################################################################
    // ############################################# XTAG #############################################
    // ################################################################################################
    
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);
                
                prepareElement(element);
                bindElement(element);
                
                //// if no "qs" set or "qs" key set in query string <- non-standard behaviour, you could want 
                //if ((!element.hasAttribute('qs') || GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs')))) {
                //    getData(element);
                //}
                
                getData(element);
                //pushReplacePopHandler(element);
            }
        }
    }
    
    xtag.register('gs-folder', {
        lifecycle: {
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    
                }
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
}());
window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('<gs-font>', '<gs-font>', 'gs-font min-width="${1}">\n' +
                                                    '    ${0}\n' +
                                                    '</gs-font>');
    
    designRegisterElement('gs-font', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-font.html');
    
    window.designElementProperty_GSFONT = function (selectedElement) {
        addProp('Min-Width Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('min-width') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'min-width', this.value);
        });
        
        addProp('Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('media') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'media', this.value);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
        
        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var arrTakenFonts = [];
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            
        }
    }
    
    //
    function elementInserted(element) {
        var styleElement;
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
                // if the style element for the container CSS doesn't exist: create it
                if (!document.getElementById('gs-dynamic-css')) {
                    styleElement = document.createElement('style');
                    styleElement.setAttribute('id', 'gs-dynamic-css');
                    styleElement.setAttribute('gs-dynamic', '');
                    document.head.appendChild(styleElement);
                }
                
                if (element.getAttribute('min-width')) {
                    element.handleMinWidthCSS();
                } else if (element.getAttribute('media')) {
                    element.handleMediaCSS();
                }
            }
        }
    }
    
    xtag.register('gs-font', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // if the "min-width" attribute changed
                    if (strAttrName === 'min-width') {
                        this.handleMinWidthCSS();
                        
                    // if the "media" attribute changed
                    } else if (strAttrName === 'media') {
                        this.handleMediaCSS();
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            handleMinWidthCSS: function () {
                var strMinWidth = this.getAttribute('min-width'), arrMinWidths, strCSS, i, len, arrClassesToRemove, intContainerID,
                    arrParts, strMedia, strResult;
                
                // remove old classes
                arrClassesToRemove = String(this.classList).match(/font-id-[0-9]*/g) || [];
                
                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }
                
                // all {15px}; lrg {25px};
                // all {15px}; lrg {25px};
                // all {20px}; sml {25px}; med {30px}; lrg {35px};
                
                // all close curly braces, remove all whitespace, lowercase, trim off semicolons
                strMinWidth = GS.trim(strMinWidth.replace(/\}/g, '').replace(/\s+/g, '').toLowerCase(), ';');
                
                // replace shortcuts (lrg => 1200px)
                strMinWidth = strMinWidth.replace(/all/g, '0px')
                                         .replace(/small|sml/g, '768px')
                                         .replace(/medium|med/g, '992px')
                                         .replace(/large|lrg/g, '1200px');
                
                arrMinWidths = strMinWidth.split(';'); // seperate out layouts
                
                //console.log(strMinWidth, arrMinWidths);
                
                if (arrTakenFonts.indexOf(strMinWidth) === -1) {
                    arrTakenFonts.push(strMinWidth);
                    intContainerID = arrTakenFonts.length - 1;
                    strCSS = '';
                    
                    for (i = 0, len = arrMinWidths.length; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strMedia = arrParts[0];
                        strResult = arrParts[1];
                        
                        strCSS +=   '\n@media (min-width:' + strMedia + ') {\n' +
                                    '    gs-font.font-id-' + intContainerID + ' { font-size:' + strResult + '; }\n' +
                                    '}\n';
                    }
                    
                    //console.log(strCSS);
                    
                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* font #' + intContainerID + ' */\n' + strCSS;
                    
                } else {
                    intContainerID = arrTakenFonts.indexOf(strMinWidth);
                }
                
                this.classList.add('font-id-' + intContainerID);
            },
            
            handleMediaCSS: function () {
                var strMedia = this.getAttribute('media'), arrMedias, strCSS, i, len,
                    arrClassesToRemove, arrParts, strCurrentMedia, strWidth, intContainerID;
                
                // remove old classes
                arrClassesToRemove = String(this.classList).match(/font-id-[0-9]*/g) || [];
                
                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }
                
                // print {20px}; all and (max-width: 500px) {20px}; (min-width: 500px) {25px};
                
                // trim, remove all close curly braces, lowercase, trim off semicolons
                strMedia = GS.trim(strMedia.trim().replace(/\}/g, '').toLowerCase(), ';');
                
                // replace shortcuts (lrg => 1200px)
                strMedia = strMedia.replace(/all/g, '0px')
                                   .replace(/small|sml/g, '768px')
                                   .replace(/medium|med/g, '992px')
                                   .replace(/large|lrg/g, '1200px');
                
                arrMedias = strMedia.split(';'); // seperate out layouts
                
                //console.log(strMedia, arrMedias);
                
                if (arrTakenFonts.indexOf(strMedia) === -1) {
                    arrTakenFonts.push(strMedia);
                    intContainerID = arrTakenFonts.length - 1;
                    strCSS = '';
                    
                    
                    for (i = 0, len = arrMedias.length; i < len; i += 1) {
                        arrParts = arrMedias[i].split('{');
                        strCurrentMedia = arrParts[0].trim() || 'all';
                        strWidth = arrParts[1].trim() || '900px';
                        
                        strCSS +=   '\n@media ' + strCurrentMedia + ' {\n' +
                                    '    gs-font.font-id-' + intContainerID + ' ' +
                                                '{ font-size: ' + strWidth + '; }\n' +
                                    '}\n';
                    }
                    
                    //console.log(strCSS);
                    
                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* font #' + intContainerID + ' */\n' + strCSS;
                    
                } else {
                    intContainerID = arrTakenFonts.indexOf(strMinWidth);
                }
                
                this.classList.add('font-id-' + intContainerID);
            }
        }
    });
});//global registerDesignSnippet, designRegisterElement, window, addProp, addFlexContainerProps, addFlexProps, document, xtag

window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet('<gs-footer>', '<gs-footer>', 'gs-footer>$0</gs-footer>');

    designRegisterElement('gs-footer', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-page.html');

    window.designElementProperty_GSFOOTER = function (selectedElement) {
        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true,
                '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                '    <option value="">Visible</option>' +
                '    <option value="hidden">Invisible</option>' +
                '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                '    <option value="hide-on-phone">Invisible at phone size</option>' +
                '    <option value="show-on-desktop">Visible at desktop size</option>' +
                '    <option value="show-on-tablet">Visible at tablet size</option>' +
                '    <option value="show-on-phone">Visible at phone size</option>' +
                '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        addFlexContainerProps(selectedElement);
        //addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    xtag.register('gs-footer', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
});//jslint white:true miltivar:true
window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('<gs-form>', '<gs-form>', 'gs-form src="${1:test.tpeople}">\n' +
                                                    '    <template>\n' +
                                                    '        ${2}\n' +
                                                    '    </template>\n' +
                                                    '</gs-form>');
    
    designRegisterElement('gs-form', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-form.html');
    
    window.designElementProperty_GSFORM = function (selectedElement) {
        addProp('Source', true, '<gs-memo class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('src') ||
                                                                                        selectedElement.getAttribute('source') || '')) + '" mini></gs-memo>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
        });
        
        addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
        });
        
        addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('where') || '')) + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'where', encodeURIComponent(this.value));
        });
        
        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });
        
        addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
        });
        
        addProp('Limit', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
        });
        
        addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
        });
        
        addProp('Save&nbsp;While&nbsp;Typing', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('save-while-typing')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'save-while-typing', (this.value === 'true'), true);
        });
        
        addProp('Suppress<br />"No&nbsp;Record&nbsp;Found"<br />Error', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suppress-no-record-found')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suppress-no-record-found', (this.value === 'true'), true);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
            this.removeAttribute('refresh-on-querystring-change');
            return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
        });
        
        addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
            this.removeAttribute('refresh-on-querystring-values');
            return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
        });
        
        addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    function triggerAfterUpdate(element) {
        GS.triggerEvent(element, 'after_update');
        if (element.hasAttribute('afterupdate')) {
            new Function(element.getAttribute('afterupdate')).apply(element);
        }
    }
    
    // ##################################################################
    // ######################## UPDATE FUNCTIONS ########################
    // ##################################################################
    
    function emergencyUpdate(element) {
        if (element.currentSaveAjax) {
            element.currentSaveAjax.abort();
        }
        element.bolCurrentlySaving = false;
        updateDataWithoutTemplate(element, false);
    }
    
    function updateData(element, updateElement, strColumn, newValue) {
        if (window.bolSocket === true) {
            var data, parentRecord, strID, strHash
              , srcParts = GS.templateWithQuerystring(element.getAttribute('src')).split('.')
              , strSchema = srcParts[0]
              , strObject = srcParts[1]
              , strReturnCols = element.arrColumns.join('\t')
              , strHashCols = element.lockColumn
              , updateFrameData, strRoles, strColumns, arrTotalRecords = [];
            
            parentRecord = GS.findParentElement(updateElement, '.form-record');
            
            strID = parentRecord.getAttribute('data-id');
            strHash = CryptoJS.MD5(parentRecord.getAttribute('data-' + element.lockColumn)).toString();
            
            strRoles   = 'pk\thash\tset';
            strColumns = 'id\thash\t' + GS.encodeForTabDelimited(strColumn);
            updateFrameData = strID + '\t' + strHash + '\t' + GS.encodeForTabDelimited(newValue);
            
            updateFrameData = (strRoles + '\n' + strColumns + '\n' + updateFrameData);
            GS.triggerEvent(element, 'before_update');
            
            GS.requestUpdateFromSocket(
                GS.envSocket, strSchema, strObject
              , strReturnCols, strHashCols, updateFrameData
                
              , function (data, error, transactionID) {
                    if (error) {
                        getData(element);
                        GS.removeLoader(element);
                        GS.webSocketErrorDialog(data);
                    }
                }
              , function (data, error, transactionID, commitFunction, rollbackFunction) {
                    GS.removeLoader(element);
                    
                    if (!error) {
                        if (data === 'TRANSACTION COMPLETED') {
                            commitFunction();
                        } else {
                            var arrRecords, arrCells, i, len, cell_i, cell_len;
                            
                            arrRecords = GS.trim(data, '\n').split('\n');
                            
                            for (i = 0, len = arrRecords.length; i < len; i += 1) {
                                arrCells = arrRecords[i].split('\t');
                                
                                for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                                    arrCells[cell_i] = GS.decodeFromTabDelimited(arrCells[cell_i]);
                                }
                                
                                arrTotalRecords.push(arrCells);
                            }
                        }
                        
                    } else {
                        rollbackFunction();
                        getData(element);
                        GS.webSocketErrorDialog(data);
                    }
                }
              , function (strAnswer, data, error) {
                    GS.removeLoader(element);
                    
                    if (!error) {
                        if (strAnswer === 'COMMIT') {
                            var idIndex, i, len;
                            
                            idIndex = element.lastSuccessData.arr_column.indexOf('id');
                            
                            for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                                if (String(element.lastSuccessData.dat[i][idIndex]) === strID) {
                                    element.lastSuccessData.dat[i] = arrTotalRecords[0];
                                    break;
                                }
                            }
                            
                            triggerAfterUpdate(element);
                            handleData(element, element.lastSuccessData);
                            
                            GS.triggerEvent(element, 'after_update');
                        } else {
                            getData(element);
                        }
                    } else {
                        getData(element);
                        GS.webSocketErrorDialog(data);
                    }
                }
            );
        } else {
            var data, strLink, parentRecordElement, strID,
                strSource = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') ||
                                                                        element.getAttribute('source') || ''));
            
            strLink = '/' + (element.getAttribute('action-update') || 'env/action_update') + '?src=' + encodeURIComponent(strSource);
            
            parentRecordElement = GS.findParentElement(updateElement, '.form-record');
            
            strID = parentRecordElement.getAttribute('data-id');
            
            strLink +=  '&where=' + encodeURIComponent(
                                        'id=' + strID +
                                       '&' + element.lockColumn + '=' + parentRecordElement.getAttribute('data-' + element.lockColumn)
                                    ) +
                        '&column=' + strColumn +
                        '&value=' +  encodeURIComponent(newValue);
            
            GS.triggerEvent(element, 'before_update');
            // run ajax
            GS.dataFetch(strLink, true);
            
            // when the ajax is finished
            document.addEventListener('dataready_' + encodeURIComponent(strLink), function __THIS_FUNCTION__(event) {
                var idIndex, i, len;
                
                if (!event.detail.error) {
                    idIndex = element.lastSuccessData.arr_column.indexOf('id');
                    
                    for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                        if (String(element.lastSuccessData.dat[i][idIndex]) === strID) {
                            element.lastSuccessData.dat[i] = event.detail.response;
                            break;
                        }
                    }
                    
                    //element.lastSuccessData.dat[0] = event.detail.response;
                    triggerAfterUpdate(element);
                    handleData(element, element.lastSuccessData);
                } else {
                    GS.ajaxErrorDialog(event.detail.response);
                }
                
                document.removeEventListener('dataready_' + encodeURIComponent(strLink), __THIS_FUNCTION__);
            });
        }
    }
    
    function updateDataWithoutTemplate(element, bolErrorHandling) {
        if (window.bolSocket === true) {
            if (element.bolCurrentlySaving === false && !element.bolErrorOpen) {
                var data, parentRecord, strID, strHash
                  , srcParts = GS.templateWithQuerystring(element.getAttribute('src')).split('.')
                  , strSchema = srcParts[0]
                  , strObject = srcParts[1]
                  , strReturnCols = element.arrColumns.join('\t')
                  , strHashCols = element.lockColumn
                  , updateFrameData, strRoles, strColumns, arrTotalRecords = [];
                
                functionUpdateRecord = function (strID, strColumn, recordIndex, strParameters) {
                    var strWhere, strChangeStamp, strValue;
                    
                    element.bolCurrentlySaving = true;
                    element.jsnUpdate[strID][strColumn] = undefined;
                    
                    // run ajax
                    removeMessage(element, 'waiting');
                    addMessage(element, 'saving');
                    element.state = 'saving';
                    
                    strWhere        = GS.qryGetVal(strParameters, 'where');
                    strColumn       = GS.qryGetVal(strParameters, 'column');
                    strValue        = GS.qryGetVal(strParameters, 'value');
                    
                    strID           = GS.qryGetVal(strWhere,      'id');
                    strChangeStamp  = GS.qryGetVal(strWhere,      element.lockColumn);
                    
                    strHash = CryptoJS.MD5(strChangeStamp).toString();
                    
                    //parentRecord = GS.findParentElement(updateElement, '.form-record');
                    
                    strRoles   = 'pk\thash\tset';
                    strColumns = 'id\thash\t' + GS.encodeForTabDelimited(strColumn);
                    updateFrameData = strID + '\t' + strHash + '\t' + GS.encodeForTabDelimited(strValue);
                    
                    updateFrameData = (strRoles + '\n' + strColumns + '\n' + updateFrameData);
                    
                    
                    
                    console.log(strParameters);
                    console.log(updateFrameData);
                    console.log(strSchema, strObject, strReturnCols, strHashCols);
                    
                    GS.requestUpdateFromSocket(
                        GS.envSocket, strSchema, strObject
                      , strReturnCols, strHashCols, updateFrameData
                        
                      , function (data, error, transactionID) {
                            if (error) {
                                getData(element);
                                GS.removeLoader(element);
                                GS.webSocketErrorDialog(data);
                            }
                        }
                      , function (data, error, transactionID, commitFunction, rollbackFunction) {
                            GS.removeLoader(element);
                            
                            if (!error) {
                                if (data === 'TRANSACTION COMPLETED') {
                                    commitFunction();
                                } else {
                                    var arrRecords, arrCells, i, len, cell_i, cell_len;
                                    
                                    arrRecords = GS.trim(data, '\n').split('\n');
                                    
                                    for (i = 0, len = arrRecords.length; i < len; i += 1) {
                                        arrCells = arrRecords[i].split('\t');
                                        
                                        for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                                            arrCells[cell_i] = GS.decodeFromTabDelimited(arrCells[cell_i]);
                                        }
                                        
                                        arrTotalRecords.push(arrCells);
                                    }
                                }
                                
                            } else {
                                rollbackFunction();
                                getData(element);
                                GS.webSocketErrorDialog(data);
                            }
                        }
                      , function (strAnswer, data, error) {
                            var col_key, key, bolSaveWaiting;
                            removeMessage(element, 'saving');
                            element.state = 'saved';
                            
                            GS.removeLoader(element);
                            
                            if (!error) {
                                if (strAnswer === 'COMMIT') {
                                    element.lastSuccessData.dat[recordIndex] = arrTotalRecords[0];
                                    element.bolCurrentlySaving = false;
                                    
                                    // if there is another save in the pipeline: bolSaveWaiting = true
                                    for (key in element.jsnUpdate) {
                                        for (col_key in element.jsnUpdate[key]) {
                                            if (element.jsnUpdate[key][col_key] !== undefined) {
                                                bolSaveWaiting = true;
                                                break;
                                            }
                                        }
                                    }
                                    
                                    // if there is a save waiting: update again
                                    if (bolSaveWaiting) {
                                        updateDataWithoutTemplate(element);
                                        
                                    } else {
                                        triggerAfterUpdate(element);
                                    }
                                } else {
                                    getData(element);
                                }
                            } else {
                                GS.webSocketErrorDialog(data);
                            }
                        }
                    );
                    
                    
                    //element.currentSaveAjax = GS.ajaxJSON(strLink, strParameters, function (data, error) {
                    //    var col_key, key, bolSaveWaiting;
                    //    removeMessage(element, 'saving');
                    //    element.state = 'saved';
                    //    
                    //    if (!error) {
                    //        element.lastSuccessData.dat[recordIndex] = data.dat;
                    //        element.bolCurrentlySaving = false;
                    //        
                    //        // if there is another save in the pipeline: bolSaveWaiting = true
                    //        for (key in element.jsnUpdate) {
                    //            for (col_key in element.jsnUpdate[key]) {
                    //                if (element.jsnUpdate[key][col_key] !== undefined) {
                    //                    bolSaveWaiting = true;
                    //                    break;
                    //                }
                    //            }
                    //        }
                    //        
                    //        // if there is a save waiting: update again
                    //        if (bolSaveWaiting) {
                    //            updateDataWithoutTemplate(element);
                    //            
                    //        } else {
                    //            triggerAfterUpdate(element);
                    //        }
                    //        
                    //    } else if (bolErrorHandling !== false) {
                    //        element.bolCurrentlySaving = false;
                    //        element.bolSaveWaiting = false;
                    //        element.bolErrorOpen = true;
                    //        
                    //        GS.ajaxErrorDialog(data, function () {
                    //            if (element.saveTimerID) {
                    //                clearTimeout(element.saveTimerID);
                    //                element.saveTimerID = undefined;
                    //            }
                    //            
                    //            element.bolErrorOpen = false;
                    //            functionUpdateRecord(strID, strColumn, recordIndex, strParameters);
                    //        }, function () {
                    //            element.bolErrorOpen = false;
                    //        });
                    //    }
                    //});
                };
                
                // loop through the jsnUpdate variable and make one update for every record that needs an update
                console.log(JSON.stringify(element.jsnUpdate));
                
                for (key in element.jsnUpdate) {
                    for (col_key in element.jsnUpdate[key]) {
                        if (element.jsnUpdate[key][col_key] !== undefined) {
                            strID = key;
                            strColumn = col_key;
                            newValue = element.jsnUpdate[key][col_key];
                            idIndex = element.lastSuccessData.arr_column.indexOf('id');
                            
                            for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                                if (String(element.lastSuccessData.dat[i][idIndex]) === strID) {
                                    functionUpdateRecord(strID, strColumn, i,
                                                'src=' + encodeURIComponent(strSource) +
                                                '&where=' + encodeURIComponent(
                                                    'id=' + strID +
                                                    '&' + element.lockColumn + '=' + GS.envGetCell(element.lastSuccessData, i, element.lockColumn)
                                                ) +
                                                '&column=' + strColumn +
                                                '&value=' +  encodeURIComponent(newValue));
                                    
                                    break;
                                }
                            }
                            
                            break;
                        }
                    }
                }
            }
            
        } else {
            var data, strLink, strParameters, strSource, strUpdate, key, col_key, functionUpdateRecord,
                idIndex, i, len, strID, strColumn, newValue;
            
            //console.trace('updateDataWithoutTemplate');
            
            if (element.bolCurrentlySaving === false && !element.bolErrorOpen) {
                strSource = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') || element.getAttribute('source') || ''));
                strLink = '/' + (element.getAttribute('action-update') || 'env/action_update');
                
                functionUpdateRecord = function (strID, strColumn, recordIndex, strParameters) {
                    element.bolCurrentlySaving = true;
                    
                    element.jsnUpdate[strID][strColumn] = undefined;
                    
                    // run ajax
                    removeMessage(element, 'waiting');
                    addMessage(element, 'saving');
                    element.state = 'saving';
                    
                    element.currentSaveAjax = GS.ajaxJSON(strLink, strParameters, function (data, error) {
                        var col_key, key, bolSaveWaiting;
                        removeMessage(element, 'saving');
                        element.state = 'saved';
                        
                        if (!error) {
                            element.lastSuccessData.dat[recordIndex] = data.dat;
                            
                            element.bolCurrentlySaving = false;
                            
                            // if there is another save in the pipeline: bolSaveWaiting = true
                            for (key in element.jsnUpdate) {
                                for (col_key in element.jsnUpdate[key]) {
                                    if (element.jsnUpdate[key][col_key] !== undefined) {
                                        bolSaveWaiting = true;
                                        break;
                                    }
                                }
                            }
                            
                            // if there is a save waiting: update again
                            if (bolSaveWaiting) {
                                updateDataWithoutTemplate(element);
                                
                            } else {
                                triggerAfterUpdate(element);
                            }
                            
                        } else if (bolErrorHandling !== false) {
                            element.bolCurrentlySaving = false;
                            element.bolSaveWaiting = false;
                            element.bolErrorOpen = true;
                            
                            GS.ajaxErrorDialog(data, function () {
                                if (element.saveTimerID) {
                                    clearTimeout(element.saveTimerID);
                                    element.saveTimerID = undefined;
                                }
                                
                                element.bolErrorOpen = false;
                                functionUpdateRecord(strID, strColumn, recordIndex, strParameters);
                            }, function () {
                                element.bolErrorOpen = false;
                            });
                        }
                    });
                };
                
                // loop through the jsnUpdate variable and make one update for every record that needs an update
                for (key in element.jsnUpdate) {
                    for (col_key in element.jsnUpdate[key]) {
                        if (element.jsnUpdate[key][col_key] !== undefined) {
                            strID = key;
                            strColumn = col_key;
                            newValue = element.jsnUpdate[key][col_key];
                            idIndex = element.lastSuccessData.arr_column.indexOf('id');
                            
                            for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                                if (String(element.lastSuccessData.dat[i][idIndex]) === strID) {
                                    functionUpdateRecord(strID, strColumn, i,
                                                'src=' + encodeURIComponent(strSource) +
                                                '&where=' + encodeURIComponent(
                                                    'id=' + strID +
                                                    '&' + element.lockColumn + '=' + GS.envGetCell(element.lastSuccessData, i, element.lockColumn)
                                                ) +
                                                '&column=' + strColumn +
                                                '&value=' +  encodeURIComponent(newValue));
                                    
                                    break;
                                }
                            }
                            
                            break;
                        }
                    }
                }
            }
        }
    }
    
    
    // #################################################################
    // ######################### DATA HANDLING #########################
    // #################################################################
    
    // handles fetching the data
    //      if bolInitalLoad === true then
    //          use: initialize query COALESCE TO source query
    //      else
    //          use: source query
    function getData(element) { //bolClearPrevious
        if (window.bolSocket === true) {
            var srcParts   = GS.templateWithQuerystring(element.getAttribute('src')).split('.')
              , strSchema  = srcParts[0]
              , strObject  = srcParts[1]
              , strColumns = GS.templateWithQuerystring(element.getAttribute('cols') || '*').split(',').join('\t')
              , strWhere   = GS.templateWithQuerystring(element.getAttribute('where') || '')
              , strOrd     = GS.templateWithQuerystring(element.getAttribute('ord') || '')
              , strLimit   = GS.templateWithQuerystring(element.getAttribute('limit') || '1')
              , strOffset  = GS.templateWithQuerystring(element.getAttribute('offset') || '')
              , response_i = 0, response_len = 0, arrTotalRecords = [];
            
            GS.triggerEvent(element, 'before_select');
            GS.requestSelectFromSocket(GS.envSocket, strSchema, strObject, strColumns
                                     , strWhere, strOrd, strLimit, strOffset
                                     , function (data, error) {
                var arrRecords, arrCells, i, len, cell_i, cell_len;
                
                if (!error) {
                    if (data.strMessage !== 'TRANSACTION COMPLETED') {
                        arrRecords = GS.trim(data.strMessage, '\n').split('\n');
                        
                        for (i = 0, len = arrRecords.length; i < len; i += 1) {
                            arrCells = arrRecords[i].split('\t');
                            
                            for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                                arrCells[cell_i] = GS.decodeFromTabDelimited(arrCells[cell_i]);
                            }
                            
                            arrTotalRecords.push(arrCells);
                        }
                    } else {
                        element.arrColumns = data.arrColumnNames;
                        
                        handleData(element, {
                            "arr_column": data.arrColumnNames
                          , "dat": arrTotalRecords
                          , "row_count": arrTotalRecords.length
                        }, '', 'load');
                    }
                } else {
                    GS.webSocketErrorDialog(data);
                }
            });
            
        } else {
            var data, strLink,
                strSource = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') ||
                    element.getAttribute('source') || '')),
                strCols = element.getAttribute('cols') || '';
            
            //// use the source query and prepare the parameters for a fetch that would use the source query
            //if (strSource.trim().toLowerCase().indexOf('select') === 0) {
            //    strLink = '/env/action_select_sql?select=' + encodeURIComponent(strSource);
            //} else {
            //    strLink = '/env/action_select?view=' + encodeURIComponent(strSource);
            //}
            
            if (element.getAttribute('where') !== 'false') {
                strLink = '/' + (element.getAttribute('action-select') || 'env/action_select') + '?src=' + encodeURIComponent(strSource);
                
                strLink += '&where='    + encodeURIComponent(GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('where') || ''))) +
                           '&limit='    + encodeURIComponent(GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('limit') || '1'))) +
                           '&offset='   + encodeURIComponent(GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('offset') || ''))) +
                           '&order_by=' + encodeURIComponent(GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('ord') || ''))) +
                           '&cols='     + encodeURIComponent(strCols);
                
                GS.triggerEvent(element, 'before_select');
                GS.addLoader('refresh_' + encodeURIComponent(strLink));
                //if (GS.dataFetch(strLink, bolClearPrevious)) {
                //    data = GS.dataFetch(strLink, bolClearPrevious);
                //    
                //    handleData(element, data.response, data.error);
                //} else {
                GS.dataFetch(strLink, true);
                
                document.addEventListener('dataready_' + encodeURIComponent(strLink), function __THIS_FUNCTION__(event) {
                    GS.removeLoader('refresh_' + encodeURIComponent(strLink));
                    handleData(element, event.detail.response, event.detail.error, 'load');
                    document.removeEventListener('dataready_' + encodeURIComponent(strLink), __THIS_FUNCTION__);
                });
            }
        }
    }
    
    // handles data result from method function: getData 
    //      success:  template
    //      error:    add error classes
    function handleData(element, data, error, strAction, failCallback) {
        var arrElements, i, len, arrHeaders = [], intColumnElementFocusNumber, jsnSelection, matchElement,
            templateElement = document.createElement('template'), focusTimerID, focusToElement, timer_i;
        
        // clear any old error status
        element.classList.remove('error');
        
        if (!error && data.dat.length === 0 && !element.hasAttribute('limit') && !element.hasAttribute('suppress-no-record-found')) {
            templateElement.setAttribute('data-theme', 'error');
            templateElement.innerHTML = ml(function () {/*
                <gs-page>
                    <gs-header><center><h3>Error</h3></center></gs-header>
                    <gs-body padded>
                        <center>No record found</center>
                    </gs-body>
                    <gs-footer>
                        <gs-grid>
                            <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                            <gs-block><gs-button dialogclose listen-for-return bg-primary>Try Again</gs-button></gs-block>
                        </gs-grid>
                    </gs-footer>
                </gs-page>
            */});
            
            GS.openDialog(templateElement, '', function (event, strAnswer) {
                if (strAnswer === 'Try Again') {
                    element.refresh();
                }
            });
        }
        
        // if there was no error
        if (!error) {
            element.error = false;
            
            // save success data
            element.lastSuccessData = data;
            
            if (GS.findParentElement(document.activeElement, 'gs-form') === element) {
                //console.log('Hey');
                arrElements = xtag.query(element, '[column]');
                matchElement = GS.findParentElement(document.activeElement, '[column]');
                
                if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                    jsnSelection = GS.getInputSelection(document.activeElement);
                }
                
                if (matchElement) {
                    for (i = 0, len = arrElements.length; i < len; i += 1) {
                        if (arrElements[i] === matchElement) {
                            intColumnElementFocusNumber = i;
                            break;
                        }
                    }
                }
            }
            
            element.innerHTML = dataTemplateRecords(element, data);
            
            // if template is not native: handle templates inside the form
            if (shimmed.HTMLTemplateElement) {
                HTMLTemplateElement.bootstrap(element);
            }
            
            // handle autofocus
            arrElements = xtag.query(element, '[autofocus]');
            
            if (arrElements.length > 0 && !evt.touchDevice) {
                arrElements[0].focus();
                
                if (arrElements.length > 1) {
                    console.warn('dialog Warning: Too many [autofocus] elements, defaulting to the first one. Please have only one [autofocus] element per form.');
                }
            }
            
            // if there is a intColumnElementFocusNumber: restore focus
            if (intColumnElementFocusNumber) {
                arrElements = xtag.query(element, '[column]');
                
                //console.log(intColumnElementFocusNumber, jsnSelection);
                //
                //console.log('arrElements: ', arrElements);
                //console.log('intColumnElementFocusNumber: ', intColumnElementFocusNumber);
                //console.log('element: ', arrElements[intColumnElementFocusNumber]);
                //console.log('jsnSelection: ', jsnSelection);
                //
                //console.log('element upgrade: ', arrElements[intColumnElementFocusNumber].__upgraded__);
                
                //console.log('1***');
                if (arrElements.length > intColumnElementFocusNumber) {
                    //console.log('2***', document.activeElement);
                    focusToElement = arrElements[intColumnElementFocusNumber];
                    
                    // if element registration is not shimmed, we can just focus into the target element
                    if (shimmed.registerElement === false) {
                        focusToElement.focus();
                        if (jsnSelection) {
                            GS.setInputSelection(document.activeElement, jsnSelection.start, jsnSelection.end);
                        }
                        
                    // else, we have to check on a loop to see if the element has been upgraded,
                    //      the reason I need to use a loop here is because there is no event for
                    //      when an element is upgraded (if there was then 1000 custom elements
                    //      would emit 1000 events, which is a lot and we don't want to bog the
                    //      browser down)
                    } else {
                        timer_i = 0;
                        focusTimerID = setInterval(function () {
                            if (focusToElement.__upgraded__ || timer_i >= 10) {
                                clearTimeout(focusTimerID);
                            }
                            if (focusToElement.__upgraded__) {
                                focusToElement.focus();
                                if (jsnSelection) {
                                    GS.setInputSelection(document.activeElement, jsnSelection.start, jsnSelection.end);
                                }
                            }
                            timer_i += 1;
                        }, 5);
                    }
                }
            }
            
            //console.log('current element', document.activeElement);
            
            // trigger after_select
            GS.triggerEvent(element, 'after_select');
            //console.log(element, 'after_select');
            
        // else there was an error: add error class, title attribute
        } else {
            element.error = true;
            element.classList.add('error');
            
            element.innerHTML = 'This form encountered an error.'
            
            //GS.ajaxErrorDialog(event.detail.response);
            GS.ajaxErrorDialog(data);
        }
    }
    
    
    function dataTemplateRecords(element, data) {
        var jsnTemplate, strRet;
        
        jsnTemplate = GS.templateHideSubTemplates(element.templateHTML);
        
        //console.log(jsnTemplate.templateHTML);
        
        strRet = GS.templateWithEnvelopeData('<div class="form-record" ' + (data.dat.length === 1 ? 'style="height: 100%;" ' : '') +
                                                'data-id="{{! row.id }}" data-' + element.lockColumn + '="{{! row.' + element.lockColumn + ' }}" gs-dynamic>' +
                                                jsnTemplate.templateHTML +
                                            '</div>',
                                            data);
        
        strRet = GS.templateShowSubTemplates(strRet, jsnTemplate);
        
        //console.log(strRet);
        
        return strRet;
    }
    
    
    // #################################################################
    // ########################### UTILITIES ###########################
    // #################################################################
    
    function addMessage(element, strMessageName) {
        if (strMessageName === 'saving') {
            if (element.savingMessage) {
                removeMessage(element, 'saving');
            }
            element.savingMessage = document.createElement('div');
            element.savingMessage.classList.add('message');
            element.savingMessage.innerHTML = 'Saving...';
            
            element.appendChild(element.savingMessage);
            
        } else if (strMessageName === 'waiting') {
            if (element.waitingMessage) {
                removeMessage(element, 'waiting');
            }
            element.waitingMessage = document.createElement('div');
            element.waitingMessage.classList.add('message');
            element.waitingMessage.innerHTML = 'Waiting<br />to save...';
            
            element.appendChild(element.waitingMessage);
        }
    }
    
    function removeMessage(element, strMessageName) {
        if (strMessageName === 'saving' && element.savingMessage) {
            element.removeChild(element.savingMessage);
            element.savingMessage = undefined;
            
        } else if (strMessageName === 'waiting' && element.waitingMessage) {
            element.removeChild(element.waitingMessage);
            element.waitingMessage = undefined;
        }
    }
    
    function columnParentsUntilForm(form, element) {
        var intColumnParents = 0, currentElement = element, maxLoops = 50, i = 0;
        
        while (currentElement.parentNode !== form && currentElement.parentNode && i < maxLoops) {
            if (currentElement.parentNode.hasAttribute('column') === true) {
                intColumnParents += 1;
            }
            
            currentElement = currentElement.parentNode;
            i += 1;
        }
        
        return intColumnParents;
    }
    
    //function pushReplacePopHandler(element) {
    //    var i, len, arrPopKeys, bolRefresh = false, currentValue, strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //    
    //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.setAttribute('where', 'id=' + GS.qryGetVal(strQueryString, strQSCol));
    //        bolRefresh = true;
    //        
    //    } else if (element.hasAttribute('refresh-on-querystring-values')) {
    //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
    //        
    //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
    //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
    //            
    //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
    //                bolRefresh = true;
    //            }
    //            
    //            element.popValues[arrPopKeys[i]] = currentValue;
    //        }
    //        
    //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
    //        bolRefresh = true;
    //    }
    //    
    //    if (bolRefresh) {
    //        element.refresh();
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh;
        var strOperator;

        if (strQSCol) {
            if (strQSCol.indexOf('=') !== -1) {
                arrAttrParts = strQSCol.split(',');
                i = 0;
                len = arrAttrParts.length;
                while (i < len) {
                    strQSCol = arrAttrParts[i];
    
                    if (strQSCol.indexOf('!=') !== -1) {
                        strOperator = '!=';
                        arrQSParts = strQSCol.split('!=');
                    } else {
                        strOperator = '=';
                        arrQSParts = strQSCol.split('=');
                    }
    
                    strQSCol = arrQSParts[0];
                    strQSAttr = arrQSParts[1] || arrQSParts[0];
    
                    // if the key is not present or we've got the negator: go to the attribute's default or remove it
                    if (strOperator === '!=') {
                        // if the key is not present: add the attribute
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            element.setAttribute(strQSAttr, '');
                        // else: remove the attribute
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    } else {
                        // if the key is not present: go to the attribute's default or remove it
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        // else: set attribute to exact text from QS
                        } else {
                            element.setAttribute(strQSAttr, (
                                GS.qryGetVal(strQS, strQSCol) ||
                                element.internal.defaultAttributes[strQSAttr] ||
                                ''
                            ));
                        }
                    }
                    i += 1;
                }
            } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                strQSValue = GS.qryGetVal(strQS, strQSCol);
    
                if (element.internal.bolQSFirstRun !== true) {
                    if (strQSValue !== '' || !element.getAttribute('value')) {
                        element.setAttribute('where', 'id=' + (isNaN(strQSValue) ? '$WHEREQuoTE$' + strQSValue + '$WHEREQuoTE$' : strQSValue));
                        bolRefresh = true;
                    }
                } else {
                    element.setAttribute('where', 'id=' + (isNaN(strQSValue) ? '$WHEREQuoTE$' + strQSValue + '$WHEREQuoTE$' : strQSValue));
                    bolRefresh = true;
                }
            }
        }
        
        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                
                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);
                    
                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }
                    
                    element.popValues[arrPopKeys[i]] = currentValue;
                }
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                
                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                }
            }
            
            if (GS.getQueryString() || element.hasAttribute('refresh-on-querystring-change') || element.hasAttribute('src')) {
                bolRefresh = true;
            }
        }
        
        if (bolRefresh && element.hasAttribute('src')) {
            getData(element);
        } else if (bolRefresh && !element.hasAttribute('src')) {
            console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
        }
        
        element.internal.bolQSFirstRun = true;
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            
        }
    }
    
    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);
                
                var //templateElement = document.createElement('template'),
                    //templateElementSubTemplateSafe = document.createElement('template'),
                    firstChildElement = element.children[0],
                    //arrElements, i, len, arrColumnElement, arrTemplates,
                    strQueryString = GS.getQueryString(), changeHandler;
                
                // if this form has the "save-while-typing" attribute
                if (element.hasAttribute('save-while-typing')) {
                    GS.addBeforeUnloadEvent(function () {
                        if (element.bolCurrentlySaving || element.saveTimerID) {
                            return 'The page has not finished saving.';
                        }
                    });
                } else {
                    // this prevents the issue where you type in a change but then unload
                    //      the page without causing a change event to fire, which means you lose your change
                    GS.addBeforeUnloadEvent(function () {
                        document.activeElement.blur();
                    });
                }
                
                // lock attribute and defaulting
                element.lockColumn = element.getAttribute('lock') || 'change_stamp';
                
                // if the first child is a template element: save its HTML
                if (firstChildElement.nodeName === 'TEMPLATE') {
                    element.templateHTML = firstChildElement.innerHTML;
                    
                // else: save the innerHTML of the form and send a warning
                } else {
                    console.warn('Warning: gs-form is now built to use a template element. ' +
                                 'Please use a template element to contain the template for this form. ' + // this warning was added: March 12th 2015
                                 'A fix has been included so that it is not necessary to use the template element, but that code may be removed at a future date.');
                    
                    element.templateHTML = element.innerHTML;
                }
                
                // if there is no HTML: throw an error
                if (!element.templateHTML.trim()) { throw 'GS-FORM error: no template HTML.'; }
                
                // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                element.templateHTML = GS.templateColumnToValue(element.templateHTML);
                
                // handle "qs" attribute
                if (element.getAttribute('qs') ||
                        element.getAttribute('refresh-on-querystring-values') ||
                        element.hasAttribute('refresh-on-querystring-change')) {
                    element.popValues = {};
                    
                    //if (element.getAttribute('qs')) {
                    //    if (GS.qryGetVal(strQueryString, element.getAttribute('qs'))) {
                    //        element.setAttribute('where', 'id=' + GS.qryGetVal(strQueryString, element.getAttribute('qs')));
                    //    } else {
                    //        element.setAttribute('where', 'false');
                    //    }
                    //}
                    
                    //if (GS.getQueryString() || element.hasAttribute('refresh-on-querystring-change')) {
                    pushReplacePopHandler(element);
                    //}
                    
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                } else {
                    getData(element);
                }
                
                element.addEventListener('keydown', function (event) {
                    var intKeyCode = event.which || event.keyCode, jsnSelection;
                    
                    if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                        jsnSelection = GS.getInputSelection(event.target);
                    }
                    
                    if ((intKeyCode === 37 && (!jsnSelection || jsnSelection.start === 0)) ||
                        (intKeyCode === 39 && (!jsnSelection || jsnSelection.end === event.target.value.length))) {
                        var focusToElement, i, len, arrElementsFocusable, currentElement;
                        //Left
                        if (intKeyCode === 37 && (!jsnSelection || jsnSelection.start === 0)) {
                            arrElementsFocusable = xtag.query(document, 'input:not([disabled]), ' +
                                'select:not([disabled]), memo:not([disabled]), button:not([disabled]), ' +
                                '[tabindex]:not([disabled]), [column]');
                            
                            for (i = 0,len = arrElementsFocusable.length;i < len;i++) {
                                currentElement = arrElementsFocusable[i];
                                //console.log(currentElement === event.target, currentElement, event.target);
                                if (currentElement === event.target ||
                                    ((event.target.nodeName === 'INPUT' || event.target.nodeName === 'TEXTAREA') &&
                                    currentElement === event.target.parentNode)) {
                                    if (i === 0) {
                                        focusToElement = currentElement;
                                    } else {
                                        focusToElement = arrElementsFocusable[i - 1];
                                    }
                                    break;
                                }
                            }
                            //console.log(focusToElement);
                        //Right
                        } else if (intKeyCode === 39 && (!jsnSelection || jsnSelection.end === event.target.value.length)) {
                            arrElementsFocusable = xtag.query(document, 'input:not([disabled]), ' +
                                'select:not([disabled]), memo:not([disabled]), button:not([disabled]), ' +
                                '[tabindex]:not([disabled]), [column]');
                            
                            for (i = 0,len = arrElementsFocusable.length;i < len;i++) {
                                currentElement = arrElementsFocusable[i];
                                if (currentElement === event.target) {
                                    if (i === len) {
                                        focusToElement = currentElement;
                                    } else {
                                        focusToElement = arrElementsFocusable[i + 1];
                                    }
                                    break;
                                }
                            }
                        }
                        
                        //console.log('focusable', GS.isElementFocusable(focusToElement));
                        if (focusToElement && GS.isElementFocusable(focusToElement)) {
                            //console.log('focus');
                            event.preventDefault();
                            
                            focusToElement.focus();
                            
                            if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                                GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
                            }
                        }
                    }
                });
                
                // bind save code
                if (element.hasAttribute('save-while-typing')) {
                    element.bolCurrentlySaving = false;
                    element.jsnUpdate = {};
                    element.state = 'saved';
                    //element.currentSaveAjax = false;
                    
                    // possible states:
                    //      'saved'
                    //      'waiting to save'
                    //      'saving'
                    
                    // JSON object for holding columns to update
                    // on keydown, keyup, change add to JSON object
                    // keep updating until all columns have been saved (undefined marks an empty column)
                    
                    changeHandler = function (event) {
                        var intKeyCode = event.which || event.keyCode, newValue,
                            targetColumnParent = GS.findParentElement(event.target, '[column]'),
                            parentRecordElement, strID;
                        
                        //console.log(event.target, targetColumnParent);
                        
                        if (targetColumnParent.getAttribute('column') && columnParentsUntilForm(element, targetColumnParent) === 0 &&
                            element.column(targetColumnParent.getAttribute('column')) !== targetColumnParent.value) {
                            
                            //event.stopPropagation();
                            if (element.saveTimerID) {
                                clearTimeout(element.saveTimerID);
                                element.saveTimerID = undefined;
                            }
                            
                            addMessage(element, 'waiting');
                            element.state = 'waiting to save';
                            
                            if (targetColumnParent.value !== null && targetColumnParent.value !== null) {
                                newValue = targetColumnParent.value;
                            } else {
                                newValue = targetColumnParent.checked;
                            }
                            
                            parentRecordElement = GS.findParentElement(targetColumnParent, '.form-record[data-id]');
                            strID = parentRecordElement.getAttribute('data-id');
                            
                            if (!element.jsnUpdate[strID]) {
                                element.jsnUpdate[strID] = element.jsnUpdate[strID] = {};
                            }
                            element.jsnUpdate[strID][targetColumnParent.getAttribute('column')] = newValue;
                            
                            element.saveTimerID = setTimeout(function () {
                                updateDataWithoutTemplate(element);
                                element.saveTimerID = undefined;
                            }, 300);
                        }
                    };
                    
                    element.addEventListener('keydown', changeHandler);
                    element.addEventListener('keyup', changeHandler);
                    element.addEventListener('change', changeHandler);
                    
                } else {
                    element.addEventListener('change', function (event) {
                        var newValue;
                        
                        if (event.target.getAttribute('column')
                                && columnParentsUntilForm(element, event.target) === 0
                                && GS.findParentTag(event.target, 'gs-form') === element) {
                            //event.stopPropagation();
                            
                            if (event.target.value !== null) {
                                newValue = event.target.value;
                            } else {
                                newValue = event.target.checked;
                            }
                            
                            updateData(element, event.target, event.target.getAttribute('column'), newValue);
                        }
                    });
                }
            }
        }
    }
    
    xtag.register('gs-form', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                }
            },
            
            removed: function () {
                if (this.hasAttribute('save-while-typing') && this.saveTimerID) {
                    clearTimeout(this.saveTimerID);
                    emergencyUpdate(this);
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            refresh: function () {
                getData(this);
            },
            
            column: function (strColumn) {
                //console.log(this.lastSuccessData);
                return GS.envGetCell(this.lastSuccessData, 0, strColumn);
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet('<gs-grid>', '<gs-grid>', 'gs-grid widths="${1}">\n' +
                                                    '    <gs-block>${2}</gs-block>\n' +
                                                    '</gs-grid>');
    
    designRegisterElement('gs-grid', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-grid.html');
    
    window.designElementProperty_GSGRID = function(selectedElement) {
        addProp('Min-Width Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('min-width') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'min-width', this.value);
        });
        
        addProp('Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('media') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'media', this.value);
        });
        
        addProp('Widths', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('widths') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'widths', this.value);
        });
        
        addProp('Padded', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('padded')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'padded', (this.value === 'true'), true);
        });
        
        addProp('Gutters', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('gutter')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'gutter', (this.value === 'true'), true);
        });
        
        addProp('Reflow At', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('reflow-at') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'reflow-at', this.value);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});
    
window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('<gs-block>', '<gs-block>', 'gs-block>${2}</gs-block>');
    
    designRegisterElement('gs-block', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-grid.html');
    
    window.designElementProperty_GSBLOCK = function(selectedElement) {
        addProp('Width:', true, '<gs-text class="target" value="' + (selectedElement.getAttribute('width') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'width', this.value);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + (selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        addFlexContainerProps(selectedElement);
        //addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var arrTakenGrids = [];
    
    function handleObserver(element) {
        var observer = new MutationObserver(function(mutations) {
            element.handleBlocks();
        });
        
        observer.observe(element, {childList: true});
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            handleObserver(element);
        }
    }
    
    //
    function elementInserted(element) {
        var styleElement;
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
                // if the style element for the grid column CSS doesn't exist: create it
                if (!document.getElementById('gs-dynamic-css')) {
                    styleElement = document.createElement('style');
                    styleElement.setAttribute('id', 'gs-dynamic-css');
                    styleElement.setAttribute('gs-dynamic', '');
                    document.head.appendChild(styleElement);
                }
                
                // if no width parameter is set: default
                if (!element.getAttribute('widths') && !element.getAttribute('min-width') && !element.getAttribute('media')) {
                    element.bolIgnoreAttribute = true;
                    element.setAttribute('widths', new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(','));
                    element.bolIgnoreAttribute = false;
                }
                
                element.handleCSS();
                element.handleBlocks();
            }
        }
    }
    
    xtag.register('gs-grid', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // if the "widths" attribute changed
                    if (strAttrName === 'widths' && this.bolIgnoreAttribute !== true) {
                        this.handleCSS();
                        this.handleBlocks();
                        
                    // if the "reflow-at" attribute changed
                    } else if (strAttrName === 'reflow-at') {
                        this.handleCSS();
                        
                    // if the "min-width" attribute changed
                    } else if (strAttrName === 'min-width') {
                        this.handleCSS();
                        this.handleBlocks();
                        
                    // if the "media" attribute changed
                    } else if (strAttrName === 'media') {
                        this.handleCSS();
                        this.handleBlocks();
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            
            getWidthsParameters: function (strWidths) {
                var arrWidths, intGridWidth, i, len;
                
                arrWidths = strWidths
                        .replace(/[^0-9,]/gim, '') // remove everything except commas and numbers
                        .replace(/,{1,}/gim, ',')  // replace multiple commas right next to each other with a single comma
                        .replace(/^,|,$/gim, '')   // remove commas at the end and the beginning of the line
                        .split(',');               // split on commas to make an array of numbers (which are currently type 'string')
                
                // if the array doesn't have content: error
                if (arrWidths.length === 0) {
                    throw 'gs-grid Error: no valid widths found. Please put a comma seperated list of widths in the "widths" attribute.';
                }
                
                // convert the array of strings to an array of integers
                for (i = 0, len = arrWidths.length; i < len; i += 1) {
                    arrWidths[i] = parseInt(arrWidths[i], 10);
                }
                
                // add up the array of integers to come up with a grid width
                for (i = 0, len = arrWidths.length, intGridWidth = 0; i < len; i += 1) {
                    intGridWidth += arrWidths[i];
                }
                
                return {
                    'arrWidths': arrWidths,
                    'intGridWidth': intGridWidth
                };
            },
            
            handleCSS: function () {
                var jsnWidthsParameters;
                
                if (this.getAttribute('widths')) {
                    jsnWidthsParameters = this.getWidthsParameters(this.getAttribute('widths'));
                    
                    this.handleWidthsCSS(jsnWidthsParameters.arrWidths, jsnWidthsParameters.intGridWidth);
                    
                } else if (this.getAttribute('min-width')) {
                    this.handleMinWidthCSS();
                    
                } else if (this.getAttribute('media')) {
                    this.handleMediaCSS();
                }
            },
            
            handleBlocks: function () {
                var jsnWidthsParameters;
                
                if (this.getAttribute('widths')) {
                    jsnWidthsParameters = this.getWidthsParameters(this.getAttribute('widths'));
                    
                    this.handleWidthsBlocks(jsnWidthsParameters.arrWidths, jsnWidthsParameters.intGridWidth);
                    
                } else if (this.getAttribute('min-width')) {
                    this.handleMinWidthBlocks();
                    
                } else if (this.getAttribute('media')) {
                    this.handleMediaBlocks();
                }
            },
            
            
            
            
            handleWidthsCSS: function (arrWidths, intGridWidth) {
                var styleElement = document.getElementById('gs-dynamic-css'),
                    i, len, strCurrentWidth, intCurrentWidth, widthIncreaseAmount, strCSS,
                    strReflowAt = this.getAttribute('reflow-at') || '', arrClassesToRemove;
                
                // reflow-at shortcuts
                strReflowAt = strReflowAt.replace(/small|sml/g,  '992px');
                strReflowAt = strReflowAt.replace(/medium|med/g, '1200px');
                strReflowAt = strReflowAt.replace(/large|lrg/g,  '10000px');
                
                // remove old classes
                arrClassesToRemove = String(this.classList).match(/width-[0-9]*/g) || [];
                
                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }
                
                // make sure that this grid hasn't been done before
                if (!styleElement.classList.contains('col-' + intGridWidth)) {
                    // column CSS
                    
                    // calculate the amount to increase every block width setting by
                    widthIncreaseAmount = 100 / intGridWidth;
                    
                    // create a style for every block
                    for (i = 0, len = intGridWidth, intCurrentWidth = 0, strCSS = ''; i < len; i += 1) {
                        intCurrentWidth += widthIncreaseAmount;
                        strCurrentWidth = String(parseFloat(intCurrentWidth.toFixed(5).toString(), 10));
                        
                        strCSS += 'gs-grid.width-' + intGridWidth + ' > gs-block[width="' + (i + 1) + '"] { width: ' + strCurrentWidth + '%; }\n';
                    }
                    
                    // add col-NUM to the styleElement's "class" attribute
                    styleElement.classList.add('col-' + intGridWidth);
                    
                    // append the column CSS
                    styleElement.innerHTML += '\n/* grid width: ' + intGridWidth + ' */\n' +
                                              strCSS +
                                              'gs-grid.width-' + intGridWidth + ' > gs-block.first-of-row { padding-left: 0; }\n' +
                                              'gs-grid.width-' + intGridWidth + ' > gs-block.last-of-row { padding-right: 0; }\n';
                }
                
                // reflow CSS
                
                // remove class from the gs-grid that allowed the generated reflow CSS to apply
                this.classList.remove('reflow-' + this.strReflowAt);
                
                // clean reflow-at attribute variable
                strReflowAt = strReflowAt.replace(/[^0-9a-z]/gi, '');
                
                // if reflow-at contains anything
                if (strReflowAt) {
                    // if reflow-at doesn't have a unit specified: add 'px' to the end of it
                    if (strReflowAt.replace(/[0-9]/gi, '') === '') {
                        strReflowAt += 'px';
                    }
                    
                    // save the current reflow width so that we can use it later
                    this.strReflowAt = strReflowAt;
                    
                    // add class to the gs-grid so that the generated reflow CSS will apply
                    this.classList.add('reflow-' + strReflowAt);
                    
                    // if the reflow CSS for this grid width doesn't already exist: append it
                    if (!styleElement.classList.contains('reflow-' + strReflowAt)) {
                        
                        // add reflow-SIZE to the styleElement's "class" attribute
                        styleElement.classList.add('reflow-' + strReflowAt);
                        
                        // append the reflow CSS
                        styleElement.innerHTML += '\n/* grid reflow width: ' + strReflowAt + ' */\n' +
                                                  '@media only all and (max-width: ' + strReflowAt + ') {\n' +
                                                  '    gs-grid.reflow-' + strReflowAt + '            { width: 100%; }\n' +
                                                  '    gs-grid.reflow-' + strReflowAt + ' > gs-block { width: auto !important; float: none; }\n' +
                                                  '    gs-grid.reflow-' + strReflowAt + ' > gs-block { padding-left: 0 !important; padding-right: 0 !important; }\n' +
                                                  '}\n';
                    }
                }
                
                // apply CSS for blocks
                this.classList.add('width-' + intGridWidth);
            },
            
            handleMinWidthCSS: function () {
                var strMinWidth = this.getAttribute('min-width'), arrMinWidths, strCSS, strCurrentCSS,
                    i, len, arrParts, strWidth, strResult, intCurrentGridID, bolMedia, intCurrentWidth,
                    strCurrentWidth, intGridWidth, widthIncreaseAmount, grid_i, grid_len, intLayout, arrArrGridWidths,
                    column_i, column_len, arrWidths = [], width_i, strNextWidth;
                
                // 0 {1,1}; 1000 {2,1}; 10000 {2,1}; 12000 {1,1}
                // all {reflow}; sml {1,1}; med {1,1,1}; lrg {reflow}
                
                strMinWidth = strMinWidth.replace(/\s+/g, ''); // remove all whitespace
                strMinWidth = strMinWidth.replace(/\}/g, ''); // remove all close curly braces
                strMinWidth = strMinWidth.toLowerCase(); // lowercase
                strMinWidth = GS.trim(strMinWidth, ';'); // trim off semicolons
                
                // replace shortcuts (lrg => 1200px)
                strMinWidth = strMinWidth.replace(/all/g,        '0px');
                strMinWidth = strMinWidth.replace(/small|sml/g,  '768px');
                strMinWidth = strMinWidth.replace(/medium|med/g, '992px');
                strMinWidth = strMinWidth.replace(/large|lrg/g,  '1200px');
                
                arrMinWidths = strMinWidth.split(';'); // seperate out layouts
                
                //console.log(strMinWidth, arrMinWidths);
                
                if (arrTakenGrids.indexOf(strMinWidth) === -1) {
                    arrTakenGrids.push(strMinWidth);
                    intCurrentGridID = arrTakenGrids.length - 1;
                    strCSS = '';
                    arrArrGridWidths = [];
                    
                    for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strWidth = arrParts[0] || '0px';
                        strResult = arrParts[1] || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(',');
                        bolMedia = parseInt(strWidth) > 0;
                        strCurrentCSS = '';
                        
                        if (strResult === 'reflow') {
                            intLayout += 1;
                            arrArrGridWidths.push('reflow');
                            
                            // reflow css
                            strCurrentCSS += 
                                '    gs-grid.grid-id-' + intCurrentGridID + '            { width: 100%; }\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                            ' { width: auto; float: none; }\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                            ' { padding-left: 0; padding-right: 0; }\n';
                            
                        } else {
                            intLayout += 1;
                            arrArrGridWidths.push(strResult.split(','));
                            
                            // grid css
                            intGridWidth = this.getWidthsParameters(strResult).intGridWidth;
                            
                            // calculate the amount to increase every block width setting by
                            widthIncreaseAmount = 100 / intGridWidth;
                            
                            // create a style for every block
                            for (grid_i = 0, grid_len = intGridWidth, intCurrentWidth = 0; grid_i < grid_len; grid_i += 1) {
                                intCurrentWidth += widthIncreaseAmount;
                                strCurrentWidth = String(parseFloat(intCurrentWidth.toFixed(5).toString(), 10));
                                
                                strCurrentCSS += '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.width-' + (grid_i + 1) + '-layout-' + intLayout + ' { ' +
                                                     'width: ' + strCurrentWidth + '%; float: left; ' +
                                                 '}\n';
                            }
                            
                            strCurrentCSS =
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.clearfix-layout-' + intLayout +
                                            ' { clear: left; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + '[gutter] > gs-block { padding-left: 0.5em; padding-right: 0.5em; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.first-of-row-layout-' + intLayout +
                                            ' { padding-left: 0; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.last-of-row-layout-' + intLayout +
                                            ' { padding-right: 0; }\n\n' +
                                strCurrentCSS;
                        }
                        
                        //if (bolMedia) {
                        strNextWidth = '';
                        if (arrMinWidths[i + 1]) {
                            strNextWidth = arrMinWidths[i + 1].split('{')[0];
                            
                            // subtract 1 from the next width so that max-width doesn't allow the
                            //      media to apply at the same time as the next media
                            strNextWidth = (parseInt(strNextWidth) - 1) + strNextWidth.replace(/[0-9]/g, '');
                        }
                        
                        strCurrentCSS = '\n@media (min-width:' + strWidth + ')' + (strNextWidth ? ' and (max-width:' + strNextWidth + ')' : '') + ' {\n' +
                                            strCurrentCSS +
                                        '}\n';
                        //}
                        
                        strCSS += strCurrentCSS;
                    }
                    //console.log(strCSS);
                    
                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* grid #' + intCurrentGridID + ' */\n' + strCSS;
                    
                } else {
                    intCurrentGridID = arrTakenGrids.indexOf(strMinWidth);
                    arrArrGridWidths = [];
                    
                    for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strWidth = arrParts[0] || '0px';
                        strResult = arrParts[1] || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(',');
                        
                        intLayout += 1;
                        
                        if (strResult !== 'reflow') {
                            arrArrGridWidths.push(strResult.split(','));
                        } else {
                            arrArrGridWidths.push('reflow');
                        }
                    }
                }
                
                //
                this.intLayouts = intLayout;
                this.arrArrWidths = arrArrGridWidths;
                
                for (i = 0, len = this.arrArrWidths.length; i < len; i += 1) {
                    if (this.arrArrWidths[i] !== 'reflow') {
                        arrWidths.push(0);
                        width_i = arrWidths.length - 1;
                        
                        for (column_i = 0, column_len = this.arrArrWidths[i].length; column_i < column_len; column_i += 1) {
                            this.arrArrWidths[i][column_i] = parseInt(this.arrArrWidths[i][column_i], 10);
                            arrWidths[width_i] += 1;
                        }
                    } else {
                        arrWidths.push('reflow');
                    }
                }
                
                this.arrWidths = arrWidths;
                
                // add class so that the CSS can apply
                this.classList.add('grid-id-' + intCurrentGridID);
            },
            
            handleMediaCSS: function () {
                var strMinWidth = this.getAttribute('media'), arrMinWidths, strCSS, strCurrentCSS,
                    i, len, arrParts, strMedia, strResult, intCurrentGridID, bolMedia, intCurrentWidth,
                    strCurrentWidth, intGridWidth, widthIncreaseAmount, grid_i, grid_len, intLayout, arrArrGridWidths,
                    column_i, column_len, arrWidths = [], width_i;
                
                strMinWidth = strMinWidth.trim().replace(/\}/g, ''); // remove all close curly braces
                strMinWidth = strMinWidth.toLowerCase(); // lowercase
                strMinWidth = GS.trim(strMinWidth, ';'); // trim off semicolons
                
                // all {reflow}; all and (min-width: small) {2,2,2}; all and (min-width: med) {3,3}; all and (min-width: large) {reflow};
                
                // replace shortcuts (lrg => 1200px)
                strMinWidth = strMinWidth.replace(/small|sml/g,  '768px');
                strMinWidth = strMinWidth.replace(/medium|med/g, '992px');
                strMinWidth = strMinWidth.replace(/large|lrg/g,  '1200px');
                
                arrMinWidths = strMinWidth.split(';'); // seperate out layouts
                
                if (arrTakenGrids.indexOf(strMinWidth) === -1) {
                    arrTakenGrids.push(strMinWidth);
                    intCurrentGridID = arrTakenGrids.length - 1;
                    strCSS = '';
                    arrArrGridWidths = [];
                    
                    //console.log(strMinWidth, arrMinWidths);
                    
                    for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strMedia = arrParts[0].trim() || 'all';
                        strResult = arrParts[1].trim() || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(',');
                        strCurrentCSS = '';
                        
                        if (strResult === 'reflow') {
                            intLayout += 1;
                            arrArrGridWidths.push('reflow');
                            
                            // reflow css
                            strCurrentCSS += 
                                '    gs-grid.grid-id-' + intCurrentGridID + '            { width: 100%; }\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                            ' { width: auto; float: none; }\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                            ' { padding-left: 0; padding-right: 0; }\n';
                            
                        } else {
                            intLayout += 1;
                            arrArrGridWidths.push(strResult.split(','));
                            
                            // grid css
                            intGridWidth = this.getWidthsParameters(strResult).intGridWidth;
                            
                            // calculate the amount to increase every block width setting by
                            widthIncreaseAmount = 100 / intGridWidth;
                            
                            // create a style for every block
                            for (grid_i = 0, grid_len = intGridWidth, intCurrentWidth = 0; grid_i < grid_len; grid_i += 1) {
                                intCurrentWidth += widthIncreaseAmount;
                                strCurrentWidth = String(parseFloat(intCurrentWidth.toFixed(5).toString(), 10));
                                
                                strCurrentCSS += '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.width-' + (grid_i + 1) + '-layout-' + intLayout + ' { ' +
                                                     'width: ' + strCurrentWidth + '%; float: left; ' +
                                                 '}\n';
                            }
                            
                            strCurrentCSS =
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.clearfix-layout-' + intLayout +
                                            ' { clear: left; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + '[gutter] > gs-block { padding-left: 0.5em; padding-right: 0.5em; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.first-of-row-layout-' + intLayout +
                                            ' { padding-left: 0; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.last-of-row-layout-' + intLayout +
                                            ' { padding-right: 0; }\n\n' +
                                strCurrentCSS;
                        }
                        
                        strCurrentCSS = '\n@media ' + strMedia + ' {\n' +
                                            strCurrentCSS +
                                        '}\n';
                        
                        strCSS += strCurrentCSS;
                    }
                    
                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* grid #' + intCurrentGridID + ' */\n' + strCSS;
                    
                } else {
                    intCurrentGridID = arrTakenGrids.indexOf(strMinWidth);
                    arrArrGridWidths = [];
                    
                    for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strWidth = arrParts[0] || '0px';
                        strResult = arrParts[1] || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(',');
                        
                        intLayout += 1;
                        
                        if (strResult !== 'reflow') {
                            arrArrGridWidths.push(strResult.split(','));
                        } else {
                            arrArrGridWidths.push('reflow');
                        }
                    }
                }
                
                //
                this.intLayouts = intLayout;
                this.arrArrWidths = arrArrGridWidths;
                
                for (i = 0, len = this.arrArrWidths.length; i < len; i += 1) {
                    if (this.arrArrWidths[i] !== 'reflow') {
                        arrWidths.push(0);
                        width_i = arrWidths.length - 1;
                        
                        for (column_i = 0, column_len = this.arrArrWidths[i].length; column_i < column_len; column_i += 1) {
                            this.arrArrWidths[i][column_i] = parseInt(this.arrArrWidths[i][column_i], 10);
                            arrWidths[width_i] += 1;
                        }
                    } else {
                        arrWidths.push('reflow');
                    }
                }
                
                this.arrWidths = arrWidths;
                
                //
                this.classList.add('grid-id-' + intCurrentGridID);
            },
            
            
            
            
            
            handleWidthsBlocks: function (arrWidths, intGridWidth) {
                var i, len, unset_i, arrElements, intNumberOfWidths = arrWidths.length, intCurrentRowWidth = 0, intNextToAdd;
                
                // mark initally set blocks
                arrElements = xtag.queryChildren(this, 'gs-block[width]');
                
                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    arrElements[i].initallySet = true;
                }
                
                // get all child blocks
                arrElements = xtag.queryChildren(this, 'gs-block');
                
                // loop through the blocks
                for (i = 0, unset_i = 0, len = arrElements.length; i < len; i += 1) {
                    intNextToAdd = parseInt(arrElements[i].getAttribute('width'), 10) || arrWidths[unset_i % intNumberOfWidths];
                    
                    // if this block wasn't initally set: remove the width attribute
                    if (!arrElements[i].initallySet) {
                        arrElements[i].removeAttribute('width');
                    }
                    arrElements[i].classList.remove('first-of-row');
                    arrElements[i].classList.remove('last-of-row');
                    arrElements[i].style.clear = '';
                    
                    // if this is the first block in the row
                    if (intCurrentRowWidth === 0) {
                        // set the clear to left, this fixes an issue where a tall cell will move a cell over to the right
                        arrElements[i].style.clear = 'left';
                        arrElements[i].classList.add('first-of-row');
                    }
                    
                    // if this is the last block in the row
                    //console.log(intCurrentRowWidth, intNextToAdd, intGridWidth);
                    if ((intCurrentRowWidth + intNextToAdd) === intGridWidth) {
                        arrElements[i].classList.add('last-of-row');
                    }
                    
                    // if this block doesn't have a set width: set its width (if there are more unset width blocks than widths: the widths repeat)
                    if (!arrElements[i].hasAttribute('width')) {
                        arrElements[i].setAttribute('width', arrWidths[unset_i % intNumberOfWidths]);
                        unset_i += 1;
                    }
                    
                    intCurrentRowWidth += intNextToAdd;
                    intCurrentRowWidth = intCurrentRowWidth % intGridWidth;
                }
            },
            
            
            
            iterateBlocks: function (intLayouts, arrArrWidths, arrIntGridWidth) {
                var arrBlocks = xtag.queryChildren(this, 'gs-block'), i, len, block_i, block_len, width_i;
                
                for (i = 0, len = intLayouts; i < len; i += 1) {
                    width_i = 0;
                    
                    //console.log(arrArrWidths[i]);
                    if (arrArrWidths[i] !== 'reflow') {
                        for (block_i = 0, block_len = arrBlocks.length; block_i < block_len; block_i += 1) {
                            // if this is the first block in the row:
                            //      set the clear to left, this fixes an issue where a tall cell will move a cell over to the right
                            if (width_i === 0) {
                                arrBlocks[block_i].classList.add('clearfix-layout-' + (i + 1));
                                arrBlocks[block_i].classList.add('first-of-row-layout-' + (i + 1));
                            } else if ((width_i + 1) === arrIntGridWidth[i]) {
                                arrBlocks[block_i].classList.add('last-of-row-layout-' + (i + 1));
                            }
                            
                            arrBlocks[block_i].classList.add('width-' + arrArrWidths[i][width_i] + '-layout-' + (i + 1));
                            
                            //console.log(width_i, arrArrWidths[i][width_i], arrIntGridWidth[i]);
                            width_i += 1;
                            width_i = width_i % arrIntGridWidth[i];
                        }
                    } else {
                        for (block_i = 0, block_len = arrBlocks.length; block_i < block_len; block_i += 1) {
                            arrBlocks[block_i].classList.add('reflow-layout-' + (i + 1));
                        }
                    }
                }
                
                
            },
            
            handleMinWidthBlocks: function () {
                this.iterateBlocks(this.intLayouts, this.arrArrWidths, this.arrWidths);
            },
            
            handleMediaBlocks: function () {
                this.iterateBlocks(this.intLayouts, this.arrArrWidths, this.arrWidths);
            }
        }
    });
    
    xtag.register('gs-block', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
});
//global xtag
//jslint browser:true
document.addEventListener("DOMContentLoaded", function () {
    "use strict";
    // fill gs-group based on current content
    function buildElement(element) {
        var rootBox = document.createElement("div");
        var innerBox = document.createElement("gs-groupborder");
        var titleBox = document.createElement("gs-grouptitle");

        // fill "innerBox" by transfering all of "element"'s child nodes to it (this includes text nodes)
        var arrElements = xtag.toArray(element.childNodes);
        var i = 0;
        var len = arrElements.length;

        while (i < len) {
            innerBox.appendChild(arrElements[i]);
            i += 1;
        }

        // fill "titleBox"
        titleBox.textContent = element.getAttribute("name");

        // give "rootBox" the class "root"
        rootBox.classList.add("root");

        // make "rootBox" flex it's content vertically, and make it fill horizontally
        rootBox.setAttribute("flex-vertical", "");
        rootBox.setAttribute("flex-fill", "");

        // make "innerBox" flex to fill height
        innerBox.setAttribute("flex", "");

        // mark "titleBox" and "innerBox" as dynamic elements
        //      because we want developers to know that these
        //      are generated
        innerBox.setAttribute("gs-dynamic", "");
        titleBox.setAttribute("gs-dynamic", "");

        // append "titleBox" and "innerBox" to "rootBox"
        rootBox.appendChild(innerBox);
        rootBox.appendChild(titleBox);

        // append "rootBox" to "element"
        element.appendChild(rootBox);
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute("suspend-created") && !element.hasAttribute("suspend-inserted")) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                if (!element.children[0].classList.contains('root')) {
                    buildElement(element);
                }
            }
        }
    }

    xtag.register("gs-groupborder", {});
    xtag.register("gs-grouptitle", {});
    xtag.register("gs-group", {
        lifecycle: {
            inserted: function () {
                elementInserted(this);
            },
            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;

                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === "suspend-created" && newValue === null) {
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === "suspend-inserted" && newValue === null) {
                    elementInserted(element);
                }
                // else if (!element.hasAttribute("suspend-created") && !element.hasAttribute("suspend-inserted")) {
                //    // attribute code
                //}
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});
window.addEventListener('design-register-element', function () {
    registerDesignSnippet('Centered Header', '<gs-header>', '<gs-header><center><h3>$0</h3></center></gs-header>');
    registerDesignSnippet('Header', '<gs-header>', '<gs-header><h3>$0</h3></gs-header>');
    registerDesignSnippet('<gs-header>', '<gs-header>', 'gs-header><h3>$0</h3></gs-header>');
    
    designRegisterElement('gs-header', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-page.html');
    
    window.designElementProperty_GSHEADER = function(selectedElement) {
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        addFlexContainerProps(selectedElement);
        //addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    xtag.register('gs-header', {
        lifecycle: {
            /*inserted: function () {
                if (this.border_line) {
                    this.removeChild(this.border_line);
                }
                
                this.border_line = document.createElement('div');
                this.border_line.classList.add('border-line');
                this.border_line.setAttribute('gs-dynamic', '');
                
                this.appendChild(this.border_line);
            },
            removed: function () {
                if (this.border_line.parentNode === this) {
                    this.removeChild(this.border_line);
                }
            }*/
        },
        events: {},
        accessors: {},
        methods: {}
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('<gs-img>', '<gs-img>', 'gs-img src="${1}"></gs-img>');
    
    designRegisterElement('gs-img', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-image.html');
    
    window.designElementProperty_GSIMG = function(selectedElement) {
        addProp('Min-Width Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('min-width') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'min-width', this.value);
        });
        
        addProp('Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('media') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'media', this.value);
        });
        
        addProp('Source', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('src') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', this.value);
        });
        
        addProp('Alignment', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('align') || '') + '" mini>' +
                                   '    <option value="left">Left</option>' +
                                   '    <option value="">Center</option>' +
                                   '    <option value="right">Right</option>' +
                                   '</gs-select>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'align', this.value);
        });
        
        addProp('Image Cover', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('image-cover') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'image-cover', this.value === 'true', true);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var arrTakenlayouts = [];
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            
        }
    }
    
    //
    function elementInserted(element) {
        var styleElement;
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
                // if the style element for the grid column CSS doesn't exist: create it
                if (!document.getElementById('gs-dynamic-css')) {
                    styleElement = document.createElement('style');
                    styleElement.setAttribute('id', 'gs-dynamic-css');
                    styleElement.setAttribute('gs-dynamic', '');
                    document.head.appendChild(styleElement);
                }
                
                element.handleSrc();
                
                if (element.getAttribute('min-width')) {
                    element.handleMinWidthCSS();
                } else if (element.getAttribute('media')) {
                    element.handleMediaCSS();
                }
            }
        }
    }
    
    xtag.register('gs-img', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // if the "min-width" attribute changed
                    if (strAttrName === 'min-width') {
                        this.handleMinWidthCSS();
                        
                    // if the "media" attribute changed
                    } else if (strAttrName === 'media') {
                        this.handleMediaCSS();
                        
                    // if the "src" attribute changed
                    } else if (strAttrName === 'src') {
                        this.handleSrc();
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            handleSrc: function () {
                var strSrc = this.getAttribute('src');
                
                if (strSrc) {
                    this.style.backgroundImage = 'url("' + strSrc + '")';
                } else {
                    this.style.backgroundImage = '';
                }
            },
            
            handleMinWidthCSS: function () {
                var strMinWidth = this.getAttribute('min-width'), arrLayouts, strCSS, strCurrentMinWidth,
                    i, len, arrClassesToRemove, intImageID, arrParts, strDimensions, strWidth, strHeight;
                
                // remove old classes
                arrClassesToRemove = String(this.classList).match(/image-id-[0-9]*/g) || [];
                
                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }
                
                // all {150px}; lrg {75px};
                // all {150px, 75px}; lrg {75px, 150px};
                
                // remove all whitespace, remove all close curly braces, lowercase, trim off semicolons
                strMinWidth = GS.trim(strMinWidth.replace(/\s+/g, '').replace(/\}/g, '').toLowerCase(), ';');
                
                // replace shortcuts (lrg => 1200px)
                strMinWidth = strMinWidth.replace(/all/g, '0px')
                                         .replace(/small|sml/g, '768px')
                                         .replace(/medium|med/g, '992px')
                                         .replace(/large|lrg/g, '1200px');
                
                // seperate out layouts
                arrLayouts = strMinWidth.split(';');
                
                //console.log(strMinWidth, arrLayouts);
                
                if (arrTakenlayouts.indexOf(strMinWidth) === -1) {
                    arrTakenlayouts.push(strMinWidth);
                    intImageID = arrTakenlayouts.length - 1;
                    strCSS = '';
                    
                    for (i = 0, len = arrLayouts.length; i < len; i += 1) {
                        arrParts = arrLayouts[i].split('{');
                        strCurrentMinWidth = arrParts[0] || '0px';
                        strDimensions = arrParts[1];
                        
                        if (strDimensions.indexOf(',') === -1) {
                            strWidth = strDimensions;
                            strHeight = strDimensions;
                        } else {
                            arrParts = strDimensions.split(',');
                            strWidth = arrParts[0];
                            strHeight = arrParts[1];
                        }
                        
                        strCSS +=   '\n@media (min-width:' + strCurrentMinWidth + ') {\n' +
                                    '    gs-img.image-id-' + intImageID + ' { width:' + strWidth + '; height: ' + strHeight + '; }\n' +
                                    '}\n';
                    }
                    
                    //console.log(strCSS);
                    
                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* image #' + intImageID + ' */\n' + strCSS;
                    
                } else {
                    intImageID = arrTakenlayouts.indexOf(strMinWidth);
                }
                
                this.classList.add('image-id-' + intImageID);
            },
            
            handleMediaCSS: function () {
                var strMedia = this.getAttribute('media'), arrLayouts, strCSS, i, len,
                    arrClassesToRemove, arrParts, strCurrentMedia, strWidth, intImageID,
                    arrParts, strCurrentMedia, strDimensions, strWidth, strHeight;
                
                // remove old classes
                arrClassesToRemove = String(this.classList).match(/image-id-[0-9]*/g) || [];
                
                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }
                
                // print {200px}; all and (max-width: 500px) {500px}; (min-width 500px) {600px};
                
                // trim, remove all close curly braces, lowercase, trim off semicolons
                strMedia = GS.trim(strMedia.trim().replace(/\}/g, '').toLowerCase(), ';');
                
                // replace shortcuts (lrg => 1200px)
                strMedia = strMedia.replace(/small|sml/g, '768px').replace(/medium|med/g, '992px').replace(/large|lrg/g, '1200px');
                
                arrLayouts = strMedia.split(';'); // seperate out layouts
                
                //console.log(strMedia, arrLayouts);
                
                if (arrTakenlayouts.indexOf(strMedia) === -1) {
                    arrTakenlayouts.push(strMedia);
                    intImageID = arrTakenlayouts.length - 1;
                    strCSS = '';
                    
                    for (i = 0, len = arrLayouts.length; i < len; i += 1) {
                        arrParts = arrLayouts[i].split('{');
                        strCurrentMedia = arrParts[0].trim() || 'all';
                        strDimensions = arrParts[1].trim();
                        
                        if (strDimensions.indexOf(',') === -1) {
                            strWidth = strDimensions;
                            strHeight = strDimensions;
                        } else {
                            arrParts = strDimensions.split(',');
                            strWidth = arrParts[0];
                            strHeight = arrParts[1];
                        }
                        
                        strCSS +=   '\n@media ' + strCurrentMedia + ' {\n' +
                                    '    gs-img.image-id-' + intImageID + ' { width:' + strWidth + '; height: ' + strHeight + '; }\n' +
                                    '}\n';
                    }
                    
                    console.log(strCSS);
                    
                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* image #' + intImageID + ' */\n' + strCSS;
                    
                } else {
                    intImageID = arrTakenlayouts.indexOf(strMinWidth);
                }
                
                this.classList.add('image-id-' + intImageID);
            }
        }
    });
});//jslint white:true
window.addEventListener('design-register-element', function () {
    registerDesignSnippet('<gs-insert>', '<gs-insert>', 'gs-insert src="${1:test.tpeople}">\n' +
                                                        '    ${2}\n' +
                                                        '</gs-insert>');
    
    designRegisterElement('gs-insert', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-insert.html');
    
    window.designElementProperty_GSINSERT = function(selectedElement) {
        addProp('Source&nbsp;Query', true,
                        '<gs-memo rows="1" autoresize class="target" value="' + encodeHTML(selectedElement.getAttribute('src') ||
                                selectedElement.getAttribute('source') || '') + '" mini></gs-memo>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', this.value);
        });
        
        addProp('Additional&nbsp;Values', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('addin') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'addin', this.value);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        addProp('Primary Keys', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('pk') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'pk', this.value);
        });
        
        addProp('Sequences', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('seq') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'seq', this.value);
        });
        
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))          { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop')) { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))  { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))   { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop')) { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))  { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))   { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    xtag.register('gs-insert', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {
            submit: function (callback) {
                if (window.bolSocket === true) {
                    var element = this
                      , srcParts    = GS.templateWithQuerystring(element.getAttribute('src') || '').split('.')
                      , strSchema   = srcParts[0]
                      , strObject   = srcParts[1]
                      , strSeqCols, strPkCols, strAddIn
                      , strColumns = '', strResponseColumns, strInsertRecord = '', strInsertData
                      , arrElement, arrKey, arrValue, i, len, strResponse, parentSrcElement;
                    
                    // addin insert data
                    strAddIn = GS.templateWithQuerystring(element.getAttribute('addin'));
                    if (strAddIn) {
                        arrKey = GS.qryGetKeys(strAddIn);
                        arrValue = GS.qryGetKeys(strAddIn);
                        
                        for (i = 0, len = arrKey.length; i < len; i += 1) {
                            strColumns += (strColumns ? '\t' : '') + GS.encodeForTabDelimited(arrKey[i]);
                            strInsertRecord += (strInsertRecord ? '\t' : '') + GS.encodeForTabDelimited(arrValue[i]);
                        }
                    }
                    
                    // control insert data
                    arrElement = xtag.query(element, '[column]');
                    for (i = 0, len = arrElement.length; i < len; i += 1) {
                        parentSrcElement = GS.findParentElement(arrElement[i].parentNode, '[src]');
                        if (
                            parentSrcElement === element &&
                            (
                                arrElement[i].value !== undefined &&
                                arrElement[i].value !== null &&
                                arrElement[i].value !== ''
                            )) {
                            strColumns += (strColumns ? '\t' : '') + GS.encodeForTabDelimited(arrElement[i].getAttribute('column'));
                            strInsertRecord += (strInsertRecord ? '\t' : '') + GS.encodeForTabDelimited(arrElement[i].value);
                        }
                    }
                    
                    strPkCols = GS.templateWithQuerystring(element.getAttribute('pk') || 'id');
                    strSeqCols = GS.templateWithQuerystring(element.getAttribute('seq') || '');
                    strInsertData = (strColumns + '\n' + strInsertRecord);
                    strResponseColumns = (strPkCols + (strPkCols ? '\t' : '') + strColumns);
                    
                    GS.requestInsertFromSocket(
                            GS.envSocket, strSchema, strObject, strResponseColumns, strPkCols, strSeqCols, strInsertData
                            // beginCallback
                          , function () {}
                            
                            // confirmCallback
                          , function (data, error, transactionID, commitFunction, rollbackFunction) {
                                var arrCells, i, len, arrElements, jsnSelection, focusElement, focusColumnParent, focusColumnParentIndex;
                                
                                if (data !== 'TRANSACTION COMPLETED') {
                                    if (!error) {
                                        strResponse = data;
                                        commitFunction();
                                        
                                    } else {
                                        GS.webSocketErrorDialog(data);
                                        rollbackFunction();
                                    }
                                } else {
                                    commitFunction();
                                }
                            }
                            
                            // finalCallback
                          , function (strType, data, error) {
                                var arrColumns, arrCells, jsnRow = {}, i, len;
                                
                                if (strType === 'COMMIT') {
                                    arrColumns = strResponseColumns.split('\t');
                                    arrCells = (strResponse || '').split('\n')[0].split('\t');
                                    
                                    if (arrColumns.length !== arrCells.length) {
                                        throw 'gs-insert Error: Insert API call isn\'t returning correctly. (' + arrColumns.join(',') + ') -> (' + arrCells.join(',') + ')';
                                    } else {
                                        for (i = 0, len = arrColumns.length; i < len; i += 1) {
                                            jsnRow[GS.decodeFromTabDelimited(arrColumns[i])] = GS.decodeFromTabDelimited(arrCells[i]);
                                        }
                                        
                                        GS.triggerEvent(element, 'after_insert');
                                        
                                        if (typeof callback === 'function') {
                                            callback(GS.decodeFromTabDelimited(arrCells[0]), jsnRow);
                                        }
                                    }
                                }
                            }
                    );
                } else {
                    var element = this, strInsertString = '', arrElement, i, len, jsnRow = {}, parentSrcElement,
                        strSource = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') ||
                                                                                   element.getAttribute('source') || '')),
                        strParameters, strLink;
                    
                    // if there is an addin attribute on this element:
                    if (element.getAttribute('addin')) {
                        strInsertString += GS.templateWithQuerystring(element.getAttribute('addin'));
                    }
                    
                    // build insert string
                    arrElement = xtag.query(element, '[column]');
                    
                    for (i = 0, len = arrElement.length; i < len; i += 1) {
                        parentSrcElement = GS.findParentElement(arrElement[i].parentNode, '[src]');
                        if (
                            parentSrcElement === element &&
                            (
                                arrElement[i].value !== undefined &&
                                arrElement[i].value !== null &&
                                arrElement[i].value !== ''
                            )) {
                            jsnRow[arrElement[i].getAttribute('column')] = arrElement[i].value;
                            strInsertString += (strInsertString ? '&' : '') + arrElement[i].getAttribute('column') + '=' +
                                                                                    encodeURIComponent(arrElement[i].value);
                        }
                    }
                    
                    strInsertString = encodeURIComponent(strInsertString);
                    
                    strParameters = 'src=' + encodeURIComponent(strSource) + '&data=' + strInsertString;
                    
                    if (element.getAttribute('seq')) {
                        strParameters += '&currval=' + element.getAttribute('seq');
                    }
                    
                    strLink = '/' +
                              (element.getAttribute('action-insert') || 'env/action_insert');
                    
                    // add a loader to the page
                    GS.addLoader('gs-insert', 'Inserting Record...');
                    
                    // make the insert call
                    GS.ajaxJSON(strLink, strParameters, function (data, error) {
                        GS.removeLoader('gs-insert');
                        
                        // if there was no error: trigger event
                        if (!error) {
                            GS.triggerEvent(element, 'after_insert');
                            
                            if (typeof callback === 'function') {
                                callback(data.dat.lastval, jsnRow);
                            }
                            
                        // else if there was an error: error dialog
                        } else {
                            GS.ajaxErrorDialog(data);
                        }
                    });
                }
            }
        }
    });
});//global GS, window, document, xtag, evt, ml, encodeHTML, addFlexProps, setOrRemoveTextAttribute, setOrRemoveBooleanAttribute, addProp

window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-interval>', '<gs-interval>', 'gs-interval column="${1:complete_time}"></gs-interval>');
    registerDesignSnippet('<gs-interval> With Label', '<gs-interval>', 'label for="${1:interval-insert-complete_time}">${2:Time to complete}:</label>\n' +
                                                               '<gs-interval id="${1:interval-insert-complete_time}" column="${3:complete_time}"></gs-interval>');
    
    designRegisterElement('gs-interval', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-interval.html');

    window.designElementProperty_GSINTERVAL = function (selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        addProp('Time Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-picker')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-picker', (this.value === 'true'), false);
        });

        addProp(
            'Unit',
            true,
            '        <gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('unit') || 'hours') + '" mini>' +
                    '    <option value="hours">Hours</option>' +
                    '    <option value="minutes">Minutes</option>' +
                    '    <option value="seconds">Seconds</option>' +
                    '</gs-select>',
            function () {
                return setOrRemoveTextAttribute(selectedElement, 'unit', this.value);
            }
        );

        addProp('Hour Places', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('hour-places') || '3') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'hour-places', this.value);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });


        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility',
                true,
                '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                '    <option value="">Visible</option>' +
                '    <option value="hidden">Invisible</option>' +
                '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                '    <option value="hide-on-phone">Invisible at phone size</option>' +
                '    <option value="show-on-desktop">Visible at desktop size</option>' +
                '    <option value="show-on-tablet">Visible at tablet size</option>' +
                '    <option value="show-on-phone">Visible at phone size</option>' +
                '</gs-select>',
                function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        addFlexProps(selectedElement);

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});


document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    //x attributes:
    //x      disabled:      copy to control element
    //x      tabindex:      move to control element
    //x      qs:            fill value from querystring, update value as querystring changes
    //x      value:         affects control value
    //x      no-picker:     affects innerHTML because it removes the picker button
    //x      unit
    //x      hour-places
    //x      minute-places
    //x      second-places

    //x accessors:
    //x      value:     returns text value
    //x      state:     returns text representation of state: "open" or "closed"

    //x methods:
    //x      open:   opens popup
    //x      close:  closes popup
    //x      toggle: toggles open and closed methods

    //x text editing behaviours:
    //x      text is divided by colons into portions
    //x      if value is deleted or empty, it displays with zeros

    //x events:
    //x      picker button click: runs "toggle" method
    //x      control keydown:
    //x          up arrow:    increase currently selected portion
    //x          down arrow:  previous minute
    //x          left arrow:  select previous portion
    //x          right arrow: select next portion

    //x dropdown behaviours:
    //x          if from control to bottom has enough room: popup below
    //x          else: popup above

    /*
        unit:
            hours: shows hours only
            minutes: shows minutes and hours
            seconds: shows seconds, minutes and hours
        hour-places: allows the dev to choose the maximum places in the hours
    */


    // #####################################################################################
    // ################################## EVENT  TRIGGERING ################################
    // #####################################################################################

    function handleChange(element) {
        element.close();
        if (element.lastChangeValue !== element.getAttribute('value')) {
            GS.triggerEvent(element, 'change');
            element.lastChangeValue = element.getAttribute('value');
        }
    }

    // #####################################################################################
    // ################################## EVENT RETARGETING ################################
    // #####################################################################################

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        event.target.parentNode.setAttribute('value', event.target.value);
        handleChange(event.target.parentNode);
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
    }


    // #####################################################################################
    // ######################################## VALUE ######################################
    // #####################################################################################

    //console.log('1***', translateValue(GS.stringToElement('<gs-interval unit="hours"></gs-interval>'), '5.255')); // 5 hours, 15 mins, 30 seconds
    //console.log('2***', translateValue(GS.stringToElement('<gs-interval unit="minutes"></gs-interval>'), '500.25')); // 8 hours, 20 mins, 15 seconds
    //console.log('3***', translateValue(GS.stringToElement('<gs-interval unit="seconds"></gs-interval>'), '5000')); // 1 hour, 23 mins, 20 seconds
    //console.log('4***', translateValue(GS.stringToElement('<gs-interval unit="seconds"></gs-interval>'), '0.03333333333333333')); // 2 mins

    function valueGetCurrentNumber(element) {
        var intValue = 0;

        if (element.internal.unit === 'minutes') {
            intValue += (element.internal.value.hours * 60);
            intValue += element.internal.value.minutes;
            //intValue += (element.internal.value.seconds / 60);
        } else if (element.internal.unit === 'seconds') {
            intValue += ((element.internal.value.hours * 60) * 60);
            intValue += (element.internal.value.minutes * 60);
            intValue += element.internal.value.seconds;
        } else {//hours
            intValue += element.internal.value.hours;
            //intValue += parseFloat((element.internal.value.minutes / 60).toFixed(5));
            //intValue += parseFloat(((element.internal.value.seconds / 60) / 60).toFixed(5));
        }

        return String(intValue);
    }

    function valueGetCurrentDisplay(element) {
        var strValue = '';
        var intHours = element.internal.value.hours;
        var intMinutes = element.internal.value.minutes;
        var intSeconds = element.internal.value.seconds;

        if (element.internal.places.hours > 0) {
            strValue += GS.leftPad(intHours || '', '0', element.internal.places.hours);
        }

        if (element.internal.places.minutes > 0) {
            strValue += (strValue ? ':' : '');
            strValue += GS.leftPad(intMinutes || '', '0', element.internal.places.minutes);
        }

        if (element.internal.places.seconds > 0) {
            strValue += (strValue ? ':' : '');
            strValue += GS.leftPad(intSeconds || '', '0', element.internal.places.seconds);
        }

        return String(strValue);
    }

    function valueUpdatePicker(element) {
        var currentValue = valueGetCurrentDisplay(element);
        var i;
        var len;
        var arrElements;
        var intColons = 0;

        //console.log('currentValue:', currentValue);
        //console.log('PLACES: ', element.internal.places.hours, element.internal.places.minutes, element.internal.places.seconds);

        // set value of the select boxes
        i = 0;
        len = element.internal.places.hours;
        arrElements = xtag.query(element.internal.picker, '[data-hour]');
        while (i < len) {
            //console.log('SELECTBOX HR: ', arrElements[i]);
            arrElements[i].value = currentValue[i];
            i += 1;
        }
        if (len > 0) {
            intColons += 1;
        }

        i = 0;
        len = element.internal.places.minutes;
        arrElements = xtag.query(element.internal.picker, '[data-minute]');
        while (i < len) {
            //console.log('SELECTBOX MIN: ', arrElements[i]);
            arrElements[i].value =
                    currentValue[element.internal.places.hours + intColons + i];
            i += 1;
        }
        if (len > 0) {
            intColons += 1;
        }

        i = 0;
        len = element.internal.places.seconds;
        arrElements = xtag.query(element.internal.picker, '[data-second]');
        while (i < len) {
            //console.log('SELECTBOX SEC: ', arrElements[i]);
            arrElements[i].value =
                    currentValue[element.internal.places.hours + element.internal.places.minutes + intColons + i];
            i += 1;
        }
    }

    function valueUpdateDisplay(element) {
        if (element.control) {
            element.control.value = valueGetCurrentDisplay(element);
        } else {
            element.textContent = valueGetCurrentDisplay(element);
        }
    }

    function valueUpdateAttribute(element) {
        element.setAttribute('value', valueGetCurrentNumber(element));
    }


    // #####################################################################################
    // ####################################### CONTROL #####################################
    // #####################################################################################

    function refreshControl(element) {
        var i;
        var len;
        var arrPassThroughAttributes;
        var strHTML;

        // clear out HTML
        element.innerHTML = '';

        // clear out element variables
        element.control = '';
        element.button = '';

        // if we are not disabled:
        if (!element.hasAttribute('disabled')) {
            // build HTML
            strHTML =
                    '<input class="control" gs-dynamic type="text" ' +
                    'autocorrect="off" autocapitalize="off" ' +
                    'autocomplete="off" spellcheck="false" />';
            if (!element.hasAttribute('no-picker')) {
                strHTML += '<gs-button class="time-picker-button" gs-dynamic inline icononly icon="hourglass-o" no-focus></gs-button>';
            }

            // set control HTML
            element.innerHTML = strHTML;

            // fill element variables
            element.control = element.children[0];
            element.button = element.children[1];

            // handle passthrough attributes
            arrPassThroughAttributes = ['name', 'autofocus', 'spellcheck', 'readonly'];

            i = 0;
            len = arrPassThroughAttributes.length;
            while (i < len) {
                if (element.hasAttribute(arrPassThroughAttributes[i])) {
                    element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
                }
                i += 1;
            }

            // move tabindex, tabindex is special because tabindex affects any displayed element it's used on
            if (element.hasAttribute('tabindex')) {
                element.oldTabIndex = element.getAttribute('tabindex');
                element.removeAttribute('tabindex');
            }

            if (element.oldTabIndex) {
                element.control.tabIndex = element.oldTabIndex;
            }

            // bind control retargeting
            element.control.removeEventListener('change', changeFunction);
            element.control.addEventListener('change', changeFunction);

            element.control.removeEventListener('focus', focusFunction);
            element.control.addEventListener('focus', focusFunction);
        }

        // display value
        valueUpdateDisplay(element);
        //displayValue(element);
        //setValueDisplay(element, element.getAttribute('value'));
    }

    function valueSiphonAttribute(element) {
        var fltValue = parseFloat(element.getAttribute('value') || '0');

        var intHours;
        var intMinutes;
        var intSeconds;

        if (element.internal.unit === 'minutes') {
            intHours = Math.floor(fltValue / 60);
            fltValue = fltValue - (intHours * 60); // remove the hours from fltValue

            intMinutes = Math.floor(fltValue);
            fltValue = fltValue - Math.floor(fltValue); // remove the minutes from fltValue

            intSeconds = 0; //Math.floor(fltValue);

        } else if (element.internal.unit === 'seconds') {
            intHours = Math.floor((fltValue / 60) / 60);
            fltValue = fltValue - ((intHours * 60) * 60); // remove the hours from fltValue

            intMinutes = Math.floor(fltValue / 60);
            fltValue = fltValue - (intMinutes * 60); // remove the minutes from fltValue

            intSeconds = Math.round(fltValue);
        } else {
            intHours = Math.floor(fltValue);
            //fltValue = fltValue - intHours; // remove the hours from fltValue

            intMinutes = 0;//Math.floor(fltValue * 60);
            //fltValue = fltValue - (intMinutes / 60);

            intSeconds = 0;//Math.round((fltValue * 100) * 60);
        }

        if (isNaN(intHours)) {
            intHours = 0;
        }
        if (isNaN(intMinutes)) {
            intMinutes = 0;
        }
        if (isNaN(intSeconds)) {
            intSeconds = 0;
        }

        //console.log('siphon: ', element);
        //console.log('intHours:   ', intHours);
        //console.log('intMinutes: ', intMinutes);
        //console.log('intSeconds: ', intSeconds);

        element.internal.value.hours = intHours;
        element.internal.value.minutes = intMinutes;
        element.internal.value.seconds = intSeconds;
    }


    // #####################################################################################
    // ##################################### QUERYSTRING ###################################
    // #####################################################################################

    //function pushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString();
    //    var strQSCol = element.getAttribute('qs');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
    //    }
    //}

    
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.setAttribute('value', strQSValue);
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    function handleQS(element) {
        //var strQSValue;

        if (!element.qsEventFunction) {
            element.qsEventFunction = function () {
                pushReplacePopHandler(element);
            };
        }

        window.removeEventListener('pushstate', element.qsEventFunction);
        window.removeEventListener('replacestate', element.qsEventFunction);
        window.removeEventListener('popstate', element.qsEventFunction);

        // handle "qs" attribute
        if (element.getAttribute('qs')) {
            pushReplacePopHandler(element);
            //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));

            //if (strQSValue !== '' || !element.getAttribute('value')) {
            //    element.setAttribute('value', strQSValue);
            //}

            window.addEventListener('pushstate', element.qsEventFunction);
            window.addEventListener('replacestate', element.qsEventFunction);
            window.addEventListener('popstate', element.qsEventFunction);
        }
    }

    // #####################################################################################
    // ################################### PARENT  ELEMENT #################################
    // #####################################################################################

    function prepElement(element) {
        element.internal = {};

        element.internal.value = {
            "hours": 0,
            "minutes": 0,
            "seconds": 0
        };

        element.internal.places = {
            "hours": 0,
            "minutes": 0,
            "seconds": 0
        };

        element.internal.unit = '';

        element.internal.picker = '';
    }

    function siphonElement(element) {
        // siphon the unit
        element.internal.unit = element.getAttribute('unit') || '';
        element.internal.unit = element.internal.unit.toLowerCase();
        element.internal.unit = element.internal.unit || 'minutes';

        if (element.internal.unit !== 'hours' &&
                element.internal.unit !== 'minutes' &&
                element.internal.unit !== 'seconds') {
            element.internal.unit = 'minutes';
            console.warn(
                'gs-interval Warning: invalid "unit" attribute. ' +
                        'Please use "hours", "minutes" or "seconds".  ' +
                        'Defaulting "unit" to "minutes"',
                element
            );
        }

        // get the place settings
        var intHourPlaces = parseInt(element.getAttribute('hour-places'), 10);
        var intMinutePlaces = 0;
        var intSecondPlaces = 0;

        // default place settings
        if (isNaN(intHourPlaces)) {
            intHourPlaces = 3;
        }
        if (element.internal.unit === 'minutes' || element.internal.unit === 'seconds') {
            intMinutePlaces = 2;
        }
        if (element.internal.unit === 'seconds') {
            intSecondPlaces = 2;
        }

        element.internal.places.hours = intHourPlaces;
        element.internal.places.minutes = intMinutePlaces;
        element.internal.places.seconds = intSecondPlaces;

        // siphon the value attribute
        // get hours/minutes/seconds from value
        valueSiphonAttribute(element);
    }

    // #####################################################################################
    // ###################################### LIFECYCLE ####################################
    // #####################################################################################

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
            }
        }
    }

    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.innerState = 'closed';

                prepElement(element);
                siphonElement(element);
                saveDefaultAttributes(element);
                refreshControl(element);

                if (element.getAttribute('qs')) {
                    handleQS(element);
                }

                element.lastChangeValue = element.getAttribute('value');
            }
        }
    }

    // ######################################################################################
    // ##################################### REGISTRATION ###################################
    // ######################################################################################

    xtag.register('gs-interval', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'disabled' || strAttrName === 'no-picker' || strAttrName === 'tabindex') {
                        siphonElement(element);
                        refreshControl(element);

                    } else if (strAttrName === 'qs') {
                        handleQS(element);

                    } else if (strAttrName === 'value' && element.inserted) {
                        ////displayValue(element);
                        //siphonElement(element);
                        //displayValue(element);
                        ////setValueDisplay(element, newValue);
                        valueSiphonAttribute(element);
                        valueUpdateDisplay(element);

                        if (element.innerState === 'open') {
                            valueUpdatePicker(element);
                        }
                    }
                }
            }
        },
        events: {
            'click': function (event) {
                var element = this;
                if (event.target === element.button) {
                    element.toggle();
                }
            },

            'mouseup': function (event) {
                var element = this;
                var strValue = element.control.value;
                var jsnTextSelection;
                var intCursor;
                var i;
                var len;
                var arrDelimiterIndexes;
                var intSection;

                if (!element.hasAttribute('readonly')) {
                    element.numberOfCharsTyped = 0;
    
                    jsnTextSelection = GS.getInputSelection(element.control);
    
                    i = 0;
                    len = strValue.length;
                    arrDelimiterIndexes = [0];
                    while (i < len) {
                        if (strValue[i] === ':') {
                            arrDelimiterIndexes.push(i);
                        }
                        i += 1;
                    }
                    arrDelimiterIndexes.push(strValue.length);
    
                    event.preventDefault();
    
                    intCursor = jsnTextSelection.start;
    
                    // find out what section the cursor is in
                    i = 1;
                    len = arrDelimiterIndexes.length;
                    while (i < len) {
                        if (intCursor >= arrDelimiterIndexes[i - 1] && intCursor <= arrDelimiterIndexes[i]) {
                            intSection = i;
                            break;
                        }
                        i += 1;
                    }
    
                    // select the section of the value that the cursor is in
                    if (intSection === 1) {
                        GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1], arrDelimiterIndexes[intSection]);
                    } else {
                        GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1] + 1, arrDelimiterIndexes[intSection]);
                    }
                }
            },

            'keydown': function (event) { // don't use the "input" event, doesn't work for this
                var element = this;
                var strValue = element.control.value;
                var intKeyCode = (event.keyCode || event.which);

                var jsnTextSelection;
                var arrDelimiterIndexes;
                var i;
                var len;
                var intCursor;
                var intSection;
                var strPlace;
                var strChar;
                var strSection;

                if (!element.hasAttribute('readonly')) {
                    jsnTextSelection = GS.getInputSelection(element.control);
    
                    i = 0;
                    len = strValue.length;
                    arrDelimiterIndexes = [0];
                    while (i < len) {
                        if (strValue[i] === ':') {
                            arrDelimiterIndexes.push(i);
                        }
                        i += 1;
                    }
                    arrDelimiterIndexes.push(strValue.length);
    
                    // get cursor position
                    intCursor = jsnTextSelection.start;
    
                    // find out what section the cursor is in
                    i = 1;
                    len = arrDelimiterIndexes.length;
                    while (i < len) {
                        if (intCursor >= arrDelimiterIndexes[i - 1] && intCursor <= arrDelimiterIndexes[i]) {
                            intSection = i;
                            break;
                        }
                        i += 1;
                    }
    
                    // if key was an arrow
                    if (intKeyCode >= 37 && intKeyCode <= 40) {
                        element.numberOfCharsTyped = 0;
                        event.preventDefault();
    
                        // left     37
                        // top      38
                        // right    39
                        // down     40
    
                        // handle/right arrows moving the cursor
                        if (intKeyCode === 37) {
                            intSection -= 1;
                            intSection = Math.max(intSection, 1);
                        } else if (intKeyCode === 39) {
                            intSection += 1;
                            intSection = Math.min(intSection, arrDelimiterIndexes.length - 1);
                        }
    
                        // select the section of the value that the cursor is in
                        if (intSection === 1) {
                            GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1], arrDelimiterIndexes[intSection]);
                        } else {
                            GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1] + 1, arrDelimiterIndexes[intSection]);
                        }
    
                        // find out what section that the cursor is in (hours, minutes or seconds)
                        if (intSection === 0 || intSection === 1) {
                            strPlace = 'hours';
                        } else if (intSection === 2) {
                            strPlace = 'minutes';
                        } else if (intSection === 3 || intSection === 4) {
                            strPlace = 'seconds';
                        }
    
                        // update text selection variable
                        jsnTextSelection = GS.getInputSelection(element.control);
    
                        // handle up and down arrows incrementing/decrementing
                        //      the value of the currently selected section
                        if (intKeyCode === 38) { // up
                            if (strPlace === 'hours') {
                                element.internal.value.hours += 1;
                            } else if (strPlace === 'minutes') {
                                element.internal.value.minutes += 1;
                            } else if (strPlace === 'seconds') {
                                element.internal.value.seconds += 1;
                            }
    
                            if (String(element.internal.value.hours).length > element.internal.places.hours) {
                                element.internal.value.hours = parseInt(
                                    '999999999999999'.substring(0, element.internal.places.hours),
                                    10
                                );
                            }
                            if (element.internal.value.seconds > 59) {
                                element.internal.value.minutes += 1;
                                element.internal.value.seconds = 0;
                            }
                            if (element.internal.value.minutes > 59) {
                                element.internal.value.hours += 1;
                                element.internal.value.minutes = 0;
                            }
    
                        } else if (intKeyCode === 40) { // down
                            if (strPlace === 'hours') {
                                element.internal.value.hours -= 1;
                            } else if (strPlace === 'minutes') {
                                element.internal.value.minutes -= 1;
                            } else if (strPlace === 'seconds') {
                                element.internal.value.seconds -= 1;
                            }
    
                            if (element.internal.value.seconds < 0) {
                                if (element.internal.value.minutes > 0) {
                                    element.internal.value.minutes -= 1;
                                    element.internal.value.seconds = 59;
                                } else if (element.internal.value.hours > 0) {
                                    element.internal.value.hours -= 1;
                                    element.internal.value.minutes = 59;
                                    element.internal.value.seconds = 59;
                                } else {
                                    element.internal.value.seconds = 0;
                                }
                            }
                            if (element.internal.value.minutes < 0) {
                                if (element.internal.value.hours > 0) {
                                    element.internal.value.minutes = 59;
                                    element.internal.value.hours -= 1;
                                } else {
                                    element.internal.value.minutes = 0;
                                }
                            }
                            if (element.internal.value.hours < 0) {
                                element.internal.value.hours = 0;
                            }
                        }
    
                        if (intKeyCode === 38 || intKeyCode === 40) {
                            //trinkleValueDown(element);
                            //displayValue(element);
                            valueUpdateAttribute(element);
                            GS.setInputSelection(element.control, jsnTextSelection.start, jsnTextSelection.end);
                        }
    
                    // if key was a number
                    } else if ((intKeyCode >= 48 && intKeyCode <= 57) || (intKeyCode >= 96 && intKeyCode <= 105)) {
                        element.numberOfCharsTyped = element.numberOfCharsTyped || 0;
                        event.preventDefault();
    
                        // get the character that was typed
                        strChar = String.fromCharCode(intKeyCode);
                        if (intKeyCode === 96) { strChar = '0'; }
                        if (intKeyCode === 97) { strChar = '1'; }
                        if (intKeyCode === 98) { strChar = '2'; }
                        if (intKeyCode === 99) { strChar = '3'; }
                        if (intKeyCode === 100) { strChar = '4'; }
                        if (intKeyCode === 101) { strChar = '5'; }
                        if (intKeyCode === 102) { strChar = '6'; }
                        if (intKeyCode === 103) { strChar = '7'; }
                        if (intKeyCode === 104) { strChar = '8'; }
                        if (intKeyCode === 105) { strChar = '9'; }
    
                        // select the section of the value that the cursor is in
                        if (intSection === 1) {
                            GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1], arrDelimiterIndexes[intSection]);
                        } else {
                            GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1] + 1, arrDelimiterIndexes[intSection]);
                        }
    
                        // find out what section that the cursor is in (hours, minutes or seconds)
                        if (intSection === 0 || intSection === 1) {
                            strPlace = 'hours';
                        } else if (intSection === 2) {
                            strPlace = 'minutes';
                        } else if (intSection === 3 || intSection === 4) {
                            strPlace = 'seconds';
                        }
    
                        // update text selection variable
                        jsnTextSelection = GS.getInputSelection(element.control);
    
                        // when you type in a number,
                        //      if no data is set saying "this is where the typing begins":
                        //              insert the number as the first character of the section
                        //              after that set data to say where the typing begins
                        //      no matter what is typed: stay in the same section
                        strSection = strValue.substring(jsnTextSelection.start, jsnTextSelection.end);
    
                        strSection =
                                strSection.substring(0, element.numberOfCharsTyped) +
                                strChar +
                                strSection.substring(element.numberOfCharsTyped + 1);
    
                        strValue =
                                strValue.substring(0, jsnTextSelection.start) +
                                strSection +
                                strValue.substring(jsnTextSelection.end);
    
                        //console.log(element.numberOfCharsTyped);
                        element.numberOfCharsTyped += 1;
    
                        if (element.numberOfCharsTyped === strSection.length) {
                            element.numberOfCharsTyped = 0;
                        }
    
                        if (strPlace === 'hours') {
                            element.internal.value.hours = parseInt(strSection, 10);
                        }
                        if (strPlace === 'minutes') {
                            element.internal.value.minutes = parseInt(strSection, 10);
                        }
                        if (strPlace === 'seconds') {
                            element.internal.value.seconds = parseInt(strSection, 10);
                        }
    
                        //console.log(strValue, element.control.value, translateValueToNumber(element, strValue));
    
                        if (strValue !== element.control.value) {
                            //trinkleValueDown(element);
                            //displayValue(element);
                            valueUpdateAttribute(element);
                            GS.setInputSelection(element.control, jsnTextSelection.start, jsnTextSelection.end);
                        }
                    } else if (intKeyCode === 13) {
                        element.numberOfCharsTyped = 0;
                        event.preventDefault();
                        handleChange(element);
                    } else if (intKeyCode !== 9 && event.ctrlKey === false && event.metaKey === false) {
                        element.numberOfCharsTyped = 0;
                        event.preventDefault();
                    }
                }
            },
            'blur': function () {// don't use 'focusout', it doesn't work on firefox
                var element = this;
                if (element.innerState === 'closed') {
                    handleChange(element);
                }
            }
        },
        accessors: {
            value: {
                get: function () {
                    return this.getAttribute('value');
                },
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                }
            },
            state: {
                get: function () {
                    return this.innerState;
                },
                set: function (newValue) {
                    var element = this;
                    if (newValue === 'open') {
                        element.open();
                    } else {
                        element.close();
                    }
                }
            }
        },
        methods: {
            focus: function () {
                this.control.focus();
            },

            open: function () {
                var element = this;
                var pickerContainerElement;
                var overlayElement;
                var pickerElement;
                var handleLook;
                var strHTML;
                var i;
                var len;
                var arrElements;

                if (element.innerState === 'closed') {
                    element.innerState = 'open';
                    element.lastClosedValue = element.getAttribute('value');

                    // if we are not on a touch device: focus control
                    if (!evt.touchDevice) {
                        element.control.focus();
                        GS.setInputSelection(element.control, 0, element.control.value.length);
                    }

                    // create picker elements
                    pickerContainerElement = document.createElement('div');
                    pickerContainerElement.classList.add('gs-interval-time-picker-container');

                    overlayElement = document.createElement('div');
                    overlayElement.classList.add('gs-interval-time-picker-overlay');

                    pickerElement = document.createElement('div');
                    pickerElement.classList.add('gs-interval-time-picker');
                    element.internal.picker = pickerElement;

                    // save picker container
                    element.pickerContainerElement = pickerContainerElement;

                    // append picker elements
                    pickerContainerElement.appendChild(overlayElement);
                    pickerContainerElement.appendChild(pickerElement);

                    document.body.appendChild(pickerContainerElement);

                    // fill picker popup
                    strHTML = '';
                    strHTML += '<div class="time-inner-container">';

                    i = 0;
                    len = element.internal.places.hours;
                    while (i < len) {
                        strHTML +=
                                '<select class="gs-interval-hour" data-hour="' + i + '">' +
                                '    <option value="0">&nbsp;0</option>' +
                                '    <option value="1">&nbsp;1</option>' +
                                '    <option value="2">&nbsp;2</option>' +
                                '    <option value="3">&nbsp;3</option>' +
                                '    <option value="4">&nbsp;4</option>' +
                                '    <option value="5">&nbsp;5</option>' +
                                '    <option value="6">&nbsp;6</option>' +
                                '    <option value="7">&nbsp;7</option>' +
                                '    <option value="8">&nbsp;8</option>' +
                                '    <option value="9">&nbsp;9</option>' +
                                '</select>';
                        i += 1;
                    }

                    if (element.internal.places.hours > 0 && element.internal.places.minutes > 0) {
                        strHTML += '<span class="colon">:</span>';
                    }

                    i = 0;
                    len = element.internal.places.minutes;
                    while (i < len) {
                        strHTML +=
                                '<select class="gs-interval-minute" data-minute="' + i + '">' +
                                '    <option value="0">&nbsp;0</option>' +
                                '    <option value="1">&nbsp;1</option>' +
                                '    <option value="2">&nbsp;2</option>' +
                                '    <option value="3">&nbsp;3</option>' +
                                '    <option value="4">&nbsp;4</option>' +
                                '    <option value="5">&nbsp;5</option>';

                        if (i > 0) {
                            strHTML +=
                                    '<option value="6">&nbsp;6</option>' +
                                    '<option value="7">&nbsp;7</option>' +
                                    '<option value="8">&nbsp;8</option>' +
                                    '<option value="9">&nbsp;9</option>';
                        }

                        strHTML +=
                                '</select>';
                        i += 1;
                    }

                    if (element.internal.places.minutes > 0 && element.internal.places.seconds > 0) {
                        strHTML += '<span class="colon">:</span>';
                    }

                    i = 0;
                    len = element.internal.places.seconds;
                    while (i < len) {
                        strHTML +=
                                '<select class="gs-interval-second" data-second="' + i + '">' +
                                '    <option value="0">&nbsp;0</option>' +
                                '    <option value="1">&nbsp;1</option>' +
                                '    <option value="2">&nbsp;2</option>' +
                                '    <option value="3">&nbsp;3</option>' +
                                '    <option value="4">&nbsp;4</option>' +
                                '    <option value="5">&nbsp;5</option>';

                        if (i > 0) {
                            strHTML +=
                                    '<option value="6">&nbsp;6</option>' +
                                    '<option value="7">&nbsp;7</option>' +
                                    '<option value="8">&nbsp;8</option>' +
                                    '<option value="9">&nbsp;9</option>';
                        }

                        strHTML +=
                                '</select>';
                        i += 1;
                    }

                    strHTML += '</div>';
                    pickerElement.innerHTML = strHTML;


                    // set picker value
                    valueUpdatePicker(element);

                    // bind picker click
                    overlayElement.addEventListener('click', function () {
                        element.close();
                    });

                    pickerElement.addEventListener('change', function () {//event
                        //var arrElements;
                        //var i;
                        //var len;
                        var newValue = 0;
                        var strCurrentValue;

                        if (element.internal.unit === 'hours') {
                            i = 0;
                            len = element.internal.places.hours;
                            arrElements = xtag.query(pickerElement, '[data-hour]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10);
                            }

                            //i = 0;
                            //len = element.internal.places.minutes;
                            //arrElements = xtag.query(pickerElement, '[data-minute]');
                            //strCurrentValue = '';
                            //while (i < len) {
                            //    strCurrentValue += arrElements[i].value;
                            //    i += 1;
                            //}
                            //if (arrElements.length > 0) {
                            //    newValue += (parseInt(strCurrentValue, 10) / 60);
                            //}

                            //i = 0;
                            //len = element.internal.places.seconds;
                            //arrElements = xtag.query(pickerElement, '[data-second]');
                            //strCurrentValue = '';
                            //while (i < len) {
                            //    strCurrentValue += arrElements[i].value;
                            //    i += 1;
                            //}
                            //if (arrElements.length > 0) {
                            //    newValue += ((parseInt(strCurrentValue, 10) / 60) / 60);
                            //}
                        }
                        if (element.internal.unit === 'minutes') {
                            i = 0;
                            len = element.internal.places.hours;
                            arrElements = xtag.query(pickerElement, '[data-hour]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10) * 60;
                            }

                            i = 0;
                            len = element.internal.places.minutes;
                            arrElements = xtag.query(pickerElement, '[data-minute]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10);
                            }

                            //i = 0;
                            //len = element.internal.places.seconds;
                            //arrElements = xtag.query(pickerElement, '[data-second]');
                            //strCurrentValue = '';
                            //while (i < len) {
                            //    strCurrentValue += arrElements[i].value;
                            //    i += 1;
                            //}
                            //if (arrElements.length > 0) {
                            //    newValue += ((parseInt(strCurrentValue, 10) * 60) * 60);
                            //}
                        }
                        if (element.internal.unit === 'seconds') {
                            i = 0;
                            len = element.internal.places.hours;
                            arrElements = xtag.query(pickerElement, '[data-hour]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += ((parseInt(strCurrentValue, 10) * 60) * 60);
                            }

                            i = 0;
                            len = element.internal.places.minutes;
                            arrElements = xtag.query(pickerElement, '[data-minute]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10) * 60;
                            }

                            i = 0;
                            len = element.internal.places.seconds;
                            arrElements = xtag.query(pickerElement, '[data-second]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10);
                            }
                        }

                        element.setAttribute('value', newValue);
                        //trinkleValueDown(element);
                        //setValueDisplay(element, newValue);
                    });

                    // handle/bind positioning and look
                    handleLook = function () {
                        var positionData;
                        var intPopupHeight;
                        var intPopupWidth;

                        if (pickerContainerElement.parentNode !== document.body) {
                            window.removeEventListener('resize', handleLook);
                            window.removeEventListener('orientationchange', handleLook);
                            return;
                        }

                        // clear current styles
                        pickerElement.style.top = '';
                        pickerElement.style.left = '';
                        pickerElement.style.marginTop = '';
                        //pickerContainerElement.classList.remove('modal');

                        // get position/size data
                        positionData = GS.getElementPositionData(element);
                        intPopupHeight = pickerElement.offsetHeight;
                        intPopupWidth = pickerElement.offsetWidth;

                        // if from control to bottom has enough room: popup below
                        if (positionData.intRoomBelow > intPopupHeight) {
                            pickerElement.style.top = (positionData.objElementOffset.top + positionData.intElementHeight) + 'px';

                        // else: popup above
                        } else {
                            pickerElement.style.top = (positionData.objElementOffset.top - intPopupHeight) + 'px';
                        }

                        pickerElement.style.left =
                                (((positionData.objElementOffset.left + positionData.intElementWidth) - intPopupWidth) - 4) + 'px';
                    };

                    handleLook();

                    window.addEventListener('resize', handleLook);
                    window.addEventListener('orientationchange', handleLook);
                }
            },

            close: function () {
                var element = this;

                if (element.innerState === 'open') {
                    element.innerState = 'closed';
                    if (element.pickerContainerElement) {
                        document.body.removeChild(element.pickerContainerElement);
                        element.pickerContainerElement = '';
                    }
                    if (element.getAttribute('value') !== element.lastClosedValue) {
                        handleChange(element);
                    }
                }
            },

            toggle: function () {
                var element = this;

                if (element.innerState === 'open') {
                    element.close();
                } else {
                    element.open();
                }
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('<gs-jumbo>', '<gs-jumbo>', 'gs-jumbo>\n' +
                                                                '    ${0}\n' +
                                                                '</gs-jumbo>');
    
    designRegisterElement('gs-jumbo', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-container-jumbo.html');
    
    window.designElementProperty_GSJUMBO = function(selectedElement) {
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    xtag.register('gs-jumbo', {});
});
window.addEventListener('design-register-element', function () {
    registerDesignSnippet('Static Template <gs-listbox>', '<gs-listbox>', 'gs-listbox>\n'+
                                                                     '    <template>\n'+
                                                                     '        <table>\n'+
                                                                     '            <tbody>\n'+
                                                                     '                <tr value="${1}">\n'+
                                                                     '                    <td>${0}</td>\n'+
                                                                     '                </tr>\n'+
                                                                     '            </tbody>\n'+
                                                                     '        </table>\n'+
                                                                     '    </template>\n' +
                                                                     '</gs-listbox>');
    registerDesignSnippet('Custom Template <gs-listbox>', '<gs-listbox>', 'gs-listbox src="${1:test.tpeople}">\n'+
                                                                     '    <template>\n'+
                                                                     '        <table>\n'+
                                                                     '            <tbody>\n'+
                                                                     '                <tr value="{{! row.id }}">\n'+
                                                                     '                    <td>{{! row.${3:name} }}</td>\n'+
                                                                     '                </tr>\n'+
                                                                     '            </tbody>\n'+
                                                                     '        </table>\n'+
                                                                     '    </template>\n' +
                                                                     '</gs-listbox>');
    registerDesignSnippet('Dynamic Template <gs-listbox>', '<gs-listbox>', 'gs-listbox src="${1:test.tpeople}"></gs-listbox>');
    registerDesignSnippet('<gs-listbox>', '<gs-listbox>', 'gs-listbox src="${1:test.tpeople}"></gs-listbox>');
    
    designRegisterElement('gs-listbox', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-listbox.html');
    
    window.designElementProperty_GSLISTBOX = function(selectedElement) {
        addProp('Source', true, '<gs-memo class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('src') ||
                                                                            selectedElement.getAttribute('source') || '')) + '" mini></gs-memo>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
        });
        
        addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
        });
        
        addProp('Hide Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('hide') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'hide', this.value);
        });
        
        addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('where') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'where', this.value);
        });
        
        addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
        });
        
        addProp('Limit', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
        });
        
        addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
        });
        
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });
        
        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });
        
        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });
        
        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))           { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });
        
        // NO-SELECT attribute
        addProp('Dissallow&nbsp;Select', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-select') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-select', this.value === 'true', true);
        });
        
        // LETTER-SCROLLBAR attribute
        addProp('Letter&nbsp;Scrollbar', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('letter-scrollbar') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'letter-scrollbar', this.value === 'true', true);
        });
        
        // LETTER-DIVIDERS attribute
        addProp('Letter Dividers', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('letter-dividers') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'letter-dividers', this.value === 'true', true);
        });
        
        addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
            this.removeAttribute('refresh-on-querystring-change');
            return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
        });
        
        addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
            this.removeAttribute('refresh-on-querystring-values');
            return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    // removes selected class from old selected records adds class selected to record
    function highlightRecord(element, record) {
        var i, len, arrSelectedTrs;
        
        //console.log(record);
        
        if (element.tableElement && xtag.queryChildren(element.tableElement, 'tbody')[0]) {
            // clear previous selection
            arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]');
            
            for (i = 0, len = arrSelectedTrs.length; i < len; i += 1) {
                arrSelectedTrs[i].removeAttribute('selected');
            }
        }
        
        // select/highlight the record that was provided
        if (record) {
            record.setAttribute('selected', '');
        }
    }

    // loops through the records and finds a record using the parameter
    function findRecordFromValue(element, searchValue) {
        var i, len, matchedRecord, arrTrs, strSearchString;

        if (element.tableElement && xtag.queryChildren(element.tableElement, 'tbody')[0]) {
            //console.log('1***', element.tableElement);
            //console.log('2***', xtag.queryChildren(element.tableElement, 'tbody')[0]);
            //console.log('3***', xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr'));
            arrTrs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr');
            strSearchString = String(searchValue);

            // search exact text and search both the value attribute (if present) and the first td text
            for (i = 0, len = arrTrs.length; i < len; i += 1) {
                if (arrTrs[i].getAttribute('value') === strSearchString || xtag.queryChildren(arrTrs[i], 'td')[0].textContent === strSearchString) {
                    matchedRecord = arrTrs[i];
                    break;
                }
            }
        }

        return matchedRecord;
    }

    function selectRecord(element, handle, bolChange) {
        var record, strRecordValue, strFirstTdText;
        
        if (!element.hasAttribute('no-select')) {
            if (typeof handle === 'string' || typeof handle === 'number') {
                record = findRecordFromValue(element, handle);
            } else {
                record = handle;
            }
            
            //console.trace(handle, record);
            
            if (!record && handle !== '') {
                console.warn('Listbox warning: record not found' + (typeof handle === 'string' ? ': "' + handle + '"' : ''));
                
            } else if (record) {
                //console.log('1***', this.selectedRecord, this.value);
                
                strRecordValue = record.getAttribute('value');
                strFirstTdText = xtag.queryChildren(record, 'td')[0].textContent;
                
                if (element.value !== (strRecordValue || strFirstTdText)) {
                    element.innerValue = strRecordValue || strFirstTdText;
                    element.innerSelectedRecord = record;
                    if (bolChange) {
                        element.hackToPreventScroll = true;
                        if (element.innerValue !== element.getAttribute('value')) {
                            element.setAttribute('value', element.innerValue);
                        }
                        element.hackToPreventScroll = false;
                        element.triggerChange();
                        //console.log('2*** change triggered');
                    }
                }
            }
            
            // highlightRecord has its own checking for no record supplied,
            // so this deselects any rows then selects the supplied record or none
            highlightRecord(element, record);
            
            //console.log('3***', element.selectedRecord, element.value);
        }
    }
    
    
    // #################################################################
    // ########################## USER EVENTS ##########################
    // #################################################################
    
    // handle behaviours on keydown
    function handleKeyDown(event) {
        var element = event.target, intKeyCode = event.keyCode || event.which, selectedTr, trs, i, len, selectedRecordIndex;
        
        if (!element.hasAttribute('disabled')) {
            if (!element.hasAttribute('no-select')) {
                if ((intKeyCode === 40 || intKeyCode === 38) && !event.shiftKey && !event.metaKey && !event.ctrlKey && !element.error) {
                    
                    trs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr:not(.divider)');
                    
                    for (i = 0, len = trs.length; i < len; i += 1) {
                        if (trs[i].hasAttribute('selected')) {
                            selectedRecordIndex = i;
                            selectedTr = trs[i];
                            trs[i].removeAttribute('selected');
                            
                            break;
                        }
                    }
                    
                    if (intKeyCode === 40) {// next record or circle to first record or start selection at the first
                        if (!selectedTr || selectedRecordIndex === trs.length - 1) {
                            highlightRecord(element, trs[0]);
                            selectedTr = trs[0];
                            
                        } else {
                            highlightRecord(element, trs[selectedRecordIndex + 1]);
                            selectedTr = trs[selectedRecordIndex + 1];
                        }
                        
                    } else if (intKeyCode === 38) {// prev record or circle to last record or start selection at the last
                        if (!selectedTr || selectedRecordIndex === 0) {
                            highlightRecord(element, trs[trs.length - 1]);
                            selectedTr = trs[trs.length - 1];
                            
                        } else {
                            highlightRecord(element, trs[selectedRecordIndex - 1]);
                            selectedTr = trs[selectedRecordIndex - 1];
                        }
                    }
                    
                    //GS.scrollIntoView(selectedTr);
                    element.scrollToSelectedRecord();
                    event.preventDefault();
                    event.stopPropagation();
                    
                } else if (event.keyCode === 13) {
                    selectedTr = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]')[0];
                    
                    if (element.tableElement && selectedTr) {
                        selectRecord(element, selectedTr, true);
                    }
                }
            }
        } else {
            if (event.keyCode !== 9) {
                event.preventDefault();
                event.stopPropagation();
            }
        }
        
        //console.log('handleKeyDown', intKeyCode, event);
    }
    
    function handleFocusout(event) {
        var element = event.target, selectedTr;
        
        if (element.tableElement) {
            selectedTr = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]')[0];
            
            if (selectedTr) {
                selectRecord(element, selectedTr, true);
            }
        }
    }
    
    
    // #################################################################
    // ######################### DATA HANDLING #########################
    // #################################################################
    
    
    // handles fetching the data
    //      if bolInitalLoad === true then
    //          use: initialize query COALESCE TO source query
    //      else
    //          use: source query
    function getData(element, callback, bolInitalLoad, bolClearPrevious) {
        
        if (window.bolSocket === true) {
            var srcParts   = GS.templateWithQuerystring(
                                (bolInitalLoad && element.getAttribute('initialize')
                                    ? element.getAttribute('initialize')
                                    : element.getAttribute('src')
                                )
                            ).split('.')
              , strSchema  = srcParts[0]
              , strObject  = srcParts[1]
              , strColumns = GS.templateWithQuerystring(element.getAttribute('cols') || '*').split(',').join('\t')
              , strWhere   = GS.templateWithQuerystring(element.getAttribute('where') || '')
              , strOrd     = GS.templateWithQuerystring(element.getAttribute('ord') || '')
              , strLimit   = GS.templateWithQuerystring(element.getAttribute('limit') || '1')
              , strOffset  = GS.templateWithQuerystring(element.getAttribute('offset') || '')
              , response_i = 0, response_len = 0, arrTotalRecords = [];
            
            GS.addLoader(element, 'Loading...');
            GS.requestSelectFromSocket(GS.envSocket, strSchema, strObject, strColumns
                                     , strWhere, strOrd, strLimit, strOffset
                                     , function (data, error) {
                var arrRecords, arrCells, envData
                  , i, len, cell_i, cell_len;
                
                //console.log(data);
                
                if (!error) {
                    if (data.strMessage !== 'TRANSACTION COMPLETED') {
                        arrRecords = GS.trim(data.strMessage, '\n').split('\n');
                        
                        for (i = 0, len = arrRecords.length; i < len; i += 1) {
                            arrCells = arrRecords[i].split('\t');
                            
                            for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                                arrCells[cell_i] = GS.decodeFromTabDelimited(arrCells[cell_i]);
                            }
                            
                            arrTotalRecords.push(arrCells);
                        }
                    } else {
                        GS.removeLoader(element);
                        element.arrColumnNames = data.arrColumnNames;
                        
                        envData = {'arr_column': element.arrColumnNames, 'dat': arrTotalRecords};
                        
                        handleData(element, bolInitalLoad, envData);
                        GS.triggerEvent(element, 'after_select');
                        if (typeof callback === 'function') {
                            callback();
                        }
                    }
                } else {
                    handleData(element, bolInitalLoad, data, error);
                    GS.removeLoader(element);
                }
            });
        } else {
            var strLink,
                strSource = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') ||
                                                                   element.getAttribute('source') || ''));
            
            strLink = '/' + (element.getAttribute('action-select') || 'env/action_select') +
                    '?src=' + encodeURIComponent(strSource) +
                    '&where='    + encodeURIComponent(GS.templateWithQuerystring(element.getAttribute('where') || '')) +
                    '&limit='    + encodeURIComponent(GS.templateWithQuerystring(element.getAttribute('limit') || '')) +
                    '&offset='   + encodeURIComponent(GS.templateWithQuerystring(element.getAttribute('offset') || '')) +
                    '&order_by=' + encodeURIComponent(GS.templateWithQuerystring(element.getAttribute('ord') || '')) +
                    '&cols='     + encodeURIComponent(element.getAttribute('cols') || '');
            
            document.addEventListener('dataready_' + encodeURIComponent(strLink), function __THIS_FUNCTION__(event) {
                GS.removeLoader(element);
                
                handleData(element, bolInitalLoad, event.detail.response, event.detail.error);
                GS.triggerEvent(element, 'after_select');
                if (typeof callback === 'function') {
                    callback();
                }
                
                document.removeEventListener('dataready_' + encodeURIComponent(strLink), __THIS_FUNCTION__);
            });
            
            GS.dataFetch(strLink, true);
            
            GS.addLoader(element, 'Loading...');
        }
    }
    
    // handles data result from method function: getData 
    //      success:  template
    //      error:    add error classes
    function handleData(element, bolInitalLoad, data, error) {
        var strTemplate, divElement, tableElement, theadElement, theadCellElements, tbodyElement, tbodyCellElements, lastRecordElement,
            recordElements, recordElement, currentCellLabelElement, template, i, len, arrHeaders = [], arrHide, intVisibleColumns, strHeaderCells, strRecordCells, jsnTemplate, strHTML;
        
        // clear any old error status
        element.classList.remove('error');
        element.setAttribute('title', '');
        
        //console.log(error, data, bolInitalLoad);
        
        // if there was no error
        if (!error) {
            element.error = false;
            
            if (element.tableTemplate) {// element.tableTemplateElement
                strTemplate = element.tableTemplate;// element.tableTemplateElement
                
            } else {
                // create an array of hidden column numbers
                arrHide = (element.getAttribute('hide') || '').split(/[\s]*,[\s]*/);
                
                // build up the header cells variable and the record cells variable
                for (i = 0, len = data.arr_column.length, strHeaderCells = '', strRecordCells = '', intVisibleColumns = 0; i < len; i += 1) {
                    // if this column is not hidden
                    if (arrHide.indexOf((i + 1) + '') === -1 && arrHide.indexOf(data.arr_column[i]) === -1) {
                        // append a new cell to each of the header cells and record cells variables
                        strHeaderCells += '<th gs-dynamic>' + encodeHTML(data.arr_column[i]) + '</th> ';
                        strRecordCells += '<td gs-dynamic>{{! row[\'' + data.arr_column[i] + '\'] }}</td> ';
                        intVisibleColumns += 1;
                    }
                }
                
                // put everything together
                strTemplate =   '<table gs-dynamic>';
                
                if (intVisibleColumns > 1) { // data.arr_column.length (didn't take into account hidden columns)
                    strTemplate +=  '<thead gs-dynamic>' +
                                        '<tr gs-dynamic>' +
                                            strHeaderCells +
                                        '</tr>' +
                                    '</thead>';
                }
                
                strTemplate +=      '<tbody gs-dynamic>' +
                                        '<tr value="{{! row[\'' + data.arr_column[0] + '\'] }}" gs-dynamic>' +
                                            strRecordCells +
                                        '</tr>' +
                                    '</tbody>' +
                                '<table>';
            }
            
            divElement = document.createElement('div');
            divElement.innerHTML = strTemplate;
            
            tableElement = xtag.queryChildren(divElement, 'table')[0];
            theadElement = xtag.queryChildren(tableElement, 'thead')[0];
            tbodyElement = xtag.queryChildren(tableElement, 'tbody')[0];
            
            // if there is a tbody
            if (tbodyElement) {
                recordElement = xtag.queryChildren(tbodyElement, 'tr')[0];
                
                // if there is a record: template
                if (recordElement) {
                    
                    // if there is a thead element: add reflow cell headers to the tds
                    if (theadElement) {
                        theadCellElements = xtag.query(theadElement, 'td, th');
                        tbodyCellElements = xtag.query(tbodyElement, 'td, th');
                        
                        for (i = 0, len = theadCellElements.length; i < len; i += 1) {
                            currentCellLabelElement = document.createElement('b');
                            currentCellLabelElement.classList.add('cell-label');
                            currentCellLabelElement.setAttribute('data-text', (theadCellElements[i].textContent || '') + ':');
                            
                            if (tbodyCellElements[i].childNodes) {
                                tbodyCellElements[i].insertBefore(currentCellLabelElement, tbodyCellElements[i].childNodes[0]);
                            } else {
                                tbodyCellElements[i].insertChild(currentCellLabelElement);
                            }
                        }
                    }
                    
                    // template
                    jsnTemplate = GS.templateHideSubTemplates(tbodyElement.innerHTML, true);
                    strHTML = GS.templateWithEnvelopeData(jsnTemplate.templateHTML, data);
                    tbodyElement.innerHTML = GS.templateShowSubTemplates(strHTML, jsnTemplate);
                    
                    element.tableElement = tableElement;
                    element.syncView();
                }
            }
            
            //console.log('1***', bolInitalLoad, element.getAttribute('value'));
            
            //if (bolInitalLoad && element.getAttribute('value')) {
            //    //console.log('2***', bolInitalLoad, element.getAttribute('value'));
            //    selectRecord(element, element.getAttribute('value'), false);
            //    element.scrollToSelectedRecord();
            //    
            //// select first record
            //} else
            
            if (bolInitalLoad && !element.getAttribute('value') && element.hasAttribute('select-first')) {
                selectRecord(element, xtag.query(element, 'tbody tr')[0].getAttribute('value'), false);
                element.scrollToSelectedRecord();
            }
            
        // else there was an error: add error class, title attribute
        } else {
            element.error = true;
            element.classList.add('error');
            element.setAttribute('title', 'This listbox has failed to load.');
            
            element.setAttribute('disabled', '');
            
            GS.ajaxErrorDialog(data);
        }
    }
    
    function getParentCell(element) {
        var currentElement = element;
        
        while (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH' && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }
        
        if (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH') {
            return undefined;
        }
        
        return currentElement;
    }
    
    function windowResizeHandler() {
        var i, len, arrElement;
        
        arrElement = document.getElementsByTagName('gs-listbox');
        
        for (i = 0, len = arrElement.length; i < len; i += 1) {
            if (GS.pxToEm(document.body, this.oldWidth) !== GS.pxToEm(document.body, this.offsetWidth) && // <== if the width (in ems) changes
                arrElement[i].hasAttribute('letter-scrollbar') &&
                arrElement[i].tableElement) {
                
                if (arrElement[i].hasAttribute('letter-dividers') || arrElement[i].hasAttribute('letter-scrollbar')) {
                    arrElement[i].refreshDividingPoints();
                }
                arrElement[i].letterScrollbarHandler();
                this.oldWidth = this.offsetWidth;
            }
        }
    }
    
    window.addEventListener('resize', windowResizeHandler);  // I want to debounce this event but that would require a timer -michael
    window.addEventListener('orientationchange', windowResizeHandler);
    
    //function pushReplacePopHandler(element) {
    //    var i, len, currentValue, bolRefresh = false, strQueryString = GS.getQueryString(), arrPopKeys, strQSCol = element.getAttribute('qs');
    //    
    //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1 && element.value !== GS.qryGetVal(strQueryString, strQSCol)) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //    
    //    // if this element has a refresh-on-querystring-values attribute: check for changes
    //    if (element.hasAttribute('refresh-on-querystring-values')) {
    //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
    //        
    //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
    //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
    //            
    //            if ((element.popValues[arrPopKeys[i]] || '') !== currentValue) {
    //                bolRefresh = true;
    //            }
    //            
    //            element.popValues[arrPopKeys[i]] = currentValue;
    //        }
    //        
    //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
    //        bolRefresh = true;
    //    }
    //    
    //    if (bolRefresh) {
    //        element.refresh();
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh;
        var strOperator;

        if (strQSCol) {
            if (strQSCol.indexOf('=') !== -1) {
                arrAttrParts = strQSCol.split(',');
                i = 0;
                len = arrAttrParts.length;
                while (i < len) {
                    strQSCol = arrAttrParts[i];
    
                    if (strQSCol.indexOf('!=') !== -1) {
                        strOperator = '!=';
                        arrQSParts = strQSCol.split('!=');
                    } else {
                        strOperator = '=';
                        arrQSParts = strQSCol.split('=');
                    }
    
                    strQSCol = arrQSParts[0];
                    strQSAttr = arrQSParts[1] || arrQSParts[0];
    
                    // if the key is not present or we've got the negator: go to the attribute's default or remove it
                    if (strOperator === '!=') {
                        // if the key is not present: add the attribute
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            element.setAttribute(strQSAttr, '');
                        // else: remove the attribute
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    } else {
                        // if the key is not present: go to the attribute's default or remove it
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        // else: set attribute to exact text from QS
                        } else {
                            element.setAttribute(strQSAttr, (
                                GS.qryGetVal(strQS, strQSCol) ||
                                element.internal.defaultAttributes[strQSAttr] ||
                                ''
                            ));
                        }
                    }
                    i += 1;
                }
            } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                strQSValue = GS.qryGetVal(strQS, strQSCol);
    
                if (element.internal.bolQSFirstRun !== true) {
                    if (strQSValue !== '' || !element.getAttribute('value')) {
                        element.setAttribute('value', strQSValue);
                    }
                } else if (element.value !== strQSValue) {
                    element.value = strQSValue;
                }
            }
        }
        
        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                
                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);
                    
                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }
                    
                    element.popValues[arrPopKeys[i]] = currentValue;
                }
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            }
            
            if (bolRefresh && element.hasAttribute('src')) {
                getData(element);
            } else if (bolRefresh && !element.hasAttribute('src')) {
                console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                
                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                }
            }
        }
        
        element.internal.bolQSFirstRun = true;
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value && !element.getAttribute('value')) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = null;
            }
        }
    }
    
    //
    function elementInserted(element) {
        var tableTemplateElement, arrElement, recordElement, tableTemplateElementCopy, strQSValue, i, len, currentElement;
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.error = false;
                element.internal = {};
                saveDefaultAttributes(element);
                
                // handle "qs" attribute
                if (element.hasAttribute('qs') ||
                        element.hasAttribute('refresh-on-querystring-values') ||
                        element.hasAttribute('refresh-on-querystring-change')) {
                    element.popValues = {};
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.setAttribute('value', strQSValue);
                    //}

                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                    //element.popValues = GS.qryToJSON(GS.getQueryString());
                }
                
                // allows the element to have focus
                if (!element.hasAttribute('tabindex')) {
                    element.setAttribute('tabindex', '0');
                }
                
                // select for template
                tableTemplateElement = xtag.queryChildren(element, 'template')[0];
                
                if (tableTemplateElement) {
                    // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                    element.tableTemplate = GS.templateColumnToValue(tableTemplateElement.innerHTML);
                }
                
                //console.log(element.tableTemplate);
                
                if (element.getAttribute('src') || element.getAttribute('source')) {
                    getData(element, '', true);
                } else {
                    if (tableTemplateElement) {
                        element.tableElement = xtag.query(tableTemplateElement.content, 'table')[0];
                    } else if (xtag.queryChildren(element, 'table')[0]) {
                        element.tableElement = xtag.queryChildren(element, 'table')[0];
                    } else {
                        element.tableElement = document.createElement('table');
                    }
                    
                    element.syncView();
                }
            }
        }
    }
    
    xtag.register('gs-listbox', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value' && newValue !== oldValue) {
                        this.value = newValue;
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    return this.innerValue;
                },
                
                set: function (strNewValue) {
                    selectRecord(this, strNewValue);
                    this.scrollToSelectedRecord();
                }
            },
            
            selectedRecord: {
                get: function () {
                    return this.innerSelectedRecord;
                },
                
                set: function (newValue) {
                    selectRecord(this, newValue);
                    this.scrollToSelectedRecord();
                }
            },
            
            textValue: {
                get: function () {
                    if (this.innerSelectedRecord) {
                        return xtag.queryChildren(this.innerSelectedRecord, 'td')[0].textContent;
                    }
                    return undefined;
                },
                
                set: function () {
                    selectRecord(this, strNewValue);
                    this.scrollToSelectedRecord();
                }
            }
        },
        methods: {
            // just a semantic alias to the getData function
            refresh: function (callback) {
                getData(this, callback);
            },
            
            // #################################################################
            // ########### SELECTION / HIGHLIGHTING / RECORD / VALUE ###########
            // #################################################################
            
            // scroll the dropdown to the selected record
            scrollToSelectedRecord: function () {
                var selectedTr;
                
                if (this.tableElement) {
                    selectedTr = xtag.query(this.tableElement, 'tr[selected]')[0];
                    
                    if (selectedTr) {
                        GS.scrollIntoView(selectedTr);
                    }
                }
                
                /*var scrollingContainer, arrTrs, i, len, intScrollTop, bolFoundSelected = false;
                
                if (this.tableElement) {
                    scrollingContainer = this;
                    arrTrs = xtag.query(this.tableElement, 'tr');
                    
                    for (i = 0, intScrollTop = 0, len = arrTrs.length; i < len; i += 1) {
                        if (arrTrs[i].hasAttribute('selected')) {
                            intScrollTop += arrTrs[i].offsetHeight / 2;
                            
                            bolFoundSelected = true;
                            
                            break;
                        } else {
                            intScrollTop += arrTrs[i].offsetHeight;
                        }
                    }
                    
                    if (bolFoundSelected) {
                        intScrollTop = intScrollTop - scrollingContainer.offsetHeight / 2;
                    } else {
                        intScrollTop = 0;
                    }
                    
                    scrollingContainer.scrollTop = intScrollTop;
                }*/
            },
            
            // ################################################################
            // ####################### LETTER SCROLLBAR #######################
            // ################################################################
            
            letterScrollbarHandler: function () {
                var element = this, i, len, intTextHeight, intLettersDropped, intSkipperHeight,
                    intElementHeight, intDistance, strHTML, arrSkippers;
                
                // if there is no letter scrollbar container: create it
                if (xtag.queryChildren(element, '.letter-scrollbar-container').length === 0) {
                    element.letterScrollbarContainer = document.createElement('div');
                    element.letterScrollbarContainer.classList.add('letter-scrollbar-container');
                    element.letterScrollbarContainer.setAttribute('gs-dynamic', '');
                    element.appendChild(element.letterScrollbarContainer);
                    
                // else: clear out the old letterScrollbarContainer
                } else {
                    element.letterScrollbarContainer.innerHTML = '';
                }
                
                if (element.clientHeight < element.scrollContainer.scrollHeight) {
                    intTextHeight = GS.getTextHeight(element.letterScrollbarContainer);
                    intSkipperHeight = intTextHeight * this.arrDividingPoints.length;
                    intElementHeight = element.clientHeight / this.arrDividingPoints.length;
                    
                    if (intElementHeight < intTextHeight) {
                        intElementHeight = intTextHeight;
                    }
                    
                    if (intSkipperHeight > element.clientHeight) { 
                        intLettersDropped = 0;
                        while (intSkipperHeight > element.clientHeight && intLettersDropped < 100) {
                            intSkipperHeight -= intTextHeight;
                            intLettersDropped += 1;
                        }
                        intDistance = Math.ceil(this.arrDividingPoints.length / intLettersDropped);
                    }
                    
                    for (i = 0, len = this.arrDividingPoints.length, strHTML = ''; i < len; i += 1) {
                        if (intLettersDropped === undefined || (intLettersDropped > 0 && i % intDistance !== 0)) {
                            strHTML += '<div class="skipper" gs-dynamic ' +
                                            'style="height: ' + intElementHeight + 'px; line-height: ' + intElementHeight + 'px;" ' + 
                                            'data-target-offset="' + this.arrDividingPoints[i].offset + '">' +
                                            '<span gs-dynamic>' + this.arrDividingPoints[i].letter + '</span>' +
                                        '</div>';
                        }
                    }
                    
                    element.letterScrollbarContainer.innerHTML = strHTML;
                    
                    if (element.paddingElement && element.paddingElement.parentNode === element.scrollContainer) {
                        element.scrollContainer.removeChild(element.paddingElement);
                    }
                    
                    element.paddingElement = document.createElement('div');
                    element.paddingElement.setAttribute('gs-dynamic', '');
                    if (this.arrDividingPoints.length > 0) {
                    element.paddingElement.style.height = (element.clientHeight -
                                                        (element.scrollContainer.scrollHeight - parseInt(this.arrDividingPoints[this.arrDividingPoints.length - 1].offset, 10))) + 'px';
                    }
                    element.scrollContainer.appendChild(element.paddingElement);
                    
                    // bind skipper click, mousedown-then-drag
                    arrSkippers = element.letterScrollbarContainer.children;
                    
                    if (element.mousedownHandler) {
                        window.removeEventListener(evt.mousedown, element.mousedownHandler);
                        window.removeEventListener(evt.mousemove, element.mousemoveHandler);
                        window.removeEventListener(evt.mouseup, element.mouseupHandler);
                    }
                    
                    //element.clickHandler = function () {
                    //    //console.log('-webkit-overflow-scrolling: touch;',   element.scrollContainer.scrollTop);
                    //    element.style.webkitOverflowScrolling = 'initial';
                    //    //console.log('-webkit-overflow-scrolling: initial;', element.scrollContainer.scrollTop);
                    //    element.scrollContainer.scrollTop = parseInt(this.getAttribute('data-target-offset'), 10);
                    //    //console.log('-webkit-overflow-scrolling: initial;', element.scrollContainer.scrollTop);
                    //    element.style.webkitOverflowScrolling = 'touch';
                    
                    element.clickHandler = function () {
                        //console.log('-webkit-overflow-scrolling: touch;',   element.scrollContainer.scrollTop);
                        element.style.webkitOverflowScrolling = 'initial';
                        //console.log('-webkit-overflow-scrolling: initial;', element.scrollContainer.scrollTop);
                        element.scrollContainer.scrollTop = parseInt(this.getAttribute('data-target-offset'), 10);
                        //console.log('-webkit-overflow-scrolling: initial;', element.scrollContainer.scrollTop);
                        element.style.webkitOverflowScrolling = 'touch';
                        
                        //alert('Here I am');
                        
                        //element.scrollContainer.className = element.scrollContainer.className;
                        //element.scrollContainer.style.outline = '1px solid #000000';
                        //element.scrollContainer.style.outline = '';
                        //console.log('-webkit-overflow-scrolling: touch;',   element.scrollContainer.scrollTop);
                        //console.log('test');
                    };
                    element.mousedownHandler = function (event) { // event
                        window.addEventListener(evt.mousemove, element.mousemoveHandler);
                        if (event.target.classList.contains('skipper') && evt.touchDevice) {
                            element.style.webkitOverflowScrolling = 'initial';
                        }
                        //element.mousemoveHandler(event);
                    };
                    element.mousemoveHandler = function (event) {
                        var jsnMousePosition, targetElement;
                        
                        if (event.which !== 0 || evt.touchDevice) {
                            jsnMousePosition = GS.mousePosition(event);
                            targetElement = document.elementFromPoint(jsnMousePosition.left, jsnMousePosition.top);
                            
                            if (targetElement) {
                                if (targetElement.nodeName === 'SPAN') {
                                    targetElement = targetElement.parentNode;
                                }
                                
                                //console.log(targetElement, jsnMousePosition);
                                
                                if (targetElement.classList.contains('skipper')) {
                                    element.style.webkitOverflowScrolling = 'initial';
                                    event.preventDefault();
                                    element.scrollContainer.scrollTop = parseInt(targetElement.getAttribute('data-target-offset'), 10);
                                }
                            }
                        } else {
                            window.removeEventListener(evt.mousemove, element.mousemoveHandler);
                        }
                    };
                    element.mouseupHandler = function () {
                        element.style.webkitOverflowScrolling = 'touch';
                        window.removeEventListener(evt.mousemove, element.mousemoveHandler);
                    };
                    
                    //window
                    element.addEventListener(evt.mousedown, element.mousedownHandler);
                    //window
                    element.addEventListener(evt.mouseup, element.mouseupHandler);
                    
                    for (i = 0, len = arrSkippers.length; i < len; i += 1) {
                        arrSkippers[i].addEventListener('click', element.clickHandler);
                    }
                    //}
                }
            },
            
            
            // #################################################################
            // ########################### UTILITIES ###########################
            // #################################################################
            
            refreshDividingPoints: function () {
                var tbodyElement, arrElement, arrLetter, dividerElement, strLetter, intOffset, numColumns, theadElement, i, len;
                
                tbodyElement = xtag.queryChildren(this.tableElement, 'tbody')[0];
                
                arrElement = xtag.queryChildren(tbodyElement, 'tr.divider');
                
                for (i = 0, len = arrElement.length; i < len; i += 1) {
                    tbodyElement.removeChild(arrElement[i]);
                }
                
                this.arrDividingPoints = [];
                
                arrElement = xtag.queryChildren(tbodyElement, 'tr');
                
                if (arrElement.length > 0) {
                    numColumns = arrElement[0].children.length;
                    
                    
                    //console.log(theadElement, (theadElement ? theadElement.offsetHeight : 0));
                    theadElement = xtag.queryChildren(this.tableElement, 'thead')[0];
                    intOffset = (theadElement ? theadElement.offsetHeight : 0);
                    
                    for (i = 0, len = arrElement.length, arrLetter = []; i < len; i += 1) {
                        strLetter = xtag.queryChildren(arrElement[i], 'td')[0].textContent.substring(0, 1).toUpperCase();
                        
                        if (arrLetter.indexOf(strLetter) === -1) {
                            this.arrDividingPoints.push({
                                'letter': strLetter,
                                'offset': intOffset
                            });
                            
                            if (this.hasAttribute('letter-dividers')) {
                                dividerElement = document.createElement('tr');
                                dividerElement.classList.add('divider');
                                dividerElement.setAttribute('gs-dynamic', '');
                                dividerElement.setAttribute('data-target-offset', intOffset);
                                //if (!this.hasAttribute('letter-dividers')) { <== messed with odd and even record colors when letter-scrollbar but not letter-dividers -michael
                                //    dividerElement.setAttribute('hidden', '');
                                //}
                                
                                dividerElement.innerHTML = '<td colspan="' + numColumns + '" gs-dynamic>' + encodeHTML(strLetter) + '</td>';
                                
                                tbodyElement.insertBefore(dividerElement, arrElement[i]);
                                
                                intOffset += dividerElement.offsetHeight;
                            }
                            
                            arrLetter.push(strLetter);
                        }
                        
                        intOffset += arrElement[i].offsetHeight;
                    }
                }
            },
            
            syncView: function () {
                var element = this, tbodyElement, i, len, arrElements, clickHandler, mousedownHandler, mouseoutHandler, mouseoverHandler;
                
                element.removeEventListener('keydown', handleKeyDown);
                element.addEventListener('keydown', handleKeyDown);
                
                element.removeEventListener('focusout', handleFocusout);
                element.addEventListener('focusout', handleFocusout);
                
                element.innerHTML = '';
                
                element.scrollContainer = document.createElement('div');
                element.scrollContainer.setAttribute('gs-dynamic', '');
                element.scrollContainer.classList.add('root');
                element.scrollContainer.classList.add('scroll-container');
                element.scrollContainer.appendChild(element.tableElement);
                
                element.appendChild(element.scrollContainer);
                tbodyElement = xtag.queryChildren(element.tableElement, 'tbody')[0];
                
                // add dividers
                if (element.hasAttribute('letter-dividers') || element.hasAttribute('letter-scrollbar')) {
                    element.refreshDividingPoints();
                    
                    // if we have the letter-scrollbar attribute: add the letter scrollbar
                    if (element.hasAttribute('letter-scrollbar')) {
                        element.letterScrollbarHandler();
                    }
                }
                
                // this fixes the fact that this function was clearing the selection
                if (this.getAttribute('value')) {
                    selectRecord(this, this.getAttribute('value'));
                    this.scrollToSelectedRecord();
                }
                
                // click handling code
                // get list of record elements
                arrElements = xtag.toArray(tbodyElement.children);
                
                // create click event function
                clickHandler = function (event) {
                    this.classList.remove('down');
                    selectRecord(element, this, true);
                };
                
                // add click event with click event function to all record elements that are not dividers
                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    if (!arrElements[i].classList.contains('divider')) {
                        arrElements[i].addEventListener('click', clickHandler);
                    }
                }
                
                // if we are not on a touch device: hover and down events
                if (!evt.touchDevice) {
                    mousedownHandler = function () {
                        this.classList.add('down');
                    };
                    mouseoutHandler = function () {
                        this.classList.remove('down');
                        this.classList.remove('hover');
                    };
                    mouseoverHandler = function () {
                        this.classList.remove('down');
                        this.classList.add('hover');
                    };
                
                    // add click event with click event function to all record elements that are not dividers
                    for (i = 0, len = arrElements.length; i < len; i += 1) {
                        if (!arrElements[i].classList.contains('divider')) {
                            arrElements[i].addEventListener(evt.mousedown, mousedownHandler);
                            arrElements[i].addEventListener(evt.mouseout, mouseoutHandler);
                            arrElements[i].addEventListener(evt.mouseover, mouseoverHandler);
                        }
                    }
                }
                
                //tbodyElement.addEventListener('click', function (event) {
                //    var parentRecord = GS.findParentTag(event.target, 'TR');
                //    
                //    if (parentRecord && !parentRecord.classList.contains('divider')) {
                //        selectRecord(element, parentRecord, true);
                //    }
                //});
            },
            
            triggerChange: function () {
                xtag.fireEvent(this, 'change', {
                    bubbles: true,
                    cancelable: true
                });
            }
        }
    });
});//element.clientHeight < element.scrollHeight

window.addEventListener('design-register-element', function () {
    
    registerDesignSnippet('<gs-memo>', '<gs-memo>', 'gs-memo column="${1:name}"></gs-memo>');
    registerDesignSnippet('<gs-memo> With Label', '<gs-memo>', 'label for="${1:memo-insert-note}">${2:Notes}:</label>\n' +
                                                               '<gs-memo id="${1:memo-insert-note}" column="${3:note}"></gs-memo>');
    
    designRegisterElement('gs-memo', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-memo.html');
    
    window.designElementProperty_GSMEMO = function(selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });
        
        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });
        
        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });
        
        addProp('Rows', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('rows') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'rows', this.value);
        });
        
        addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
        });
        
        //console.log(selectedElement.hasAttribute('mini'));
        
        addProp('Autoresize', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('autoresize')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'autoresize', (this.value === 'true'), true);
        });
        
        addProp('Allow tab', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('allow-tab-char')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'allow-tab-char', (this.value === 'true'), true);
        });
        
        addProp('Resize Handle', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-resize-handle')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-resize-handle', (this.value === 'true'), false);
        });
        
        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });
        
        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });
        
        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });
        
        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });
        
        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });
        
        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

// trigger resize to text on window resize
window.addEventListener('resize', function () {
    var i, len, arrElements = document.getElementsByTagName('gs-memo');
    
    for (i = 0, len = arrElements.length; i < len; i += 1) {
        //if (arrElements[i].control.clientHeight < arrElements[i].control.scrollHeight) {
        arrElements[i].handleResizeToText();
        //}
    }
});


if (!evt.touchDevice) {
    window.gsMemo = {};
    window.gsMemo.bolFirstMouseMoveWhileDown = true;
    window.gsMemo.currentMouseTarget = null;
    
    window.addEventListener('mousemove', function (event) {
        var mousePosition, intWhich;// = GS.mousePosition(event);
        
        // firefox sometimes doesn't permit access to "event.which"
        //      so this try/catch statement will prevent the error and nothing will run
        try {
            intWhich = event.which;
        } catch (e) {}
        
        if (window.bolFirstMouseMoveWhileDown === true && intWhich !== undefined && intWhich !== 0) {
            mousePosition = GS.mousePosition(event);
            
            window.bolFirstMouseMoveWhileDown = false;
            window.gsMemo.currentMouseTarget = document.elementFromPoint(mousePosition.x, mousePosition.y);
            
        } else if (intWhich !== undefined && intWhich === 0) {
            window.bolFirstMouseMoveWhileDown = true;
        }
        
        if (window.gsMemo.currentMouseTarget &&
            intWhich !== undefined && intWhich !== 0 &&
            window.gsMemo.currentMouseTarget.nodeName === 'TEXTAREA' &&
            window.gsMemo.currentMouseTarget.parentNode.nodeName === 'GS-MEMO' && //event.target === element.control &&
            window.bolFirstMouseMoveWhileDown === false &&
                (window.gsMemo.currentMouseTarget.lastWidth !== window.gsMemo.currentMouseTarget.clientWidth ||
                window.gsMemo.currentMouseTarget.lastHeight !== window.gsMemo.currentMouseTarget.clientHeight)) {// && //element.control === window.lastMouseDownElement) {
            
            //GS.triggerEvent(window.gsMemo.currentMouseTarget.parentNode, 'size-changed');
            
            window.gsMemo.currentMouseTarget.style.margin = '';
            window.gsMemo.currentMouseTarget.style.marginLeft = '';
            window.gsMemo.currentMouseTarget.style.marginRight = '';
            window.gsMemo.currentMouseTarget.style.marginTop = '';
            window.gsMemo.currentMouseTarget.style.marginBottom = '';
            window.gsMemo.currentMouseTarget.lastWidth  = window.gsMemo.currentMouseTarget.clientWidth;
            window.gsMemo.currentMouseTarget.lastHeight = window.gsMemo.currentMouseTarget.clientHeight;
            
            GS.triggerEvent(window.gsMemo.currentMouseTarget.parentNode, 'size-changed');
            
            //console.log('mousemove (' + new Date().getTime() + ')');
        }
    });
    
    window.addEventListener('mouseup', function (event) {
        //var mousePosition = GS.mousePosition(event);
        
        window.bolFirstMouseMoveWhileDown = true;
        //console.log('3***'); //, document.elementFromPoint(mousePosition.x, mousePosition.y)); //event.target);
        //window.lastMouseDownElement = element.control;
    });
}

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    var multiLineTemplateElement = document.createElement('template'),
        multiLineTemplate;
    
    multiLineTemplateElement.innerHTML = '<textarea class="control" gs-dynamic></textarea>';
    
    multiLineTemplate = multiLineTemplateElement.content;
    
    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();
        
        GS.triggerEvent(event.target.parentNode, 'change');
    }
    
    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
    }
    // function focusFunction(event) {
    //     event.preventDefault();
    //     event.stopPropagation();
    //     if (event.target.parentNode.hasAttribute('first-value')) {
    //             console.log(event);
    //         //GS.triggerEvent(event.target.parentNode, 'focus');
    //     } else {
    //         event.target.parentNode.setAttribute('first-value', event.target.value);
    //         GS.triggerEvent(event.target.parentNode, 'focus');
    //         //console.log('test');
    //     }
    // }
    
    //
    function keydownFunction(event) {
        var element = event.target;
        if (!element.hasAttribute('readonly')) {
            if (element.getAttribute('disabled') !== null && !(event.keyCode === 122 && event.metaKey)) {
                event.preventDefault();
                event.stopPropagation();
            } else if (event.keyCode === 9 && element.parentNode.hasAttribute('allow-tab-char') === true) {
                event.preventDefault();
                event.stopPropagation();
                var cursor_pos_memo = parseInt(element.selectionStart, 10);
                element.value = element.value.substring(0, cursor_pos_memo) + '\t' + element.value.substring(cursor_pos_memo, element.value.length);
                GS.setInputSelection(element, parseInt(cursor_pos_memo, 10) + 1, parseInt(cursor_pos_memo, 10) + 1);
            } else {
                //this.parentNode.syncView();
                element.parentNode.setAttribute('value', element.value);
                element.parentNode.handleResizeToText();
            }
        }
    }
    
    //
    function keyupFunction(event) {
        var element = event.target;
        if (!element.hasAttribute('readonly')) {
            //this.parentNode.syncView();
            element.parentNode.setAttribute('value', element.value);
            element.parentNode.handleResizeToText();
        }
    }
    
    function insertFunction(event) {
        var element = event.target;
        element.parentNode.handleResizeToText();
    }
    
    ////
    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //    
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.value = strQSValue;
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = null;
            }
        }
    }

    //
    function elementInserted(element) {
        //var strQSValue;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.hasAttribute('tabindex')) {
                    element.setAttribute('data-tabindex', element.getAttribute('tabindex'));
                    element.removeAttribute('tabindex');
                }

                element.appendChild(multiLineTemplate.cloneNode(true));
                if (element.hasAttribute('data-tabindex')) {
                    xtag.query(element, '.control')[0].setAttribute('tabindex', element.getAttribute('data-tabindex'));
                }
                // set a variable with the control element for convenience and speed
                element.control = xtag.queryChildren(element, '.control')[0];

                element.control.lastWidth = element.control.clientWidth;
                element.control.lastHeight = element.control.clientHeight;
                element.syncView();

                if (element.getAttribute('qs')) {
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}

                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                }
            }
        }
    }

    xtag.register('gs-memo', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    //console.log(this.getAttribute('id'), strAttrName, oldValue, newValue);
                    if (strAttrName === 'disabled' && newValue !== null) {
                        this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder');
                    } else if (strAttrName === 'disabled' && newValue === null) {
                        this.innerHTML = '';
                        this.appendChild(multiLineTemplate.cloneNode(true));
                        if (this.hasAttribute('data-tabindex')) {
                            xtag.query(this, '.control')[0].setAttribute('tabindex', this.getAttribute('data-tabindex'));
                        }
                        // set a variable with the control element for convenience and speed
                        this.control = xtag.queryChildren(this, '.control')[0];
                        
                        this.control.lastWidth = this.control.clientWidth;
                        this.control.lastHeight = this.control.clientHeight;
                        this.syncView();
                    } else if (strAttrName === 'value' && newValue !== oldValue) {
                        this.value = newValue;
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    if (this.control) {
                        return this.control.value;
                    } else {
                        return this.innerHTML;
                    }
                },
                
                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    if (this.getAttribute('value') !== strNewValue) {
                        this.setAttribute('value', strNewValue);
                    }
                    if (this.control) {
                        this.control.value = strNewValue;
                    } else {
                        this.innerHTML = strNewValue;
                    }
                    this.syncView();
                }
            },
            textValue: {
                // get value straight from the input
                get: function () {
                    if (this.control) {
                        return this.control.value;
                    } else {
                        return this.innerHTML;
                    }
                },
                
                // set the value attribute
                set: function (newValue) {
                    //this.setAttribute('value', newValue);
                    this.value = newValue;
                }
            }
        },
        methods: {
            focus: function () {
                if (this.control) {
                    this.control.focus();
                }
            },
            
            // sync control and resize to text
            syncView: function () {
                var element = this, arrPassThroughAttributes, i, len;
                
                /*
                if (this.innerHTML === '') {
                    this.appendChild(multiLineTemplate.cloneNode(true));
                }
                */
                /*
                if ((! this.hasAttribute('disabled')) && (! this.control)) {
                    this.appendChild(multiLineTemplate.cloneNode(true));
                    // set a variable with the control element for convenience and speed
                    this.control = xtag.queryChildren(this, '.control')[0];
                    
                    this.control.lastWidth = this.control.clientWidth;
                    this.control.lastHeight = this.control.clientHeight;
                }
                */
                
                if (this.hasAttribute('rows')) {
                    if (this.control) {
                        this.control.setAttribute('rows', this.getAttribute('rows'));
                    }
                }
                
                if (this.control) {
                    this.control.removeEventListener('change', changeFunction);
                    this.control.addEventListener('change', changeFunction);
                    
                    this.control.removeEventListener('focus', focusFunction);
                    this.control.addEventListener('focus', focusFunction);
                    
                    this.control.removeEventListener('keydown', keydownFunction);
                    this.control.addEventListener('keydown', keydownFunction);
                    
                    this.control.removeEventListener('insert', insertFunction);
                    this.control.addEventListener('insert', insertFunction);
                }
                
                if (this.control) {
                    this.control.value = this.getAttribute('value');
                } else {
                    this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder') || '';
                }
                    
                if (this.getAttribute('value')) {
                    this.handleResizeToText();
                }
                
                if (this.control) {
                    arrPassThroughAttributes = [
                        'placeholder',
                        'name',
                        'maxlength',
                        'autocorrect',
                        'autocapitalize',
                        'autocomplete',
                        'autofocus',
                        'rows',
                        'spellcheck',
                        'readonly'
                    ];
                    for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                        if (this.hasAttribute(arrPassThroughAttributes[i])) {
                            this.control.setAttribute(arrPassThroughAttributes[i], this.getAttribute(arrPassThroughAttributes[i]) || '');
                        }
                    }
                }
                
                // copy passthrough attributes to control
            },
            
            // if element is multiline and autoresize is not turned off: resize the element to fit the content
            handleResizeToText: function () {
                var element = this, intMinHeight;
                
                if (element.control) {
                    if (element.hasAttribute('autoresize')) {
                        element.control.style.height = '';
                        intMinHeight = element.control.offsetHeight;
                        element.control.style.height = ''; // '0';
                        
                        if (element.control.scrollHeight > intMinHeight) {
                            element.control.style.height = element.control.scrollHeight + 'px';
                        } else {
                            element.control.style.height = intMinHeight + 'px';
                        }
                    }
                    
                    
                    if (element.control.lastWidth !== element.control.clientWidth && element.control.lastHeight !== element.control.clientHeight) {
                        element.control.lastWidth = element.control.clientWidth;
                        element.control.lastHeight = element.control.clientHeight;
                        
                        GS.triggerEvent(element, 'size-changed');
                    }
                }
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('<gs-scroller>', '<gs-scroller>', 'gs-scroller>\n' +
                                                        '    <gs-scroller-inner style="width: ${1:1000px}; height: ${2:1000px};">\n' +
                                                        '        ${0}\n' +
                                                        '    </gs-scroller-inner>\n' +
                                                        '</gs-scroller>');
    
    designRegisterElement('gs-scroller', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-scroller.html');
    
    window.designElementProperty_GSSCROLLER = function (selectedElement) {
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
    };
});


Math.easeOutQuad = function (current_time, start_value, end_change, end_time) {
    'use strict';
    // Quadratic equation (produced by Robert Penner (www.robertpenner.com))
    current_time /= end_time;
    return -end_change * current_time * (current_time - 2) + start_value;
};

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    // using element, direction and X delta: move element using quadratic equation
    function easeOutX(dragElement, target, bolRight, intXDelta, intervalEaseXID) {
        var intFrames = Math.ceil(intXDelta / 0.25), intFrame = 0, intInterval = 20
          , intTotalTime = (intFrames * intInterval);
        
        //console.log(bolRight, intXDelta);
        
        if (intXDelta > 5) {
            intervalEaseXID = setInterval(function () {
                var intLeft;
                
                if (intFrame < intFrames) {
                    intLeft = parseInt(dragElement.style.left, 10);
                    
                    if (bolRight) {
                        intLeft = intLeft - Math.easeOutQuad((intFrame * intInterval), intXDelta, -intXDelta, intTotalTime);
                    } else {
                        intLeft = intLeft + Math.easeOutQuad((intFrame * intInterval), intXDelta, -intXDelta, intTotalTime);
                    }
                    
                    setElementLeft(dragElement, target, intLeft);
                } else {
                    clearTimeout(intervalEaseXID);
                }
                
                intFrame += 1;
            }, intInterval);
        }
        return intervalEaseXID;
    }
    
    // using element, direction and Y delta: move element using quadratic equation
    function easeOutY(dragElement, target, bolBottom, intYDelta, intervalEaseYID) {
        var intFrames = Math.ceil(intYDelta / 0.25), intFrame = 0, intInterval = 20
          , intTotalTime = (intFrames * intInterval);
        
        if (intYDelta > 5) {
            intervalEaseYID = setInterval(function () {
                var intTop;
                
                if (intFrame < intFrames) {
                    intTop = parseInt(dragElement.style.top, 10);
                    
                    if (bolBottom) {
                        intTop = intTop - Math.easeOutQuad((intFrame * intInterval), intYDelta, -intYDelta, intTotalTime);
                    } else {
                        intTop = intTop + Math.easeOutQuad((intFrame * intInterval), intYDelta, -intYDelta, intTotalTime);
                    }
                    
                    setElementTop(dragElement, target, intTop);
                } else {
                    clearTimeout(intervalEaseYID);
                }
                
                intFrame += 1;
            }, intInterval);
        }
        return intervalEaseYID;
    }
    
    // set left and respect boundries
    function setElementLeft(dragElement, target, intLeft) {
        var intWidth = dragElement.offsetWidth, minRight = target.offsetWidth;
        
        // target right edge must never get < container right edge
        if ((intLeft + intWidth) < minRight) {
            intLeft = (minRight - intWidth);
        }
        
        // target left edge must never get > container left edge
        if (intLeft > 0) {
            intLeft = 0;
        }
        
        dragElement.style.left = intLeft + 'px';
    }
    
    // set top and respect boundries
    function setElementTop(dragElement, target, intTop) {
        var intHeight = dragElement.offsetHeight, minBottom = target.offsetHeight;
        
        // target bottom edge must never get < container bottom edge
        if ((intTop + intHeight) < minBottom) {
            intTop = (minBottom - intHeight);
        }
        
        // target top edge must never get > container top edge
        if (intTop > 0) {
            intTop = 0;
        }
        
        dragElement.style.top = intTop + 'px';
    }
    
    function handleVerticalBoundries(dragElement, target) {
        var intTop = parseFloat(dragElement.style.top)
          , intHeight = dragElement.offsetHeight
          , minBottom = target.offsetHeight;
        
        // target bottom edge must never get < container bottom edge
        if ((intTop + intHeight) < minBottom) {
            intTop = (minBottom - intHeight);
        }
        
        // target top edge must never get > container top edge
        if (intTop > 0) {
            intTop = 0;
        }
        
        dragElement.style.top = intTop + 'px';
    }
    
    function handleHorizontalBoundries(dragElement, target) {
        var intLeft = parseFloat(dragElement.style.left)
          , intWidth = dragElement.offsetWidth
          , minRight = target.offsetWidth;
        
        // target right edge must never get < container right edge
        if ((intLeft + intWidth) < minRight) {
            intLeft = (minRight - intWidth);
        }
        
        // target left edge must never get > container left edge
        if (intLeft > 0) {
            intLeft = 0;
        }
        
        dragElement.style.left = intLeft + 'px';
    }
    
    function bindEvents(element) {
        var target = element, dragElement = element.children[0], intervalEaseXID
          , intervalEaseYID, lastClearTime, intScrollDelta = 0, minZoom = 0.5
          , maxZoom = 6;
        
        // zoom with mousewheel
        target.addEventListener('wheel', function (event) {
            var intDelta = event.deltaY, intNewZoom, currentTime
              , jsnMousePosition = GS.mousePosition(event), mouseEMX, mouseEMY, mousePXX, mousePXY
              , jsnOffsets = GS.getElementOffset(dragElement)
              , jsnTargetOffset
              , intCurrentZoom = (parseFloat(dragElement.style.fontSize) || 1)
              , intOldHeight = dragElement.offsetHeight
              , intOldWidth = dragElement.offsetWidth
              , intNewHeight, intNewWidth, intWidthDifference, intHeightDifference
              , intRelativeX, intRelativeY, intPercentX, intPercentY;
            
            event.preventDefault();
            event.stopPropagation();
            
            // get mouse position over dragElement in ems
            mousePXY = (jsnMousePosition.y - jsnOffsets.top);
            mousePXX = (jsnMousePosition.x - jsnOffsets.left);
            
            mouseEMY = GS.pxToEm(dragElement, mousePXY);
            mouseEMX = GS.pxToEm(dragElement, mousePXX);
            //console.log(jsnOffsets.top, jsnMousePosition.y, mouseEMY);
            //console.log(jsnOffsets.left, jsnMousePosition.x, mouseEMX);
            
            //console.log(event, event.deltaY, intDelta);
            if (lastClearTime) {
                currentTime = new Date().getTime();
                
                //console.log(currentTime - lastClearTime);
                if ((currentTime - lastClearTime) > 200) {
                    intScrollDelta = 0;
                    lastClearTime = new Date().getTime();
                }
            }
            
            // need to add clear if change direction
            
            lastClearTime = new Date().getTime();
            
            // if negative delta: increase custom delta by 0.1
            //      (unless we're at the maximum zoom, in which case: reset the delta)
            if (intDelta < 0) {
                intScrollDelta = (intScrollDelta > 0 ? intScrollDelta : 0);
                intScrollDelta = 0.05;
                if (intCurrentZoom < maxZoom) {
                    intScrollDelta += 0.05;
                } else {
                    intScrollDelta = 0;
                }
                
            // if positive delta: decrease custom delta by 0.1
            //      (unless we're at the minimum zoom, in which case: reset the delta)
            } else {
                intScrollDelta = (intScrollDelta < 0 ? intScrollDelta : 0);
                intScrollDelta = -0.05;
                if (intCurrentZoom > minZoom) {
                    intScrollDelta -= 0.05;
                } else {
                    intScrollDelta = 0;
                }
            }
            
            // add new delta to current zoom
            intNewZoom = (intCurrentZoom + intScrollDelta);
            
            // if the new zoom is above 6em: cap it off at 6em
            intNewZoom = (intNewZoom > maxZoom ? maxZoom : intNewZoom);
            
            // if the new zoom is below minZoom: cap it off at minZoom
            intNewZoom = (intNewZoom < minZoom ? minZoom : intNewZoom);
            
            //console.log('1:' + intNewZoom, '2:' + intScrollDelta, '3:' + intCurrentZoom);
            
            // apply new zoom
            dragElement.style.fontSize = intNewZoom + 'em';
            
            if (intCurrentZoom !== intNewZoom) {
                // get new height
                intNewWidth = dragElement.offsetWidth;
                intNewHeight = dragElement.offsetHeight;
                
                // adjust to mouse position
                
                // get full height difference
                intWidthDifference = (intNewWidth - intOldWidth);
                intHeightDifference = (intNewHeight - intOldHeight);
                
                // get relative x and y
                jsnTargetOffset = GS.getElementOffset(dragElement);
                intRelativeX = (jsnMousePosition.x - jsnTargetOffset.left);
                intRelativeY = (jsnMousePosition.y - jsnTargetOffset.top);
                
                // get percentage of x and y
                intPercentX = ((intRelativeX / intOldWidth) * 100);
                intPercentY = ((intRelativeY / intOldHeight) * 100);
                
                //console.log(intNewWidth, intOldWidth, intWidthDifference, intRelativeX, intPercentX);
                //console.log(intNewHeight, intOldHeight, intHeightDifference, intRelativeY, intPercentY);
                
                // percentage of height difference
                dragElement.style.left = (parseFloat(dragElement.style.left || '0') - ((intWidthDifference / 100) * intPercentX)) + 'px';
                dragElement.style.top = (parseFloat(dragElement.style.top || '0') - ((intHeightDifference / 100) * intPercentY)) + 'px';
            }
            
            // handle boundries
            handleVerticalBoundries(dragElement, target);
            handleHorizontalBoundries(dragElement, target);
        });
        
        // scrolling by dragging
        target.addEventListener(evt.mousedown, function (event) {
            var jsnMousePosition = GS.mousePosition(event)
              , jsnTargetOffsets = GS.getElementOffset(target)
              , jsnOffsets = GS.getElementOffset(dragElement)
              , startX = jsnMousePosition.x
              , startY = jsnMousePosition.y
              , offsetX = jsnOffsets.left - jsnTargetOffsets.left
              , offsetY = jsnOffsets.top - jsnTargetOffsets.top
              , lastX = 0, lastY = 0, currentX = 0, currentY = 0
              , deltaX, deltaY
              , mousemoveHandler, mouseupHandler;
            
            // stop text selection
            event.preventDefault();
            
            // stop easing functions
            clearTimeout(intervalEaseXID);
            clearTimeout(intervalEaseYID);
            
            // add "down" class
            dragElement.classList.add('down');
            
            mousemoveHandler = function (event) {
                var jsnMousePosition;
                
                if (event.which === 0 && !evt.touchDevice) {
                    mouseupHandler(event);
                    
                } else {
                    // handle move
                    jsnMousePosition = GS.mousePosition(event);
                    
                    // saving the current postition and the previous position for calculating the delta
                    lastX = currentX;
                    lastY = currentY;
                    currentX = jsnMousePosition.x;// - jsnTargetOffsets.left;
                    currentY = jsnMousePosition.y;// - jsnTargetOffsets.top;
                    
                    // moving element
                    //console.log(offsetX, currentX, startX);//, jsnTargetOffsets.left);
                    //console.log(offsetY, currentY, startY);//, jsnTargetOffsets.top);
                    setElementLeft(dragElement, target, (offsetX + (currentX - startX)));
                    setElementTop(dragElement, target, (offsetY + (currentY - startY)));
                    
                    event.preventDefault();
                }
            };
            
            mouseupHandler = function (event) {
                // calculate delta
                deltaX = lastX - currentX;
                deltaY = lastY - currentY;
                
                // ease out
                intervalEaseXID = easeOutX(dragElement, target, (deltaX > 0), Math.abs(deltaX), intervalEaseXID);
                intervalEaseYID = easeOutY(dragElement, target, (deltaY > 0), Math.abs(deltaY), intervalEaseYID);
                
                // remove "down" class
                dragElement.classList.remove('down');
                
                // unbind mousemove and mouseup
                document.body.removeEventListener(evt.mousemove, mousemoveHandler);
                document.body.removeEventListener(evt.mouseup, mouseupHandler);
            };
            
            document.body.addEventListener(evt.mousemove, mousemoveHandler);
            document.body.addEventListener(evt.mouseup, mouseupHandler);
        });
    }
    
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            
        }
    }
    
    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
                if (element.children.length > 1) {
                    throw 'gs-scroller Error: Too many children. gs-scroller elements must have one child and it must be a <gs-scroller-inner> element.';
                    
                } else if (element.children.length === 0) {
                    throw 'gs-scroller Error: No children. gs-scroller elements must have one child and it must be a <gs-scroller-inner> element.';
                    
                } else if (element.children[0].nodeName !== 'GS-SCROLLER-INNER') {
                    throw 'gs-scroller Error: Invalid child. gs-scroller elements must have one child and it must be a <gs-scroller-inner> element.';
                }
                
                // if we're not on a touch device: bind events and set the title text
                if (!evt.touchDevice) {
                    // bind events
                    bindEvents(element);
                    
                    // title text
                    element.children[0].setAttribute('title', 'Click and drag to move around, scroll to zoom.');
                    
                // else: make the element scrollable
                } else {
                    element.classList.add('scrollable');
                }
            }
        }
    }
    
    xtag.register('gs-scroller-inner', {});
    xtag.register('gs-scroller', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    
                }
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});
window.addEventListener('design-register-element', function () {
    
    registerDesignSnippet('<gs-number>', '<gs-number>', 'gs-number column="${1:name}"></gs-number>');
    registerDesignSnippet('<gs-number> With Label', '<gs-number>', 'label for="${1:number-insert-qty}">${2:Quantity}:</label>\n' +
                                                                   '<gs-number id="${1:number-insert-qty}" column="${3:qty}"></gs-number>');
    
    designRegisterElement('gs-number', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-number.html');
    
    window.designElementProperty_GSNUMBER = function(selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });
        
        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });
        
        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });
        
        addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
        });
        
        //console.log(selectedElement.hasAttribute('mini'));
        
        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });
        
        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });
        
        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });
        
        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });
        
        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });
        
        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var singleLineTemplateElement = document.createElement('template'),
        singleLineTemplate;

    singleLineTemplateElement.innerHTML = '<input class="control" gs-dynamic type="text" />';
    singleLineTemplate = singleLineTemplateElement.content;

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        GS.triggerEvent(event.target.parentNode, 'change');

        handleFormat(event.target.parentNode, event);
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
    }

    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // sync control value and resize to text
    function syncView(element) {
        if (element.control) {
            if (element.getAttribute('value') !== element.control.value) {
                element.setAttribute('value', element.control.value);
            }
        } else {
            if (element.getAttribute('value') !== element.innerHTML) {
                element.setAttribute('value', element.innerHTML);
            }
        }
    }

    function handleFormat(element, event, bolAlertOnError) {
        var strFormat, intValue;

        if (element.hasAttribute('format')) {
            strFormat = element.getAttribute('format');

            intValue = element.value; // parseFloat(element.value.replace(/[^0-9.]*/g, ''), 10);

            if (isNaN(intValue)) {
                if (bolAlertOnError !== undefined && bolAlertOnError !== false) {
                    alert('Invalid Number: ' + element.value);
                }

                if (element.control) {
                    GS.setInputSelection(element.control, 0, element.value.length);
                }

                if (event) {
                    event.stopPropagation();
                    event.preventDefault();
                }

            } else {
                if (element.control) {
                    element.control.value = formatNumber(intValue, strFormat);
                } else {
                    element.innerHTML = formatNumber(intValue, strFormat);
                }
            }
        }
    }

    function formatNumber(intValue, strFormat) {
        /* (this function contains a (modified) substantial portion of code from another source
            here is the copyright for sake of legality) (Uses code by Matt Kruse)
        Copyright (c) 2006-2009 Rostislav Hristov, Asual DZZD

        Permission is hereby granted, free of charge, to any person obtaining a
        copy of this software and associated documentation files
        (the "Software"), to deal in the Software without restriction,
        including without limitation the rights to use, copy, modify, merge,
        publish, distribute, sublicense, and/or sell copies of the Software,
        and to permit persons to whom the Software is furnished to do so,
        subject to the following conditions:

        The above copyright notice and this permission notice shall be included
        in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/
        var groupingSeparator,
            groupingIndex,
            decimalSeparator,
            decimalIndex,
            roundFactor,
            result,
            i,
            locale = {
                groupingSeparator: ',',
                decimalSeparator: '.',
                currencySymbol: '$',
                percentSymbol: '%'
            };

        if (strFormat.toLowerCase() === 'currency') {
            strFormat = locale.currencySymbol + '0.00';
        } else if (strFormat.toLowerCase() === 'percent') {
            intValue = intValue * 100;
            strFormat = locale.percentSymbol + '0.00';
        }

        var integer = '',
            fraction = '',
            negative,
            minFraction,
            maxFraction,
            powFraction,
            bolCurrencySymbol = strFormat[0] === locale.currencySymbol,
            bolPercentSymbol = strFormat[0] === locale.percentSymbol;

        if (bolCurrencySymbol || bolPercentSymbol) {
            strFormat = strFormat.substring(1);
        }

        groupingSeparator = ',';
        groupingIndex = strFormat.lastIndexOf(groupingSeparator);
        decimalSeparator = '.';
        decimalIndex = strFormat.indexOf(decimalSeparator);

        negative = intValue < 0;
        minFraction = strFormat.substr(decimalIndex + 1).replace(/#/g, '').length;
        maxFraction = strFormat.substr(decimalIndex + 1).length;
        powFraction = 10;

        intValue = Math.abs(intValue);

        if (decimalIndex != -1) {
            fraction = locale.decimalSeparator;
            if (maxFraction > 0) {
                roundFactor = 1000;
                powFraction = Math.pow(powFraction, maxFraction);
                var tempRound = Math.round(parseInt(intValue * powFraction * roundFactor -
                            Math.round(intValue) * powFraction * roundFactor, 10) / roundFactor),
                    tempFraction = String(tempRound < 0 ? Math.round(parseInt(intValue * powFraction * roundFactor -
                            parseInt(intValue, 10) * powFraction * roundFactor, 10) / roundFactor) : tempRound),
                    parts = intValue.toString().split('.');
                if (typeof parts[1] != 'undefined') {
                    for (i = 0; i < maxFraction; i++) {
                        if (parts[1].substr(i, 1) == '0' && i < maxFraction - 1 &&
                                tempFraction.length != maxFraction) {
                            tempFraction = '0' + tempFraction;
                        } else {
                            break;
                        }
                    }
                }
                for (i = 0; i < (maxFraction - fraction.length); i++) {
                    tempFraction += '0';
                }
                var symbol, formattedFraction = '';

                for (i = 0; i < tempFraction.length; i++) {
                    symbol = tempFraction.substr(i, 1);
                    if (i >= minFraction && symbol == '0' && (/^0*$/).test(tempFraction.substr(i + 1))) {
                        break;
                    }
                    formattedFraction += symbol;
                }
                fraction += formattedFraction;
            }
            if (fraction == locale.decimalSeparator) {
                fraction = '';
            }
        }

        if (decimalIndex !== 0) {
            if (fraction !== '') {
                integer = String(parseInt(Math.round(intValue * powFraction) / powFraction, 10));
            } else {
                integer = String(Math.round(intValue));
            }
            var grouping = locale.groupingSeparator,
                groupingSize = 0;
            if (groupingIndex != -1) {
                if (decimalIndex != -1) {
                    groupingSize = decimalIndex - groupingIndex;
                } else {
                    groupingSize = strFormat.length - groupingIndex;
                }
                groupingSize--;
            }
            if (groupingSize > 0) {
                var count = 0, 
                    formattedInteger = '';
                i = integer.length;
                while (i--) {
                    if (count !== 0 && count % groupingSize === 0) {
                        formattedInteger = grouping + formattedInteger;    
                    }
                    formattedInteger = integer.substr(i, 1) + formattedInteger;
                    count++;
                }
                integer = formattedInteger;
            }
            var maxInteger, maxRegExp = /#|,/g;
            if (decimalIndex != -1) {
                maxInteger = strFormat.substr(0, decimalIndex).replace(maxRegExp, '').length;
            } else {
                maxInteger = strFormat.replace(maxRegExp, '').length;
            }
            var tempInteger = integer.length;
            for (i = tempInteger; i < maxInteger; i++) {
                integer = '0' + integer;
            }
        }
        result = integer + fraction;
        return (bolPercentSymbol ? locale.percentSymbol : '') +
               (bolCurrencySymbol ? locale.currencySymbol : '') +
               (negative ? '-' : '') + result;
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = null;
            }
        }
    }

    function elementInserted(element) {
        //var strQSValue;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.hasAttribute('tabindex')) {
                    element.setAttribute('data-tabindex', element.getAttribute('tabindex'));
                    element.removeAttribute('tabindex');
                }
                if (element.hasAttribute('disabled')) {
                    element.innerHTML = element.getAttribute('value') || element.getAttribute('placeholder');
                } else {
                    element.innerHTML = '';
                    element.appendChild(singleLineTemplate.cloneNode(true));
                    if (element.hasAttribute('data-tabindex')) {
                        xtag.query(element, '.control')[0].setAttribute('tabindex', element.getAttribute('data-tabindex'));
                    }
                }

                if (element.getAttribute('qs')) {
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}

                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                }

                if (element.innerHTML === '') {
                    element.appendChild(singleLineTemplate.cloneNode(true));
                    if (element.hasAttribute('data-tabindex')) {
                        xtag.query(element, '.control')[0].setAttribute('tabindex', element.getAttribute('data-tabindex'));
                    }
                }
                element.refresh();
            }
        }
    }

    xtag.register('gs-number', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                    if (strAttrName === 'disabled') {
                        if (this.hasAttribute('tabindex')) {
                            this.setAttribute('data-tabindex', this.getAttribute('tabindex'));
                            this.removeAttribute('tabindex');
                        }
                        if (this.hasAttribute('disabled')) {
                            this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder');
                        } else {
                            this.innerHTML = '';
                            this.appendChild(singleLineTemplate.cloneNode(true));
                            if (this.hasAttribute('data-tabindex')) {
                                xtag.query(this, '.control')[0].setAttribute('tabindex', this.getAttribute('data-tabindex'));
                            }
                        }

                        this.refresh();
                    } else if (strAttrName === 'value' && newValue !== oldValue) {
                        this.value = newValue;
                    }
                }
            }
        },
        events: {
            // on keydown and keyup sync the value attribute and the control value
            keydown: function (event) {
                if (window.bolDesignMode !== true) {
                    if (this.getAttribute('disabled') !== null && event.keyCode !== 9) {
                        event.preventDefault();
                        event.stopPropagation();
                    } else {
                        syncView(this);
                    }
                }
            },
            keyup: function () {
                if (window.bolDesignMode !== true) {
                    syncView(this);
                }
            }//,
            //'change:delegate(.control)': function (event) {
            //    var element = this.parentNode;
            //
            //    event.preventDefault();
            //    event.stopPropagation();
            //
            //    xtag.fireEvent(element, 'change', {
            //        bubbles: true,
            //        cancelable: true
            //    });
            //}
        },
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    if (this.control) {
                        return parseFloat(this.control.value.replace(/[^-0-9.]*/g, ''), 10); // this.control.value;
                    } else {
                        return parseFloat(this.innerHTML.replace(/[^-0-9.]*/g, ''), 10); // this.control.value;
                    }
                },
                
                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    if (this.control) {
                        this.control.value = strNewValue;
                    } else {
                        this.innerHTML = strNewValue;
                    }
                    handleFormat(this);
                    syncView(this);
                }
            }
        },
        methods: {
            focus: function () {
                this.control.focus();
            },
            
            refresh: function () {
                var arrPassThroughAttributes, i, len;
                
                // set a variable with the control element for convenience and speed
                this.control = xtag.query(this, '.control')[0];
                
                if (this.control) {
                    this.control.removeEventListener('change', changeFunction);
                    this.control.addEventListener('change', changeFunction);
                    
                    this.control.removeEventListener('focus', focusFunction);
                    this.control.addEventListener('focus', focusFunction);
                }
                // if there is a value already in the attributes of the element: set the control value
                if (this.hasAttribute('value')) {
                    if (this.control) {
                        this.control.value = this.getAttribute('value') || this.getAttribute('placeholder');
                    } else {
                        this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder');
                    }
                    handleFormat(this, undefined, false);
                }
                
                if (this.control) {
                    // copy passthrough attributes to control
                    arrPassThroughAttributes = [
                        'placeholder',
                        'name',
                        'maxlength',
                        'autocorrect',
                        'autocapitalize',
                        'autocomplete',
                        'autofocus',
                        'spellcheck',
                        'readonly'
                    ];
                    for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                        if (this.hasAttribute(arrPassThroughAttributes[i])) {
                            this.control.setAttribute(arrPassThroughAttributes[i], this.getAttribute(arrPassThroughAttributes[i]) || '');
                        }
                    }
                }
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    registerDesignSnippet('<gs-optionbox>', '<gs-optionbox>', 'gs-optionbox column="${1}">\n' +
                                                              '    <gs-option value="${2}">${3}</gs-option>\n' +
                                                              '</gs-optionbox>');
    
    designRegisterElement('gs-optionbox', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-optionbox.html');
    
    window.designElementProperty_GSOPTIONBOX = function(selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });
        
        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });
        
        addProp('Clearable', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('clearable') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'clearable', this.value === 'true', true);
        });
        
        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });
        
        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', this.value === 'true', true);
        });
        
        addProp('No Targets', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-target') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-target', this.value === 'true', true);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
    /*
    window.designElementProperty_GSOPTION = function(selectedElement) {
        addProp('Hidden Value:', true, '<gs-text class="target" value="' + (selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + (selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        addFlexContainerProps(selectedElement);
        //addFlexProps(selectedElement);
    };*/
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    // removes selected attribute from old selected option adds selected attribute to option
    function highlightOption(element, option) {
        var i, len, arrSelectedOptions, arrTempSelectedOptions;
        
        // clear previous selection
        arrSelectedOptions = xtag.query(element, 'gs-option[selected]');
        arrTempSelectedOptions = xtag.query(element, 'gs-option[tempselect]');
        for (i = 0, len = arrSelectedOptions.length; i < len; i += 1) {
            arrSelectedOptions[i].removeAttribute('selected');
        }
        
        for (i = 0, len = arrTempSelectedOptions.length; i < len; i += 1) {
            arrTempSelectedOptions[i].removeAttribute('tempselect');
        }

        // select/highlight the record that was provided
        if (option) {
            option.setAttribute('selected', '');
        }
    }

    // loops through the options and finds a option using the parameter
    function findOptionFromString(element, strSearchString) {
        var i, len, matchedOption, arrOptions = xtag.query(element, 'gs-option');

        // search exact text and search both the value attribute (if present) and the text content
        for (i = 0, len = arrOptions.length; i < len; i += 1) {
            if (arrOptions[i].getAttribute('value') === strSearchString || arrOptions[i].textContent === strSearchString) {
                matchedOption = arrOptions[i];
                break;
            }
        }

        return matchedOption;
    }

    function selectOption(element, handle, bolChange) {
        var option, strOptionValue, strOptionText;

        if (typeof handle === 'string') {
            option = findOptionFromString(element, handle);

            if (!option) {
                throw 'gs-optionbox Error: value: \'' + handle + '\' not found.';
            }
        } else {
            option = handle;
        }
        
        highlightOption(element, option);

        if (option) {
            strOptionValue = option.getAttribute('value');
            strOptionText = option.textContent;
        } else {
            strOptionValue = '';
            strOptionText = '';
        }

        if (element.value !== (strOptionValue || strOptionText)) {
            element.innerValue = strOptionValue || strOptionText;
            element.innerSelectedOption = option;

            if (bolChange) {
                xtag.fireEvent(element, 'change', {bubbles: true, cancelable: true});
            }
        }
    }

    // #################################################################
    // ########################## USER EVENTS ##########################
    // #################################################################
    /*
    // handle behaviours on keydown
    function handleKeyDown(event) {
        var element = event.target, intKeyCode = event.keyCode || event.which,
            selectedOption, selectedOptionIndex,
            tempSelectedOption, tempSelectedOptionIndex, arrOptions, i, len;

        if (!element.hasAttribute('disabled')) {
            if ((intKeyCode === 40 || intKeyCode === 38) && !event.shiftKey && !event.metaKey && !event.ctrlKey && !element.error) {
                arrOptions = xtag.query(element, 'gs-option');

                for (i = 0, len = arrOptions.length; i < len; i += 1) {
                    if (arrOptions[i].hasAttribute('tempselect')) {
                        tempSelectedOptionIndex = i;
                        tempSelectedOption = arrOptions[i];
                        arrOptions[i].removeAttribute('tempselect');
                    }

                    if (arrOptions[i].hasAttribute('selected')) {
                        selectedOptionIndex = i;
                        selectedOption = arrOptions[i];
                    }

                    if (selectedOption && tempSelectedOption) {
                        break;
                    }
                }

                //console.log(selectedOption, selectedOptionIndex, tempSelectedOption, tempSelectedOptionIndex, arrOptions.length);

                if (tempSelectedOption && tempSelectedOptionIndex !== arrOptions.length - 1 && intKeyCode === 40) {
                    if (!arrOptions[tempSelectedOptionIndex + 1].hasAttribute('selected')) {
                        arrOptions[tempSelectedOptionIndex + 1].setAttribute('tempselect', '');
                    }
                } else if (tempSelectedOption && tempSelectedOptionIndex !== 0 && intKeyCode === 38) {
                    if (!arrOptions[tempSelectedOptionIndex - 1].hasAttribute('selected')) {
                        arrOptions[tempSelectedOptionIndex - 1].setAttribute('tempselect', '');
                    }
                } else if (!tempSelectedOption && selectedOption && selectedOptionIndex !== arrOptions.length - 1 && intKeyCode === 40) {
                    if (!arrOptions[selectedOptionIndex + 1].hasAttribute('selected')) {
                        arrOptions[selectedOptionIndex + 1].setAttribute('tempselect', '');
                    }
                } else if (!tempSelectedOption && selectedOption && selectedOptionIndex !== 0 && intKeyCode === 38) {
                    if (!arrOptions[selectedOptionIndex - 1].hasAttribute('selected')) {
                        arrOptions[selectedOptionIndex - 1].setAttribute('tempselect', '');
                    }
                // tempselect first record
                } else if (intKeyCode === 40) {
                    if (!arrOptions[0].hasAttribute('selected')) {
                        arrOptions[0].setAttribute('tempselect', '');
                    }
                // tempselect last record
                } else if (intKeyCode === 38) {
                    if (!arrOptions[arrOptions.length - 1].hasAttribute('selected')) {
                        arrOptions[arrOptions.length - 1].setAttribute('tempselect', '');
                    }
                }
                event.preventDefault();
                event.stopPropagation();

            } else if (event.keyCode === 13 || event.keyCode === 32) {
                selectedOption = xtag.query(element, 'gs-option[selected]')[0];
                tempSelectedOption = xtag.query(element, 'gs-option[tempselect]')[0];

                if (tempSelectedOption) {
                    selectOption(element, tempSelectedOption, true);
                } else if (selectedOption) {
                    selectOption(element, selectedOption, true);
                }
            }
        } else {
            if (event.keyCode !== 9) {
                event.preventDefault();
                event.stopPropagation();
            }
        }

        //console.log('handleKeyDown', intKeyCode, event);
    }*/

    function getParentOption(element) {
        var currentElement = element;

        while (currentElement.nodeName !== 'GS-OPTION' && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }

        if (currentElement.nodeName !== 'GS-OPTION') {
            return undefined;
        }

        return currentElement;
    }

    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    function enhanceChildren(element) {
        var arrElement, i, len;

        arrElement = xtag.query(element, 'gs-option');

        for (i = 0, len = arrElement.length; i < len; i += 1) {
            // this if allows the developer to define the icon position
            if (!arrElement[i].hasAttribute('icontop')
                    && !arrElement[i].hasAttribute('iconleft')
                    && !arrElement[i].hasAttribute('iconbottom')
                    && !arrElement[i].hasAttribute('iconright')) {
                arrElement[i].setAttribute('iconleft', '');
            }
            arrElement[i].setAttribute('icon', '');
        }
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
                // element.value = null;
            }
        }
    }

    //
    function elementInserted(element) {
        var strQSValue, observer;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                //// allows the element to have focus
                //if (!element.hasAttribute('tabindex')) {
                //    element.setAttribute('tabindex', '0');
                //}

                if (element.getAttribute('value')) {
                    selectOption(element, element.getAttribute('value'), false);
                }

                if (element.getAttribute('qs')) {
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));

                    //if (strQSValue !== '') {
                    //    selectOption(element, strQSValue, false);
                    //}
                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                }

                // if we are not [no-target]
                if (!element.hasAttribute('no-target')) {
                    enhanceChildren(element);

                    // put an observer on the option element to enhance new children

                    // create an observer instance
                    observer = new MutationObserver(function(mutations) {
                        var bolRefreshOptionList = true;

                        // check each mutation: if only option and optgroup tags were added: refersh option tags in select
                        mutations.forEach(function(mutation) {
                            var i, len;

                            for (i = 0, len = mutation.addedNodes.length; i < len; i += 1) {
                                if (mutation.addedNodes[i].nodeName !== 'GS-OPTION') {
                                    bolRefreshOptionList = false;
                                }
                            }
                        });

                        if (bolRefreshOptionList) {
                            enhanceChildren(element);
                        }
                    });

                    // pass in the element node, as well as the observer options
                    observer.observe(element, {childList: true});
                }
            }
        }
    }

    xtag.register('gs-optionbox', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value' && newValue !== oldValue) {
                        selectOption(this, newValue);
                    }
                }
            }
        },
        events: {
            //'keydown': function (event) {
            //    if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
            //        handleKeyDown(event);
            //    }
            //},
            
            'click': function (event) {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                    var parentOption = getParentOption(event.target);
                    
                    //console.log(parentOption);
                    
                    //  else if (this.hasAttribute('clearable') && newValue === oldValue) {
                    //     console.log('running');
                    //     selectOption(this, undefined);
                    // }
                    
                    if (parentOption && !parentOption.hasAttribute('selected')) {
                        selectOption(this, parentOption, true);
                    } else if (this.hasAttribute('clearable')) {
                        selectOption(this, undefined);
                    }
                }
            }//,
            
            //'focusout': function () {
            //    if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
            //        var selectedOption = xtag.query(this, 'gs-option[selected]')[0],
            //            tempSelectedOption = xtag.query(this, 'gs-option[tempselect]')[0];
            //        
            //        if (tempSelectedOption) {
            //            selectOption(this, tempSelectedOption, true);
            //            
            //        } else if (selectedOption) {
            //            selectOption(this, selectedOption, true);
            //        }
            //    }
            //}
        },
        accessors: {
            value: {
                get: function () {
                    return this.innerValue;
                },
                
                set: function (strNewValue) {
                    selectOption(this, strNewValue);
                }
            },
            
            selectedOption: {
                get: function () {
                    return this.innerSelectedOption;
                },
                
                set: function (newValue) {
                    selectOption(this, newValue);
                }
            },
            
            textValue: {
                get: function () {
                    return this.innerSelectedOption.textContent;
                },
                
                set: function (newValue) {
                    selectOption(this, newValue);
                }
            }
        }
    });
});

window.addEventListener('design-register-element', function () {
    registerDesignSnippet('Empty <gs-page>', '<gs-page>', 'gs-page>\n' +
                                                          '    $0\n' +
                                                          '</gs-page>');
    registerDesignSnippet('<gs-page> With Header', '<gs-page>', 'gs-page>\n' +
                                                         '    <gs-header>\n' +
                                                         '        <center><h3>${1}</h3></center>\n' +
                                                         '    </gs-header>\n' +
                                                         '    <gs-body>\n' +
                                                         '        $0\n' +
                                                         '    </gs-body>\n' +
                                                         '</gs-page>');
    registerDesignSnippet('Full <gs-page>', '<gs-page>', 'gs-page>\n' +
                                                         '    <gs-header>\n' +
                                                         '        <center><h3>${1}</h3></center>\n' +
                                                         '    </gs-header>\n' +
                                                         '    <gs-body>\n' +
                                                         '        $0\n' +
                                                         '    </gs-body>\n' +
                                                         '    <gs-footer>${2}</gs-footer>\n' +
                                                         '</gs-page>');
    
    designRegisterElement('gs-page', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-page.html');
    
    window.designElementProperty_GSPAGE = function (selectedElement) {
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            var observer,
                headerElement = xtag.queryChildren(element, 'gs-header')[0],
                footerElement = xtag.queryChildren(element, 'gs-footer')[0];
            
            // create an observer instance
            observer = new MutationObserver(function(mutations) {
                element.recalculatePadding();
                //console.log('mutation observed');
            });
            
            // pass in the element node, as well as the observer options
            if (headerElement) {
                observer.observe(headerElement, {childList: true, subtree: true});
            }
            if (footerElement) {
                observer.observe(footerElement, {childList: true, subtree: true});
            }
        }
    }
    
    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
                element.recalculatePadding();
                
                window.addEventListener('load', function () {
                    element.recalculatePadding();
                });
                window.addEventListener('resize', function () {
                    element.recalculatePadding();
                });
                element.recalculatePadding();
            }
        }
    }
    
    xtag.register('gs-page', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            recalculatePadding: function () {
                var headerElement = xtag.queryChildren(this, 'gs-header')[0],
                    footerElement = xtag.queryChildren(this, 'gs-footer')[0];
                
                if (headerElement) {
                    //console.log('1***', headerElement.offsetHeight);
                    this.style.paddingTop = headerElement.offsetHeight + 'px';
                } else {
                    this.style.paddingTop = '';
                }
                if (footerElement) {
                    //console.log('2***', footerElement.offsetHeight);
                    this.style.paddingBottom = footerElement.offsetHeight + 'px';
                } else {
                    this.style.paddingBottom = '';
                }
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet('<gs-panel>', '<gs-panel>', 'gs-panel id="panel">\n' +
                                                      '    <gs-page id="${1:left-bar}" style="width: 17em;">\n' +
                                                      '        \n' +
                                                      '    </gs-page>\n' +
                                                      '    <gs-page>\n' +
                                                      '        \n' +
                                                      '    </gs-page>\n' +
                                                      '</gs-panel>');
    
    designRegisterElement('gs-panel', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-panel.html');
    
    window.designElementProperty_GSPANEL = function(selectedElement) {
        // no-shadow-dismiss attribute
        addProp('Dismissible By Clicking The Shadow', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-shadow-dismiss')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-shadow-dismiss', this.value === 'true', false);
        });
        
        // dismissible attribute
        addProp('Dismissible On Desktop', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('dismissible') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'dismissible', this.value === 'true', true);
        });
        
        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    function pushReplacePopHandler(element) {
        var query = GS.getQueryString(), arrQueryKeys = GS.qryGetKeys(query),
            strID = element.getAttribute('id'), strAttributeName, i, len, strNewValue;
        
        for (i = 0, len = arrQueryKeys.length; i < len; i += 1) {
            if (arrQueryKeys[i].indexOf(strID + '.') === 0 &&
                element.panelIDs.indexOf(arrQueryKeys[i].split('.')[1]) > -1) {
                
                strAttributeName = arrQueryKeys[i].split('.')[1];
                strNewValue = GS.qryGetVal(query, arrQueryKeys[i]);
                
                if (element.getAttribute(strAttributeName) !== strNewValue) {
                    element.setAttribute(strAttributeName, strNewValue);
                }
            }
        }
        
        for (i = 0, len = element.arrQueryStringAttributes.length; i < len; i += 1) {
            if (arrQueryKeys.indexOf(element.arrQueryStringAttributes[i]) === -1) {
                element.removeAttribute(element.arrQueryStringAttributes[i].split('.')[1]);
            }
        }
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            
        }
    }
    
    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
                var arrElement, i, len, blockerElement, blockerClickHandler;
                
                element.arrQueryStringAttributes = [];
                element.panelIDs = [];
                
                blockerClickHandler = function (event) {
                    var target = event.target;
                    
                    if (target.classList.contains('gs-panel-page-blocker')) {
                        element.hide(target.getAttribute('blocking'));
                    }
                };
                
                arrElement = xtag.queryChildren(element, '*');
                
                for (i = 0, len = arrElement.length; i < len; i += 1) {
                    if (arrElement[i].style.width === '') {
                        arrElement[i].setAttribute('flex', '');
                    } else {
                        if (!arrElement[i].hasAttribute('id')) {
                            console.warn('gs-panel Warning: No ID attribute on side-page element:',
                                         GS.cloneElement(arrElement[i]),
                                         ', please set ID the attribute');
                            
                            arrElement[i].setAttribute('id', 'side-' + GS.GUID().substring(0, 8));
                        }
                        element.panelIDs.push(arrElement[i].getAttribute('id'));
                        
                        blockerElement = document.createElement('div');
                        blockerElement.classList.add('gs-panel-page-blocker');
                        blockerElement.setAttribute('gs-dynamic', '');
                        blockerElement.setAttribute('blocking', arrElement[i].getAttribute('id'));
                        blockerElement.setAttribute('id', arrElement[i].getAttribute('id') + '-blocker');
                        
                        element.insertBefore(blockerElement, arrElement[i]);
                        
                        arrElement[i].setAttribute('panel-set-width', '');
                        
                        if (arrElement[i].hasAttribute('hidden')) {
                            arrElement[i].removeAttribute('hidden');
                            element.hide(arrElement[i].getAttribute('id'));
                            
                        } else {
                            if (element.getAttribute(arrElement[i].getAttribute('id')) === 'hide') {
                                element.hide(arrElement[i].getAttribute('id'));
                            }
                        }
                        
                        if (!element.hasAttribute('no-shadow-dismiss')) {
                            blockerElement.addEventListener('click', blockerClickHandler);
                        }
                    }
                }
                
                window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                
                if (element.hasAttribute('id')) {
                    pushReplacePopHandler(element);
                }
            }
        }
    }
    
    xtag.register('gs-panel', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (document.getElementById(strAttrName) &&
                        document.getElementById(strAttrName).parentNode === this) {
                        if (newValue === 'hide' || newValue === 'show') {
                            this[newValue](strAttrName);
                        }
                        /*if (newValue === 'hide') {
                            this.hide(strAttrName);
                        } else if (newValue === 'show') {
                            this.show(strAttrName);
                        }*/
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            'show': function (strID) {
                var strQueryString = GS.getQueryString(), strElementID = this.getAttribute('id');
                //document.getElementById(strID).setAttribute('shown', '');
                //document.getElementById(strID).removeAttribute('hidden');
                //document.getElementById(strID + '-blocker').setAttribute('shown', '');
                //document.getElementById(strID + '-blocker').removeAttribute('hidden');
                
                //document.getElementById(strID).style.display = '';
                //document.getElementById(strID + '-blocker').style.display = '';
                
                //if (window.innerWidth <= 768 || this.hasAttribute('dismissible')) {
                
                if ((strElementID && GS.qryGetKeys(strQueryString).indexOf(strElementID + '.' + strID) > -1) &&
                    GS.qryGetVal(strQueryString, strElementID + '.' + strID) === 'hide') {
                    GS.pushQueryString(strElementID + '.' + strID + '=show');
                    
                } else if (this.getAttribute(strID) === 'show') {
                    //document.getElementById(strID).style.left = '';
                    //document.getElementById(strID).style.position = '';
                    //document.getElementById(strID + '-blocker').style.left = ''; // <-- works on a phone
                    document.getElementById(strID).removeAttribute('panel-hide');
                    document.getElementById(strID + '-blocker').removeAttribute('panel-hide');
                    
                    //this.hiddenIDs.splice(this.hiddenIDs.indexOf(strID), 1);
                    //
                    GS.triggerEvent(document.getElementById(strID), 'show');
                    GS.triggerEvent(window, 'resize'); //, {'triggered': true});
                } else {
                    this.setAttribute(strID, 'show');
                }
                //}
            },
            
            'hide': function (strID) {
                var strQueryString = GS.getQueryString(), strElementID = this.getAttribute('id');
                //document.getElementById(strID).setAttribute('hidden', '');
                //document.getElementById(strID).removeAttribute('shown');
                //document.getElementById(strID + '-blocker').setAttribute('hidden', '');
                //document.getElementById(strID + '-blocker').removeAttribute('shown');
                
                //document.getElementById(strID).style.display = 'none';
                //document.getElementById(strID + '-blocker').style.display = 'none';
                
                if ((strElementID && GS.qryGetKeys(strQueryString).indexOf(strElementID + '.' + strID) > -1) &&
                    GS.qryGetVal(strQueryString, strElementID + '.' + strID) === 'show') {
                    GS.pushQueryString(strElementID + '.' + strID + '=hide');
                    
                } else if (this.getAttribute(strID) === 'hide') {
                    document.getElementById(strID).setAttribute('panel-hide', '');
                    document.getElementById(strID + '-blocker').setAttribute('panel-hide', '');
                    
                    //if (window.innerWidth <= 768 || this.hasAttribute('dismissible')) {
                    //    document.getElementById(strID).style.left = '-100%';
                    //    document.getElementById(strID).style.position = 'absolute';
                    //    document.getElementById(strID + '-blocker').style.left = '-100%'; // <-- works on a phone
                    //    
                    //    this.hiddenIDs.push(strID);
                    //    
                    GS.triggerEvent(document.getElementById(strID), 'hide');
                    GS.triggerEvent(window, 'resize'); //, {'triggered': true});
                    //}
                } else {
                    this.setAttribute(strID, 'hide');
                }
            },
            
            'toggle': function (strID) {
                var element = document.getElementById(strID);
                
                if (element.hasAttribute('shown') || !element.hasAttribute('panel-hide')) {
                    this.hide(strID);
                } else {
                    this.show(strID);
                }
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet('Push Message', 'GS.pushMessage', 'pushMessage(\'${1:HTML}\', ${2:1500}, function () {${3}});');
});

GS.pushMessage = function (strHTML, intTime, callback) {
    var pushMessageElement, containerElement;
    
    // if there is no html to put in the pushmessage: throw an error
    if (strHTML === undefined) {
        throw 'GS.pushMessage Error: no HTML to display.';
    }
    
    // if there is no container: add it
    if (document.getElementsByTagName('gs-pushmessage-container').length === 0) {
        containerElement = document.createElement('gs-pushmessage-container');
        containerElement.setAttribute('gs-dynamic', '');
        document.body.appendChild(containerElement);
    } else {
        containerElement = document.getElementsByTagName('gs-pushmessage-container')[0];
    }
    
    // create the pushmessage
    pushMessageElement = document.createElement('gs-pushmessage');
    pushMessageElement.setAttribute('gs-dynamic', '');
    pushMessageElement.innerHTML = strHTML;
    
    // append the pushmessage to the container
    containerElement.appendChild(pushMessageElement);
    
    // if there is a callback: run it
    if (typeof callback === 'function') {
        callback.apply(pushMessageElement);
    }
    
    // if there is a time: set a timeout to close the message
    if (intTime) {
        setTimeout(function() {
            GS.closePushMessage(pushMessageElement);
        }, intTime);
    }
    
    // return the pushmessage
    return pushMessageElement;
};

window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet('GS.closePushMessage', 'GS.closePushMessage', 'GS.closePushMessage(${0:pushMessageElement});');
    registerDesignSnippet('Close Push Message',  'Close Push Message',  'GS.closePushMessage(${0:pushMessageElement});');
});

GS.closePushMessage = function (pushMessageElement) {
    var containerElement = document.getElementsByTagName('gs-pushmessage-container')[0];
    
    // fade the pushmessage out
    GS.animateStyle(pushMessageElement, 'opacity', '1', '0', function () {
        
        // if there is only one pushmessage element: remove the container
        if (document.getElementsByTagName('gs-pushmessage').length === 1) {
            document.body.removeChild(containerElement);
            
        // else: just remove the element
        } else {
            containerElement.removeChild(pushMessageElement);
        }
    }, 250, 100);
};


document.addEventListener('DOMContentLoaded', function () {
    xtag.register('gs-pushmessage', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
    
    xtag.register('gs-pushmessage-container', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
});
window.addEventListener('design-register-element', function () {
    registerDesignSnippet('<gs-search>', '<gs-search>', 'gs-search id="${1}"></gs-search>');

    designRegisterElement('gs-search', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-search.html');

    window.designElementProperty_GSSEARCH = function(selectedElement) {
        addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
        });

        //console.log(selectedElement.hasAttribute('mini'));

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var singleLineTemplateElement = document.createElement('template');
    var singleLineTemplate;

    singleLineTemplateElement.innerHTML = '<input class="control" gs-dynamic type="text" placeholder="Search..." />';
    singleLineTemplate = singleLineTemplateElement.content;

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        GS.triggerEvent(event.target.parentNode, 'change');
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
    }

    //function loadPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString();
    //    var strQSCol = element.getAttribute('qs') || element.getAttribute('id');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function loadPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol && strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }



    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.hasAttribute('tabindex')) {
                    element.oldTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }

                element.refresh();

                loadPushReplacePopHandler(element);
                window.addEventListener('pushstate',    function () { loadPushReplacePopHandler(element); });
                window.addEventListener('replacestate', function () { loadPushReplacePopHandler(element); });
                window.addEventListener('popstate',     function () { loadPushReplacePopHandler(element); });
            }
        }
    }

    xtag.register('gs-search', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            inserted: function () {
                elementInserted(this);
            },
            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'disabled') {
                        element.refresh();
                    } else if (strAttrName === 'value' && newValue !== oldValue) {
                        element.value = newValue;
                    }
                }
            }
        },
        events: {
            // on keydown and keyup sync the value attribute and the control value
            keydown: function (event) {
                if (!this.hasAttribute('readonly')) {
                    if (this.hasAttribute('disabled') && event.keyCode !== 9) {
                        event.preventDefault();
                        event.stopPropagation();
                    } else {
                        this.syncView();
                    }
                }
            },
            keyup: function () {
                if (!this.hasAttribute('readonly')) {
                    this.syncView();
                }
            },
            change: function () {
                var strQueryString = GS.getQueryString(), strColumn = (this.getAttribute('qs') || this.getAttribute('id'));
                
                if ((GS.qryGetVal(strQueryString, strColumn) || '') !== (this.control.value || '')) {
                    GS.pushQueryString(strColumn + '=' + encodeURIComponent(this.control.value));
                }
            }
        },
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    if (this.control) {
                        return this.control.value;
                    } else {
                        return this.innerHTML;
                    }
                },
                
                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    var element = this;
                    if (element.control) {
                        element.control.value = strNewValue;
                    } else {
                        element.innerHTML = strNewValue;
                    }
                    element.syncView();
                }
            }
        },
        methods: {
            focus: function () {
                if (this.control) {
                    this.control.focus();
                }
            },
            
            // adapt gs-input element to whatever control is in it and
            //      set the value of the control to the value attribute (if there is a value attribute) and
            //      resize the resize to text
            refresh: function () {
                var element = this;
                var arrPassThroughAttributes;
                var i;
                var len;

                element.innerHTML = '';
                element.appendChild(singleLineTemplate.cloneNode(true));
                if (element.oldTabIndex) {
                    xtag.query(element, '.control')[0].setAttribute('tabindex', element.oldTabIndex);
                }

                // set a variable with the control element for convenience and speed
                element.control = xtag.query(element, '.control')[0];

                element.control.removeEventListener('change', changeFunction);
                element.control.addEventListener('change', changeFunction);

                element.control.removeEventListener('focus', focusFunction);
                element.control.addEventListener('focus', focusFunction);

                // if there is a value already in the attributes of the element: set the control value
                if (element.hasAttribute('value')) {
                    element.control.value = element.getAttribute('value');
                }

                // copy passthrough attributes to control
                arrPassThroughAttributes = [
                    'placeholder', 'name', 'type', 'maxlength', 'autocorrect',
                    'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                    'readonly'
                ];
                for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                    if (element.hasAttribute(arrPassThroughAttributes[i])) {
                        element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
                    }
                }
            },

            // sync control value and resize to text
            syncView: function () {
                if (this.control) {
                    if (this.getAttribute('value') !== this.control.value) {
                        this.setAttribute('value', this.control.value);
                    }
                } else {
                    this.innerHTML = this.control.value;
                }
            }
        }
    });
});window.addEventListener('design-register-element', function () {
    registerDesignSnippet('<gs-select>', '<gs-select>', 'gs-select>\n' +
                                                        '    <option>${0}</option>\n' +
                                                        '</gs-select>');

    designRegisterElement('gs-select', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-select.html');

    window.designElementProperty_GSSELECT = function(selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))          { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop')) { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))  { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))   { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop')) { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))  { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))   { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var templateElement = document.createElement('template'), template;

    templateElement.innerHTML = '<select class="control" gs-dynamic></select>';
    template = templateElement.content;

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();
        
        GS.triggerEvent(event.target.parentNode, 'change');
        
        //return false;
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
    }

    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.value = strQSValue;
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            var strValue = element.value, observer;

            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (strValue) {
                element.setAttribute('value', strValue);
                delete element.value;
            }

            // #############################################################
            // ##################### MUTATION OBSERVER #####################
            // #############################################################

            // create an observer instance
            observer = new MutationObserver(function(mutations) {
                var bolRefreshOptionList = true;

                // check each mutation: if only option and optgroup tags were added: refersh option tags in select
                mutations.forEach(function(mutation) {
                    var i, len;
                    
                    for (i = 0, len = mutation.addedNodes.length; i < len; i += 1) {
                        if (mutation.addedNodes[i].nodeName !== 'OPTION' && mutation.addedNodes[i].nodeName !== 'OPTGROUP') {
                            bolRefreshOptionList = false;
                        }
                    }
                });

                if (bolRefreshOptionList) {
                    element.refreshOptionList();
                }
            });

            // pass in the element node, as well as the observer options
            observer.observe(element, {childList: true});
        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.hasAttribute('tabindex')) {
                    element.oldTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }

                element.refreshOptionList();

                //element.control.removeEventListener('change', changeFunction);
                element.control.addEventListener('change', changeFunction);

                //element.control.removeEventListener('focus', focusFunction);
                element.control.addEventListener('focus', focusFunction);

                // set the value from the value attribute (if it exists)
                if (element.getAttribute('value')) {
                    element.value = element.getAttribute('value');
                }

                //handle query-string
                if (element.getAttribute('qs')) {
                    //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}
                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                }
            }
        }
    }

    xtag.register('gs-select', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value' && newValue !== oldValue) {
                        this.value = newValue;
                    }
                }
            }
        },
        events: {
            'keydown': function (event) {
                var intKeyCode = (event.keyCode || event.which);

                if (this.hasAttribute('readonly') &&
                        (
                            (
                                intKeyCode !== 9 && // if not tab and CMD, CTRL and SHFT are not down: prevent default
                                !event.metaKey &&
                                !event.ctrlKey &&
                                !event.shiftKey
                            ) ||
                            intKeyCode === 32 // if it's space: definitely prevent default
                        )) {
                    event.preventDefault();
                }
            },
            'keyup': function (event) {
                var intKeyCode = (event.keyCode || event.which);

                if (this.hasAttribute('readonly') &&
                        (
                            (
                                intKeyCode !== 9 && // if not tab and CMD, CTRL and SHFT are not down: prevent default
                                !event.metaKey &&
                                !event.ctrlKey &&
                                !event.shiftKey
                            ) ||
                            intKeyCode === 32 // if it's space: definitely prevent default
                        )) {
                    event.preventDefault();
                }
            },
            'mousedown': function (event) {
                if (this.hasAttribute('readonly')) {
                    if (evt.touchDevice === false) {
                        this.control.focus();
                    }
                    event.preventDefault();
                }
            },
            'mouseup': function (event) {
                if (this.hasAttribute('readonly')) {
                    event.preventDefault();
                }
            }
        },
        accessors: {
            value: {
                get: function () {
                    if (this.control) {
                        return this.control.value;
                    } else if (this.getAttribute('value')) {
                        return this.getAttribute('value');
                    }
                    return undefined;
                },

                set: function (newValue) {
                    if (this.getAttribute('value') !== newValue) {
                        this.setAttribute('value', newValue);
                    }
                    this.control.value = newValue;
                }
            },
            textValue: {
                get: function () {
                    return this.control.options[this.control.selectedIndex].text;
                },

                set: function (newValue) {
                    this.setAttribute('value', newValue);
                    this.control.value = newValue;
                }
            }
        },
        methods: {
            focus: function () {
                this.control.focus();
            },

            refreshOptionList: function () {
                var i, len, elementsToMove, oldvalue, arrChildren, controlElement;

                //console.log('refreshOptionList');

                // remove invalid elements from immediate children
                arrChildren = this.children;

                for (i = arrChildren.length - 1; i > -1; i -= 1) {
                    //console.log(arrChildren[i]);
                    if (arrChildren[i].nodeName !== 'OPTION' &&
                        arrChildren[i].nodeName !== 'OPTGROUP' &&
                        arrChildren[i].nodeName !== 'SELECT' &&
                        arrChildren[i].classList.contains('control')) {
                        this.removeChild(arrChildren[i]);
                    }
                }

                // if there is already a control
                controlElement = xtag.queryChildren(this, '.control')[0];

                if (controlElement) { //this.control && this.control.parentNode) {
                    // save the old value
                    oldvalue = controlElement.value;

                    // save the old control
                    this.oldcontrol = controlElement;

                    // remove the control class from the old control so that when
                    //      we select for the new control we dont get the old control
                    controlElement.classList.remove('control');
                }

                // append new control
                this.appendChild(template.cloneNode(true));

                // set a variable with the new control element for convenience and speed
                this.control = xtag.query(this, '.control')[0];

                // if there is an old control: get the options and optgroups out of it and move them to the new control
                if (this.oldcontrol) {
                    elementsToMove = xtag.queryChildren(this.oldcontrol, 'option, optgroup');

                    for (i = 0, len = elementsToMove.length; i < len; i += 1) {
                        elementsToMove[i].setAttribute('gs-hidden', '');

                        this.control.appendChild(elementsToMove[i]);
                    }
                }

                // fill the control with all of the option and optgroup tags that are direct descendents of the gs-select
                elementsToMove = xtag.queryChildren(this, 'option, optgroup');

                for (i = 0, len = elementsToMove.length; i < len; i += 1) {
                    this.control.appendChild(elementsToMove[i]);
                }

                // if there was an old control
                if (this.oldcontrol) {
                    // this if statement prevents an error when the gs-select shares and ID with another element
                    if (this.oldcontrol.parentNode === this) {
                        // remove the old control if it is currently a child of the select
                        this.removeChild(this.oldcontrol);
                    }

                    // set the oldcontrol variable to undefined so that the next time this function is run we dont get the old control
                    this.oldcontrol = undefined;

                    // set the value back to the old value
                    //console.log(this.getAttribute('value'));
                    this.control.value = this.getAttribute('value') || oldvalue;

                } else if (this.hasAttribute('value')) {
                    //alert(this.getAttribute('value'));
                    this.control.value = this.getAttribute('value');
                }

                if (this.oldTabIndex) {
                    this.control.setAttribute('tabindex', this.oldTabIndex);
                }
            }
        }
    });
});//global window, GS, addProp, registerDesignSnippet, designRegisterElement, setOrRemoveTextAttribute, setOrRemoveBooleanAttribute, encodeHTML, addFlexContainerProps, addFlexProps

window.addEventListener('design-register-element', function () {

    registerDesignSnippet('<gs-static>', '<gs-static>', 'gs-static column="${1:name}"></gs-static>');

    designRegisterElement('gs-static', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-static.html');

    window.designElementProperty_GSSTATIC = function (selectedElement) {
        addProp('Formatted&nbsp;Text', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('pre')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'pre', (this.value === 'true'), true);
        });

        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Inline', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('inline')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'inline', (this.value === 'true'), true);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true,
                '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                '    <option value="">Visible</option>' +
                '    <option value="hidden">Invisible</option>' +
                '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                '    <option value="hide-on-phone">Invisible at phone size</option>' +
                '    <option value="show-on-desktop">Visible at desktop size</option>' +
                '    <option value="show-on-tablet">Visible at tablet size</option>' +
                '    <option value="show-on-phone">Visible at phone size</option>' +
                '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value && !element.hasAttribute('value')) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = null;
            }
        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                //var strQSValue;
                element.refresh();

                if (element.getAttribute('qs')) {
                    //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}
                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                }
            }
        }
    }
    
    xtag.register('gs-static', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    this.refresh();
                }
            }
        },
        events: {},
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    return this.getAttribute('value');
                },
                
                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    this.setAttribute('value', strNewValue);
                }
            }
        },
        methods: {
            refresh: function () {
                this.innerHTML = this.getAttribute('value');
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('<gs-sticky>', '<gs-sticky>', 'gs-sticky>\n' +
                                                        '    <gs-sticky-inner>\n' +
                                                        '        ${0}\n' +
                                                        '    </gs-sticky-inner>\n' +
                                                        '</gs-sticky>');
    
    designRegisterElement('gs-sticky', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-sticky.html');
    
    window.designElementProperty_GSSTICKY = function (selectedElement) {
        addProp('Direction', true,  '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('direction') || '') + '" mini>' +
                                        '<option value="">Up</option>' +
                                        '<option value="down">Down</option>' +
                                    '</gs-select>',
                                    function () {
            return setOrRemoveTextAttribute(selectedElement, 'direction', this.value);
        });
        
        addProp('Always Stuck', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('stuck') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'stuck', this.value === 'true', true);
        });
        
        addProp('Touch Devices Allowed', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('touch-device-allowed') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'touch-device-allowed', this.value === 'true', true);
        });
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop')) { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet')) { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone')) { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop')) { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet')) { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone')) { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    function stickHandler(element) {
        var bolTop = (element.getAttribute('direction') !== 'down'),
            intScrollPosition = document.body.scrollTop,
            jsnElementPositionData = GS.getElementPositionData(element),
            bolShouldBeStuck = (bolTop && jsnElementPositionData.intRoomAbove < 0) || (!bolTop && jsnElementPositionData.intRoomBelow < 0);
        
        if (bolShouldBeStuck && !element.hasAttribute('stuck')) {
            element.style.height = element.offsetHeight + 'px';
            element.setAttribute('stuck', '');
            
            //if (bolTop) {
            //    element.parentNode.style.paddingTop = element.offsetHeight + 'px';
            //} else {
            //    element.parentNode.style.paddingBottom = element.offsetHeight + 'px';
            //}
            
        } else if (!bolShouldBeStuck && element.hasAttribute('stuck')) {
            element.style.height = '';
            element.removeAttribute('stuck');
            //
            //if (bolTop) {
            //    element.parentNode.style.paddingTop = '';
            //} else {
            //    element.parentNode.style.paddingBottom = '';
            //}
        }
        
        //console.log(bolTop, intScrollPosition, jsnElementPositionData);
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            
        }
    }
    
    //
    function elementInserted(element) {
        var currentParent;
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
                if (element.children.length > 1) {
                    throw 'gs-sticky Error: Too many children. gs-sticky elements must have one child and it must be a <gs-sticky-inner> element.';
                    
                } else if (element.children.length === 0) {
                    throw 'gs-sticky Error: No children. gs-sticky elements must have one child and it must be a <gs-sticky-inner> element.';
                    
                } else if (element.children[0].nodeName !== 'GS-STICKY-INNER') {
                    throw 'gs-sticky Error: Invalid child. gs-sticky elements must have one child and it must be a <gs-sticky-inner> element.';
                }
                
                element.parentNode.style.height = 'auto';
                
                if (element.hasAttribute('stuck')) {
                    //console.log(element.children[0].offsetHeight, element.getAttribute('direction'));
                    if (element.getAttribute('direction') !== 'down') {
                        element.parentNode.style.paddingTop = element.children[0].offsetHeight + 'px';
                    } else {
                        element.parentNode.style.paddingBottom = element.children[0].offsetHeight + 'px';
                    }
                }
                
                if (!element.hasAttribute('stuck') && (!evt.touchDevice || element.hasAttribute('touch-device-allowed'))) {
                    stickHandler(element);
                    currentParent = element.parentNode;
                    if (currentParent.nodeName !== 'BODY') {
                        console.warn('gs-sticky Warning: Element not immediate child of BODY. This element was designed for being an immediate child of the BODY, doing otherwise may give unexpected results.');
                    }
                    
                    window.addEventListener('resize', function () {
                        if (element.parentNode === currentParent) {
                            stickHandler(element);
                        }
                    });
                    
                    window.addEventListener('scroll', function () {
                        if (element.parentNode === currentParent) {
                            stickHandler(element);
                        }
                    });
                    
                    window.addEventListener('orientationchange', function () {
                        if (element.parentNode === currentParent) {
                            stickHandler(element);
                        }
                    });
                }
            }
        }
    }
    
    xtag.register('gs-sticky-inner', {});
    xtag.register('gs-sticky', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    
                }
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});//global window, document, GS, ml, encodeHTML, addFlexContainerProps, addFlexProps, addProp, registerDesignSnippet, designRegisterElement, setOrRemoveTextAttribute, setOrRemoveBooleanAttribute, xtag, doT

window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet('<gs-switch>', '<gs-switch>', 'gs-switch>\n' +
                                                        '    <template for="${1:none}"></template>\n' +
                                                        '    <template for="${2:detail}"></template>\n' +
                                                        '</gs-switch>');

    designRegisterElement('gs-switch', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-switch.html');

    window.designElementProperty_GSSWITCH = function (selectedElement) {

        addProp('Template', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'template', this.value);
        });

        addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
            this.removeAttribute('refresh-on-querystring-change');
            return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
        });

        addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
            this.removeAttribute('refresh-on-querystring-values');
            return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
        });

        addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function subsafeTemplate(strTemplate) {
        var templateElement = document.createElement('template');
        var strID;
        var arrTemplates;
        var i;
        var len;
        var jsnTemplates;
        var strRet;
        var arrTemplateNames;

        templateElement.innerHTML = strTemplate;

        // temporarily remove templates. recursively go through templates whose parents do not have the source attribute
        i = 0;
        arrTemplates = xtag.query(templateElement.content, 'template');

        jsnTemplates = {};
        arrTemplateNames = [];

        while (arrTemplates.length > 0 && i < 100) {
            //console.log(arrTemplates[0]);
            //console.log(arrTemplates[0].parentNode);
            //console.log(arrTemplates[0].parentNode.hasAttribute('src'));

            // if the current template has a source parent: remove temporarily
            if (
                arrTemplates[0].parentNode &&
                arrTemplates[0].parentNode.hasAttribute &&
                (
                    arrTemplates[0].parentNode.hasAttribute('src') ||
                    arrTemplates[0].parentNode.hasAttribute('source')
                )
            ) {
                strID = 'UNIqUE_PLaCEhOLDER-' + GS.GUID() + '-UNiQUE_PLaCEhOLdER';
                jsnTemplates[strID] = arrTemplates[0].outerHTML;
                arrTemplates[0].outerHTML = strID;
                arrTemplateNames.push(strID);

            // else: add to the arrTemplates array
            } else if (arrTemplates[0].content) {
                arrTemplates.push.apply(arrTemplates, xtag.query(arrTemplates[0].content, 'template'));
            }

            // remove the current template from the arrTemplates array
            arrTemplates.splice(0, 1);

            i += 1;
        }

        strRet = doT.template(
            '{{##def.snippet:\n' +
                    '    {{ var qs = GS.qryToJSON(GS.getQueryString()); }} {{# def.template }}\n' +
                    '#}}\n' +
                    '{{#def.snippet}}',
            null,
            {"template": templateElement.innerHTML}
        )();

        i = 0;
        len = arrTemplateNames.length;
        //for (strID in jsnTemplates) {
        while (i < len) {
            // DO NOT DELETE THE REPLACE, it allows single dollar signs to be inside dot notation
            strRet = strRet.replace(
                new RegExp(arrTemplateNames[i], 'g'),
                jsnTemplates[arrTemplateNames[i]].replace(/\$/g, '$$$$')
            );
            i += 1;
        }

        return strRet;
    }

    //function pushReplacePopHandler(element) { //, eventName
    //    var i;
    //    var len;
    //    var arrPopKeys = [];
    //    var bolRefresh = false;
    //    var strQS = GS.getQueryString();
    //    var currentValue;
    //    var strQSCol = element.getAttribute('qs');

    //    //console.log(eventName);

    //    if (element.hasAttribute('refresh-on-querystring-values') || element.hasAttribute('qs')) {
    //        if (element.hasAttribute('refresh-on-querystring-values')) {
    //            arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
    //        }
    //        if (strQSCol && GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
    //            GS.listAdd(arrPopKeys, strQSCol);
    //        }

    //        //for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
    //        i = 0;
    //        len = arrPopKeys.length;
    //        while (i < len) {
    //            currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

    //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
    //                //console.log(arrPopKeys[i], element.popValues[arrPopKeys[i]], currentValue);
    //                bolRefresh = true;
    //            }

    //            element.popValues[arrPopKeys[i]] = currentValue;
    //            i += 1;
    //        }
    //    } else {
    //        bolRefresh = true;
    //    }

    //    if (bolRefresh) {
    //        element.refresh();
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh = false;
        var strOperator;

        if (strQSCol && strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        }

        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values') || element.hasAttribute('qs')) {
                if (element.getAttribute('refresh-on-querystring-values')) {
                    arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                } else {
                    arrPopKeys = [];
                }

                if (strQSCol) {
                    GS.listAdd(arrPopKeys, strQSCol);
                }

                i = 0;
                len = arrPopKeys.length;
                //for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                while (i < len) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }

                    element.popValues[arrPopKeys[i]] = currentValue;
                    i += 1;
                }
                
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            } else if (element.hasAttribute('template') || element.hasAttribute('value')) {
                bolRefresh = true;
            }

            if (bolRefresh) {
                element.refresh();
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                i = 0;
                len = arrPopKeys.length;
                //for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                while (i < len) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                    i += 1;
                }
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                // transfer 'value' attribute to 'template'
                if (element.hasAttribute('value')) {
                    element.setAttribute('template', element.getAttribute('value'));
                    console.warn('gs-switch Warning: "value" attribute is deprecated. Please use the "template" attribute to replace the "value" attribute.', element);
                }
                
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                // Get templates and define some variables
                var arrTemplate = xtag.queryChildren(element, 'template');
                var i;
                var len;
                var attr_i;
                var attr_len;
                var arrAttrNames;
                var arrAttrValues;
                var strAttrName;
                var root;
                var template;
                var arrPopKeys;
                var strQueryString;
                var strQSCol;

                element.attributesFromTemplate = [];
                element.templates = {};

                //for (i = 0, len = arrTemplate.length; i < len; i += 1) {
                i = 0;
                len = arrTemplate.length;
                while (i < len) {
                    if (i === 0) {
                        element.firstTemplate = arrTemplate[i].getAttribute('for') || arrTemplate[i].getAttribute('id');
                    }

                    arrAttrNames = [];
                    arrAttrValues = [];

                    attr_i = 0;
                    attr_len = arrTemplate[i].attributes.length;
                    //for (attr_i = 0, attr_len = arrTemplate[i].attributes.length; attr_i < attr_len; attr_i += 1) {
                    while (attr_i < attr_len) {
                        strAttrName = arrTemplate[i].attributes[attr_i].nodeName;

                        if (strAttrName !== 'for' && strAttrName !== 'id') {
                            arrAttrNames.push(strAttrName);
                            arrAttrValues.push(arrTemplate[i].attributes[attr_i].value);
                        }
                        attr_i += 1;
                    }

                    template = arrTemplate[i];
                    element.templates[template.getAttribute('for') || template.getAttribute('id')] = {
                        'content': template.innerHTML,
                        'arrAttrNames': arrAttrNames,
                        'arrAttrValues': arrAttrValues,
                        'templated': !(element.hasAttribute('static') || template.hasAttribute('static'))
                    };

                    i += 1;
                }

                // Clear out the templates from the DOM
                element.innerHTML = '';

                element.arrQueryStringAttributes = [];
                element.popValues = {};

                if (
                    (
                        element.hasAttribute('template') &&
                        element.getAttribute('template').indexOf('{{') > -1
                    ) ||
                    element.hasAttribute('qs') ||
                    element.hasAttribute('refresh-on-querystring-values') ||
                    element.hasAttribute('refresh-on-querystring-change')
                ) {
                    //arrPopKeys = [];
                    //strQueryString = GS.getQueryString();
                    //strQSCol = element.getAttribute('qs');

                    //if (element.hasAttribute('refresh-on-querystring-values')) {
                    //    arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                    //}
                    //if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
                    //    GS.listAdd(arrPopKeys, strQSCol);
                    //}

                    //i = 0;
                    //len = arrPopKeys.length;
                    ////for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    //while (i < len) {
                    //    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQueryString, arrPopKeys[i]);
                    //    i += 1;
                    //}
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate', function () {
                        pushReplacePopHandler(element);
                    });
                    window.addEventListener('replacestate', function () {
                        pushReplacePopHandler(element);
                    });
                    window.addEventListener('popstate', function () {
                        pushReplacePopHandler(element);
                    });
                }

                element.refresh();
            }
        }
    }

    xtag.register('gs-switch', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value') { // && oldValue !== newValue
                        //element.refresh();
                        element.setAttribute('template', newValue);
                        console.warn('gs-switch Warning: "value" attribute is deprecated. Please use the "template" attribute to replace the "value" attribute.', element);

                    } else if (strAttrName === 'template' && element.inserted === true) {
                        element.refresh();
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    var element = this;
                    console.warn('gs-switch Warning: \'.value\' accessor is deprecated. Please use the \'.template\' accessor to replace the \'.value\' accessor.', element);
                    return element.getAttribute('template');
                },
                set: function (newValue) {
                    var element = this;
                    console.warn('gs-switch Warning: \'.value\' accessor is deprecated. Please use the \'.template\' accessor to replace the \'.value\' accessor.', element);
                    element.setAttribute('template', newValue);
                }
            },
            template: {
                get: function () {
                    return this.getAttribute('template');
                },
                set: function (newValue) {
                    this.setAttribute('template', newValue);
                }
            }
        },
        methods: {
            refresh: function () {
                var element = this;
                var strQueryString = GS.getQueryString();
                var strQSAttribute = element.getAttribute('qs');
                var strValueAttribute = element.getAttribute('template') || element.getAttribute('value');
                var templateName;
                var i;
                var len;

                if (strQSAttribute && GS.qryGetVal(strQueryString, strQSAttribute)) {
                    templateName = GS.qryGetVal(strQueryString, strQSAttribute);
                } else if (strValueAttribute) {
                    templateName = GS.templateWithQuerystring(strValueAttribute);
                }

                templateName = templateName || element.firstTemplate;

                if (element.templates[templateName] && element.templates[templateName].content) {
                    // if there are values in element.attributesFromTemplate
                    if (element.attributesFromTemplate.length > 0) {
                        // loop through them
                        i = 0;
                        len = element.attributesFromTemplate.length;
                        //for (i = 0, len = element.attributesFromTemplate.length; i < len; i += 1) {
                        while (i < len) {
                            // if attribute was initallySet: set it back to initalvalue
                            if (element.attributesFromTemplate[i].initallySet) {
                                element.setAttribute(element.attributesFromTemplate[i].name, element.attributesFromTemplate[i].initalValue);

                            // else: remove it
                            } else {
                                element.removeAttribute(element.attributesFromTemplate[i].name);
                            }
                            i += 1;
                        }
                    }

                    // clear element.attributesFromTemplate
                    element.attributesFromTemplate = [];

                    // if there are values in element.templates[templateName].arrAttrNames
                    if (element.templates[templateName].arrAttrNames.length > 0) {
                        // loop through them
                        i = 0;
                        len = element.templates[templateName].arrAttrNames.length;
                        //for (i = 0, len = element.templates[templateName].arrAttrNames.length; i < len; i += 1) {
                        while (i < len) {
                            // add to element.attributesFromTemplate
                            element.attributesFromTemplate.push({
                                'name': element.templates[templateName].arrAttrNames[i],
                                'initallySet': element.hasAttribute(element.templates[templateName].arrAttrNames[i]),
                                'initalValue': element.getAttribute(element.templates[templateName].arrAttrNames[i])
                            });

                            // set attribute
                            element.setAttribute(element.templates[templateName].arrAttrNames[i], GS.templateWithQuerystring(this.templates[templateName].arrAttrValues[i]));
                            i += 1;
                        }
                    }

                    if (element.templates[templateName].templated) {
                        element.innerHTML = subsafeTemplate(element.templates[templateName].content);
                    } else {
                        element.innerHTML = element.templates[templateName].content;
                    }

                    // if template is not native: handle templates inside the switch
                    if (shimmed.HTMLTemplateElement) {
                        window.HTMLTemplateElement.bootstrap(element);
                    }
                    //console.trace('trace this');
                    GS.triggerEvent(element, 'templatechange', {'templateName': templateName});
                    GS.triggerEvent(element, 'template_change', {'templateName': templateName});
                } else {
                    element.innerHTML = '';
                }
            }
        }
    });
});//global GS, window, document, registerDesignSnippet, designRegisterElement, addProp, encodeHTML, setOrRemoveTextAttribute, setOrRemoveBooleanAttribute, addFlexProps

window.addEventListener('design-register-element', function () {

    registerDesignSnippet('<gs-text>', '<gs-text>', 'gs-text column="${1:name}"></gs-text>');
    registerDesignSnippet('<gs-text> With Label', '<gs-text>',
            'label for="${1:text-insert-last_name}">${2:Last Name}:</label>\n' +
            '<gs-text id="${1:text-insert-last_name}" column="${3:last_name}"></gs-text>');

    designRegisterElement('gs-text', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-text.html');

    window.designElementProperty_GSTEXT = function (selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
        });

        //console.log(selectedElement.hasAttribute('mini'));

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true,
                '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                '    <option value="">Visible</option>' +
                '    <option value="hidden">Invisible</option>' +
                '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                '    <option value="hide-on-phone">Invisible at phone size</option>' +
                '    <option value="show-on-desktop">Visible at desktop size</option>' +
                '    <option value="show-on-tablet">Visible at tablet size</option>' +
                '    <option value="show-on-phone">Visible at phone size</option>' +
                '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();

        event.target.parentNode.syncGetters();//iphone sometimes doesn't do a key like with time wheels

        GS.triggerEvent(event.target.parentNode, 'change');

        return false;
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
    }

    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.value = strQSValue;
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = null;
            }
        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                //var strQSValue;

                // handle control
                element.handleContents();

                // fill control
                element.syncView();

                // bind/handle query string
                if (element.getAttribute('qs')) {
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));

                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}
                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate', function () {
                        createPushReplacePopHandler(element);
                    });
                    window.addEventListener('replacestate', function () {
                        createPushReplacePopHandler(element);
                    });
                    window.addEventListener('popstate', function () {
                        createPushReplacePopHandler(element);
                    });
                }

                // if this element is empty when it is inserted: initalize
                if (element.innerHTML.trim() === '') {
                    // handle control
                    element.handleContents();

                    // fill control
                    element.syncView();
                }
            }
        }
    }

    xtag.register('gs-text', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    var currentValue;

                    if (strAttrName === 'disabled' || strAttrName === 'readonly') {
                        // handle control
                        element.handleContents();

                        // fill control
                        element.syncView();

                    } else if (strAttrName === 'value' && element.initalized) {
                        //if (element.hasAttribute('disabled')) {
                        //    currentValue = element.innerHTML;
                        //} else {
                            currentValue = element.control.value;
                        //}

                        // if there is a difference between the new value in the
                        //      attribute and the valued in the front end: refresh the front end
                        if (newValue !== currentValue) {
                            element.syncView();
                        }
                    }
                }
            }
        },
        events: {
            // on keydown and keyup sync the value attribute and the control value
            'keydown': function (event) {
                var element = this;
                if (!element.hasAttribute('readonly') && !element.hasAttribute('disabled')) {
                    //if (element.hasAttribute('disabled') && event.keyCode !== 9) {
                    //    event.preventDefault();
                    //    event.stopPropagation();
                    //} else {
                        element.syncGetters();
                    //}
                }
            },
            'keyup': function () {
                var element = this;
                if (!element.hasAttribute('readonly') && !element.hasAttribute('disabled')) {
                    element.syncGetters();
                }
            }
        },
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    return this.getAttribute('value');
                },

                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    this.setAttribute('value', strNewValue);
                }
            }
        },
        methods: {
            focus: function () {
                var element = this;
                if (element.control) {
                    element.control.focus();
                }
            },

            handleContents: function () {
                var element = this;
                var arrPassThroughAttributes = [
                        'placeholder', 'name', 'maxlength', 'autocorrect',
                        'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                        'readonly', 'disabled'
                    ];
                var i;
                var len;

                // if the gs-text element has a tabindex: save the tabindex and remov the attribute
                if (element.hasAttribute('tabindex')) {
                    element.savedTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }

                // if the gs-text doesn't have a disabled attribute: use an input element
                // if (!element.hasAttribute('disabled')) {
                    // add control input and save it to a variable for later use
                    element.innerHTML = '<input class="control" gs-dynamic type="' + (element.getAttribute('type') || 'text') + '" />';
                    element.control = element.children[0];

                    // bind event re-targeting functions
                    element.control.removeEventListener('change', changeFunction);
                    element.control.addEventListener('change', changeFunction);

                    element.control.removeEventListener('focus', focusFunction);
                    element.control.addEventListener('focus', focusFunction);

                    element.control.removeEventListener('blur', blurFunction);
                    element.control.addEventListener('blur', blurFunction);

                    // copy passthrough attributes to control
                    i = 0;
                    len = arrPassThroughAttributes.length;
                    while (i < len) {
                        if (element.hasAttribute(arrPassThroughAttributes[i])) {
                            if (arrPassThroughAttributes[i] === 'disabled') {
                                element.control.setAttribute(
                                    'readonly',
                                    element.getAttribute(arrPassThroughAttributes[i]) || ''
                                );
                            } else {
                                element.control.setAttribute(
                                    arrPassThroughAttributes[i],
                                    element.getAttribute(arrPassThroughAttributes[i]) || ''
                                );
                            }
                        }
                        i += 1;
                    }

                    // if we saved a tabindex: apply the tabindex to the control
                    if (element.savedTabIndex !== undefined && element.savedTabIndex !== null) {
                        element.control.setAttribute('tabindex', element.savedTabIndex);
                    }

                // else if the gs-text is disabled: clear the control variable and empty the gs-text
                // } else {
                //     element.control = undefined;
                //     element.innerHTML = '';
                // }
            },

            syncView: function () {
                var element = this;
                //if (element.hasAttribute('disabled')) {
                //    element.textContent = element.getAttribute('value') || element.getAttribute('placeholder');
                //} else {
                    element.control.value = element.getAttribute('value') || '';
                //}
                element.initalized = true;
            },

            syncGetters: function () {
                this.setAttribute('value', this.control.value);
            }
        }
    });
});window.addEventListener('design-register-element', function () {

    registerDesignSnippet('<gs-time>', '<gs-time>', 'gs-time column="${1:name}"></gs-time>');
    registerDesignSnippet('<gs-time> With Label', '<gs-time>', 'label for="${1:time-insert-start_time}">${2:Start Time}:</label>\n' +
                                                               '<gs-time id="${1:time-insert-start_time}" column="${3:start_time}"></gs-time>');

    designRegisterElement('gs-time', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-time.html');

    window.designElementProperty_GSTIME = function(selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        addProp('Time Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-picker')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-picker', (this.value === 'true'), false);
        });

        addProp('Non-Empty', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('non-empty')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'non-empty', (this.value === 'true'), true);
        });

        addProp('Now Button', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-now-button')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-now-button', (this.value === 'true'), false);
        });

        addProp('Display Format', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('format') || '') + '" mini>' +
                                    '<option value="">Regular (1:30 PM)</option>' +
                                    '<option value="military">Military (13:30)</option>' +
                                '</gs-select>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'format', this.value);
        });

        addProp('Output Format', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('output-format') || '') + '" mini>' +
                                    '<option value="">Regular (1:30 PM)</option>' +
                                    '<option value="military">Military (13:30)</option>' +
                                '</gs-select>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'output-format', this.value);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });

        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var currentErrorControl;

    window.addEventListener('focus', function (event) {
        if (currentErrorControl && event.target !== currentErrorControl.control) {
            currentErrorControl.control.focus();
            if (currentErrorControl.control) {
                GS.setInputSelection(currentErrorControl.control, 0, currentErrorControl.control.value.length);
            }
        }

        if (currentErrorControl && currentErrorControl.control && currentErrorControl.control.value) {
            currentErrorControl = '';
        }
    });

    //x attributes:
    //x      placeholder:   copy to control element
    //x      disabled:      copy to control element
    //x      tabindex:      move to control element
    //x      qs:            fill value from querystring, update value as querystring changes
    //x      non-empty:     prevent leaving the field if value is empty, console warn if value starts as empty
    //x      format:        affects value translation when filling control
    //x      no-now-button: affects dropdown html and "n" key
    //x      value:         affects control value
    //x      no-picker:     affects innerHTML because it removes the picker button

    //x accessors:
    //x      value:     returns text value
    //x      dateValue: returns value as a date object
    //x      state:     returns text representation of state: "open" or "closed"

    //x methods:
    //x      open:   opens popup
    //x      close:  closes popup
    //x      toggle: toggles open and closed methods

    //x events:
    //x      picker button click: runs "toggle" method
    //x      control keydown:
    //x          up arrow:    next minute
    //x          down arrow:  previous minute
    //x          left arrow:  previous minute
    //x          right arrow: next minute
    //x          "c":         clear (if allowed)
    //x          "n":         now (if allowed)

    //x dropdown behaviours:
    //x      if from control to bottom is too small and from control to top is too small: dialog
    //x      else if window width < 400px: dialog
    //x      else if window height < 550px: dialog
    //x      else:
    //x          if from control to bottom has enough room: popup below
    //x          else: popup above

    // #####################################################################################
    // ################################## EVENT RETARGETING ################################
    // #####################################################################################

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        event.target.parentNode.setAttribute('value', event.target.value);
        //console.log('this is a test', event.target);
        handleChange(event.target.parentNode);
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
    }


    // #####################################################################################
    // ####################################### CONTROL #####################################
    // #####################################################################################

    function refreshControl(element) {
        var i, len, arrPassThroughAttributes, strHTML;

        // clear out HTML
        element.innerHTML = '';

        // clear out element variables
        element.control = '';
        element.button = '';

        // if we are not disabled:
        if (!element.hasAttribute('disabled')) {
            // build HTML
            strHTML = '<input class="control" gs-dynamic type="text" />';
            if (!element.hasAttribute('no-picker')) {
                strHTML += '<gs-button class="time-picker-button" gs-dynamic inline icononly icon="clock-o" no-focus></gs-button>';
            }

            // set control HTML
            element.innerHTML = strHTML;

            // fill element variables
            element.control = element.children[0];
            element.button = element.children[1];

            // handle passthrough attributes
            arrPassThroughAttributes = [
                'placeholder', 'name', 'maxlength', 'autocorrect',
                'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                'readonly'
            ];

            i = 0;
            len = arrPassThroughAttributes.length;
            while (i < len) {
                if (element.hasAttribute(arrPassThroughAttributes[i])) {
                    element.control.setAttribute(
                        arrPassThroughAttributes[i],
                        element.getAttribute(arrPassThroughAttributes[i]) || ''
                    );
                }
                i += 1;
            }

            // move tabindex
            if (element.hasAttribute('tabindex')) {
                element.oldTabIndex = element.getAttribute('tabindex');
                element.removeAttribute('tabindex');
            }

            if (element.oldTabIndex) {
                element.control.tabIndex = element.oldTabIndex;
            }

            // bind control retargeting
            element.control.removeEventListener('change', changeFunction);
            element.control.addEventListener('change', changeFunction);

            element.control.removeEventListener('focus', focusFunction);
            element.control.addEventListener('focus', focusFunction);
        }

        // display value
        setValueDisplay(element, element.getAttribute('value'));
    }

    function handleChange(element) {
        element.close();
        if (handleNonEmpty(element) && element.lastChangeValue !== element.getAttribute('value')) {
            GS.triggerEvent(element, 'change');
            element.lastChangeValue = element.getAttribute('value');
        }
    }

    function handleNonEmpty(element) {
        var bolAllClear = true;

        if (element.hasAttribute('non-empty') && !element.getAttribute('value')) {
            bolAllClear = false;
            currentErrorControl = element;
            alert('Error: Invalid Time. Please input a time.');
            element.open();
        }

        return bolAllClear;
    }


    // #####################################################################################
    // ######################################## VALUE ######################################
    // #####################################################################################

    // translate inputed value to a format that is allowed. no seconds as of yet, defaults to AM
    function translateValue(strFormat, newValue) {
        var translatedValue;
        var valueDate;
        var strHour;
        var strMinute;
        var strPeriod;
        var arrParts;
        var intHours;

        // coalesce value
        newValue = newValue || '';

        // if value is a string: parse
        if (typeof newValue === 'string') {
            // input types:
            //      "1530"          => "15:30"
            //      "0330"          => "03:30"
            //      "3:30"          => "3:30"
            //      "3:30PM"        => "3:30 PM" (all cases/variations of PM/AM) ('a', 'p', 'am', 'pm', 'Am', 'Pm', 'AM', 'PM')
            //      "330"           => "3:30"
            //      "3"             => "3:00"
            //      "12"            => "12:00"
            //      "12PM"          => "12:00 PM" (all cases/variations of PM/AM) ('a', 'p', 'am', 'pm', 'Am', 'Pm', 'AM', 'PM')
            //      "12:30:12 PM"   => "12:30 PM" (no seconds as of yet)
            //      "123012"        => "12:30" (no seconds as of yet)

            // extract period
            strPeriod = (newValue.match(/pm|am|a|p/gi) || [''])[0].toLowerCase();
            newValue  = newValue.replace(/[^0-9:]/gi, '');

            if (strPeriod) {
                strPeriod = (strPeriod[0] === 'a' ? 'AM' : 'PM');
            }

            if (newValue) {
                // if there are colon(s): split on colons
                if ((/:/).test(newValue)) {
                    arrParts = newValue.split(':');

                    strHour = arrParts[0];
                    strMinute = GS.leftPad(arrParts[1], '0', 2);

                    // if hour is greater than 12: subtract 12 and set period to PM
                    if (parseInt(strHour, 10) > 12) {
                        strHour = parseInt(strHour, 10) - 12;
                        strPeriod = 'PM';
                    }

                // else (if there are just numbers)
                } else {
                    newValue = newValue.substring(0, 4);

                    // if the new value is 3 or 4 characters long: last 2 are minute and the rest is hour
                    if (newValue.length >= 3) {
                        strMinute = newValue.substring(newValue.length - 2);
                        strHour = newValue.substring(0, newValue.length - 2);

                        // if hour is greater than 12: subtract 12 and set period to PM
                        if (parseInt(strHour, 10) > 12) {
                            strHour = parseInt(strHour, 10) - 12;
                            strPeriod = 'PM';
                        }

                    // else:
                    } else {
                        newValue = parseInt(newValue, 10);

                        // if (format is military AND number > 24) OR (format isn't military AND number > 12): newValue is minute
                        if ((strFormat === 'military') && newValue > 24 || (strFormat !== 'military') && newValue > 12) {
                            strHour = '12';
                            strMinute = String(newValue);
                        } else {
                            strHour = String(newValue);
                            strMinute = '00';
                        }
                    }
                }
            }

            if (strHour && strMinute) {
                if (!strPeriod) {
                    if (parseInt(strHour, 10) < 6 || parseInt(strHour, 10) === 12) {
                        strPeriod = 'PM';
                    } else {
                        strPeriod = 'AM';
                    }
                }
                valueDate = new Date('1/1/1111 ' + strHour + ':' + strMinute + ' ' + strPeriod);
            }
        // else: just copy date object
        } else {
            valueDate = new Date(newValue);
        }

        //console.log(strHour, strMinute, strPeriod);

        // if we have enough data to make a value
        if (valueDate) {
            // output types:
            //      regular time:  "3:30 PM"
            //      military time: "15:30"

            if (strFormat === 'military') {
                translatedValue = GS.leftPad(valueDate.getHours(), '0', 2) + ':' +
                                  GS.leftPad(valueDate.getMinutes(), '0', 2);
            } else {
                intHours = valueDate.getHours();

                if (intHours >= 12) {
                    intHours = intHours - 12;
                }
                if (intHours === 0) {
                    intHours = 12;
                }

                translatedValue = intHours + ':' +
                                  GS.leftPad(valueDate.getMinutes(), '0', 2) + ' ' +
                                  (valueDate.getHours() >= 12 ? 'PM' : 'AM');
            }
        } else {
            translatedValue = '';
        }

        return translatedValue;
    }

    function setValueDisplay(element, newValue) {
        var translatedOutputValue = translateValue((element.getAttribute('output-format') === 'military' ? 'military' : 'regular'), newValue);
        var translatedDisplayValue = translateValue((element.getAttribute('format') === 'military' ? 'military' : 'regular'), newValue);

        element.setAttribute('value', translatedOutputValue);

        if (!element.hasAttribute('disabled')) {
            element.control.value = translatedDisplayValue;
        } else {
            element.textContent = translatedDisplayValue || element.getAttribute('placeholder') || '';
        }

        if (element.innerState === 'open') {
            refreshPickerValue(element);
        }
    }

    function refreshPickerValue(element) {
        var arrElements;
        var strTranslatedValue;
        var dteTranslatedValue;
        var i;
        var len;
        var intHours;

        if (element.innerState === 'open') {
            strTranslatedValue = translateValue((element.getAttribute('format') === 'military' ? 'military' : 'regular'), element.getAttribute('value'));
            dteTranslatedValue = new Date('1/1/1111 ' + strTranslatedValue);

            element.pickerModalControlElement.setAttribute('value', strTranslatedValue);

            arrElements = xtag.query(element.pickerContainerElement, '.selected');

            i = 0;
            len = arrElements.length;
            while (i < len) {
                arrElements[i].classList.remove('selected');
                i += 1;
            }


            intHours = dteTranslatedValue.getHours();

            if (intHours >= 12) {
                intHours = intHours - 12;
            }
            if (intHours === 0) {
                intHours = 12;
            }

            xtag.query(element.pickerContainerElement,
                '.clock-hour[data-value="' + intHours + '"]')[0].classList.add('selected');
            xtag.query(element.pickerContainerElement,
                '.clock-minute[data-value="' + (Math.floor(dteTranslatedValue.getMinutes() / 5) * 5) + '"]')[0].classList.add('selected');
            xtag.query(element.pickerContainerElement,
                '.clock-period-switch.' + (dteTranslatedValue.getHours() >= 12 ? 'pm' : 'am'))[0].classList.add('selected');
        }
    }


    // #####################################################################################
    // ##################################### QUERYSTRING ###################################
    // #####################################################################################

    function handleQS(element) {
        var strQSValue;

        if (!element.qsEventFunction) {
            element.qsEventFunction = function () {
                pushReplacePopHandler(element);
            };
        }

        window.removeEventListener('pushstate',    element.qsEventFunction);
        window.removeEventListener('replacestate', element.qsEventFunction);
        window.removeEventListener('popstate',     element.qsEventFunction);

        // handle "qs" attribute
        if (element.getAttribute('qs')) {
            //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));

            //if (strQSValue !== '' || !element.getAttribute('value')) {
            //    element.setAttribute('value', strQSValue);
            //}
            pushReplacePopHandler(element);
            window.addEventListener('pushstate',    element.qsEventFunction);
            window.addEventListener('replacestate', element.qsEventFunction);
            window.addEventListener('popstate',     element.qsEventFunction);
        }
    }


    //function pushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString();
    //    var strQSCol = element.getAttribute('qs');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
    //    }
    //}

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }


    // #####################################################################################
    // ###################################### LIFECYCLE ####################################
    // #####################################################################################

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
            }
        }
    }

    //
    function elementInserted(element) {
        var now;
        var strQSValue;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.innerState = 'closed';
                element.internal = {};
                saveDefaultAttributes(element);

                // if value attribute = now: set value attribute to the current time
                if (element.getAttribute('value') === 'now') {
                    now = new Date();

                    if (now.getHours() > 12) {
                        now = GS.leftPad(now.getHours() - 12, '0', 2) + ':' + GS.leftPad(now.getMinutes(), '0', 2) + ' PM';
                    } else {
                        now = GS.leftPad(now.getHours(), '0', 2) + ':' + GS.leftPad(now.getMinutes(), '0', 2) + ' AM';
                    }

                    element.setAttribute('value', now);
                }

                element.inserted = true;

                refreshControl(element);

                if (element.getAttribute('qs')) {
                    handleQS(element);
                }

                element.lastChangeValue = element.getAttribute('value');

                if (element.hasAttribute('non-empty') && !element.getAttribute('value')) {
                    console.warn('gs-time Warning: No value provided on "non-empty" gs-time control. Defaulting to "12:00 PM". Please provide a default value.');
                    element.setAttribute('value', '12:00 PM');
                }
            }
        }
    }


    // ######################################################################################
    // ##################################### REGISTRATION ###################################
    // ######################################################################################

    xtag.register('gs-time', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'placeholder' ||
                        strAttrName === 'disabled' ||
                        strAttrName === 'format' ||
                        strAttrName === 'no-picker' ||
                        strAttrName === 'tabindex') {
                        refreshControl(element);

                    } else if (strAttrName === 'qs') {
                        handleQS(element);

                    } else if (strAttrName === 'value' && element.inserted) {// && this.control
                        setValueDisplay(element, newValue);
                    }
                }
            }
        },
        events: {
            'click': function (event) {
                var element = this;
                if (event.target === element.button) {
                    element.toggle();
                }
            },
            'keydown:': function (event) {
                var element = this;
                var intKeyCode = (event.keyCode || event.which);
                var newControlValue;

                if (!element.hasAttribute('no-keys') && !element.hasAttribute('readonly')) {
                    if (element.getAttribute('value') && (intKeyCode === 38 || intKeyCode === 39 || intKeyCode === 40 || intKeyCode === 37)) {
                        newControlValue = new Date('1/1/1111 ' + element.getAttribute('value'));
                        event.preventDefault();
                        event.stopPropagation();

                        // up arrow:    next minute
                        // right arrow: next minute
                        if (intKeyCode === 38 || intKeyCode === 39) {
                            newControlValue = newControlValue.setMinutes(newControlValue.getMinutes() + 1);

                        // down arrow: previous minute
                        // left arrow: previous minute
                        } else if (intKeyCode === 40 || intKeyCode === 37) {
                            newControlValue = newControlValue.setMinutes(newControlValue.getMinutes() - 1);
                        }
                    }

                    // "c": clear (if allowed)
                    if (intKeyCode === 67 && !event.ctrlKey && !event.metaKey && !element.hasAttribute('non-empty')) {
                        newControlValue = '';
                        event.preventDefault();
                        event.stopPropagation();

                    // "n": now (if allowed)
                    } else if (intKeyCode === 78 && !event.ctrlKey && !event.metaKey && !element.hasAttribute('no-now-button')) {
                        newControlValue = new Date();
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    if (newControlValue !== undefined) {
                        setValueDisplay(element, newControlValue);
                        GS.setInputSelection(element.control, 0, element.control.value.length);
                    }

                    if (intKeyCode === 13) {
                        handleNonEmpty(element);
                    }
                }
            },
            'focusout': function (event) {
                var element = this;
                if (element.innerState === 'open') {
                    element.close();
                } else {
                    handleChange(element);
                }
            }
        },
        accessors: {
            value: {
                get: function () {
                    // return this.getAttribute('value');
                    if (this.getAttribute('value').trim() === '') {
                        return 'NULL';
                    } else {
                        return this.getAttribute('value');
                    }
                },
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                }
            },
            dateValue: {
                get: function () {
                    return new Date('1/1/1111 ' + this.getAttribute('value'));
                },
                set: function (newValue) {
                    setValueDisplay(this, newValue);
                }
            },
            state: {
                get: function () {
                    return this.innerState;
                },
                set: function (newValue) {
                    var element = this;
                    if (newValue === 'open') {
                        element.open();
                    } else {
                        element.close();
                    }
                }
            }
        },
        methods: {
            focus: function () {
                this.control.focus();
            },

            open: function () {
                var element = this;
                var pickerContainerElement;
                var overlayElement;
                var pickerElement;
                var handleLook;
                var strHTML;

                if (element.innerState === 'closed') {
                    element.innerState = 'open';
                    element.lastClosedValue = element.getAttribute('value');

                    // if we are not on a touch device: focus control
                    if (!evt.touchDevice) {
                        element.control.focus();
                        GS.setInputSelection(element.control, 0, element.control.value.length);

                    } else {
                        //this.control.focus()
                        //this.control.blur();
                    }

                    // create picker elements
                    pickerContainerElement = document.createElement('div');
                    pickerContainerElement.classList.add('gs-time-time-picker-container');

                    overlayElement = document.createElement('div');
                    overlayElement.classList.add('gs-time-time-picker-overlay');

                    pickerElement = document.createElement('div');
                    pickerElement.classList.add('gs-time-time-picker');

                    // save picker container
                    element.pickerContainerElement = pickerContainerElement;

                    // append picker elements
                    pickerContainerElement.appendChild(overlayElement);
                    pickerContainerElement.appendChild(pickerElement);

                    document.body.appendChild(pickerContainerElement);

                    // fill picker popup
                    strHTML = ml(function () {/*
                        <div class="time-modal-control-container" flex-horizontal>
                            <gs-text class="time-modal-control" flex></gs-text>
                            <gs-button class="modal-done">Done</gs-button>
                        </div>
                        <div class="time-inner-container">
                            <div class="time-top-toolbar">
                                <div flex-horizontal align-bottom>
                                    <gs-button class="decrement-time" icononly icon="arrow-left"></gs-button>
                                    <div flex></div>
                                    <gs-button class="increment-time" icononly icon="arrow-right"></gs-button>
                                </div>
                            </div>
                            <div class="gs-time-clock-container" prevent-text-selection>
                                <div class="gs-time-bezel">
                                    <div class="clock-face-layer layer-1">
                                        <div class="clock-line" style="top: 0%;"><div class="clock-button clock-hour" data-value="12"><span class="content">12</span></div></div><div class="clock-line" style="top: 5.9%;"><div class="clock-split" style="width: 45.25%;
left: 4.5%;"><div class="clock-button clock-hour" data-value="11"><span class="content">11</span></div></div><div class="clock-split" style="width: 45.25%;
left: 46.75%;"><div class="clock-button clock-hour" data-value="1">&nbsp;<span class="content">1</span></div></div></div><div class="clock-line" style="top: 22.5%;"><div class="clock-split" style="width: 22%;
left: 0%;"><div class="clock-button clock-hour" data-value="10"><span class="content">10</span></div></div><div class="clock-split" style="width: 22%;
left: 78%;"><div class="clock-button clock-hour" data-value="2">&nbsp;<span class="content">2</span></div></div></div><div class="clock-line" style="top: 45.3%;"><div class="clock-split" style="width: 14%;
left: 0%;"><div class="clock-button clock-hour" data-value="9"><span class="content">9</span>&nbsp;</div></div><div class="clock-split" style="width: 14%;
left: 86%;"><div class="clock-button clock-hour" data-value="3">&nbsp;<span class="content">3</span></div></div></div><div class="clock-line" style="top: 67.8%;"><div class="clock-split" style="width: 22%;
left: 0%;"><div class="clock-button clock-hour" data-value="8"><span class="content">8</span>&nbsp;</div></div><div class="clock-split" style="width: 22%;
left: 78%"><div class="clock-button clock-hour" data-value="4">&nbsp;<span class="content">4</span></div></div></div><div class="clock-line" style="top: 83.5%;"><div class="clock-split" style="width: 45.25%;
left: 4.5%;"><div class="clock-button clock-hour" data-value="7"><span class="content">7</span>&nbsp;</div></div><div class="clock-split" style="width: 45.25%;
left: 46.75%;"><div class="clock-button clock-hour" data-value="5">&nbsp;<span class="content">5</span></div></div></div><div class="clock-line" style="top: 90%;"><div class="clock-button clock-hour" data-value="6"><span class="content">6</span></div></div>
                                    </div>
                                    <div class="clock-face-layer layer-2">
                                        <div class="clock-line" style="top: 0%;"><div class="clock-button clock-minute" data-value="0"><span class="content">00</span></div></div>
                                        <div class="clock-line" style="top: 5.9%;"><div class="clock-split" style="width: 45.25%;
left: 4.5%;"><div class="clock-button clock-minute" data-value="55"><span class="content">55</span></div></div><div class="clock-split" style="width: 45.25%;
left: 49.75%;"><div class="clock-button clock-minute" data-value="5"><span class="content">05</span></div></div></div>
                                        <div class="clock-line" style="top: 22.5%;"><div class="clock-split" style="width: 22%;
left: 0%;"><div class="clock-button clock-minute" data-value="50"><span class="content">50</span></div></div><div class="clock-split" style="width: 22%;
left: 78%;"><div class="clock-button clock-minute" data-value="10"><span class="content">10</span></div></div></div>
                                        <div class="clock-line" style="top: 45.3%;"><div class="clock-split" style="width: 16%;
left: 0%;"><div class="clock-button clock-minute" data-value="45"><span class="content">45</span></div></div><div class="clock-split" style="width: 16%;
left: 84%;"><div class="clock-button clock-minute" data-value="15"><span class="content">15</span></div></div></div>
                                        <div class="clock-line" style="top: 67.8%;"><div class="clock-split" style="width: 22%;
left: 0%;"><div class="clock-button clock-minute" data-value="40"><span class="content">40</span></div></div><div class="clock-split" style="width: 22%;
left: 78%;"><div class="clock-button clock-minute" data-value="20"><span class="content">20</span></div></div></div>
                                        <div class="clock-line" style="top: 83.5%;"><div class="clock-split" style="width: 45.25%;
left: 4.5%;"><div class="clock-button clock-minute" data-value="35"><span class="content">35</span></div></div><div class="clock-split" style="width: 45.25%;
left: 49.75%;"><div class="clock-button clock-minute" data-value="25"><span class="content">25</span></div></div></div>
                                        <div class="clock-line" style="top: 90%;"><div class="clock-button clock-minute" data-value="30"><span class="content">30</span></div></div>
                                        <div class="clock-center"><div class="clock-period-switch am"><span class="content">AM</span></div><div class="clock-period-switch pm"><span class="content">PM</span></div></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    */});

                    strHTML += '<div class="time-bottom-toolbar">' +
                                    '<div flex-horizontal align-top>';

                    if (!element.hasAttribute('no-now-button')) {
                        strHTML += '<gs-button class="now-time">Now</gs-button>';
                    }

                    strHTML += '<gs-button class="done" flex>Done</gs-button>';

                    if (!element.hasAttribute('non-empty')) {
                        strHTML += '<gs-button class="clear-time">Clear</gs-button>';
                    }

                    strHTML +=      '</div>' +
                                '</div>';

                    pickerElement.innerHTML = strHTML;

                    // save picker control
                    element.pickerModalControlElement = xtag.query(pickerContainerElement, '.time-modal-control')[0];

                    // set picker value
                    refreshPickerValue(element);

                    // bind picker control change
                    element.pickerModalControlElement.addEventListener('change', function (event) {
                        setValueDisplay(element, this.value);
                    });

                    // bind picker control keydown
                    element.pickerModalControlElement.addEventListener('keydown', function (event) {
                        if ((event.keyCode || event.which) === 13) {
                            element.close();
                        }
                    });

                    // bind picker click
                    pickerElement.addEventListener('mousedown', function (event) {
                        if (!evt.touchDevice) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    });

                    //console.log('0***', pickerElement);
                    pickerElement.addEventListener('click', function (event) {
                        var target = event.target, arrElements, i, len, newValue;

                        //console.log('1***', newValue);

                        if (target.classList.contains('content')) {
                            target = target.parentNode;
                        }

                        if (target.classList.contains('clock-button') || target.classList.contains('clock-period-switch')) {
                            if (target.classList.contains('clock-hour')) {
                                arrElements = xtag.query(pickerElement, '.clock-hour');
                            }
                            if (target.classList.contains('clock-minute')) {
                                arrElements = xtag.query(pickerElement, '.clock-minute');
                            }
                            if (target.classList.contains('clock-period-switch')) {
                                arrElements = xtag.query(pickerElement, '.clock-period-switch');
                            }

                            for (i = 0, len = arrElements.length; i < len; i += 1) {
                                arrElements[i].classList.remove('selected');
                            }

                            target.classList.add('selected');

                            arrElements = xtag.query(pickerElement, '.selected');
                            if (arrElements.length === 3) {
                                newValue = arrElements[0].textContent + ':' +
                                           arrElements[1].textContent + ' ' +
                                           arrElements[2].textContent;
                            }
                        }

                        if (target.classList.contains('increment-time') && element.getAttribute('value')) {
                            newValue = new Date('1/1/1111 ' + element.getAttribute('value'));
                            newValue = newValue.setMinutes(newValue.getMinutes() + 1);
                        } else if (target.classList.contains('decrement-time') && element.getAttribute('value')) {
                            newValue = new Date('1/1/1111 ' + element.getAttribute('value'));
                            newValue = newValue.setMinutes(newValue.getMinutes() - 1);
                        } else if (target.classList.contains('now-time')) {
                            newValue = new Date();
                        } else if (target.classList.contains('clear-time')) {
                            newValue = '';
                        } else if (target.classList.contains('modal-done') || target.classList.contains('done')) {
                            element.close();
                        }

                        //console.log('2***', newValue);
                        if (newValue !== undefined) {
                            setValueDisplay(element, newValue);
                            //console.log('3***', element, element.getAttribute('value'), element.value);

                            if (!evt.touchDevice) {
                                GS.setInputSelection(element.control, 0, element.control.value.length);
                            }
                        }
                    });

                    // handle/bind positioning and look
                    handleLook = function () {
                        var positionData, intPopupHeight, intPopupWidth;

                        if (pickerContainerElement.parentNode !== document.body) {
                            window.removeEventListener('resize', handleLook);
                            window.removeEventListener('orientationchange', handleLook);
                            return;
                        }

                        // clear current styles
                        pickerElement.style.top = '';
                        pickerElement.style.left = '';
                        pickerElement.style.marginTop = '';
                        pickerContainerElement.classList.remove('modal');

                        // get position/size data
                        positionData = GS.getElementPositionData(element);
                        intPopupHeight = pickerElement.offsetHeight;
                        intPopupWidth = pickerElement.offsetWidth;

                        // if from control to bottom is too small and from control to top is too small
                        //      OR window width < 400px: dialog
                        //      OR window height < 550px: dialog
                        if ((positionData.intRoomAbove < intPopupHeight && positionData.intRoomBelow < intPopupHeight) ||
                            window.innerWidth < 400 ||
                            window.innerHeight < 550) {
                            // dialog mode
                            pickerElement.style.marginTop = '1em';
                            pickerContainerElement.classList.add('modal');

                        } else {
                            // if from control to bottom has enough room: popup below
                            if (positionData.intRoomBelow > intPopupHeight) {
                                pickerElement.style.top  = (positionData.objElementOffset.top + positionData.intElementHeight) + 'px';

                            // else: popup above
                            } else {
                                pickerElement.style.top  = (positionData.objElementOffset.top - intPopupHeight) + 'px';
                            }

                            pickerElement.style.left =
                                ((positionData.objElementOffset.left + positionData.intElementWidth) - intPopupWidth) + 'px';
                        }
                    };

                    handleLook();

                    window.addEventListener('resize', handleLook);
                    window.addEventListener('orientationchange', handleLook);
                }
            },

            close: function () {
                var element = this;

                if (element.innerState === 'open') {
                    element.innerState = 'closed';
                    //console.trace('closed', element.pickerContainerElement);
                    if (element.pickerContainerElement) {
                        document.body.removeChild(element.pickerContainerElement);
                        element.pickerContainerElement = '';
                    }

                    if (element.getAttribute('value') !== element.lastClosedValue) {
                        handleChange(element);
                    } else if (!element.getAttribute('value')) {
                        handleNonEmpty(element);
                    }
                }
            },

            toggle: function () {
                if (this.innerState === 'open') {
                    this.close();
                } else {
                    this.open();
                }
            }
        }
    });
});/*jslint white:true browser:true this:true*/
/*global window,GS,document,xtag,designRegisterElement,registerDesignSnippet,addProp,encodeHTML,setOrRemoveTextAttribute,setOrRemoveBooleanAttribute,addFlexProps*/

window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('<gs-timestamp>', '<gs-timestamp>', 'gs-timestamp date-format="${0:isodate}" time-format=${1}></gs-timestamp>');
    
    designRegisterElement('gs-timestamp', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-timestamp.html');
    
    window.designElementProperty_GSTIMESTAMP = function (selectedElement) {    
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        addProp('Date Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-picker')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-date-picker', (this.value === 'true'), false);
        });

        addProp('Time Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-picker')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-time-picker', (this.value === 'true'), false);
        });
        
        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
        
        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value && new Date(element.value).getTime()) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = undefined;
                //element.value = null;
            }
        }
    }

    function elementInserted(element) {
        var dateValue = '';
        var timeValue = '';
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
                var arrValue = element.getAttribute('value').split(' ');
                dateValue = new Date(arrValue[0]);
                timeValue = arrValue[1];
                
                element.dateControl = document.createElement('gs-date');
                element.timeControl = document.createElement('gs-time');
                
                if (element.hasAttribute('date-format')) {
                    element.dateControl.setAttribute('format', element.getAttribute('date-format'));
                }
                if (element.hasAttribute('time-format')) {
                    element.timeControl.setAttribute('format', element.getAttribute('time-format'));
                }
                
                if (element.hasAttribute('no-date-picker')) {
                    element.dateControl.setAttribute('no-picker', '');
                }
                if (element.hasAttribute('no-time-picker')) {
                    element.timeControl.setAttribute('no-picker', '');
                }
                
                element.dateControl.value = dateValue;
                element.timeControl.value = timeValue;
                
                element.dateControl.setAttribute('flex', '');
                element.timeControl.setAttribute('flex', '');
                
                element.dateControl.setAttribute('gs-dynamic', '');
                element.timeControl.setAttribute('gs-dynamic', '');
                
                element.dateControl.addEventListener('change', function () {
                    
                });
                element.timeControl.addEventListener('change', function () {
                    
                });
                
                console.log(element.dateControl);
                console.log(element.timeControl);
                
                element.appendChild(element.dateControl);
                element.appendChild(element.timeControl);
                
                console.log(element.children);
                
                pushReplacePopHandler(element);
                window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
            }
        }
    }
    
    xtag.register('gs-timestamp', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                var dateValue = '';
                var timeValue = '';
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value') {
                        var arrValue = newValue.split(' ');
                        dateValue = new Date(arrValue[0]);
                        timeValue = arrValue[1];
                        
                        this.dateControl.value = dateValue;
                        this.timeControl.value = timeValue;
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    return this.getAttribute('value');
                },
                
                set: function (newValue) {
                    return this.setAttribute('value', newValue);
                }
            }
        },
        methods: {
        }
    });
});
window.addEventListener('design-register-element', function () {
    
    registerDesignSnippet('<gs-toggle>', '<gs-toggle>', 'gs-toggle column="${1}">${2}</gs-toggle>');
    
    designRegisterElement('gs-toggle', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-buttons-toggle.html');
    
    window.designElementProperty_GSTOGGLE = function(selectedElement) {
        addProp('Icon', true, '<div flex-horizontal>' +
                              '     <gs-text id="prop-icon-input" class="target" value="' + (selectedElement.getAttribute('icon') || '') + '" mini flex></gs-text>' +
                              '     <gs-button id="prop-icon-picker-button" mini icononly icon="list"></gs-button>' +
                              '     <style>#prop-icon-picker-button:after {font-size: 1em;}</style>' +
                              '</div>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'icon', this.value, false);
        });
        
        document.getElementById('prop-icon-picker-button').addEventListener('click', function () {
            var i, len, html, arrIcons = GS.iconList(), strName, templateElement;
            
            for (i = 0, len = arrIcons.length, html = ''; i < len; i += 1) {
                strName = arrIcons[i].name;
                html += '<gs-block>' +
                            '<gs-button iconleft icon="' + strName + '" dialogclose>' + strName + '</gs-button>' +
                        '</gs-block>';
            }
            
            templateElement = document.createElement('template');
            templateElement.setAttribute('data-max-width', '1100px');
            
            templateElement.innerHTML = ml(function () {/*
                <gs-page>
                    <gs-header><center><h3>Choose An Icon</h3></center></gs-header>
                    <gs-body padded>
                        <gs-grid widths="1,1,1,1" reflow-at="767px">{{HTML}}</gs-grid>
                    </gs-body>
                    <gs-footer><gs-button dialogclose>Cancel</gs-button></gs-footer>
                </gs-page>
            */}).replace('{{HTML}}', html);
            
            GS.openDialog(templateElement, '', function (event, strAnswer) {
                var propInput = document.getElementById('prop-icon-input');
                
                if (strAnswer !== 'Cancel') {
                    propInput.value = strAnswer;
                    GS.triggerEvent(propInput, 'change');
                }
            });
        });
        
        if (selectedElement.getAttribute('icon') ||
            selectedElement.hasAttribute('iconleft') ||
            selectedElement.hasAttribute('iconright') ||
            selectedElement.hasAttribute('icontop') ||
            selectedElement.hasAttribute('iconbottom') ||
            selectedElement.hasAttribute('icononly') ||
            selectedElement.hasAttribute('iconrotateright') ||
            selectedElement.hasAttribute('iconrotatedown') ||
            selectedElement.hasAttribute('iconrotateleft')) {
            // iconleft
            // iconright
            // icontop
            // iconbottom
            // icononly
                   if (selectedElement.hasAttribute('iconleft'))   { strIconPos = 'iconleft';
            } else if (selectedElement.hasAttribute('iconright'))  { strIconPos = 'iconright';
            } else if (selectedElement.hasAttribute('icontop'))    { strIconPos = 'icontop';
            } else if (selectedElement.hasAttribute('iconbottom')) { strIconPos = 'iconbottom';
            } else if (selectedElement.hasAttribute('icononly'))   { strIconPos = 'icononly';
            } else { strIconPos = ''; }
            
            addProp('Icon Position', true, '<gs-select class="target" value="' + strIconPos + '" mini>' +
                                                '   <option value="">Default</option>' +
                                                '   <option value="iconleft">Left</option>' +
                                                '   <option value="iconright">Right</option>' +
                                                '   <option value="icontop">Top</option>' +
                                                '   <option value="iconbottom">Bottom</option>' +
                                                '   <option value="icononly">Icononly</option>' +
                                                '</gs-select>', function () {
                selectedElement.removeAttribute('iconleft');
                selectedElement.removeAttribute('iconright');
                selectedElement.removeAttribute('icontop');
                selectedElement.removeAttribute('iconbottom');
                selectedElement.removeAttribute('icononly');
                
                if (this.value) {
                    selectedElement.setAttribute(this.value, '');
                }
                
                return selectedElement;
            });
            
            // None
            // 90 degrees  (iconrotateright)
            // 180 degrees (iconrotatedown)
            // 270 degrees (iconrotateleft)
            
                   if (selectedElement.hasAttribute('iconrotateright')) { strIconRotation = 'iconrotateright';
            } else if (selectedElement.hasAttribute('iconrotatedown'))  { strIconRotation = 'iconrotatedown';
            } else if (selectedElement.hasAttribute('iconrotateleft'))  { strIconRotation = 'iconrotateleft';
            } else { strIconRotation = ''; }
            
            addProp('Icon&nbsp;Rotation', true, '<gs-select class="target" value="' + strIconRotation + '" mini>' +
                                                '   <option value="">None</option>' +
                                                '   <option value="iconrotateright">90 degrees</option>' +
                                                '   <option value="iconrotatedown">180 degrees</option>' +
                                                '   <option value="iconrotateleft">270 degrees</option>' +
                                                '</gs-select>', function () {
                selectedElement.removeAttribute('iconrotateright');
                selectedElement.removeAttribute('iconrotatedown');
                selectedElement.removeAttribute('iconrotateleft');
                
                if (this.value) {
                    selectedElement.setAttribute(this.value, '');
                }
                
                return selectedElement;
            });
        }
        
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });
        
        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });
        
        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }
        
        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');
            
            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }
            
            return selectedElement;
        });
        
        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        // Font Color attributes
        strFontAttribute = '';
        if (selectedElement.hasAttribute('txt-primary'))  { strFontAttribute = 'txt-primary'; }
        if (selectedElement.hasAttribute('txt-success'))  { strFontAttribute = 'txt-success'; }
        if (selectedElement.hasAttribute('txt-info'))     { strFontAttribute = 'txt-info'; }
        if (selectedElement.hasAttribute('txt-warning'))  { strFontAttribute = 'txt-warning'; }
        if (selectedElement.hasAttribute('txt-danger'))   { strFontAttribute = 'txt-danger'; }

        addProp('Font Color', true, '<gs-select class="target" value="' + strFontAttribute + '" mini>' +
                                        '<option value="">Default</option>' +
                                        '<option value="txt-primary">Primary</option>' +
                                        '<option value="txt-success">Success</option>' +
                                        '<option value="txt-info">Info</option>' +
                                        '<option value="txt-warning">Warning</option>' +
                                        '<option value="txt-danger">Danger</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('txt-primary');
            selectedElement.removeAttribute('txt-success');
            selectedElement.removeAttribute('txt-info');
            selectedElement.removeAttribute('txt-warning');
            selectedElement.removeAttribute('txt-danger');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // Background Color attributes
        strBackgroundAttribute = '';
        if (selectedElement.hasAttribute('bg-primary'))  { strBackgroundAttribute = 'bg-primary'; }
        if (selectedElement.hasAttribute('bg-success'))  { strBackgroundAttribute = 'bg-success'; }
        if (selectedElement.hasAttribute('bg-info'))     { strBackgroundAttribute = 'bg-info'; }
        if (selectedElement.hasAttribute('bg-warning'))  { strBackgroundAttribute = 'bg-warning'; }
        if (selectedElement.hasAttribute('bg-danger'))   { strBackgroundAttribute = 'bg-danger'; }

        addProp('Background Color', true, '<gs-select class="target" value="' + strBackgroundAttribute + '" mini>' +
                                        '<option value="">Default</option>' +
                                        '<option value="bg-primary">Primary</option>' +
                                        '<option value="bg-success">Success</option>' +
                                        '<option value="bg-info">Info</option>' +
                                        '<option value="bg-warning">Warning</option>' +
                                        '<option value="bg-danger">Danger</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('bg-primary');
            selectedElement.removeAttribute('bg-success');
            selectedElement.removeAttribute('bg-info');
            selectedElement.removeAttribute('bg-warning');
            selectedElement.removeAttribute('bg-danger');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        addProp('Corners', true,   '<div class="target">' +
                                        '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                    selectedElement.hasAttribute('remove-top') ||
                                                                    selectedElement.hasAttribute('remove-left') ||
                                                                    selectedElement.hasAttribute('remove-top-left'))).toString() +
                                                '" remove-right remove-bottom id="round-top-left-corner________" inline></gs-checkbox>' +

                                        '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                    selectedElement.hasAttribute('remove-top') ||
                                                                    selectedElement.hasAttribute('remove-right') ||
                                                                    selectedElement.hasAttribute('remove-top-right'))).toString() +
                                                '" remove-left remove-bottom id="round-top-right-corner________" inline></gs-checkbox><br />' +

                                        '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                    selectedElement.hasAttribute('remove-bottom') ||
                                                                    selectedElement.hasAttribute('remove-left') ||
                                                                    selectedElement.hasAttribute('remove-bottom-left'))).toString() +
                                                '" remove-right remove-top id="round-bottom-left-corner________" inline></gs-checkbox>' +

                                        '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                    selectedElement.hasAttribute('remove-bottom') ||
                                                                    selectedElement.hasAttribute('remove-right') ||
                                                                    selectedElement.hasAttribute('remove-bottom-right'))).toString() +
                                                '" remove-left remove-top id="round-bottom-right-corner________" inline></gs-checkbox>' +
                                    '</div>', function () {
            var topLeft =     document.getElementById('round-top-left-corner________').value === 'true',
                topRight =    document.getElementById('round-top-right-corner________').value === 'true',
                bottomLeft =  document.getElementById('round-bottom-left-corner________').value === 'true',
                bottomRight = document.getElementById('round-bottom-right-corner________').value === 'true',
                arrStrAttr = [], i, len;

            selectedElement.removeAttribute('remove-all');
            selectedElement.removeAttribute('remove-top');
            selectedElement.removeAttribute('remove-bottom');
            selectedElement.removeAttribute('remove-left');
            selectedElement.removeAttribute('remove-right');
            selectedElement.removeAttribute('remove-top-left');
            selectedElement.removeAttribute('remove-top-right');
            selectedElement.removeAttribute('remove-bottom-left');
            selectedElement.removeAttribute('remove-bottom-right');

            if (!topLeft && !topRight && !bottomLeft && !bottomRight) {
                arrStrAttr.push('remove-all');
            } else if (!topLeft && !topRight) {
                arrStrAttr.push('remove-top');
            } else if (!bottomLeft && !bottomRight) {
                arrStrAttr.push('remove-bottom');
            } else if (!topLeft && !bottomLeft) {
                arrStrAttr.push('remove-left');
            } else if (!topRight && !bottomRight) {
                arrStrAttr.push('remove-right');
            }

            if (!topLeft && !bottomLeft && arrStrAttr[0] !== 'remove-all') {
                arrStrAttr.push('remove-left');
            } else if (!topLeft && topRight) {
                arrStrAttr.push('remove-top-left');
            } else if (!bottomLeft && bottomRight) {
                arrStrAttr.push('remove-bottom-left');
            }

            if (!topRight && !bottomRight && arrStrAttr[0] !== 'remove-all') {
                arrStrAttr.push('remove-right');
            } else if (topLeft && !topRight) {
                arrStrAttr.push('remove-top-right');
            } else if (bottomLeft && !bottomRight) {
                arrStrAttr.push('remove-bottom-right');
            }

            for (i = 0, len = arrStrAttr.length; i < len; i += 1) {
                selectedElement.setAttribute(arrStrAttr[i], '');
            }

            return selectedElement;
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    //function pushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                // add a tabindex to allow focus
                if (!element.hasAttribute('tabindex')) {
                    element.tabIndex = 0;
                }

                if (typeof element.getAttribute('value') === 'string') {
                    if (element.getAttribute('value') === 'true' || element.getAttribute('value') === '-1') {
                        element.setAttribute('selected', '');
                    }
                }

                // handle "qs" attribute
                if (element.getAttribute('qs')) {
                    //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }
            }
        }
    }
    
    xtag.register('gs-toggle', {
        lifecycle: {
            created: function () {
                // if the value was set before the "created" lifecycle code runs: set attribute
                //      (discovered when trying to set a value of a date control in the after_open of a dialog)
                //      ("delete" keyword added because of firefox)
                if (this.value) {
                    this.setAttribute('value', this.value);
                    delete this.value;
                    //this.value = null;
                }
                
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                }
            }
        },
        events: {
            'click': function (event) {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (this.hasAttribute('selected')) {
                        this.removeAttribute('selected');
                        
                        if (this.getAttribute('value') === 'true') {
                            this.setAttribute('value', 'false');
                        } else if (this.getAttribute('value') === '-1') {
                            this.setAttribute('value', '0');
                        }
                        
                    } else {
                        this.setAttribute('selected', '');
                        
                        if (this.getAttribute('value') === 'false') {
                            this.setAttribute('value', 'true');
                        } else if (this.getAttribute('value') === '0') {
                            this.setAttribute('value', '-1');
                        }
                    }
                    
                    xtag.fireEvent(this, 'change', {
                        bubbles: true,
                        cancelable: true
                    });
                }
            },
            
            'keypress': function (event) {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // if we are not disabled and we pressed return (13) or space (32): trigger tap
                    if (!this.hasAttribute('disabled') && (event.keyCode === 13 || event.keyCode === 32)) {
                        event.preventDefault();
                        event.stopPropagation();
                        
                        xtag.fireEvent(this, 'click', {
                            bubbles: true,
                            cancelable: true
                        });
                    }
                }
            }
        },
        accessors: {
            'value': {
                'get': function () {
                    return this.hasAttribute('selected'); //this.classList.contains('down');
                },
                
                'set': function (newValue) {
                    if (newValue === true || newValue === 'true') {
                        this.setAttribute('selected', '');
                    } else {
                        this.removeAttribute('selected');
                    }
                }
            },
            
            'textValue': {
                'get': function () {
                    return this.hasAttribute('selected') ? 'YES' : 'NO';
                },
                
                'set': function (newValue) {
                    if (newValue === true || newValue === 'true' || newValue === 'YES') {
                        this.setAttribute('selected', '');
                    } else {
                        this.removeAttribute('selected');
                    }
                }
            }
        },
        methods: {
            
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';
    
    //registerDesignSnippet('<gs-checkbox>', '<gs-checkbox>', 'gs-checkbox value="0" column="${1:ready_to_ship}">${2}</gs-checkbox>');
    
    designRegisterElement('gs-tutorial', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-tutorial.html');
    
    window.designElementProperty_GSTUTORIAL = function (selectedElement) {
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    function closeCurrentPopup(element) {
        var popupElement = element.currentPopup;
        
        // run before-close code if there is any
        if (popupElement.strBeforeClose) {
            new Function(popupElement.strBeforeClose).apply(element);
        }
        
        // remove overlay if there is one
        if (popupElement.relatedOverlay) {
            document.body.removeChild(popupElement.relatedOverlay);
        }
        
        // remove popup element
        document.body.removeChild(popupElement);
    }
    
    function openPopup(element, templateElement, intTemplateNumber, intNumberOfTemplates) {
        var strTargetSelector = (templateElement.getAttribute('target') || '')
          , strDirectionRequest = (templateElement.getAttribute('direction') || 'down')
          , intMaxWidthAttribute = parseInt((templateElement.getAttribute('max-width') || '9999999'), 10)
          , strBeforeOpen = templateElement.getAttribute('before-open')
          , strBeforeClose = templateElement.getAttribute('before-close')
          , strHTML, arrElements, elementTarget, arrTests, popupElement, overlayElement, arrowElement
          , positionHandlingFunction, buttonElement, i, len;
        
        // make the template a copy so that we can alter it safely
        templateElement = templateElement.cloneNode(true);
        
        // run before-open code if there is any
        if (strBeforeOpen) {
            new Function(strBeforeOpen).apply(element);
        }
        
        // get html from template
        strHTML = (templateElement.innerHTML || '');
        
        // add next, previous and skip buttons
        
        // if first and only
        if (intTemplateNumber === 1 && intNumberOfTemplates === 1) {
            strHTML += ml(function () {/*
                            <div class="popup-control-bar">
                                <gs-button class="button-close" inline icononly icon="times"></gs-button>
                            </div>
                        */});
        // if first
        } else if (intTemplateNumber === 1 && intNumberOfTemplates > 1) {
            strHTML += ml(function () {/*
                            <div class="popup-control-bar">
                                <gs-button class="button-right" inline icononly icon="arrow-right" remove-left></gs-button>
                                <gs-button class="button-close" inline icononly icon="times" remove-right></gs-button>
                            </div>
                        */});
        // if middle
        } else if (intTemplateNumber > 1 && intNumberOfTemplates > intTemplateNumber) {
            strHTML += ml(function () {/*
                            <div class="popup-control-bar">
                                <gs-button class="button-right" inline icononly icon="arrow-right" remove-left></gs-button>
                                <gs-button class="button-close" inline icononly icon="times" remove-all></gs-button>
                                <gs-button class="button-left" inline icononly icon="arrow-left" remove-right></gs-button>
                            </div>
                        */});
        // if last
        } else { //if (intNumberOfTemplates === intTemplateNumber) {
            strHTML += ml(function () {/*
                            <div class="popup-control-bar">
                                <gs-button class="button-close" inline icononly icon="times" remove-left></gs-button>
                                <gs-button class="button-left" inline icononly icon="arrow-left" remove-right></gs-button>
                            </div>
                        */});
        }
        
        // if a selector was provided: get the instruction target
        if (strTargetSelector) {
            try {
                arrElements = xtag.toArray(document.querySelectorAll(strTargetSelector));
            } catch (e) {}
            
            arrElements = arrElements || [];
            
            if (arrElements.length > 1) {
                console.warn('gs-tutorial Warning: More than one element matched with selector \'' + strTargetSelector + '\'.');
            }
            
            if (arrElements.length === 0) {
                console.warn('gs-tutorial Warning: No elements matched with selector \'' + strTargetSelector + '\'.');
                
            } else {
                elementTarget = arrElements[0];
            }
        }
        
        // make strDirectionRequest lowercase
        strDirectionRequest.toLowerCase();
        
        // if the direction does not match any valid direction: set direction to down and warn
        if (!strDirectionRequest.match(/^up$|^down$|^left$|^right$/)) {
            console.warn('gs-tutorial Warning: ' +
                                'Direction \'' + strDirectionRequest + '\' not recognized. ' +
                                'Please use \'up\', \'down\', \'left\', \'right\'. Defaulting to \'down\'.');
            strDirectionRequest = 'down';
        }
        
        // order of tests depending direction request
        if (strDirectionRequest === 'up') { // up: up, down, left, right, full
            arrTests = ['up', 'down', 'left', 'right'];
            
        } else if (strDirectionRequest === 'down') { // down: down, up, left, right, full
            arrTests = ['down', 'up', 'left', 'right'];
            
        } else if (strDirectionRequest === 'left') { // left: left, right, down, up, full
            arrTests = ['left', 'right', 'down', 'up'];
            
        } else if (strDirectionRequest === 'right') { // right: right, left, down, up, full
            arrTests = ['right', 'left', 'down', 'up'];
        }
        
        // create popup, overlay and arrow
        popupElement = document.createElement('gs-tutorial-popup');
        
        overlayElement = document.createElement('gs-tutorial-overlay');
        
        arrowElement = document.createElement('div');
        arrowElement.classList.add('connection-arrow');
        
        // append overlay then the popup so that they can have the same z-index and the popup will be over the overlay
        //      the reason why all of the overlays and all of the popups need the same z-index is because say for example
        //      the overlays had a z-index of '1' and the popups had a z-index of '2' if we had two popups open and the
        //      first one was bigger than the second one than you would be able to see the first popup without an overlay
        //      in from of it and potentially you would be able to interact with the first popup without dealing with the
        //      second popup.
        document.body.appendChild(overlayElement);
        document.body.appendChild(popupElement);
        
        // link the popup to it's overlay so that when we close the popup we can also remove the popup overlay
        popupElement.relatedOverlay = overlayElement;
        
        // link the popup to it's before-close so that before we close the popup we can run any code inside the before-close
        popupElement.strBeforeClose = strBeforeClose;
        
        // fill popup
        popupElement.innerHTML = strHTML;
        popupElement.appendChild(arrowElement);
        
        // bind next, previous and skip buttons
        buttonElement = xtag.query(popupElement, '.popup-control-bar > .button-left')[0];
        if (buttonElement) {
            buttonElement.addEventListener('click', function () {
                element.backward();
            });
        }
        
        buttonElement = xtag.query(popupElement, '.popup-control-bar > .button-close')[0];
        if (buttonElement) {
            buttonElement.addEventListener('click', function () {
                element.end();
            });
        }
        
        buttonElement = xtag.query(popupElement, '.popup-control-bar > .button-right')[0];
        if (buttonElement) {
            buttonElement.addEventListener('click', function () {
                element.forward();
            });
        }
        
        // bind the overlay
        overlayElement.addEventListener('click', function () {
            element.forward();
        });
        
        // create a positioning function: this is so that we can refresh the popup's position from several different events
        positionHandlingFunction = function () {
            var intTemp, intMaxWidth, intMaxHeight, intResolvedWidth, intResolvedHeight
              , jsnPositionData, strResolvedDirection, intPopupMidPoint, intElementMidPoint
              , intMargin = 10, intArrow = 5, intPopupTop, intPopupLeft, intArrowLeft, intArrowTop;
            
            // if the dialog is not in the DOM: unbind and skip the contents of the function using return
            if (popupElement.parentNode !== document.body) {
                window.removeEventListener('resize', positionHandlingFunction);
                window.removeEventListener('orientationchange', positionHandlingFunction);
                return;
            }
            
            // save scroll numbers
            popupElement.oldScrollTop = popupElement.scrollTop;
            popupElement.oldScrollLeft = popupElement.scrollLeft;
            
            // clear arrow direction
            popupElement.classList.remove('up');
            popupElement.classList.remove('down');
            popupElement.classList.remove('left');
            popupElement.classList.remove('right');
            
            // clear popup and arrow css
            popupElement.setAttribute('style', '');
            arrowElement.setAttribute('style', '');
            
            // find the closest balance of width and height (using the window width as a max width)
            if ((popupElement.offsetHeight + popupElement.offsetWidth) < 300) {
                intTemp = 300;
            } else {
                intTemp = ((popupElement.offsetHeight + popupElement.offsetWidth) / 2);
            }
            intMaxWidth = (intTemp < window.innerWidth ? intTemp : window.innerWidth - (intMargin * 2));
            
            if (intMaxWidth > intMaxWidthAttribute) {
                intMaxWidth = intMaxWidthAttribute;
            }
            
            // find the maximum height (must be less than half on touch devices and less than a third on everything else)
            if (evt.touchDevice) {
                intMaxHeight = Math.floor(window.innerHeight / 2) - (intMargin * 2);
                
            } else {
                intMaxHeight = Math.floor(window.innerHeight / 3) - (intMargin * 2);
            }
            
            // apply calculated max dimensions
            popupElement.style.maxWidth = intMaxWidth + 'px';
            popupElement.style.maxHeight = intMaxHeight + 'px';
            
            // get resolved dimensions
            intResolvedWidth = popupElement.offsetWidth;
            intResolvedHeight = popupElement.offsetHeight;
            
            // if there is a target: run through tests
            if (elementTarget) {
                // get target position data
                jsnPositionData = GS.getElementPositionData(elementTarget);
                
                //console.log(intResolvedHeight,
                //            intResolvedWidth,
                //            jsnPositionData.intRoomAbove,
                //            jsnPositionData.intRoomBelow,
                //            jsnPositionData.intRoomLeft,
                //            jsnPositionData.intRoomRight);
                
                // up: compare room above to popup resolved height
                //      pass: display
                //      fail: next test
                for (i = 0, len = arrTests.length; i < len; i += 1) {
                    if ((arrTests[i] ===    'up' && (intResolvedHeight + intMargin + intArrow) <= jsnPositionData.intRoomAbove) ||
                        (arrTests[i] ===  'down' && (intResolvedHeight + intMargin + intArrow) <= jsnPositionData.intRoomBelow) ||
                        (arrTests[i] ===  'left' && ( intResolvedWidth + intMargin + intArrow) <= jsnPositionData.intRoomLeft) ||
                        (arrTests[i] === 'right' && ( intResolvedWidth + intMargin + intArrow) <= jsnPositionData.intRoomRight)) {
                        strResolvedDirection = arrTests[i];
                        break;
                    }
                }
                
                // if we could not resolve to a particular direction: position in the middle
                strResolvedDirection = strResolvedDirection || 'middle';
                
            // else: center on screen
            } else {
                strResolvedDirection = 'middle';
            }
            
            //console.log(strDirectionRequest, strResolvedDirection);
            
            // if up or down: get as close to horizontally centered on the element as possible
            if (strResolvedDirection === 'up' || strResolvedDirection === 'down') {
                intElementMidPoint = (jsnPositionData.intElementLeft + (jsnPositionData.intElementWidth / 2));
                intPopupMidPoint = (intResolvedWidth / 2);
                //console.log(intElementMidPoint, jsnPositionData.left, jsnPositionData.intElementWidth);
                
                // if centered goes past intMargin of the left edge of the screen: go to intMargin from the bottom
                if (intElementMidPoint - intPopupMidPoint < intMargin) {
                    intPopupLeft = intMargin;
                    
                    //console.log('1***', intMargin);
                    
                // else if centered goes past intMargin of the right edge of the screen: go to intMargin less than the width of the viewport
                } else if (intElementMidPoint + intPopupMidPoint > window.innerWidth - intMargin) {
                    intPopupLeft = ((window.innerWidth - intResolvedWidth) - intMargin);
                    //console.log('2***', window.innerWidth, intResolvedWidth, intMargin);
                    
                // else centered does not go past intMargin of either edge of the screen: center
                } else {
                    intPopupLeft = (intElementMidPoint - intPopupMidPoint);
                    //console.log('3***', intElementMidPoint, intPopupMidPoint, (intElementMidPoint - intPopupMidPoint) + 'px');
                }
                
                // move the arrow to be pointing at the midopoint of the target
                intArrowLeft = (intElementMidPoint - intPopupLeft);
                
                // if the midpoint of the target is really close the left of the screen: add extreme-left class to the popup
                //console.log(intElementMidPoint, intMargin, intArrow);
                if (intElementMidPoint <= (intMargin + Math.round(intArrow / 2) + 5)) {
                    popupElement.classList.add('extreme-left');
                }
                
                // if the midpoint of the target is really close the right of the screen: add extreme-right class to the popup
                //console.log(intElementMidPoint, window.innerWidth, intMargin, Math.round(intArrow / 2));
                if (intElementMidPoint >= (((window.innerWidth - intMargin) - Math.round(intArrow / 2)) - 5)) {
                    popupElement.classList.add('extreme-right');
                }
                
            // else if left or right: get as close to vertically centered next to the element as possible
            } else if (strResolvedDirection === 'left' || strResolvedDirection === 'right') {
                intElementMidPoint = (jsnPositionData.intElementTop + (jsnPositionData.intElementHeight / 2));
                intPopupMidPoint = (intResolvedHeight / 2);
                
                //console.log('0***', intElementMidPoint, intPopupMidPoint, window.innerHeight, intMargin, intDialogResolvedHeight);
                
                // if centered goes past intMargin of the top edge of the screen: go to intMargin from the bottom
                if (intElementMidPoint - intPopupMidPoint < intMargin) {
                    intPopupTop = intMargin;
                    //console.log('1***', intMargin);
                    
                // else if centered goes past intMargin of the bottom edge of the screen: go to intMargin less than the height of the viewport
                } else if (intElementMidPoint + intPopupMidPoint > window.innerHeight - intMargin) {
                    intPopupTop = ((window.innerHeight - intResolvedHeight) - intMargin);
                    //console.log('2***', window.innerHeight, intResolvedHeight, intMargin);
                    
                // else centered does not go past intMargin of either edge of the screen: center
                } else {
                    intPopupTop = (intElementMidPoint - intPopupMidPoint);
                    //console.log('3***', intElementMidPoint, intPopupMidPoint, (intElementMidPoint - intPopupMidPoint) + 'px');
                }
                
                intArrowTop = (intElementMidPoint - intPopupTop);
                
                // if the midpoint of the target is really close the left of the screen: add extreme-left class to the popup
                if (intElementMidPoint <= (intMargin + Math.round(intArrow / 2) + 5)) {
                    popupElement.classList.add('extreme-up');
                }
                
                // if the midpoint of the target is really close the right of the screen: add extreme-right class to the popup
                if (intElementMidPoint >= (((window.innerHeight - intMargin) - Math.round(intArrow / 2)) - 5)) {
                    popupElement.classList.add('extreme-down');
                }
                
            // else full: use dialog logic to get width and height and center both vertically and horizontally
            } else {
                intPopupTop = (window.innerHeight / 2) - (intResolvedHeight / 2);
                intPopupLeft = (window.innerWidth / 2) - (intResolvedWidth / 2);
            }
            
            // if direction is up: connect the bottom of the dialog to the top of the element
            if (strResolvedDirection === 'up') {
                intPopupTop = (jsnPositionData.intElementTop - intResolvedHeight) - intArrow;
                
            // if direction is down: connect the top of the dialog to the bottom of the element
            } else if (strResolvedDirection === 'down') {
                intPopupTop = (jsnPositionData.intElementTop + jsnPositionData.intElementHeight) + intArrow;
                
            // if direction is left: connect the right of the dialog to the left of the element
            } else if (strResolvedDirection === 'left') {
                intPopupLeft = (jsnPositionData.intElementLeft - intResolvedWidth) - intArrow;
                
            // if direction is right: connect the left of the dialog to the right of the element
            } else if (strResolvedDirection === 'right') {
                intPopupLeft = (jsnPositionData.intElementLeft + jsnPositionData.intElementWidth) + intArrow;
            }
            
            // prevent the dialog from vertically going outside the viewport
            if (intPopupTop + intResolvedWidth > window.innerHeight) {
                intPopupTop -= (intPopupTop + intResolvedWidth) - window.innerHeight;
            }
            
            // prevent the dialog from horizontally going outside the viewport
            if (intPopupLeft + intResolvedWidth > window.innerWidth) {
                intPopupLeft -= (intPopupLeft + intResolvedWidth) - window.innerWidth;
            }
            
            // apply CSS to the popup
            //console.log(intPopupTop, intPopupLeft);
            popupElement.style.top  = intPopupTop + 'px';
            popupElement.style.left = intPopupLeft + 'px';
            
            // handle arrow
            if (strResolvedDirection !== 'middle') {
                popupElement.classList.add(strResolvedDirection);
                
                // apply CSS to the arrow
                if (intArrowLeft) {
                    arrowElement.style.left = intArrowLeft + 'px';
                }
                if (intArrowTop) {
                    arrowElement.style.top = intArrowTop + 'px';
                }
            }
        };
        
        // run position handling function and bind to run it every window resize or re-orientation
        positionHandlingFunction();
        window.addEventListener('resize', positionHandlingFunction);
        window.addEventListener('orientationchange', positionHandlingFunction);
        
        element.currentPopup = popupElement;
    }
    
    
    // this runs code on the first inserted lifecycle call
    function elementInserted(element) {
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
            }
        }
    }
    
    xtag.register('gs-tutorial', {
        lifecycle: {
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-inserted" or "suspend-created" has been removed: run inserted code
                if ((strAttrName === 'suspend-created' || strAttrName === 'suspend-created') && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            'start': function () {
                var strBeforeStart = this.getAttribute('before-start'),
                    arrElement = xtag.queryChildren(this, 'template');
                
                // if there are no templates: warning
                if (arrElement.length === 0) {
                    console.warn('gs-tutorial Warning: No popup templates provided.' +
                                    ' Please consult the documention if you need info on how to use the gs-tutorial element.');
                    
                // if there are non-template children: warning
                } else if (this.children.length !== arrElement.length) {
                    console.warn('gs-tutorial Warning: Invalid element' + ((this.children.length - arrElement.length) === 1 ? '' : 's') + '.' +
                                    ' The gs-tutorial element only accepts template elements for it\'s children.');
                }
                
                // read first template
                this.currentIndex = 0;
                if (arrElement[this.currentIndex]) {
                    if (strBeforeStart) {
                        new Function(strBeforeStart).apply(this);
                    }
                    
                    openPopup(this, arrElement[this.currentIndex], (this.currentIndex + 1), arrElement.length);
                }
            },
            
            'end': function () {
                var strBeforeEnd = this.getAttribute('before-end');
                
                if (strBeforeEnd) {
                    new Function(strBeforeEnd).apply(this);
                }
                
                if (this.currentPopup) {
                    closeCurrentPopup(this);
                }
            },
            
            'forward': function () {
                var arrElement = xtag.queryChildren(this, 'template');
                
                this.currentIndex += 1;
                if (arrElement[this.currentIndex]) {
                    if (this.currentPopup) {
                        closeCurrentPopup(this);
                    }
                    
                    openPopup(this, arrElement[this.currentIndex], (this.currentIndex + 1), arrElement.length);
                } else {
                    this.end();
                }
            },
            
            'backward': function () {
                var arrElement = xtag.queryChildren(this, 'template');
                
                if (this.currentPopup) {
                    closeCurrentPopup(this);
                }
                
                this.currentIndex -= 1;
                if (arrElement[this.currentIndex]) {
                    if (this.currentPopup) {
                        closeCurrentPopup(this);
                    }
                    
                    openPopup(this, arrElement[this.currentIndex], (this.currentIndex + 1), arrElement.length);
                }
            },
            
            'reposition': function () {
                
            }
        }
    });
});